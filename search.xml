<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2023/06/15/test/"/>
      <url>/2023/06/15/test/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Binder</title>
      <link href="/2019/01/02//android-binder.html/"/>
      <url>/2019/01/02//android-binder.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1、binder原理"><a href="#1、binder原理" class="headerlink" title="1、binder原理"></a>1、binder原理</h1><p>纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？<br>不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。</p><p>我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进程间通讯呢？要素有三个：</p><ul><li>函数指针；</li><li>函数参数；</li><li>函数返回值；</li></ul><p>binder通讯的本质实际上非常简单，就是client、server双方在共享内存的基础上封装成自定义api函数，并无神奇之处。我们看看他是怎么和IPC三要素对应上的：</p><h2 id="1-1、IPC函数指针"><a href="#1-1、IPC函数指针" class="headerlink" title="1.1、IPC函数指针"></a>1.1、IPC函数指针</h2><p>binder的service_server可以向service_client提供service服务，但反过来不行。所以binder service其实是单向的，只有service_server端才能提供service函数，且函数只能在service_server端运行。</p><p>大部分情况下：<strong>service_server端提供的一组IPC服务本地函数</strong>，就是<strong>binder对象</strong>。</p><p>例如，mediaserver注册的一系列service中的一个”media.player”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;av&#x2F;media&#x2F;mediaserver&#x2F;main_mediaserver.cpp:</span><br><span class="line">int main(int argc __unused, char **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">&#x2F;frameworks&#x2F;av&#x2F;media&#x2F;libmediaplayerservice&#x2F;MediaPlayerService.cpp:</span><br><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service_server提供了一组可以在server本地运行的函数，即<strong>binder对象</strong>。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;av&#x2F;media&#x2F;libmedia&#x2F;IMediaPlayerService.cpp:</span><br><span class="line">status_t BnMediaPlayerService::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            sp&lt;IMediaPlayerClient&gt; client &#x3D;</span><br><span class="line">                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());</span><br><span class="line">            audio_session_t audioSessionId &#x3D; (audio_session_t) data.readInt32();</span><br><span class="line">            sp&lt;IMediaPlayer&gt; player &#x3D; create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(player));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        case CREATE_MEDIA_RECORDER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            const String16 opPackageName &#x3D; data.readString16();</span><br><span class="line">            sp&lt;IMediaRecorder&gt; recorder &#x3D; createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(recorder));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在service_client端可以通过<strong>handle</strong>来引用这个<strong>binder对象</strong>，还封装了一系列与之对应的函数来组织数据。但是这些函数实际上是通讯用的，函数的实际功能并不能在client本地执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;av&#x2F;media&#x2F;libmedia&#x2F;IMediaPlayerService.cpp:</span><br><span class="line">class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaPlayer&gt; create(</span><br><span class="line">            const sp&lt;IMediaPlayerClient&gt;&amp; client, audio_session_t audioSessionId) &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        data.writeStrongBinder(IInterface::asBinder(client));</span><br><span class="line">        data.writeInt32(audioSessionId);</span><br><span class="line"></span><br><span class="line">        remote()-&gt;transact(CREATE, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaRecorder&gt; createMediaRecorder(const String16 &amp;opPackageName)</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(opPackageName);</span><br><span class="line">        remote()-&gt;transact(CREATE_MEDIA_RECORDER, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;IMediaRecorder&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以理解<strong>binder对象</strong>和<strong>handle</strong>是非常关键的。service_server端需要在本地执行函数，所以执行时函数调用的3要素(函数、参数、返回值)都必须是本地的，所以它必须拥有一组函数的<strong>binder对象</strong>；service_client端不需要在本地执行，所以它没有函数集的<strong>binder对象</strong>，它只有函数集的远端引用<strong>handle</strong>。</p><p>binder通讯的3个主角：service_mannager、service_server、service_client。在各种场景下，分别的<strong>binder对象</strong>和<strong>handle</strong>关系如下：</p><table border="1"><caption> binder object_handle </caption><tr><th style="width: 200px;">场景</th><th style="width: 400px;">client</th><th style="width: 400px;">server</th></tr><tr><td> service_manage初始化 </td><td>service_manager:<br/><br/>本地的binder对象为svcmgr_handler()函数集；<br/>通过ioctl BINDER_SET_CONTEXT_MGR命令把该binder对象注册成全局handle0；<br/></td><td>binder device：<br/><br/>创建handle0引用，指向service_manager</td></tr><tr><td> service_server的addService </td><td>service_server:<br/><br/>target handle：handle0<br/>data：binder对象为一组本地service函数集；<br/></td><td>service_manager：<br/><br/>binder驱动会创建对该binder对象的引用handle<br/>通过SVC_MGR_ADD_SERVICE命令把该handle加入到service_manage的handle链表中；<br/></td></tr><tr><td> service_client的get_service </td><td>service_client:<br/><br/>target handle：handle0<br/>data：service name。整个过程中没有binder对象的参与。<br/>向service_manager获取service_server的service函数的handle；<br/></td><td>service_manage：<br/><br/>SVC_MGR_GET_SERVICE命令，通过service的name在service_manage的handle链表中查找对应的handle，并且把handle返回给service_client；<br/>这样对于service_server的binder对象，service_client和service_manage都持有它的handle了；</td></tr><tr><td> service_client调用service </td><td>service_client:<br/><br/>target handle：serive handle0。上一步获取的handle。<br/>data：调用参数。调用参数中也可能包含handle/binder对象。(看server端的处理)<br/></td><td>service_server：<br/><br/>驱动把target handle翻译成本地binder对象，调用对象提供的本地函数。<br/>对于data中可能包含的含handle/binder对象的处理：<br/>1、如果包含的handle是本进程binder的引用，把它翻译成本地binder，在本地可以运行；<br/>2、如果包含的handle不是本进程binder的引用，只能给它创建一份新的引用handle。这个handle也不能在server进程中运行，只能向其他service_server请求服务；<br/>3、不可能包含binder对象，因为client进程的binder对象在service_server进程中无法运行；<br/></td></tr></table><p>衍生出的原则如下：</p><ul><li>service_server类的进程只有<strong>binder对象</strong>，没有<strong>handle</strong>(除了handle0)，因为它所有操作都必须本地执行，引用远程对象毫无意义；</li><li>service_client类的进程只有<strong>handle</strong>，没有<strong>binder对象</strong>，因为它需要远程执行service不需要本地执行；</li><li>service_mannager进程同时有<strong>binder对象</strong>和<strong>handle</strong>，它本地<strong>binder对象</strong>的作用就是操作所有其他进程的<strong>handle</strong>；</li></ul><h2 id="1-2、IPC函数参数"><a href="#1-2、IPC函数参数" class="headerlink" title="1.2、IPC函数参数"></a>1.2、IPC函数参数</h2><p>如上一节描述，service_client可以通过名字向service_manage查询得到handle。这个handle就相当于远程的函数集指针。<br>但是对于一个函数调用，我们除了需要函数指针，还需要传递参数。  </p><p>binder使用parcel方式来打包函数参数和返回值。parcel可以用来传递几种类型的数据：</p><ul><li>普通类型的少量数据；</li><li>binder对象/handle(struct flat_binder_object);</li><li>fd(struct binder_fd_object)；</li></ul><p>下面详细描述每种情况的parcel包格式和承载的内容。</p><ul><li>1、普通类型的少量数据：</li></ul><p>这种普通类型(int/long/string…)的少量数据存储最为简单，存入时按照一定的顺序存入，取出时按照数据的排列格式取出即可。</p><ul><li>2、<strong>binder对象</strong>/<strong>handle</strong>(struct flat_binder_object)：</li></ul><p>这一类型数据的parcel包格式如下： </p><p><img src="/images/posts/2019/01/android_binder/binder_parcel_binder_object_format.png" alt="binder_parcel_binder_object_format"></p><p>可以看到这种类型的parcel包中包含了两种数据：data0/data1/…是普通类型数据；binder_obj0/binder_obj1/…是binder对象，binder_obj0 offset/binder_obj1 offset/…指出了了binder对象在parcel包中的偏移；</p><p>binder对象和handle共用结构体struct flat_binder_object。</p><p>上一节说过<strong>binder对象</strong>其实就是一组函数的指针，但是一个指针只需要一个long类型就可以标识了，为什么还需要用一个结构体struct flat_binder_object来传递。我理解下来主要的思想如下：使用binder都是面向对象语言c++/java，它们把函数组也要实例化成一个对象，一个对象只有被引用时才不会被回收，远程引用也需要让本地引用加1。</p><p>一组service函数，对本地进程来说就是binder，对其他需要使用的进程来说需要远程引用，就是handle，是一对多的关系。关系图如下：</p><p><img src="/images/posts/2019/01/android_binder/binder_binderobj_and_handle.png" alt="binder_binderobj_and_handle"></p><p>binder object是service_server的一个“local binder object”，service_manager和service_client创建了多个远程引用“remote handle”。</p><p>这个其实就是binder的核心思想，binder花费了大量的代码在维护这个关系上面：</p><ul><li>[x] service_server进程在驱动中创建了binder_node节点来保存<strong>binder对象</strong>，把本进程所有的binder_node都挂载在一颗红黑树proc-&gt;nodes上；</li><li>[x] service_manager和service_client每个新进程对这个<strong>binder对象</strong>引用，就创建一个新的binder_ref，它的值就是<strong>handle</strong>，并回指向binder_node。并且把本进程对其他service_server的引用都挂载到两颗红黑树proc-&gt;refs_by_node/proc-&gt;refs_by_desc上。并且远程引用会增加service_server进程关于<strong>binder对象</strong>的引用计数；</li></ul><p>binder驱动负责建立起<strong>binder对象</strong>和<strong>handle</strong>之间的映射关系，创建上述的数据结构，并负责翻译：</p><ul><li>[x] service_server把本地<strong>binder对象</strong>向service_manager注册。会在service_manager进程本地建立起binder_node，驱动会在service_manager进程中建立起对应的binder_ref引用，那么service_manager进程能看到的其实就是本进程对service_server<strong>binder对象</strong>的一个引用，并不能看到<strong>binder对象</strong>原始值；</li><li>[x] service_client根据名字向service_manager查询service。service_manager会返回本进程的handle，在内核中该handle会转换成<strong>binder对象</strong>binder_node。因为service_client不是service的本地进程，所以service_client不能得到<strong>binder对象</strong>，它只能得到引用<strong>handle</strong>。所以再针对service的<strong>binder对象</strong>创建一份service_client进程的本地引用；</li><li><p>[x] service_client调用远程service_server的service。内核判断handle引用是service_server的本地对象，就把handle转换成service_server的<strong>binder对象</strong>；</p></li><li><p>3、fd(struct binder_fd_object)：</p></li></ul><p>parcel还能传输文件句柄fd，此时的包格式如下：</p><p><img src="/images/posts/2019/01/android_binder/binder_parcel_fd_object_format.png" alt="binder_parcel_fd_object_format"></p><p>传输fd的意义何在呢？当binder的两个进程间需要传输大量的数据。例如：图像声音数据、或者是一个对象。可以在匿名共享内存(Ashmem)中创建一块区域，源进程会得到一个相应的fd，再把这个fd使用binder传递给目的进程，就可以共享数据了。</p><p>需要特别说明的是对象的传递，在同一个进程内进行函数调用的话，参数对象通常是使用引用的方式传递的。但是如果是跨进程的调用，是没有办法引用的，只有把整个对象复制过去。这种操作叫做对象的序列化，java称为Serializable，android有优化的实现Parcelable。注意对象序列化的Parcelable和binder的parcel数据封装不是一回事，尽管他们原理上很相似。binder并没有提供对象Parcelable的接口，如果我们要跨进程传输对象，只能把对象序列化(Parcelable)到匿名共享内存中，再把对应fd通过binder传输给目的进程。</p><p><img src="/images/posts/2019/01/android_binder/binder_fdobject_translate.png" alt="binder_fdobject_translate"></p><p>binder驱动在检测到传输的是fd，会在新的进程中分配一个新的fd，并指向原来的file结构，这样fd就被跨进程duplicate了。两个进程使用各自的fd对匿名共享内存区域进行mmap映射，就能访问相同的内存区域了。</p><h2 id="1-3、IPC函数返回值"><a href="#1-3、IPC函数返回值" class="headerlink" title="1.3、IPC函数返回值"></a>1.3、IPC函数返回值</h2><p>函数返回值也是使用和函数参数一样的parcel结构来封装数据的。就不再重复叙述。</p><p>上面提到的原则需要再次强调，在一次service_client和service_server之间的通讯，在传递参数和返回值时都要遵循的准则：service_client只会有<strong>handle</strong>，service_server只会有<strong>binder对象</strong>。</p><h2 id="1-4、binder内存"><a href="#1-4、binder内存" class="headerlink" title="1.4、binder内存"></a>1.4、binder内存</h2><p>前面说过binder通讯的本质就是在共享内存上加上一层api，我们来看看他是怎么管理共享内存的。</p><p><img src="/images/posts/2019/01/android_binder/binder_alloc_buffer.png" alt="binder_alloc_buffer"></p><p>我们可以看到：</p><ul><li>binder驱动给每个进程分配最多4M的buffer空间，这段空间在内核通过binder_proc-&gt;alloc红黑树来管理，同时通过mmap映射到进程用户空间；</li><li>和所有的进程通讯机制类似，这段空间相当于进程的接收邮箱inbox，其他进程发过来的消息会从其他进程用户空间复制存放到这里；</li><li>因为是mmap的所有本进程的用户空间访问免除了一次拷贝；</li><li>另外因为进程支持多个线程，所以多个线程会共享本进程的binder buffer；</li></ul><p><img src="/images/posts/2019/01/android_binder/binder_alloc_buffer_transaction.png" alt="binder_alloc_buffer_transaction"></p><p>我们看一下process 0、process n进程和process 1进程进行binder通讯时的buffer使用情况：</p><ul><li>首先会在process 1进程的inbox(binder buffer)空间中分配buffer；</li><li>binder驱动把process 0、process n进程用户空间的消息拷贝到process 1进程的inbox内核buffer中；</li><li>因为mmap，process 1进程的用户空间也可以看见这些消息了；</li></ul><h1 id="2、binder驱动"><a href="#2、binder驱动" class="headerlink" title="2、binder驱动"></a>2、binder驱动</h1><p>驱动是整个binder通讯的核心，java和native都是对其的封装。<br>因为binder驱动代码比较繁杂，看代码比较不好理解。结合第一章讲的基础知识和binder通讯具体场景，我们使用图来分析每一个典型场景下binder驱动内的变化。</p><h2 id="2-1、service-manager的初始化"><a href="#2-1、service-manager的初始化" class="headerlink" title="2.1、service_manager的初始化"></a>2.1、service_manager的初始化</h2><p><img src="/images/posts/2019/01/android_binder/binder_action_servicemanager_init.png" alt="binder_action_servicemanager_init"></p><p>通过上图我们可以看到具体过程：</p><ul><li>1、binder驱动为service_manager进程创建一个新的binder_node结构，赋值：.ptr=0、.cookie=0、.proc=当前proc；</li><li>2、把这个binder_node新节点加入到当前进程的proc-&gt;nodes红黑树中；</li><li>3、把binder_device的全局handle 0指针binder_device-&gt;context.binder_context_mgr_node指向新创建的binder_node；这样其他人通过handle 0指针就能找到对应binder_node，进一步找到service_manager是哪一个进程；</li></ul><p>service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。初始化过程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() -&gt; binder_open()、binder_become_context_manager()</span><br></pre></td></tr></table></figure><h2 id="2-2、service-server的addService"><a href="#2-2、service-server的addService" class="headerlink" title="2.2、service_server的addService"></a>2.2、service_server的addService</h2><p><img src="/images/posts/2019/01/android_binder/binder_action_serviceserver_addservice.png" alt="binder_action_serviceserver_addservice"></p><p>通过上图我们可以看到，在service_server向service_manager注册service的时候，在驱动中的具体流程如下：</p><ul><li>1、因为是向service_manager注册，所以target handle固定=0。通过binder_device-&gt;context找到handle 0对应的binder_node，也就找到了对应的binder_proc，找到了对应的service_manager进程；</li><li>2、在service_manager进程中分配binder buffer，把service_server传递过来的parcel数据全部复制进去；</li><li>3、翻译parcel数据中的binder对象，把binder翻译成handle；</li><li>4、可以看到service_manager进程的handle就是对service_server进程binder的一个引用。把handle加入到service_manager进程的handle缓存红黑树中；</li><li>5、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_manager进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li></ul><p>service_manager的读取响应和reply动作就不去具体分析了，因为都非常的清晰。service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。service_manager在svcmgr_handler()函数中响应service_server的SVC_MGR_ADD_SERVICE请求，最终调用do_add_service()把handle和对应的service name加到svclist链表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() -&gt; binder_loop() -&gt; binder_parse() -&gt; svcmgr_handler() -&gt; do_add_service()</span><br></pre></td></tr></table></figure><h2 id="2-3、service-client的get-service"><a href="#2-3、service-client的get-service" class="headerlink" title="2.3、service_client的get service"></a>2.3、service_client的get service</h2><p><img src="/images/posts/2019/01/android_binder/binder_action_serviceclient_getservice_send.png" alt="binder_action_serviceclient_getservice_send"></p><p>如上图service_client向service_manager发送get service请求的数据比较简单：</p><ul><li>1、根据handle 0找到service_manager进程；</li><li>2、在service_manager进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li><li>3、parcel的内容中没有binder或者handle，不需要翻译；</li><li>4、把parcel数据和其他信息打包成binder_transaction结构，并挂载到proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li></ul><p><img src="/images/posts/2019/01/android_binder/binder_action_serviceclient_getservice_reply.png" alt="binder_action_serviceclient_getservice_reply"></p><p>上图是service_manager给service_client回复信息的过程：</p><ul><li>1、service_manager根据service name在本地svclist链表中找到对应的handle，它把handle打包进parcel并reply给service_client；</li><li>2、根据service_manager所在线程thread-&gt;transaction_stack字段中保存的binder_transaction结构，从.from字段可以找到service_client所在的线程(binder_thread)和进程(binder_proc)；</li><li>3、在service_client进程中分配binder buffer，把service_manager传递过来的parcel数据全部复制进去；</li><li>4、翻译parcel中打包的handle结构，判断handle指向的binder_node进程不是service_client进程，所以新建service_client进程中对binder_node新的引用。新创建handle并加入到service_client进程的handle缓存红黑树中；</li><li>5、这样service_client就从service_manager中获取到了service_server binder对应的引用handle；</li><li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li></ul><h2 id="2-4、service-client调用service"><a href="#2-4、service-client调用service" class="headerlink" title="2.4、service_client调用service"></a>2.4、service_client调用service</h2><p><img src="/images/posts/2019/01/android_binder/binder_action_serviceclient_callservice.png" alt="binder_action_serviceclient_callservice"></p><p>上图是service_client调用service_server的service的过程：</p><ul><li>1、service_client的target handle为上一步向service_manager查询得到的handle，根据handle能找到对应binder_node，进一步找到service_server所在进程；</li><li>2、在service_server进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li><li>3、parcel中打包了函数参数，如果包含handle对象，需要进行翻译；不可能包含binder对象，因为service_client进程的binder对象在service_server进程中无法运行；</li><li>4、如果parcel中包含的handle指向的binder_noe和service_server是同一进程，把它翻译成本地binder，在本地可以运行；</li><li>5、如果parcel中包含的handle指向的binder_noe和service_server不是同一进程，那只能在service_server进程中给它创建一份新的引用handle。这个handle也不能在service_server进程中运行，只能向其他service_server请求服务；</li><li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li></ul><h2 id="2-5、Scatter-gather模式"><a href="#2-5、Scatter-gather模式" class="headerlink" title="2.5、Scatter-gather模式"></a>2.5、Scatter-gather模式</h2><p>在Android O中binder增加了一种性能改进模式Scatter-gather，这是因为binder在传输IPC参数数据时，因为传输的量不大，binder实际上做了3次拷贝：</p><p><img src="/images/posts/2019/01/android_binder/binder_transcation_3_copy.png" alt="binder_transcation_3_copy"></p><p>Scatter-gather把3次copy优化成1次：</p><p><img src="/images/posts/2019/01/android_binder/binder_transcation_Scatter-gather_1_copy.png" alt="binder_transcation_Scatter-gather_1_copy"></p><p>具体的代码可以看驱动对BINDER_TYPE_PTR类型数据的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">case BINDER_TYPE_PTR: &#123;</span><br><span class="line">struct binder_buffer_object *bp &#x3D;</span><br><span class="line">to_binder_buffer_object(hdr);</span><br><span class="line">size_t buf_left &#x3D; sg_buf_end - sg_bufp;</span><br><span class="line"></span><br><span class="line">if (bp-&gt;length &gt; buf_left) &#123;</span><br><span class="line">binder_user_error(&quot;%d:%d got transaction with too large buffer\n&quot;,</span><br><span class="line">  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">return_error_param &#x3D; -EINVAL;</span><br><span class="line">return_error_line &#x3D; __LINE__;</span><br><span class="line">goto err_bad_offset;</span><br><span class="line">&#125;</span><br><span class="line">if (copy_from_user(sg_bufp,</span><br><span class="line">   (const void __user *)(uintptr_t)</span><br><span class="line">   bp-&gt;buffer, bp-&gt;length)) &#123;</span><br><span class="line">binder_user_error(&quot;%d:%d got transaction with invalid offsets ptr\n&quot;,</span><br><span class="line">  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">return_error_param &#x3D; -EFAULT;</span><br><span class="line">return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">return_error_line &#x3D; __LINE__;</span><br><span class="line">goto err_copy_data_failed;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* Fixup buffer pointer to target proc address space *&#x2F;</span><br><span class="line">bp-&gt;buffer &#x3D; (uintptr_t)sg_bufp +</span><br><span class="line">binder_alloc_get_user_buffer_offset(</span><br><span class="line">&amp;target_proc-&gt;alloc);</span><br><span class="line">sg_bufp +&#x3D; ALIGN(bp-&gt;length, sizeof(u64));</span><br><span class="line"></span><br><span class="line">ret &#x3D; binder_fixup_parent(t, thread, bp, off_start,</span><br><span class="line">  offp - off_start,</span><br><span class="line">  last_fixup_obj,</span><br><span class="line">  last_fixup_min_off);</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">return_error_param &#x3D; ret;</span><br><span class="line">return_error_line &#x3D; __LINE__;</span><br><span class="line">goto err_translate_failed;</span><br><span class="line">&#125;</span><br><span class="line">last_fixup_obj &#x3D; bp;</span><br><span class="line">last_fixup_min_off &#x3D; 0;</span><br><span class="line">&#125; break;</span><br></pre></td></tr></table></figure><h2 id="2-6、多个binder-context"><a href="#2-6、多个binder-context" class="headerlink" title="2.6、多个binder context"></a>2.6、多个binder context</h2><p>Android O以后创建了3个misc设备，对应3个domain(contexts)，相互独立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # ls &#x2F;dev&#x2F;*binder</span><br><span class="line">&#x2F;dev&#x2F;binder &#x2F;dev&#x2F;hwbinder &#x2F;dev&#x2F;vndbinder</span><br></pre></td></tr></table></figure><p>因为在Android O以后HIDL也启用了binder通信，使用binder通信的进程越来越多，为了便于管理并且相互隔离，Android把binder划分成了3个domain(contexts)：</p><div class="table-container"><table><thead><tr><th>IPC Domain</th><th>Description</th></tr></thead><tbody><tr><td>/dev/binder</td><td>IPC between framework/app processes with AIDL interfaces</td></tr><tr><td>/dev/hwbinder</td><td>IPC between framework/vendor processes with HIDL interfacesIPC between vendor processes with HIDL interfaces</td></tr><tr><td>/dev/vndbinder</td><td>IPC between vendor/vendor processes with AIDL Interfaces</td></tr></tbody></table></div><h2 id="2-7、调试接口"><a href="#2-7、调试接口" class="headerlink" title="2.7、调试接口"></a>2.7、调试接口</h2><p>binder驱动创建了很多调试接口，可以方便的debug binder通讯的过程。</p><p>1、”/d/binder/state”</p><p>全局情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># more &#x2F;d&#x2F;binder&#x2F;state</span><br><span class="line">binder state:</span><br><span class="line">dead nodes:</span><br><span class="line">  node 392820: u0000007b50bf75a0 c0000007b2b4d5b80 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line"> is 1 iw 1 tr 1 proc 3021</span><br><span class="line">  node 176573: u0000007b50bf72c0 c0000007b4515a600 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line"> is 1 iw 1 tr 1 proc 5571</span><br><span class="line">  node 56178: u0000007b50a8dfa0 c0000007b50bc31c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 3135</span><br><span class="line">  node 47334: u0000007b47f0df40 c0000007b47f077c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 1458</span><br><span class="line">  node 342153: u0000007b47f0d480 c0000007b451bf8c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line"> is 1 iw 1 tr 1 proc 5571</span><br><span class="line">  node 50574: u0000007b451ffa20 c0000007b3519e5c0 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 1458</span><br><span class="line">  node 49594: u0000007b451ff940 c0000007b3507f480 pri 0:139 hs 1 hw 1 ls 0 lw 0</span><br><span class="line">is 1 iw 1 tr 1 proc 2859</span><br></pre></td></tr></table></figure><p>2、”/d/binder/stats”</p><p>全局统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># more &#x2F;d&#x2F;binder&#x2F;stats</span><br><span class="line">binder stats:</span><br><span class="line">BC_TRANSACTION: 226132</span><br><span class="line">BC_REPLY: 201918</span><br><span class="line">BC_FREE_BUFFER: 633493</span><br><span class="line">BC_INCREFS: 9234</span><br><span class="line">BC_ACQUIRE: 9415</span><br><span class="line">BC_RELEASE: 6040</span><br><span class="line">BC_DECREFS: 6014</span><br><span class="line">BC_INCREFS_DONE: 5551</span><br><span class="line">BC_ACQUIRE_DONE: 5552</span><br><span class="line">BC_REGISTER_LOOPER: 355</span><br><span class="line">BC_ENTER_LOOPER: 229</span><br><span class="line">BC_REQUEST_DEATH_NOTIFICATION: 2908</span><br><span class="line">BC_CLEAR_DEATH_NOTIFICATION: 2146</span><br><span class="line">BC_DEAD_BINDER_DONE: 225</span><br><span class="line">BC_TRANSACTION_SG: 118790</span><br><span class="line">BC_REPLY_SG: 86885</span><br><span class="line">BR_TRANSACTION: 344921</span><br><span class="line">BR_REPLY: 288803</span><br><span class="line">BR_TRANSACTION_COMPLETE: 633725</span><br><span class="line">BR_INCREFS: 5559</span><br><span class="line">BR_ACQUIRE: 5560</span><br><span class="line">BR_RELEASE: 3436</span><br><span class="line">BR_DECREFS: 3435</span><br><span class="line">BR_SPAWN_LOOPER: 357</span><br><span class="line">BR_DEAD_BINDER: 226</span><br><span class="line">BR_CLEAR_DEATH_NOTIFICATION_DONE: 2146</span><br><span class="line">proc: active 163 total 232</span><br><span class="line">thread: active 852 total 3214</span><br><span class="line">node: active 1610 total 5564</span><br><span class="line">ref: active 2557 total 9384</span><br><span class="line">death: active 746 total 2908</span><br><span class="line">transaction: active 1 total 633725</span><br><span class="line">transaction_complete: active 0 total 633725</span><br><span class="line">proc 10578</span><br><span class="line">context binder</span><br><span class="line">  threads: 18</span><br><span class="line">  requested threads: 0+2&#x2F;15</span><br><span class="line">  ready threads 3</span><br><span class="line">  free async space 520192</span><br><span class="line">  nodes: 41</span><br></pre></td></tr></table></figure><p>3、”/d/binder/proc/xxx”</p><p>具体进程的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;d&#x2F;binder&#x2F;proc&#x2F;1037</span><br><span class="line">binder proc state:</span><br><span class="line">proc 1037</span><br><span class="line">context binder</span><br><span class="line">  thread 1037: l 12 need_return 0 tr 0</span><br><span class="line">  thread 1094: l 00 need_return 0 tr 0</span><br><span class="line">  thread 1096: l 12 need_return 0 tr 0</span><br><span class="line">  node 2758: u0000006fe9c10000 c0000006fe9c0d008 pri 0:139 hs 1 hw 1 ls 0 lw 0 is 1 iw 1 tr 1 proc 704</span><br><span class="line">  node 1192: u0000006fea02f620 c0000006fea029868 pri 0:139 hs 1 hw 1 ls 0 lw 0 is 1 iw 1 tr 1 proc 549</span><br><span class="line">  ref 1190: desc 0 node 2 s 1 w 1 d 0000000000000000</span><br><span class="line">  ref 1204: desc 1 node 170 s 1 w 1 d 0000000000000000</span><br><span class="line">  ref 249105: desc 2 node 5946 s 1 w 1 d 0000000000000000</span><br><span class="line">  buffer 249107: 0000000000000000 size 3600:0:0 delivered</span><br></pre></td></tr></table></figure><h1 id="3、service-manager实现"><a href="#3、service-manager实现" class="headerlink" title="3、service manager实现"></a>3、service manager实现</h1><p>service_manager逻辑很清晰，代码也不多，主要流程在上节中已经描述就不再详细分析。<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a></p><h1 id="4、native实现"><a href="#4、native实现" class="headerlink" title="4、native实现"></a>4、native实现</h1><p>整个native层binder的实现还是以mediaserver为例来说明。</p><h2 id="4-1、process-thread"><a href="#4-1、process-thread" class="headerlink" title="4.1、process/thread"></a>4.1、process/thread</h2><p><img src="/images/posts/2019/01/android_binder/binder_native_process_thread.png" alt="binder_native_process_thread"></p><p>上图已经把native层binder通讯最重要的部分都画出来了，理解了这张图native的实现基本理解了大半：</p><ul><li>[x] binder在server接收端会创建多个线程，在发送端不会创建专门的线程直接在发送者的线程中；</li><li><p>[x] binder在server端的通用对象是BBinder，在client端的通用引用对象是BpBinder。具体service的server端和client端的实现，只要继承这两个类就行了；</p></li><li><p>1、ProcessState类</p></li></ul><p>因为binder buffer是一个进程一份的，所以不论是client还是server进程，都只会创建一个binder fd，进行一次mmap映射。binder fd、mmap公共资源在本进程内的多个线程间共享。native使用了一个ProcessState类来管理这些进程公共资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    if (gProcess !&#x3D; NULL) &#123;</span><br><span class="line">        return gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* (1) 创建新的ProcessState对象 *&#x2F;</span><br><span class="line">    gProcess &#x3D; new ProcessState(&quot;&#x2F;dev&#x2F;binder&quot;);</span><br><span class="line">    return gProcess;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">ProcessState::ProcessState(const char *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    &#x2F;* (1.1) open binder节点&quot;&#x2F;dev&#x2F;binder&quot;，获得文件句柄 *&#x2F;</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(0)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(0)</span><br><span class="line">    , mManagesContexts(false)</span><br><span class="line">    , mBinderContextCheckFunc(NULL)</span><br><span class="line">    , mBinderContextUserData(NULL)</span><br><span class="line">    , mThreadPoolStarted(false)</span><br><span class="line">    , mThreadPoolSeq(1)</span><br><span class="line">&#123;</span><br><span class="line">    if (mDriverFD &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class="line">        &#x2F;* (1.2) 根据fd映射1M的mmap空间 *&#x2F;</span><br><span class="line">        mVMStart &#x3D; mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class="line">        if (mVMStart &#x3D;&#x3D; MAP_FAILED) &#123;</span><br><span class="line">            &#x2F;&#x2F; *sigh*</span><br><span class="line">            ALOGE(&quot;Using &#x2F;dev&#x2F;binder failed: unable to mmap transaction memory.\n&quot;);</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD &#x3D; -1;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">static int open_driver(const char *driver)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1.1.1) open节点的具体操作 *&#x2F;</span><br><span class="line">    int fd &#x3D; open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;&#x3D; 0) &#123;</span><br><span class="line">        int vers &#x3D; 0;</span><br><span class="line">        status_t result &#x3D; ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        if (result &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result !&#x3D; 0 || vers !&#x3D; BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          ALOGE(&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* (1.1.2) 设置默认最大接收线程数为15 *&#x2F;</span><br><span class="line">        size_t maxThreads &#x3D; DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result &#x3D; ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        if (result &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGW(&quot;Opening &#39;%s&#39; failed: %s\n&quot;, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、IPCThreadState类</li></ul><p>native binder对线程也进行了封装。  </p><ul><li>2.1、对于server端来说，native binder创建一个线程池，可以多个接收线程来响应和运行service服务。例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ps -eT | grep Binder</span><br><span class="line">mediaex       1028  1180     1 2179292  15664 binder_thread_read  0 S Binder:1028_1</span><br><span class="line">mediaex       1028  1886     1 2179292  15664 binder_thread_read  0 S Binder:1028_2</span><br><span class="line">mediaex       1028  1887     1 2179292  15664 binder_thread_read  0 S Binder:1028_3</span><br><span class="line">mediaex       1028  2489     1 2179292  15664 binder_thread_read  0 S Binder:1028_4</span><br><span class="line">mediaex       1028  5497     1 2179292  15664 binder_thread_read  0 S Binder:1028_5</span><br><span class="line">media         1034  1130     1 2140724  10968 binder_thread_read  0 S Binder:1034_1</span><br><span class="line">media         1034  8000     1 2140724  10968 binder_thread_read  0 S Binder:1034_2</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    if (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted &#x3D; true;</span><br><span class="line">        spawnPooledThread(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::spawnPooledThread(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name &#x3D; makeBinderThreadName();</span><br><span class="line">        ALOGV(&quot;Spawning new pooled thread, name&#x3D;%s\n&quot;, name.string());</span><br><span class="line">        &#x2F;* (1)新创建一个PoolThread对象 </span><br><span class="line">            main的意思就是它是一个接收主线程，它不会动态的退出</span><br><span class="line">         *&#x2F;</span><br><span class="line">        sp&lt;Thread&gt; t &#x3D; new PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>PoolThread类继承了Thread类，并且实现了线程主循环函数：threadLoop()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class PoolThread : public Thread</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit PoolThread(bool isMain)</span><br><span class="line">        : mIsMain(isMain)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    virtual bool threadLoop()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;* (1.1) 线程主循环，进一步调用 *&#x2F;</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const bool mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>↓<br>创建IPCThreadState对象<br>frameworks/native/libs/binder/IPCThreadState.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k &#x3D; gTLS;</span><br><span class="line">        IPCThreadState* st &#x3D; (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        &#x2F;* (1.1.1) 创建一个本地线程的IPCThreadState对象 *&#x2F;</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value &#x3D; pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value !&#x3D; 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    &#x2F;&#x2F; FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">    mRealCallingPid &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F; @&#125;</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>最后进入IPCThreadState类的线程主循环函数joinThreadPool()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_THREADPOOL(&quot;**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n&quot;, (void*)pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        &#x2F;&#x2F; now get the next command to be processed, waiting if necessary</span><br><span class="line">        result &#x3D; getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result !&#x3D; TIMED_OUT &amp;&amp; result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF) &#123;</span><br><span class="line">            ALOGE(&quot;getAndExecuteCommand(fd&#x3D;%d) returned unexpected error %d, aborting&quot;,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Let this thread exit the thread pool if it is no longer</span><br><span class="line">        &#x2F;&#x2F; needed and it is not the main process thread.</span><br><span class="line">        if(result &#x3D;&#x3D; TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF);</span><br><span class="line"></span><br><span class="line">    LOG_THREADPOOL(&quot;**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err&#x3D;%d\n&quot;,</span><br><span class="line">        (void*)pthread_self(), getpid(), result);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(false);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.2.1) 和binder驱动交互：</span><br><span class="line">        把mOut中的数据发送给binder驱动</span><br><span class="line">        把接收驱动中的数据到mIn</span><br><span class="line">     *&#x2F;</span><br><span class="line">    result &#x3D; talkWithDriver();</span><br><span class="line">    if (result &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        size_t IN &#x3D; mIn.dataAvail();</span><br><span class="line">        if (IN &lt; sizeof(int32_t)) return result;</span><br><span class="line">        </span><br><span class="line">        &#x2F;* (1.1.2.2) 读出接收数据中的cmd *&#x2F;</span><br><span class="line">        cmd &#x3D; mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing top-level Command: &quot;</span><br><span class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        if (mProcess-&gt;mExecutingThreadsCount &gt;&#x3D; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs &#x3D; uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1.1.2.3) 执行cmd *&#x2F;</span><br><span class="line">        result &#x3D; executeCommand(cmd);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        if (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs !&#x3D; 0) &#123;</span><br><span class="line">            int64_t starvationTimeMs &#x3D; uptimeMillis() - mProcess-&gt;mStarvationStartTimeMs;</span><br><span class="line">            if (starvationTimeMs &gt; 100) &#123;</span><br><span class="line">                ALOGE(&quot;binder thread pool (%zu threads) starved for %&quot; PRId64 &quot; ms&quot;,</span><br><span class="line">                      mProcess-&gt;mMaxThreads, starvationTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>我们只需要关注其中BR_TRANSACTION命令的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line"></span><br><span class="line">    case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">            ALOG_ASSERT(result &#x3D;&#x3D; NO_ERROR,</span><br><span class="line">                &quot;Not enough command data for brTRANSACTION&quot;);</span><br><span class="line">            if (result !&#x3D; NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size&#x2F;sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid &#x3D; mCallingPid;</span><br><span class="line">            &#x2F;&#x2F; FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">            const pid_t  origPidCopy &#x3D; mRealCallingPid;</span><br><span class="line">            &#x2F;&#x2F; @&#125;</span><br><span class="line">            const uid_t origUid &#x3D; mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy &#x3D; mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags &#x3D; mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid &#x3D; tr.sender_pid;</span><br><span class="line">            &#x2F;&#x2F; FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">            mRealCallingPid &#x3D; tr.sender_pid;</span><br><span class="line">            &#x2F;&#x2F; @&#125;</span><br><span class="line">            mCallingUid &#x3D; tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; tr.flags;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n&quot;, mCallingPid, mCallingUid);</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BR_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self()</span><br><span class="line">                    &lt;&lt; &quot; &#x2F; obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot; &#x2F; code &quot;</span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; &quot;Data addr &#x3D; &quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; &quot;, offsets addr&#x3D;&quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                &#x2F;&#x2F; We only have a weak reference on the target object, so we must first try to</span><br><span class="line">                &#x2F;&#x2F; safely acquire a strong reference before doing anything else with it.</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line">                    &#x2F;* (1.1.2.3.1) 如果target是一个合法的本地对象， </span><br><span class="line">                        把tr.cookie转换成BBinder对象，并调用BBinder-&gt;transact()来处理数据</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    error &#x3D; reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error &#x3D; UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error &#x3D; the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n&quot;,</span><br><span class="line">            &#x2F;&#x2F;     mCallingPid, origPid, origUid);</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid &#x3D; origPid;</span><br><span class="line">            &#x2F;&#x2F; FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span><br><span class="line">            mRealCallingPid &#x3D; origPidCopy;</span><br><span class="line">            &#x2F;&#x2F; @&#125;</span><br><span class="line">            mCallingUid &#x3D; origUid;</span><br><span class="line">            mStrictModePolicy &#x3D; origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BC_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; obj &quot;</span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>BBinder是一个标准的通用binder对象，它的transact()函数会被具体的service子类重写，所以会调用到具体子类的transact()函数中<br>frameworks/native/libs/binder/Binder.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status_t BBinder::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t &#x2F;*flags*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION:</span><br><span class="line">            reply-&gt;writeString16(getInterfaceDescriptor());</span><br><span class="line">            return NO_ERROR;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>BnMediaPlayerService是负责具体实现的子类，最后会调用进BnMediaPlayerService类的onTransact()函数中：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">status_t BnMediaPlayerService::onTransact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case CREATE: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            sp&lt;IMediaPlayerClient&gt; client &#x3D;</span><br><span class="line">                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());</span><br><span class="line">            audio_session_t audioSessionId &#x3D; (audio_session_t) data.readInt32();</span><br><span class="line">            sp&lt;IMediaPlayer&gt; player &#x3D; create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(player));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line">        case CREATE_MEDIA_RECORDER: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            const String16 opPackageName &#x3D; data.readString16();</span><br><span class="line">            sp&lt;IMediaRecorder&gt; recorder &#x3D; createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(IInterface::asBinder(recorder));</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.2、对于client端来说是发送数据，native binder不会对其创建新的线程，但是IPCThreadState类也为client端的发送提供了封装。</li></ul><p>client端通用的binder远端代理类为BpBinder，它的发送数据到binder驱动的函数为transact()：<br>frameworks/native/libs/binder/BpBinder.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>最后调用到IPCThreadState类的相关方法：<br>frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err &#x3D; data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |&#x3D; TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; hand &quot;</span><br><span class="line">            &lt;&lt; handle &lt;&lt; &quot; &#x2F; code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot;</span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;* (1) 把数据写入mOut *&#x2F;</span><br><span class="line">        err &#x3D; writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError &#x3D; err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; relayout</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">        </span><br><span class="line">        &#x2F;* (2) 使用mOut、mIn和binder驱动进行通讯 *&#x2F;</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            err &#x3D; waitForResponse(reply);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err &#x3D; waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; relayout</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; hand &quot;</span><br><span class="line">                &lt;&lt; handle &lt;&lt; &quot;: &quot;;</span><br><span class="line">            if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err &#x3D; waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;* (2.1) 和binder驱动通讯 *&#x2F;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break;</span><br><span class="line">        err &#x3D; mIn.errorCheck();</span><br><span class="line">        if (err &lt; NO_ERROR) break;</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd &#x3D; (uint32_t)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;</span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2、manager-proxy"><a href="#4-2、manager-proxy" class="headerlink" title="4.2、manager proxy"></a>4.2、manager proxy</h2><p>service_client service_server和service_manager通讯时，都是处于client角色，所以只能操作service_manager的代理对象。我们看一下具体的代理对象是怎么创建起来的。</p><p>server在注册service服务时，都需要获取到默认manager代理：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/IServiceManager.cpp：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    if (gDefaultServiceManager !&#x3D; NULL) return gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        while (gDefaultServiceManager &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            &#x2F;* (1) 创建BpBinder对象，并在此基础上创建它的子类BpServiceManager对象 *&#x2F;</span><br><span class="line">            gDefaultServiceManager &#x3D; interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(NULL));</span><br><span class="line">            if (gDefaultServiceManager &#x3D;&#x3D; NULL)</span><br><span class="line">                sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>|→<br>frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; &#x2F;*caller*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1.1) 为service_manager创建handle&#x3D;0的BpBinder对象 *&#x2F;</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 *&#x2F;</span><br><span class="line">    handle_entry* e &#x3D; lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to create a new BpBinder if there isn&#39;t currently one, OR we</span><br><span class="line">        &#x2F;&#x2F; are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        &#x2F;&#x2F; in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b &#x3D; e-&gt;binder;</span><br><span class="line">        if (b &#x3D;&#x3D; NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; Special case for context manager...</span><br><span class="line">                &#x2F;&#x2F; The context manager is the only object for which we create</span><br><span class="line">                &#x2F;&#x2F; a BpBinder proxy without already holding a reference.</span><br><span class="line">                &#x2F;&#x2F; Perform a dummy transaction to ensure the context manager</span><br><span class="line">                &#x2F;&#x2F; is registered before we create the first local reference</span><br><span class="line">                &#x2F;&#x2F; to it (which will occur when creating the BpBinder).</span><br><span class="line">                &#x2F;&#x2F; If a local reference is created for the BpBinder when the</span><br><span class="line">                &#x2F;&#x2F; context manager is not present, the driver will fail to</span><br><span class="line">                &#x2F;&#x2F; provide a reference to the context manager, but the</span><br><span class="line">                &#x2F;&#x2F; driver API does not return status.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; Note that this is not race-free if the context manager</span><br><span class="line">                &#x2F;&#x2F; dies while this code runs.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; TODO: add a driver API to wait for context manager, or</span><br><span class="line">                &#x2F;&#x2F; stop special casing handle 0 for context manager and add</span><br><span class="line">                &#x2F;&#x2F; a driver API to get a handle to the context manager with</span><br><span class="line">                &#x2F;&#x2F; proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status &#x3D;&#x3D; DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* (1.1.2) 给新handle新创建一个对应BpBinder对象 *&#x2F;</span><br><span class="line">            b &#x3D; new BpBinder(handle);</span><br><span class="line">            e-&gt;binder &#x3D; b;</span><br><span class="line">            if (b) e-&gt;refs &#x3D; b-&gt;getWeakRefs();</span><br><span class="line">            result &#x3D; b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            &#x2F;&#x2F; reference to the remote proxy when this team doesn&#39;t have one</span><br><span class="line">            &#x2F;&#x2F; but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>|→<br>在创建完标准BpBinder对象以后，使用了一个模板函数interface_cast<IServiceManager>()把子类对象也给创建了。interface_cast()的定义在</p><p>frameworks/native/libs/binder/include/binder/IInterface.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename INTERFACE&gt;</span><br><span class="line">inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface_cast<IServiceManager>()扩展为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frameworks/native/libs/binder/include/binder/IInterface.h:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="line">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">        if (obj !&#x3D; NULL) &#123;                                              \</span><br><span class="line">            intr &#x3D; static_cast&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            if (intr &#x3D;&#x3D; NULL) &#123;                                         \</span><br><span class="line">                intr &#x3D; new Bp##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure><p>frameworks/native/libs/binder/IServiceManager.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;);</span><br></pre></td></tr></table></figure><p>扩展为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;)                       \</span><br><span class="line">    const ::android::String16 IServiceManager::descriptor(&quot;android.os.IServiceManager&quot;);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            IServiceManager::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return IServiceManager::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;IServiceManager&gt; intr;                               \</span><br><span class="line">        if (obj !&#x3D; NULL) &#123;                                              \</span><br><span class="line">            intr &#x3D; static_cast&lt;IServiceManager*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IServiceManager::descriptor).get());               \</span><br><span class="line">            if (intr &#x3D;&#x3D; NULL) &#123;                                         \</span><br><span class="line">                intr &#x3D; new BpServiceManager(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;                                    \</span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure><p>所以defaultServiceManager()最后得到了一个BpServiceManager对象，利用它的::addService()方法来注册service。<br>frameworks/native/libs/binder/IServiceManager.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class BpServiceManager : public BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit BpServiceManager(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,</span><br><span class="line">            bool allowIsolated)</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        data.writeInt32(allowIsolated ? 1 : 0);</span><br><span class="line">        status_t err &#x3D; remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return err &#x3D;&#x3D; NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remote()-&gt;transact()会调用到BpBinder的transact()函数，最后IPCThreadState的transact()函数。<br>frameworks/native/libs/binder/BpBinder.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用老罗的一张图总结，service_manager类之间复杂的关系：</p><p><img src="/images/posts/2019/01/android_binder/binder_class_manager.jpg" alt="binder_class_manager"></p><h2 id="4-3、server"><a href="#4-3、server" class="headerlink" title="4.3、server"></a>4.3、server</h2><p>有了manager的代理对象以后，server就可以注册服务并且创建binder rx服务线程了。</p><p>frameworks/av/media/mediaserver/main_mediaserver.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc __unused, char **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    ALOGI(&quot;ServiceManager: %p&quot;, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的细节在上面几节都已经描述过了，还是借用老罗的一张图总结service_server类之间复杂的关系：</p><p><img src="/images/posts/2019/01/android_binder/binder_class_server.jpg" alt="binder_class_server"></p><h2 id="4-4、client-proxy"><a href="#4-4、client-proxy" class="headerlink" title="4.4、client proxy"></a>4.4、client proxy</h2><p>service_client也是创建代理对象，和manager代理非常相似。我们也来具体分析一下。<br>frameworks/av/media/libmedia/IMediaDeathNotifier.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;getMediaPlayerService&quot;);</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    if (sMediaPlayerService &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;* (1) 创建manager代理对象 *&#x2F;</span><br><span class="line">        sp&lt;IServiceManager&gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;* (2) 使用manager代理获取到service的handle, </span><br><span class="line">                并根据handle创建一个BpBinder对象</span><br><span class="line">             *&#x2F;</span><br><span class="line">            binder &#x3D; sm-&gt;getService(String16(&quot;media.player&quot;));</span><br><span class="line">            if (binder !&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ALOGW(&quot;Media player service not published, waiting...&quot;);</span><br><span class="line">            usleep(500000); &#x2F;&#x2F; 0.5 s</span><br><span class="line">        &#125; while (true);</span><br><span class="line"></span><br><span class="line">        if (sDeathNotifier &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            sDeathNotifier &#x3D; new DeathNotifier();</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;linkToDeath(sDeathNotifier);</span><br><span class="line">        &#x2F;* (3) 根据BpBinder对象，使用interface_cast&lt;IMediaPlayerService&gt;()函数创建一个BpMediaPlayerService对象 *&#x2F;</span><br><span class="line">        sMediaPlayerService &#x3D; interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE_IF(sMediaPlayerService &#x3D;&#x3D; 0, &quot;no media player service!?&quot;);</span><br><span class="line">    return sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了BpMediaPlayerService对象，即MediaPlayerService的远端代理，就可以调用远端service服务了。<br>frameworks/wilhelm/src/android/android_LocAVPlayer.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void LocAVPlayer::onPrepare() &#123;</span><br><span class="line">    SL_LOGD(&quot;LocAVPlayer::onPrepare()&quot;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;* (4.1) 获取到MediaPlayerService的远端代理 *&#x2F;</span><br><span class="line">    sp&lt;IMediaPlayerService&gt; mediaPlayerService(getMediaPlayerService());</span><br><span class="line">    if (mediaPlayerService !&#x3D; NULL) &#123;</span><br><span class="line">        switch (mDataLocatorType) &#123;</span><br><span class="line">        case kDataLocatorUri:</span><br><span class="line">        </span><br><span class="line">            &#x2F;* (4.2) 调用远端service服务 *&#x2F;</span><br><span class="line">            mPlayer &#x3D; mediaPlayerService-&gt;create(mPlayerClient &#x2F;*IMediaPlayerClient*&#x2F;,</span><br><span class="line">                    mPlaybackParams.sessionId);</span><br></pre></td></tr></table></figure><p>其中通过sm-&gt;getService(String16(“media.player”))返回BpBinder的过程如下：<br>frameworks/native/libs/binder/IServiceManager.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const&#123;&#125;</span><br><span class="line">↓</span><br><span class="line">    virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        &#x2F;* (2.1) 向远程manager查询handle *&#x2F;</span><br><span class="line">        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/Parcel.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() const</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    &#x2F;&#x2F; Note that a lot of code in Android reads binders by hand with this</span><br><span class="line">    &#x2F;&#x2F; method, and that code has historically been ok with getting nullptr</span><br><span class="line">    &#x2F;&#x2F; back (while ignoring error codes).</span><br><span class="line">    readNullableStrongBinder(&amp;val);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) const</span><br><span class="line">&#123;</span><br><span class="line">    return unflatten_binder(ProcessState::self(), *this, val);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    const Parcel&amp; in, sp&lt;IBinder&gt;* out)</span><br><span class="line">&#123;</span><br><span class="line">    const flat_binder_object* flat &#x3D; in.readObject(false);</span><br><span class="line"></span><br><span class="line">    if (flat) &#123;</span><br><span class="line">        switch (flat-&gt;type) &#123;</span><br><span class="line">            case BINDER_TYPE_BINDER:</span><br><span class="line">                *out &#x3D; reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                return finish_unflatten_binder(NULL, *flat, in);</span><br><span class="line">            case BINDER_TYPE_HANDLE:</span><br><span class="line">                &#x2F;* (2.1.1) 根据handle创建BpBinder *&#x2F;</span><br><span class="line">                *out &#x3D; proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                return finish_unflatten_binder(</span><br><span class="line">                    static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>然后就来到了创建manager代理对象同样的位置：<br>frameworks/native/libs/binder/ProcessState.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 *&#x2F;</span><br><span class="line">    handle_entry* e &#x3D; lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to create a new BpBinder if there isn&#39;t currently one, OR we</span><br><span class="line">        &#x2F;&#x2F; are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        &#x2F;&#x2F; in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b &#x3D; e-&gt;binder;</span><br><span class="line">        if (b &#x3D;&#x3D; NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; Special case for context manager...</span><br><span class="line">                &#x2F;&#x2F; The context manager is the only object for which we create</span><br><span class="line">                &#x2F;&#x2F; a BpBinder proxy without already holding a reference.</span><br><span class="line">                &#x2F;&#x2F; Perform a dummy transaction to ensure the context manager</span><br><span class="line">                &#x2F;&#x2F; is registered before we create the first local reference</span><br><span class="line">                &#x2F;&#x2F; to it (which will occur when creating the BpBinder).</span><br><span class="line">                &#x2F;&#x2F; If a local reference is created for the BpBinder when the</span><br><span class="line">                &#x2F;&#x2F; context manager is not present, the driver will fail to</span><br><span class="line">                &#x2F;&#x2F; provide a reference to the context manager, but the</span><br><span class="line">                &#x2F;&#x2F; driver API does not return status.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; Note that this is not race-free if the context manager</span><br><span class="line">                &#x2F;&#x2F; dies while this code runs.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; TODO: add a driver API to wait for context manager, or</span><br><span class="line">                &#x2F;&#x2F; stop special casing handle 0 for context manager and add</span><br><span class="line">                &#x2F;&#x2F; a driver API to get a handle to the context manager with</span><br><span class="line">                &#x2F;&#x2F; proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status &#x3D;&#x3D; DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* (2.1.1.2) 给新handle新创建一个对应BpBinder对象 *&#x2F;</span><br><span class="line">            b &#x3D; new BpBinder(handle);</span><br><span class="line">            e-&gt;binder &#x3D; b;</span><br><span class="line">            if (b) e-&gt;refs &#x3D; b-&gt;getWeakRefs();</span><br><span class="line">            result &#x3D; b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            &#x2F;&#x2F; reference to the remote proxy when this team doesn&#39;t have one</span><br><span class="line">            &#x2F;&#x2F; but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据BpBinder对象，使用interface_cast<IMediaPlayerService>()函数创建一个BpMediaPlayerService对象的过程如下：</p><p>interface_cast<IMediaPlayerService>()扩展为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IMediaPlayerService&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return IMediaPlayerService::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IMediaPlayerService定义在：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(MediaPlayerService, &quot;android.media.IMediaPlayerService&quot;);</span><br></pre></td></tr></table></figure><p>展开为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define IMPLEMENT_META_INTERFACE(MediaPlayerService, &quot;android.os.IServiceManager&quot;)                       \</span><br><span class="line">    const ::android::String16 IMediaPlayerService::descriptor(&quot;android.os.IServiceManager&quot;);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            IMediaPlayerService::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return IMediaPlayerService::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;IMediaPlayerService&gt; intr;                               \</span><br><span class="line">        if (obj !&#x3D; NULL) &#123;                                              \</span><br><span class="line">            intr &#x3D; static_cast&lt;IMediaPlayerService*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IMediaPlayerService::descriptor).get());               \</span><br><span class="line">            if (intr &#x3D;&#x3D; NULL) &#123;                                         \</span><br><span class="line">                &#x2F;* (3.1) 根据BpBinder对象，创建一个BpMediaPlayerService对象 *&#x2F;</span><br><span class="line">                intr &#x3D; new BpMediaPlayerService(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IMediaPlayerService::IMediaPlayerService() &#123; &#125;                                    \</span><br><span class="line">    IMediaPlayerService::~IMediaPlayerService() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure><p>BpMediaPlayerService的定义为：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit BpMediaPlayerService(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IMediaPlayerService&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaMetadataRetriever&gt; createMetadataRetriever()</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(CREATE_METADATA_RETRIEVER, data, &amp;reply);</span><br><span class="line">        return interface_cast&lt;IMediaMetadataRetriever&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是借用老罗的一张图总结service_client类之间复杂的关系：</p><p><img src="/images/posts/2019/01/android_binder/binder_class_client.jpg" alt="binder_class_client"></p><h2 id="4-5、service-thread管理"><a href="#4-5、service-thread管理" class="headerlink" title="4.5、service thread管理"></a>4.5、service thread管理</h2><p>binder service初始会启动2个main线程来提供服务，在等待service服务过多的情况下会动态的增加binder线程的数量，但是目前没有实现动态减少binder线程可能觉得cache着更好。</p><p>service一般默认最大考验开启15个线程，这个数值也可以通过ioctl的BINDER_SET_MAX_THREADS命令来修改。</p><p>动态增加binder线程的动作是binder驱动完成的，因为驱动可以看到service进程整个的阻塞情况。</p><p>具体驱动代码binder.c：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *proc,</span><br><span class="line">      struct binder_thread *thread,</span><br><span class="line">      binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">      binder_size_t *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if (proc-&gt;requested_threads &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">     BINDER_LOOPER_STATE_ENTERED)) &#x2F;* the user-space code fails to *&#x2F;</span><br><span class="line">     &#x2F;*spawn a new thread if we leave this out *&#x2F;) &#123;</span><br><span class="line">proc-&gt;requested_threads++;</span><br><span class="line">binder_inner_proc_unlock(proc);</span><br><span class="line">binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">     &quot;%d:%d BR_SPAWN_LOOPER\n&quot;,</span><br><span class="line">     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line"></span><br><span class="line">&#x2F;* (1) 判断阻塞的情况下发送BR_SPAWN_LOOPER命令，通知native增加接收线程 *&#x2F;</span><br><span class="line">if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))</span><br><span class="line">return -EFAULT;</span><br><span class="line">binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frameworks/native/libs/binder/IPCThreadState.cpp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    case BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(false);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::spawnPooledThread(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name &#x3D; makeBinderThreadName();</span><br><span class="line">        ALOGV(&quot;Spawning new pooled thread, name&#x3D;%s\n&quot;, name.string());</span><br><span class="line">        &#x2F;* (1.1) 创建新的binder接收线程 *&#x2F;</span><br><span class="line">        sp&lt;Thread&gt; t &#x3D; new PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6、死亡通知-DeathRecipient"><a href="#4-6、死亡通知-DeathRecipient" class="headerlink" title="4.6、死亡通知(DeathRecipient)"></a>4.6、死亡通知(DeathRecipient)</h2><p>可以使用BC_REQUEST_DEATH_NOTIFICATION注册死亡通知，在server端正常或者异常死亡的情况下都能收到通知。</p><p>在server端进程正常或者异常退出时，会关闭进程所有打开的文件句柄：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">do_exit()</span><br><span class="line">↓</span><br><span class="line">exit_files()</span><br><span class="line">↓</span><br><span class="line">put_files_struct()</span><br><span class="line">↓</span><br><span class="line">static struct fdtable *close_files(struct files_struct * files)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * It is safe to dereference the fd table without RCU or</span><br><span class="line"> * -&gt;file_lock because this is the last reference to the</span><br><span class="line"> * files structure.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct fdtable *fdt &#x3D; rcu_dereference_raw(files-&gt;fdt);</span><br><span class="line">unsigned int i, j &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">unsigned long set;</span><br><span class="line">i &#x3D; j * BITS_PER_LONG;</span><br><span class="line">if (i &gt;&#x3D; fdt-&gt;max_fds)</span><br><span class="line">break;</span><br><span class="line">set &#x3D; fdt-&gt;open_fds[j++];</span><br><span class="line">while (set) &#123;</span><br><span class="line">if (set &amp; 1) &#123;</span><br><span class="line">struct file * file &#x3D; xchg(&amp;fdt-&gt;fd[i], NULL);</span><br><span class="line">if (file) &#123;</span><br><span class="line">filp_close(file, files);</span><br><span class="line">cond_resched_rcu_qs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">set &gt;&gt;&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return fdt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到binder fd的release函数，调用到死亡通知的回调:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int binder_release(struct inode *nodp, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">debugfs_remove(proc-&gt;debugfs_entry);</span><br><span class="line">binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">static void</span><br><span class="line">binder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer)</span><br><span class="line">&#123;</span><br><span class="line">mutex_lock(&amp;binder_deferred_lock);</span><br><span class="line">proc-&gt;deferred_work |&#x3D; defer;</span><br><span class="line">if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123;</span><br><span class="line">hlist_add_head(&amp;proc-&gt;deferred_work_node,</span><br><span class="line">&amp;binder_deferred_list);</span><br><span class="line">schedule_work(&amp;binder_deferred_work);</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;binder_deferred_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、java实现"><a href="#5、java实现" class="headerlink" title="5、java实现"></a>5、java实现</h1><p>略</p><h1 id="6、AIDL-Android-Interface-Definition-Language"><a href="#6、AIDL-Android-Interface-Definition-Language" class="headerlink" title="6、AIDL(Android Interface Definition Language)"></a>6、AIDL(Android Interface Definition Language)</h1><p>略</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://blog.csdn.net/Luoshengyang/article/details/6629298" target="_blank" rel="noopener">1、Android系统进程间通信（IPC）机制 罗升阳</a><br><a href="http://light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%80%85%5BParcel%5D/" target="_blank" rel="noopener">2、Android Binder 分析</a><br><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">3、Android Bander设计与实现</a><br><a href="https://blog.csdn.net/chenying126/article/details/78989413#_Toc503017553" target="_blank" rel="noopener">4、Binder实现原理分析</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="noopener">5、一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a>  </p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel 空间加载用户空间fw实现原理</title>
      <link href="/2018/11/23//implementation-of-loading-fw-from-userspace.html/"/>
      <url>/2018/11/23//implementation-of-loading-fw-from-userspace.html/</url>
      
        <content type="html"><![CDATA[<p>随着手机外围器件的集成度和复杂度越来越高, 单纯的设置相关寄存器已经无法使得器件可以正常的工作. 在一般情况下，需要将一个特定的fw下载到器件中, 确保器件可以正常稳定的运行, 比如：camera ois，camera actuator， TP等等. 一般情况下, 有以下三种方案:</p><ul><li>直接将fw data转化为特定的数组，编码在驱动代码中.</li><li>将fw data烧录到一个分区中，需要的时候从分区中load进来.</li><li>将fw打包到某个镜像中，如vendor，system等等，需要的时候从用户空间中load到kernel空间中.</li></ul><p>对于方案1, 直接将其硬编码在驱动代码中, 会造成kernel镜像size变大, 有可能造成镜像超限, 导致kernel启动失败; 并且调试也不方便, 每次修改fw都需要重新编译内核.</p><p>对于方案2, 需要实现预留好空间, 某些时候可能无法满足; 并且一般重新烧录fw, 一般机器需要进入特定的模式, 不利于在线调试.</p><p>对于方案3,  能够有效的避免前两种方案的不足, 在驱动中应用比较广泛, 也是本文叙述的主题.</p><p>下文主要从编程步骤出发, 通过调用的接口来具体分析其中实现的机制.</p><h3 id="一-编程步骤"><a href="#一-编程步骤" class="headerlink" title="一 编程步骤"></a>一 编程步骤</h3><p>linux内核为方案3提供了完整的解决方案, 驱动开发起来也相当的方便, 具体的步骤如下:</p><ol><li>在编译的时候, 将fw打包到具体镜像中. 对于android系统，可以将fw放在/etc/firmware, /vendor/firmware, /firmware/image这几个目录. 当上层服务ueventd接收到kernel上报的请求fw的uevent事件, 会依次搜索这几个目录, 查找对应名称的fw, 并通过节点data传递给kernel.</li><li>由于内核已经封装好了接口, 驱动代码比较简单, 具体如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;linux&#x2F;firmware.h&gt;</span><br><span class="line"> ....</span><br><span class="line">xxx_func() &#123;</span><br><span class="line">const struct firmware *fw&#x3D;NULL;&#96;</span><br><span class="line">......</span><br><span class="line">request_firmware(&amp;fw, fw_name, dev);</span><br><span class="line">.......</span><br><span class="line">release_firmware();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上面的步骤可知, 内核已经把接口封装的相当简洁, 使用简单的接口就可以完成load 用户空间的fw任务. 当然kernel还为我们提供了其他类型接口, 主要是提供了一些其他的特性, 满足特定条件下load 用户空间的fw. 例如, 如果在原子上下文load fw，则只能用request_firmware_nowait()接口, 该接口不会导致进程睡眠. 但是所有的这些接口, 其工作原理是一样, 因此下文将以request_firmware()为入口分析load用户空间fw的原理.</p><h3 id="二-实现原理分析"><a href="#二-实现原理分析" class="headerlink" title="二 实现原理分析"></a>二 实现原理分析</h3><h4 id="2-1-相关结构体介绍"><a href="#2-1-相关结构体介绍" class="headerlink" title="2.1 相关结构体介绍"></a>2.1 相关结构体介绍</h4><p>理解代码最好的入口是熟悉代码使用的数据结构, 理解了代码使用的数据结构, 就基本上可以对代码的实现原理有一个初步的认识. 所以下面熟悉一下相关的数据结构.</p><ul><li>firmware 结构体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">路径:include&#x2F;linux&#x2F;firmware.h</span><br><span class="line">struct firmware &#123;</span><br><span class="line">        size_t size;</span><br><span class="line">        const u8 *data;</span><br><span class="line">        struct page **pages;</span><br><span class="line"></span><br><span class="line">        &#x2F;* firmware loader private fields *&#x2F;</span><br><span class="line">        void *priv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体主要用于向驱动导出load 到内核的fw信息, 成员含义如下:<br>size: firmware 数据的大小.<br>data: firmware数据.<br>pages: 指向fw data存储的物理页面.<br>priv: 私有数据指针.</p><ul><li>builtin_fw 结构体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">路径:include&#x2F;linux&#x2F;firmware.h</span><br><span class="line">struct builtin_fw &#123;</span><br><span class="line">        char *name;</span><br><span class="line">        void *data;</span><br><span class="line">        unsigned long size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构主要用于描述编译到内核builtin_fw段的fw, 成员含义如下:<br>name: firmware 数据的名称.<br>data: 指向firmware数据的指针.<br>size: firmware的大小.</p><ul><li>firmware_buf结构体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">struct firmware_buf &#123;</span><br><span class="line">        struct kref ref;</span><br><span class="line">        struct list_head list;</span><br><span class="line">        struct completion completion;</span><br><span class="line">        struct firmware_cache *fwc;</span><br><span class="line">        unsigned long status;</span><br><span class="line">        void *data;</span><br><span class="line">        size_t size;</span><br><span class="line">        size_t allocated_size;</span><br><span class="line">#ifdef CONFIG_FW_LOADER_USER_HELPER</span><br><span class="line">        bool is_paged_buf;</span><br><span class="line">        bool need_uevent;</span><br><span class="line">        struct page **pages;</span><br><span class="line">        int nr_pages;</span><br><span class="line">        int page_array_size;</span><br><span class="line">        struct list_head pending_list;</span><br><span class="line">#endif</span><br><span class="line">        const char *fw_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体主要用于存储fw data,以及一些控制状态等等. 部分重要的成员解释如下:<br>completion: 完成量,用于在load fw完成时, 唤醒等待的进程.<br>fwc: 指向全局的fw_cache, 该结构保存了已经load 的fw的相关信息.<br>status: 保存当前的状态.<br>data: 指向保存fw data的kernel虚拟地址.<br>size: fw 的大小.<br>pages: 指向存储fw data的物理页.<br>page_array_size: 分配的物理页的数目.<br>fw_id: fw 的名称.</p><h4 id="2-2-实现原理分析"><a href="#2-2-实现原理分析" class="headerlink" title="2.2 实现原理分析"></a>2.2 实现原理分析</h4><p>request_firmware()和request_firmware_nowait()等接口都是_request_firmware()的一个前端, 仅仅只是传进的参数不一样而已, 因此基于分析request_firmware()的实现来探讨其实现原理, request_firmware()如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">int</span><br><span class="line">request_firmware(const struct firmware **firmware_p, const char *name,</span><br><span class="line"> struct device *device)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">&#x2F;* Need to pin this module until return *&#x2F;</span><br><span class="line">__module_get(THIS_MODULE);</span><br><span class="line">ret &#x3D; _request_firmware(firmware_p, name, device, NULL, 0,</span><br><span class="line">FW_OPT_UEVENT | FW_OPT_FALLBACK);</span><br><span class="line">module_put(THIS_MODULE);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看_request_firmware()函数的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static int</span><br><span class="line">_request_firmware(const struct firmware **firmware_p, const char *name,</span><br><span class="line">                  struct device *device, void *buf, size_t size,</span><br><span class="line">                  unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        ret &#x3D; _request_firmware_prepare(&amp;fw, name, device, buf, size,</span><br><span class="line">                                        opt_flags);</span><br><span class="line">        if (ret &lt;&#x3D; 0) &#x2F;* error or already assigned *&#x2F;</span><br><span class="line">                goto out;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">         ret &#x3D; fw_get_filesystem_firmware(device, fw-&gt;priv);</span><br><span class="line">         if (ret) &#123;</span><br><span class="line">                 if (!(opt_flags &amp; FW_OPT_NO_WARN))</span><br><span class="line">                         dev_dbg(device,</span><br><span class="line">                                  &quot;Firmware %s was not found in kernel paths. rc:%d\n&quot;,</span><br><span class="line">                                  name, ret);</span><br><span class="line">                 if (opt_flags &amp; FW_OPT_USERHELPER) &#123;</span><br><span class="line">                         dev_err(device, &quot;[%s]Falling back to user helper\n&quot;, __func__);</span><br><span class="line">                         ret &#x3D; fw_load_from_user_helper(fw, name, device,</span><br><span class="line">                                                        opt_flags, timeout);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line"> if (!ret)</span><br><span class="line">        ret &#x3D; assign_firmware_buf(fw, device, opt_flags);</span><br><span class="line">......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在该函数中，会依次从4个地方尝试load 相应的fw, 具体如下:</p><ul><li>从内核中相应的段中查找是否有符合要求的firmware.</li><li>从cache中查找是否有上次load相应的还没有换出firmware.</li><li>直接利用内核中文件接口中读取相应的firmware.</li><li>利用uevent接口load相应的firmware.</li></ul><p>其中, 对于第1种和第2种情况是在_request_firmware_prepare()函数中完成的; 第3种情况是在_request_firmware_prepare()函数中完成的; 第4种情况是在fw_load_from_user_helper()函数中完成的.</p><p>对于第1种情况, 其具体的实现在fw_get_builtin_firmware()函数中, 原理是通过遍历builtin_fw段的firmware, 并比较firmware的name是否相同, 如果相同, 表示匹配上,则将firmware的size和data赋值给驱动传过来的firmware结构体指针, request_firmware就完成load firmware功能, 具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">路径:drivers&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static int</span><br><span class="line">_request_firmware_prepare(struct firmware **firmware_p, const char *name,</span><br><span class="line">                          struct device *device, void *dbuf, size_t size,</span><br><span class="line">                          unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">.......</span><br><span class="line">        *firmware_p &#x3D; firmware &#x3D; kzalloc(sizeof(*firmware), GFP_KERNEL);</span><br><span class="line">        if (!firmware) &#123;</span><br><span class="line">                dev_err(device, &quot;%s: kmalloc(struct firmware) failed\n&quot;,</span><br><span class="line">                        __func__);</span><br><span class="line">                return -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fw_get_builtin_firmware(firmware, name, dbuf, size)) &#123;</span><br><span class="line">                dev_dbg(device, &quot;using built-in %s\n&quot;, name);</span><br><span class="line">                return 0; &#x2F;* assigned *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">路径:drivers&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static bool fw_get_builtin_firmware(struct firmware *fw, const char *name,</span><br><span class="line">                                    void *buf, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">        struct builtin_fw *b_fw;</span><br><span class="line"></span><br><span class="line">        for (b_fw &#x3D; __start_builtin_fw; b_fw !&#x3D; __end_builtin_fw; b_fw++) &#123;</span><br><span class="line">                if (strcmp(name, b_fw-&gt;name) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        fw-&gt;size &#x3D; b_fw-&gt;size;</span><br><span class="line">                        fw-&gt;data &#x3D; b_fw-&gt;data;</span><br><span class="line"></span><br><span class="line">                        if (buf &amp;&amp; fw-&gt;size &lt;&#x3D; size)</span><br><span class="line">                                memcpy(buf, fw-&gt;data, fw-&gt;size);</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第2种情况, 其具体的实现在fw_lookup_and_allocate_buf()函数中, 匹配原理和第1种情况相同, 只不过查找实在全局变量fw_cache的链表上查找. fw_cache的 head链表上保存了以前load过的fw的信息,比如name, data, size等等. 其中在函数sync_cached_firmware_buf()中主要检查fw是否已经load到内核空间, 如果没有, 则等待; 否在就调用fw_set_page_data(), 将fw相关的信息赋值到驱动的firmware结构体指针, 具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">路径:drivers&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static int</span><br><span class="line">_request_firmware_prepare(struct firmware **firmware_p, const char *name,</span><br><span class="line">                          struct device *device, void *dbuf, size_t size,</span><br><span class="line">                          unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">        ret &#x3D; fw_lookup_and_allocate_buf(name, &amp;fw_cache, &amp;buf, dbuf, size,</span><br><span class="line">                                        opt_flags);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * bind with &#39;buf&#39; now to avoid warning in failure path</span><br><span class="line">         * of requesting firmware.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        firmware-&gt;priv &#x3D; buf;</span><br><span class="line"></span><br><span class="line">        if (ret &gt; 0) &#123;</span><br><span class="line">                ret &#x3D; sync_cached_firmware_buf(buf);</span><br><span class="line">                if (!ret) &#123;</span><br><span class="line">                        fw_set_page_data(buf, firmware);</span><br><span class="line">                        return 0; &#x2F;* assigned *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">路径:drivers&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static int fw_lookup_and_allocate_buf(const char *fw_name,</span><br><span class="line">                                      struct firmware_cache *fwc,</span><br><span class="line">                                      struct firmware_buf **buf, void *dbuf,</span><br><span class="line">                                      size_t size, unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">        struct firmware_buf *tmp;</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;fwc-&gt;lock);</span><br><span class="line">        if (!(opt_flags &amp; FW_OPT_NOCACHE)) &#123;</span><br><span class="line">                tmp &#x3D; __fw_lookup_buf(fw_name);</span><br><span class="line">                if (tmp) &#123;</span><br><span class="line">                        kref_get(&amp;tmp-&gt;ref);</span><br><span class="line">                        spin_unlock(&amp;fwc-&gt;lock);</span><br><span class="line">                        *buf &#x3D; tmp;</span><br><span class="line">                        return 1;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第3种情况, 依据内核预先定义好的路径fw_path调用内核文件读写接口kernel_read_file_from_path load入相应的fw, 在fw_finish_direct_load()函数中做了一些load fw后的清理工作,比如设置完成标志等等.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">路径:drivers&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static int</span><br><span class="line">fw_get_filesystem_firmware(struct device *device, struct firmware_buf *buf)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; ARRAY_SIZE(fw_path); i++) &#123;</span><br><span class="line">                &#x2F;* skip the unset customized path *&#x2F;</span><br><span class="line">                if (!fw_path[i][0])</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                len &#x3D; snprintf(path, PATH_MAX, &quot;%s&#x2F;%s&quot;,</span><br><span class="line">                               fw_path[i], buf-&gt;fw_id);</span><br><span class="line">                if (len &gt;&#x3D; PATH_MAX) &#123;</span><br><span class="line">                        rc &#x3D; -ENAMETOOLONG;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 buf-&gt;size &#x3D; 0;</span><br><span class="line">                 rc &#x3D; kernel_read_file_from_path(path, &amp;buf-&gt;data, &amp;size, msize,</span><br><span class="line">                                                 id);</span><br><span class="line">                 if (rc) &#123;</span><br><span class="line">                         if (rc &#x3D;&#x3D; -ENOENT)</span><br><span class="line">                                 dev_dbg(device, &quot;loading %s failed with error %d\n&quot;,</span><br><span class="line">                                          path, rc);</span><br><span class="line">                         else</span><br><span class="line">                                 dev_warn(device, &quot;loading %s failed with error %d\n&quot;,</span><br><span class="line">                                          path, rc);</span><br><span class="line">                         continue;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dev_dbg(device, &quot;direct-loading %s\n&quot;, buf-&gt;fw_id);</span><br><span class="line">                 buf-&gt;size &#x3D; size;</span><br><span class="line">                 fw_finish_direct_load(device, buf);</span><br><span class="line">                 break;</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>fw_path具体的定义如下, 其中fw_path_para主要用于用户传递定制的路径.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const char * const fw_path[] &#x3D; &#123;</span><br><span class="line">        fw_path_para,</span><br><span class="line">        &quot;&#x2F;data&#x2F;vendor&#x2F;vibrator&quot;,</span><br><span class="line">        &quot;&#x2F;lib&#x2F;firmware&#x2F;updates&#x2F;&quot; UTS_RELEASE,</span><br><span class="line">        &quot;&#x2F;lib&#x2F;firmware&#x2F;updates&quot;,</span><br><span class="line">        &quot;&#x2F;lib&#x2F;firmware&#x2F;&quot; UTS_RELEASE,</span><br><span class="line">        &quot;&#x2F;lib&#x2F;firmware&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当在前三种情况下无法找到对应的fw时,就会进入第4种情况进行查找, 其工作在函数为fw_load_from_user_helper()种实现, 具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int fw_load_from_user_helper(struct firmware *firmware,</span><br><span class="line">                                    const char *name, struct device *device,</span><br><span class="line">                                    unsigned int opt_flags, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">        struct firmware_priv *fw_priv;</span><br><span class="line"></span><br><span class="line">        fw_priv &#x3D; fw_create_instance(firmware, name, device, opt_flags);</span><br><span class="line">        if (IS_ERR(fw_priv))</span><br><span class="line">                return PTR_ERR(fw_priv);</span><br><span class="line"></span><br><span class="line">        fw_priv-&gt;buf &#x3D; firmware-&gt;priv;</span><br><span class="line">        return _request_firmware_load(fw_priv, opt_flags, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数 fw_create_instance() 主要进行了一些设备的初始化工作, 如设备所属的class, groups等等. 具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static struct firmware_priv *</span><br><span class="line">fw_create_instance(struct firmware *firmware, const char *fw_name,</span><br><span class="line">                   struct device *device, unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">        struct firmware_priv *fw_priv;</span><br><span class="line">        struct device *f_dev;</span><br><span class="line"></span><br><span class="line">        fw_priv &#x3D; kzalloc(sizeof(*fw_priv), GFP_KERNEL);</span><br><span class="line">        if (!fw_priv) &#123;</span><br><span class="line">                fw_priv &#x3D; ERR_PTR(-ENOMEM);</span><br><span class="line">                goto exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw_priv-&gt;nowait &#x3D; !!(opt_flags &amp; FW_OPT_NOWAIT);</span><br><span class="line">        fw_priv-&gt;fw &#x3D; firmware;</span><br><span class="line">        f_dev &#x3D; &amp;fw_priv-&gt;dev;</span><br><span class="line"></span><br><span class="line">        device_initialize(f_dev);</span><br><span class="line">        dev_set_name(f_dev, &quot;%s&quot;, fw_name);</span><br><span class="line">        f_dev-&gt;parent &#x3D; device;</span><br><span class="line">        f_dev-&gt;class &#x3D; &amp;firmware_class;</span><br><span class="line">        f_dev-&gt;groups &#x3D; fw_dev_attr_groups;</span><br><span class="line">exit:</span><br><span class="line">        return fw_priv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中重点看一下 fw_dev_attr_groups属性集合, 由linux 设备驱动框架原理,当该设备加入到系统中时,会在该设备下生成两个节点data和loading, 后面讲到这两个节点的用处.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static const struct attribute_group *fw_dev_attr_groups[] &#x3D; &#123;</span><br><span class="line">        &amp;fw_dev_attr_group,</span><br><span class="line">        NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct attribute_group fw_dev_attr_group &#x3D; &#123;</span><br><span class="line">        .attrs &#x3D; fw_dev_attrs,</span><br><span class="line">        .bin_attrs &#x3D; fw_dev_bin_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct bin_attribute *fw_dev_bin_attrs[] &#x3D; &#123;</span><br><span class="line">        &amp;firmware_attr_data,</span><br><span class="line">        NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct attribute *fw_dev_attrs[] &#x3D; &#123;</span><br><span class="line">        &amp;dev_attr_loading.attr,</span><br><span class="line">        NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct bin_attribute firmware_attr_data &#x3D; &#123;</span><br><span class="line">        .attr &#x3D; &#123; .name &#x3D; &quot;data&quot;, .mode &#x3D; 0644 &#125;,</span><br><span class="line">        .size &#x3D; 0,</span><br><span class="line">        .read &#x3D; firmware_data_read,</span><br><span class="line">        .write &#x3D; firmware_data_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static DEVICE_ATTR(loading, 0644, firmware_loading_show, firmware_loading_store);</span><br></pre></td></tr></table></figure><p>在_request_firmware_load()函数中, 首先调用device_add()函数将设备注册到系统中, 接着调用kobject_uevent()函数向用户空间上报uevent事件, 最后调用wait_for_completion_killable_timeout()函数等待load fw完成.<br>loading节点写函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line"> static ssize_t firmware_loading_store(struct device *dev,</span><br><span class="line">                                       struct device_attribute *attr,</span><br><span class="line">                                       const char *buf, size_t count)</span><br><span class="line"> &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">         switch (loading) &#123;</span><br><span class="line">         case 1:</span><br><span class="line">                 &#x2F;* discarding any previous partial load *&#x2F;</span><br><span class="line">                 if (!test_bit(FW_STATUS_DONE, &amp;fw_buf-&gt;status)) &#123;</span><br><span class="line">                         for (i &#x3D; 0; i &lt; fw_buf-&gt;nr_pages; i++)</span><br><span class="line">                                 __free_page(fw_buf-&gt;pages[i]);</span><br><span class="line">                         vfree(fw_buf-&gt;pages);</span><br><span class="line">                         fw_buf-&gt;pages &#x3D; NULL;</span><br><span class="line">                         fw_buf-&gt;page_array_size &#x3D; 0;</span><br><span class="line">                         fw_buf-&gt;nr_pages &#x3D; 0;</span><br><span class="line">                         set_bit(FW_STATUS_LOADING, &amp;fw_buf-&gt;status);</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">         case 0:</span><br><span class="line">                 if (test_bit(FW_STATUS_LOADING, &amp;fw_buf-&gt;status)) &#123;</span><br><span class="line">                         int rc;</span><br><span class="line"></span><br><span class="line">                         set_bit(FW_STATUS_DONE, &amp;fw_buf-&gt;status);</span><br><span class="line">                         clear_bit(FW_STATUS_LOADING, &amp;fw_buf-&gt;status);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">                         rc &#x3D; fw_map_pages_buf(fw_buf);</span><br><span class="line">......</span><br><span class="line">                         complete_all(&amp;fw_buf-&gt;completion);</span><br><span class="line">                         break;</span><br><span class="line">                 &#125;</span><br><span class="line">......</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序将fw写入到data节点时,  如果buf-&gt;data已经映射到kernel虚拟地址空间,则调用firmware_rw_buf()直接将fw data copy到buf-&gt;data中; 如果buf-&gt;data为NULL, 则首先调用fw_realloc_buf()函数, 分配物理页, 然后调用firmware_rw()函数将fw data 拷贝到分配的物理页中.<br>data节点写函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static ssize_t firmware_data_write(struct file *filp, struct kobject *kobj,</span><br><span class="line">                                   struct bin_attribute *bin_attr,</span><br><span class="line">                                   char *buffer, loff_t offset, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">        if (buf-&gt;data) &#123;</span><br><span class="line">                if (offset + count &gt; buf-&gt;allocated_size) &#123;</span><br><span class="line">                        retval &#x3D; -ENOMEM;</span><br><span class="line">                        goto out;</span><br><span class="line">                &#125;</span><br><span class="line">                firmware_rw_buf(buf, buffer, offset, count, false);</span><br><span class="line">                retval &#x3D; count;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                retval &#x3D; fw_realloc_buffer(fw_priv, offset + count);</span><br><span class="line">                if (retval)</span><br><span class="line">                        goto out;</span><br><span class="line"></span><br><span class="line">                retval &#x3D; count;</span><br><span class="line">                firmware_rw(buf, buffer, offset, count, false);</span><br><span class="line">        &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序向该节点写入1时, 如果status的状态不是FW_STATUS_DONE, 则进行一些初始化工作, 为后续load fw做准备工作,  并将status状态设备为FW_STATUS_LOADING.</p><p>当应用程序向该节点写入0时, 设置status的状态为FW_STATUS_DONE, 并调用fw_map_pages_buf函数将保存fw data的pages映射到kernel虚拟地址空间, 变为内核可操作的数据. 然后调用complete_all 唤醒等待的进程. 进程唤醒后,会执行assign_firmware_buf()函数, 将保存在firmware_buf结构中fw信息赋值给request_firmware()的第一个参数, 从而完成fw 的load工作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">路径:driver&#x2F;base&#x2F;firmware_class.c</span><br><span class="line">static int assign_firmware_buf(struct firmware *fw, struct device *device,</span><br><span class="line">                               unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        &#x2F;* pass the pages buffer to driver at the last minute *&#x2F;</span><br><span class="line">        fw_set_page_data(buf, fw);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">static void fw_set_page_data(struct firmware_buf *buf, struct firmware *fw)</span><br><span class="line">&#123;</span><br><span class="line">        fw-&gt;priv &#x3D; buf;</span><br><span class="line">#ifdef CONFIG_FW_LOADER_USER_HELPER</span><br><span class="line">        fw-&gt;pages &#x3D; buf-&gt;pages;</span><br><span class="line">#endif</span><br><span class="line">        fw-&gt;size &#x3D; buf-&gt;size;</span><br><span class="line">        fw-&gt;data &#x3D; buf-&gt;data;</span><br><span class="line"></span><br><span class="line">        pr_debug(&quot;%s: fw-%s buf&#x3D;%p data&#x3D;%p size&#x3D;%u\n&quot;,</span><br><span class="line">                 __func__, buf-&gt;fw_id, buf, buf-&gt;data,</span><br><span class="line">                 (unsigned int)buf-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-结束语"><a href="#三-结束语" class="headerlink" title="三 结束语"></a>三 结束语</h3><p>本文以request_firmware()为入口详细探讨了内核load fw的实现原理, 以期大家对这个模块有一个全面的认识. 欢迎大家批评指正, 谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firmware </tag>
            
            <tag> uevent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android FBE</title>
      <link href="/2018/07/12//android-p-fbe.html/"/>
      <url>/2018/07/12//android-p-fbe.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-FBE"><a href="#Android-FBE" class="headerlink" title="Android FBE"></a>Android FBE</h2><h3 id="1-FBE-简介"><a href="#1-FBE-简介" class="headerlink" title="1. FBE 简介"></a>1. FBE 简介</h3><ul><li>名称: FBE, File-Based Encryption,基于文件的加密</li><li>凭据加密 (CE) 存储空间：这是默认存储位置，只有在用户解锁设备后才可用。设备加密 (DE) 存储空间：在直接启动模式期间以及用户解锁设备后均可用。</li><li>开启 FBE 方式,在相关的 fstab 文件中添加相关的代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;userdata                  &#x2F;data              ext4    noatime,nosuid,nodev,barrier&#x3D;1,noauto_da_alloc,discard wait,check,resize,**fileencryption&#x3D;aes-256-xts**,quota</span><br></pre></td></tr></table></figure><ul><li>一些概念性内容这里不再赘述，如有需要自行阅读 <a href="https://source.android.com/security/encryption/file-based" target="_blank" rel="noopener">Goole FBE</a></li></ul><h3 id="2-FBE-流程分析"><a href="#2-FBE-流程分析" class="headerlink" title="2. FBE 流程分析"></a>2. FBE 流程分析</h3><h4 id="2-1-开机过程中-加密前的准备"><a href="#2-1-开机过程中-加密前的准备" class="headerlink" title="2.1 开机过程中,加密前的准备"></a>2.1 开机过程中,加密前的准备</h4><ul><li>init.rc 中加入相关的代码,用于根据 fstab 文件中进行相关的挂载操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on fs</span><br><span class="line">    wait &#x2F;dev&#x2F;block&#x2F;bootdevice</span><br><span class="line">    write &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 100</span><br><span class="line">    mount_all fstab.qcom</span><br></pre></td></tr></table></figure><ul><li>看完 init.rc 中,当然是查看 init 进程中如何解析 init.rc ,代码在 <code>system/core/init/builtins.cpp</code> 中:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> BuiltinFunctionMap::Map&amp; <span class="title">BuiltinFunctionMap::map</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">1</span>,     kMax, do_mount_all&#125;&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mount_all</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*mount_fstab 会 fork 出一个子进程调用 fs_mgr_read_fstab 以及 fs_mgr_mount_all 函数,前一个函数用于读取 fstab 文件,后者用于 mount,之后重点分析 fs_mgr_mount_all函数*/</span></span><br><span class="line">    <span class="keyword">int</span> ret =  mount_fstab(fstabfile, mount_mode);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (queue_event) &#123;</span><br><span class="line">        <span class="comment">/* queue_fs_event will queue event based on mount_fstab return code</span></span><br><span class="line"><span class="comment">         * and return processed return code*/</span></span><br><span class="line">        ret = queue_fs_event(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在来看一下 fs_mgr_mount_all 函数,代码路径在<code>system/core/fs_mgr/fs_mgr.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fs_mgr_mount_all</span><span class="params">(struct fstab *fstab, <span class="keyword">int</span> mount_mode)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> encryptable = FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fstab-&gt;num_entries; i++) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">int</span> last_idx_inspected;</span><br><span class="line">        <span class="keyword">int</span> top_idx = i;</span><br><span class="line"></span><br><span class="line">        mret = mount_with_alternatives(fstab, i, &amp;last_idx_inspected, &amp;attempted_idx);</span><br><span class="line">        i = last_idx_inspected;</span><br><span class="line">        mount_errno = errno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Deal with encryptability. */</span></span><br><span class="line">        <span class="keyword">if</span> (!mret) &#123;</span><br><span class="line">            <span class="keyword">int</span> status = handle_encryptable(&amp;fstab-&gt;recs[attempted_idx]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status == FS_MGR_MNTALL_FAIL) &#123;</span><br><span class="line">                <span class="comment">/* Fatal error - no point continuing */</span></span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">                    <span class="comment">// Log and continue</span></span><br><span class="line">                    LERROR &lt;&lt; <span class="string">"Only one encryptable/encrypted partition supported"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//结果赋值给 encryptable</span></span><br><span class="line">                encryptable = status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Success!  Go get the next one */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        ......</span><br><span class="line">    <span class="comment">/*此处返回给父进程,即 queue_fs_event 接收返回值进行之后的处理*/</span></span><br><span class="line">    <span class="keyword">if</span> (error_count) &#123;</span><br><span class="line">        <span class="keyword">return</span> FS_MGR_MNTALL_FAIL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encryptable;</span><br><span class="line">    &#125;</span><br><span class="line">- [ ] &#125;</span><br></pre></td></tr></table></figure><ul><li>先来看一下 queue_fs_event 函数,它会根据 mount_fstab 的返回值结果进行不同的操作,而 mount_fstab 会返回 FS_MGR_MNTALL_DEV_FILE_ENCRYPTED 给 queue_fs_event，然后调用 e4crypt_install_keyring 函数用于安装 e4crypt keyring，这个用于存放文件加密的 key，之后设置相关的属性，然后触发 nonencrypted 这个 trigger 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_fs_event</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = code;</span><br><span class="line">    <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION) &#123;</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"encrypt"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) &#123;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"encrypted"</span>);</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"block"</span>);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"defaultcrypto"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) &#123;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"unencrypted"</span>);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"nonencrypted"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"unsupported"</span>);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"nonencrypted"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_RECOVERY) &#123;</span><br><span class="line">        <span class="comment">/* Setup a wipe via recovery, and reboot into recovery */</span></span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"fs_mgr_mount_all suggested recovery, so wiping data via recovery."</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; options = &#123;<span class="string">"--wipe_data"</span>, <span class="string">"--reason=fs_mgr_mount_all"</span> &#125;;</span><br><span class="line">        reboot_into_recovery(options);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* If reboot worked, there is no return. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_FILE_ENCRYPTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_install_keyring()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"encrypted"</span>);</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Although encrypted, we have device key, so we do not need to</span></span><br><span class="line">        <span class="comment">// do anything different from the nonencrypted case.</span></span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"nonencrypted"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_IS_METADATA_ENCRYPTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_install_keyring()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"encrypted"</span>);</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// defaultcrypto detects file/block encryption. init flow is same for each.</span></span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"defaultcrypto"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_METADATA_ENCRYPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_install_keyring()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// encrypt detects file/block encryption. init flow is same for each.</span></span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"encrypt"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"fs_mgr_mount_all returned unexpected error "</span> &lt;&lt; code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else ... &lt; 0: error */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之前如果有了解过全盘加密的同学应该会很熟悉,全盘加密会返回 FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION ,然后触发一个 trigger ,最后在 init.rc 中执行 vdc 进程,最后启动 vold 进行全盘加密操作.那现在我们来看一下 FBE 中的 nonencrypted 这个 trigger 中做了什么操作,没看到有触发 vold 的操作啊,那文件加密是什么时候做的呢?不着急,我们继续往下看.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br></pre></td></tr></table></figure><ul><li>我们知道,正常系统起来后,init 的执行顺序为 <code>early-init</code>,<code>init</code>,<code>late-init</code>.既然我们一下子无法知道 FBE 中 vold 是在什么时候执行的,那就只能一步步跟 init.rc,看下能否发现一些端倪,功夫不负有心人,终于在 init.rc 中发现了一点可能和 FBE 相关的东西. <strong>installkey /data</strong> 这个看着有点像.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">on post-fs-data</span><br><span class="line">    # We chown&#x2F;chmod &#x2F;data again so because mount is run as root + defaults</span><br><span class="line">    chown system system &#x2F;data</span><br><span class="line">    chmod 0771 &#x2F;data</span><br><span class="line">    # We restorecon &#x2F;data in case the userdata partition has been reset.</span><br><span class="line">    restorecon &#x2F;data</span><br><span class="line"></span><br><span class="line">    # Make sure we have the device encryption key.</span><br><span class="line">    start vold</span><br><span class="line">    installkey &#x2F;data</span><br></pre></td></tr></table></figure><ul><li>类似 mount 的处理流程, installkey /data 最后会调用<code>system/core/init/builtins.cpp</code> 中的 do_installkey 函数,do_installkey 首先判断是否为文件加密方式,如果是文件加密方式,则会执行 vdc 命令,到这里终于开始进入加密流程过程了.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_installkey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_crypto()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> unencrypted_dir = args[<span class="number">1</span>] + e4crypt_unencrypted_folder;</span><br><span class="line">    <span class="keyword">if</span> (do_installkeys_ensure_dir_exists(unencrypted_dir.c_str())) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to create "</span> &lt;&lt; unencrypted_dir;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; exec_args = &#123;<span class="string">"exec"</span>, <span class="string">"/system/bin/vdc"</span>, <span class="string">"--wait"</span>, <span class="string">"cryptfs"</span>,</span><br><span class="line">                                          <span class="string">"enablefilecrypto"</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> do_exec(exec_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-FBE-加密处理流程"><a href="#2-2-FBE-加密处理流程" class="headerlink" title="2.2 FBE 加密处理流程"></a>2.2 FBE 加密处理流程</h4><ul><li>先看一下 vdc 代码中的处理流程,在 <code>system/vold/vdc.cpp</code>, 通过 local socket 实现了 vdc 通知 vold 进行之后的操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">........</span><br><span class="line"><span class="keyword">while</span> ((sock = socket_local_client(sockname,</span><br><span class="line">                             ANDROID_SOCKET_NAMESPACE_RESERVED,</span><br><span class="line">                             SOCK_STREAM)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_socket) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Error connecting to "</span> &lt;&lt; sockname;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"monitor"</span>)) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(do_monitor(sock, <span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exit</span>(do_cmd(sock, argc, argv));</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(write(sock, cmd.c_str(), cmd.length() + <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to write command"</span>;</span><br><span class="line">    <span class="keyword">return</span> errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码在 system/vold/CryptCommandListener.cpp,通过之前的命令执行到 e4crypt_initialize_global_de 函数,到这里终于进入了文件加密的核心部分了,该函数会生成 /data/unencrypted/key.unencrypted key用来设置/data下除了<code>directories_to_exclude</code> (system/extras/ext4_utils/ext4_crypt_init_extensions.cpp 中定义)目录的当前所有目录的policy,(更准确的说,用的是 /data/unencrypted/ref ,该文件是是key 的引用(),key 其实是存入到密钥环(keyring)当中去的 ).其实 FBE 下有三种类型的 key 用于整个 Android 系统,那这里只是生成的一把 key,之后的 key 是在哪里生成的呢?</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_initialize_global_de</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"e4crypt_initialize_global_de"</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (s_global_de_initialized) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Already initialized"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *contents_mode;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filenames_mode;</span><br><span class="line">    cryptfs_get_file_encryption_modes(&amp;contents_mode, &amp;filenames_mode);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> modestring = <span class="built_in">std</span>::<span class="built_in">string</span>(contents_mode) + <span class="string">":"</span> + filenames_mode;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mode_filename = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"/data"</span>) + e4crypt_key_mode;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::WriteStringToFile(modestring, mode_filename)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Cannot save type"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> device_key_ref;</span><br><span class="line">    <span class="comment">//生成 /data/unencrypted/key这个文件夹  key 是怎样生成的 ,首先会读取 /dev/urandom 节点生成一个随机数，再通过 keymaster key 进行签名操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同时会生成 /data/uncrypt/key/version(版本信息)  /data/uncrypt/key/encrypt_key(之前通过/dev/urandom 生成的 key 再通过 keymaster key 加密过的 key)</span></span><br><span class="line">    <span class="keyword">if</span> (!android::vold::retrieveAndInstallKey(<span class="literal">true</span>,</span><br><span class="line">        device_key_path, device_key_temp, &amp;device_key_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ref_filename = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"/data"</span>) + e4crypt_key_ref;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::WriteStringToFile(device_key_ref, ref_filename)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Cannot save key reference to:"</span> &lt;&lt; ref_filename;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Wrote system DE key reference to:"</span> &lt;&lt; ref_filename;</span><br><span class="line">                </span><br><span class="line">    s_global_de_initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生成了 uncryptkey 之后, 分析 init.rc 看看之后做了什么操作,看了大部分都是 mkdir 操作啊.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Start bootcharting as soon as possible after the data partition is</span><br><span class="line"># mounted to collect more data.</span><br><span class="line">mkdir &#x2F;data&#x2F;bootchart 0755 shell shell</span><br><span class="line">bootchart start</span><br><span class="line"></span><br><span class="line"># Avoid predictable entropy pool. Carry over entropy from previous boot.</span><br><span class="line">copy &#x2F;data&#x2F;system&#x2F;entropy.dat &#x2F;dev&#x2F;urandom</span><br><span class="line"></span><br><span class="line"># create basic filesystem structure</span><br><span class="line">mkdir &#x2F;data&#x2F;misc 01771 system misc</span><br><span class="line">mkdir &#x2F;data&#x2F;misc&#x2F;recovery 0770 system log</span><br></pre></td></tr></table></figure><ul><li>也类似 mount_all ,mkdir 最终调用了 init/builtins.cpp 中的 do_mkdir 函数,关注 e4crypt_set_directory_policy 函数实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//判断是否未文件加密方式,是则执行之后的流程</span></span><br><span class="line">    <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_set_directory_policy(args[<span class="number">1</span>].c_str())) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; options = &#123;</span><br><span class="line">                <span class="string">"--prompt_and_wipe_data"</span>,</span><br><span class="line">                <span class="string">"--reason=set_policy_failed:"</span>s + args[<span class="number">1</span>]&#125;;</span><br><span class="line">            reboot_into_recovery(options);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置相关目录的加密 policy,使用的 policy 便是上面生成的 /data/unencrypted/ref (ref 是 key 经过填充后 再经过 sha512 算法得到的东西). directories_to_exclude 指定的相关目录不会被加密,因为该部分相关的子目录需要加密 (加密 key 使用之后生成的 CE/DE)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">e4crypt_set_directory_policy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dir || <span class="built_in">strncmp</span>(dir, <span class="string">"/data/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special-case /data/media/obb per b/64566063</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dir, <span class="string">"/data/media/obb"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Try to set policy on this directory, but if it is non-empty this may fail.</span></span><br><span class="line">        set_system_de_policy_on(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set policy on first level /data directories</span></span><br><span class="line">    <span class="comment">// To make this less restrictive, consider using a policy file.</span></span><br><span class="line">    <span class="comment">// However this is overkill for as long as the policy is simply</span></span><br><span class="line">    <span class="comment">// to apply a global policy to all /data folders created via makedir</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(dir + <span class="number">6</span>, <span class="string">'/'</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Special case various directories that must not be encrypted,</span></span><br><span class="line">    <span class="comment">// often because their subdirectories must be encrypted.</span></span><br><span class="line">    <span class="comment">// This isn't a nice way to do this, see b/26641735</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; directories_to_exclude = &#123;</span><br><span class="line">        <span class="string">"lost+found"</span>,</span><br><span class="line">        <span class="string">"system_ce"</span>, <span class="string">"system_de"</span>,</span><br><span class="line">        <span class="string">"misc_ce"</span>, <span class="string">"misc_de"</span>,</span><br><span class="line">        <span class="string">"media"</span>,</span><br><span class="line">        <span class="string">"data"</span>, <span class="string">"user"</span>, <span class="string">"user_de"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> prefix = <span class="string">"/data/"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d: directories_to_exclude) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((prefix + d) == dir) &#123;</span><br><span class="line">            LOG(INFO) &lt;&lt; <span class="string">"Not setting policy on "</span> &lt;&lt; dir;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set_system_de_policy_on(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e4crypt_policy_set 先填充了 eep 这个结构体,相关的加密 key 与加密方式都是通过这个结构体进行进一步操作的.最后通过 ioctl 实现相关目录的 key policy ,kernel 部分这里就不去深究了,相关代码位置在 kernel/fs/crypto/ 中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">e4crypt_policy_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *directory, <span class="keyword">const</span> <span class="keyword">char</span> *policy,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> policy_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> contents_encryption_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> filenames_encryption_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy_length != EXT4_KEY_DESCRIPTOR_SIZE) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Policy wrong length: "</span> &lt;&lt; policy_length;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = open(directory, O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to open directory "</span> &lt;&lt; directory;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//填充 eep</span></span><br><span class="line">    ext4_encryption_policy eep;</span><br><span class="line">    eep.version = <span class="number">0</span>;</span><br><span class="line">    eep.contents_encryption_mode = contents_encryption_mode;</span><br><span class="line">    eep.filenames_encryption_mode = filenames_encryption_mode;</span><br><span class="line">    eep.flags = e4crypt_get_policy_flags(filenames_encryption_mode);</span><br><span class="line">    <span class="built_in">memcpy</span>(eep.master_key_descriptor, policy, EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">    <span class="comment">//ioctl 实现最后的加密操作</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, EXT4_IOC_SET_ENCRYPTION_POLICY, &amp;eep)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to set encryption policy for "</span> &lt;&lt; directory;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> policy_hex[EXT4_KEY_DESCRIPTOR_SIZE_HEX];</span><br><span class="line">    policy_to_hex(policy, policy_hex);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Policy for "</span> &lt;&lt; directory &lt;&lt; <span class="string">" set to "</span> &lt;&lt; policy_hex;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面已经分析了 uncryptkey 加密操作. 那么文章开头说的 CE/DE 又是在哪做的操作呢? 继续分析 init.rc,发现在 init.rc 中,在 post-fs-data 中创建了一些必要的文件后,是时候为用户0创建相应的key 了 , <code>init_user0</code> 就是做了这个操作,类似之前的 do_installkey 操作, init_user0 最终会调用了 vold 下的 e4crypt_init_user0 函数,该函数会生成 /data/misc/vold/user_keys 目录下的相关文件.注:DE key 加密相关的存储空间就是在这个阶段实现的 CE 加密相关的存储空间还未生成</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_init_user0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"e4crypt_init_user0"</span>;</span><br><span class="line">    <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_key_dir, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_key_dir + <span class="string">"/ce"</span>, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_key_dir + <span class="string">"/de"</span>, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!android::vold::pathExists(get_de_key_path(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">//第一次系统起来, de/ce key 未创建,所以会走这,创建 DE/CE key 的过程都是在这个函数里面做的,类似 uncrypted key 的生成流程,</span></span><br><span class="line">        <span class="comment">// 也会通过调用 randomKey 函数生成随机 key ,storeKeyAtomically 函数生成 keymaster key ,</span></span><br><span class="line">        <span class="comment">//最后调用 installKey 将 key 加入到 密钥环(keyring)中</span></span><br><span class="line">            <span class="keyword">if</span> (!create_and_install_user_keys(<span class="number">0</span>, <span class="literal">false</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> switch to loading only DE_0 here once framework makes</span></span><br><span class="line">        <span class="comment">// explicit calls to install DE keys for secondary users</span></span><br><span class="line">        <span class="comment">// 加密之后，第一次系统起来直接走这，load key 然后用 keymaster key进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (!load_all_de_keys()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We can only safely prepare DE storage here, since CE keys are probably</span></span><br><span class="line">    <span class="comment">// entangled with user credentials.  The framework will always prepare CE</span></span><br><span class="line">    <span class="comment">// storage once CE keys are installed.</span></span><br><span class="line">    <span class="comment">//开始准备 DE 存储空间,e4crypt_prepare_user_storage 先是准备了相关的 DE 目录,之后查找相关用户id 的 key ,最后调用 ensure_policy 用户设置相关目录的加密策略</span></span><br><span class="line">    <span class="keyword">if</span> (!e4crypt_prepare_user_storage(<span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>, FLAG_STORAGE_DE)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Failed to prepare user 0 storage"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a non-FBE device that recently left an emulated mode,</span></span><br><span class="line">    <span class="comment">// restore user data directories to known-good state.</span></span><br><span class="line">    <span class="keyword">if</span> (!e4crypt_is_native() &amp;&amp; !e4crypt_is_emulated()) &#123;</span><br><span class="line">        e4crypt_unlock_user_key(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"!"</span>, <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着上面的 ensure_policy 函数,通过 cryptfs_get_file_encryption_modes 函数,根据 fstab 文件获取了 FBE 加密方式(contents_mode,filenames_mode),最后通过 e4crypt_policy_ensure 函数设置相关目录的 policy</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">e4crypt_policy_ensure</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *directory, <span class="keyword">const</span> <span class="keyword">char</span> *policy,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">size_t</span> policy_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span> *contents_encryption_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span> *filenames_encryption_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> contents_mode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> filenames_mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">"software"</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">"aes-256-xts"</span>)) &#123;</span><br><span class="line">        contents_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">"ice"</span>)) &#123;</span><br><span class="line">        contents_mode = EXT4_ENCRYPTION_MODE_PRIVATE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Invalid file contents encryption mode: "</span></span><br><span class="line">                   &lt;&lt; contents_encryption_mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filenames_encryption_mode, <span class="string">"aes-256-cts"</span>)) &#123;</span><br><span class="line">        filenames_mode = EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filenames_encryption_mode, <span class="string">"aes-256-heh"</span>)) &#123;</span><br><span class="line">        filenames_mode = EXT4_ENCRYPTION_MODE_AES_256_HEH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Invalid file names encryption mode: "</span></span><br><span class="line">                   &lt;&lt; filenames_encryption_mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> is_empty;</span><br><span class="line">    <span class="keyword">if</span> (!is_dir_empty(directory, &amp;is_empty)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_empty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e4crypt_policy_set(directory, policy, policy_length,</span><br><span class="line">                                contents_mode, filenames_mode)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e4crypt_policy_check(directory, policy, policy_length,</span><br><span class="line">                                  contents_mode, filenames_mode)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么 CE 空间是在什么时候准备好的？其实那部分代码是在 framework 里面做的。framework 相关代码在 <code>frameworks/base/services/core/java/com/android/server/StorageManagerService.java</code>，调用了 unlockUserKey 函数，该部分代码还是很简单的，主要就是通过 <code>mCryptConnector.execute(&quot;cryptfs&quot;, &quot;unlock_user_key&quot;, userId, serialNumber,encodeBytes(token), encodeBytes(secret));</code>通知 vold 需要去生成 key 了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockUserKey</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> serialNumber, <span class="keyword">byte</span>[] token, <span class="keyword">byte</span>[] secret)</span> </span>&#123;</span><br><span class="line">    enforcePermission(android.Manifest.permission.STORAGE_INTERNAL);</span><br><span class="line">    waitForReady();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">        <span class="comment">// When a user has secure lock screen, require secret to actually unlock.</span></span><br><span class="line">        <span class="comment">// This check is mostly in place for emulation mode.</span></span><br><span class="line">        <span class="keyword">if</span> (mLockPatternUtils.isSecure(userId) &amp;&amp; ArrayUtils.isEmpty(secret)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Secret required to unlock secure user "</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCryptConnector.execute(<span class="string">"cryptfs"</span>, <span class="string">"unlock_user_key"</span>, userId, serialNumber,</span><br><span class="line">                    encodeBytes(token), encodeBytes(secret));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLocalUnlockedUsers = ArrayUtils.appendInt(mLocalUnlockedUsers, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">        String propertyName = <span class="string">"sys.user."</span> + userId + <span class="string">".ce_available"</span>;</span><br><span class="line">        Slog.d(TAG, <span class="string">"Setting property: "</span> + propertyName + <span class="string">"=true"</span>);</span><br><span class="line">        SystemProperties.set(propertyName, <span class="string">"true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 system/vold/Ext4Crypt.cpp 中的 <code>e4crypt_unlock_user_key</code> 函数进行解密操作，第一次系统起来的时候，因为用户没有设置密码，所以此时的 key 是没有用 auth 进行签名的，s_ce_key_raw_refs 会直接返回，即此时的 key 是已经解密过的 key 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> rename to 'install' for consistency, and take flags to know which keys to install</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_unlock_user_key</span><span class="params">(<span class="keyword">userid_t</span> user_id, <span class="keyword">int</span> serial, <span class="keyword">const</span> <span class="keyword">char</span>* token_hex,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">char</span>* secret_hex)</span> </span>&#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"e4crypt_unlock_user_key "</span> &lt;&lt; user_id &lt;&lt; <span class="string">" serial="</span> &lt;&lt; serial</span><br><span class="line">               &lt;&lt; <span class="string">" token_present="</span> &lt;&lt; (<span class="built_in">strcmp</span>(token_hex, <span class="string">"!"</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_ce_key_raw_refs.count(user_id) != <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(WARNING) &lt;&lt; <span class="string">"Tried to unlock already-unlocked key for user "</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> token, secret;</span><br><span class="line">        <span class="keyword">if</span> (!parse_hex(token_hex, &amp;token)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!parse_hex(secret_hex, &amp;secret)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        android::<span class="function">vold::KeyAuthentication <span class="title">auth</span><span class="params">(token, secret)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!read_and_install_user_ce_key(user_id, auth)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Couldn't read key for "</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When in emulation mode, we just use chmod. However, we also</span></span><br><span class="line">        <span class="comment">// unlock directories when not in emulation mode, to bring devices</span></span><br><span class="line">        <span class="comment">// back into a known-good state.</span></span><br><span class="line">        <span class="keyword">if</span> (!emulated_unlock(android::vold::BuildDataSystemCePath(user_id), <span class="number">0771</span>) ||</span><br><span class="line">            !emulated_unlock(android::vold::BuildDataMiscCePath(user_id), <span class="number">01771</span>) ||</span><br><span class="line">            !emulated_unlock(android::vold::BuildDataMediaCePath(<span class="literal">nullptr</span>, user_id), <span class="number">0770</span>) ||</span><br><span class="line">            !emulated_unlock(android::vold::BuildDataUserCePath(<span class="literal">nullptr</span>, user_id), <span class="number">0771</span>)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to unlock user "</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之后调用 prepareUserStorage 用于设置 ce 空间相关的 policy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareUserStorage</span><span class="params">(String volumeUuid, <span class="keyword">int</span> userId, <span class="keyword">int</span> serialNumber, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    enforcePermission(android.Manifest.permission.STORAGE_INTERNAL);</span><br><span class="line">    waitForReady();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCryptConnector.execute(<span class="string">"cryptfs"</span>, <span class="string">"prepare_user_storage"</span>, escapeNull(volumeUuid),</span><br><span class="line">                userId, serialNumber, flags);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类似 DE 空间的加密流程 CE 空间也会调用 e4crypt_prepare_user_storage 进行设置目录的 policy ，这样子，加密空间就全部准备好了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_prepare_user_storage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* volume_uuid, <span class="keyword">userid_t</span> user_id, <span class="keyword">int</span> serial,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"e4crypt_prepare_user_storage for volume "</span> &lt;&lt; escape_null(volume_uuid)</span><br><span class="line">               &lt;&lt; <span class="string">", user "</span> &lt;&lt; user_id &lt;&lt; <span class="string">", serial "</span> &lt;&lt; serial &lt;&lt; <span class="string">", flags "</span> &lt;&lt; flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FLAG_STORAGE_DE) &#123;</span><br><span class="line">        <span class="comment">// DE_sys key</span></span><br><span class="line">        <span class="keyword">auto</span> system_legacy_path = android::vold::BuildDataSystemLegacyPath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_legacy_path = android::vold::BuildDataMiscLegacyPath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> profiles_de_path = android::vold::BuildDataProfilesDePath(user_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DE_n key</span></span><br><span class="line">        <span class="keyword">auto</span> system_de_path = android::vold::BuildDataSystemDePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_de_path = android::vold::BuildDataMiscDePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> user_de_path = android::vold::BuildDataUserDePath(volume_uuid, user_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(system_legacy_path, <span class="number">0700</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MANAGE_MISC_DIRS</span></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(misc_legacy_path, <span class="number">0750</span>, multiuser_get_uid(user_id, AID_SYSTEM),</span><br><span class="line">                multiuser_get_uid(user_id, AID_EVERYBODY))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(profiles_de_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(system_de_path, <span class="number">0770</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(misc_de_path, <span class="number">01771</span>, AID_SYSTEM, AID_MISC)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_de_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> de_raw_ref;</span><br><span class="line">            <span class="keyword">if</span> (!lookup_key_ref(s_de_key_raw_refs, user_id, &amp;de_raw_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(de_raw_ref, system_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(de_raw_ref, misc_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(de_raw_ref, user_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FLAG_STORAGE_CE) &#123;</span><br><span class="line">        <span class="comment">// CE_n key</span></span><br><span class="line">        <span class="keyword">auto</span> system_ce_path = android::vold::BuildDataSystemCePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_ce_path = android::vold::BuildDataMiscCePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> media_ce_path = android::vold::BuildDataMediaCePath(volume_uuid, user_id);</span><br><span class="line">        <span class="keyword">auto</span> user_ce_path = android::vold::BuildDataUserCePath(volume_uuid, user_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(system_ce_path, <span class="number">0770</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(misc_ce_path, <span class="number">01771</span>, AID_SYSTEM, AID_MISC)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(media_ce_path, <span class="number">0770</span>, AID_MEDIA_RW, AID_MEDIA_RW)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_ce_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> ce_raw_ref;</span><br><span class="line">            <span class="keyword">if</span> (!lookup_key_ref(s_ce_key_raw_refs, user_id, &amp;ce_raw_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, system_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, misc_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, media_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, user_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Now that credentials have been installed, we can run restorecon</span></span><br><span class="line">            <span class="comment">// over these paths</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> these paths need to be kept in sync with libselinux</span></span><br><span class="line">            android::vold::RestoreconRecursive(system_ce_path);</span><br><span class="line">            android::vold::RestoreconRecursive(misc_ce_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-锁屏密码与-FBE-key-的关系"><a href="#2-3-锁屏密码与-FBE-key-的关系" class="headerlink" title="2.3 锁屏密码与 FBE key 的关系"></a>2.3 锁屏密码与 FBE key 的关系</h4><p>开始前，先说说加密思想。Android FBE 中会通过密码文件生成一个 auth ，用这个 auth 再对 key 进行签名。这样子，用户在没有输入正确密码时，是无法进行解密 CE 空间的。那按照这样子，用户在不输入密码的时候岂不是用不了这些内存位置。其实，根据 auth 对 key 的签名，只针对了 CE 空间的 key 进行签名，所以系统在正常起来时，DE 空间其实已经解密完成了，现在就来看下用户在设置密码后，vold 做了哪些处理吧。</p><ul><li><p>用户设置完成密码后，vold 进程首先会调用 e4crypt_add_user_key_auth 用于生成新的 CE key，一个疑惑，在设置密码完成后，会调用两次该函数，第一次会生成一个未经过 auth 签名的 key，之后会再次生成一个经过 auth 签名的 key，不知这样的意图为何？</p></li><li><p>e4crypt_fixate_newest_user_key_auth 主要是将用户设置密码后生成的 auth 签名过 key 给重命名成之前的 key 名称</p></li><li><p>secdiscard 主要用于删除旧的 key 文件</p></li></ul><h4 id="2-4-FBE-解密"><a href="#2-4-FBE-解密" class="headerlink" title="2.4 FBE 解密"></a>2.4 FBE 解密</h4><p>这里说的解密的意思理解成读取可能会比较好理解. Android 的加密思想是如果是未经过授权的读取操作都是无法进行访问的.其实 FBE 解密流程和系统第一次起来时 set policy 的流程几乎是一样的。不同的是，在调用 ensure_policy 时，会对目录检测是否为空，如果是空，则进行 set policy 操作，而如果为非空，则进行 check_policy 操作，所以对 /data 的解密操作都在这个 check_policy ，当校验成功后，kernel 会自动对 /data 进行解密操作。如果要实现对 /data 的解密，最难的倒不是 vold 中解密流程的移植，反倒是 framework 中根据 password 生成的 auth 的提取，因为此时的 key 是使用了 auth 进行签名的 key 了，如何把加密的 key 给解出来倒成了开发的难点。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>分析到最后，其实 FBE 的加密思想并不复杂，相对于 Android 之前的全盘加密，整个流程加密思想几乎是相同的。但无疑文件加密是更为人性化的，用户无需在输入密码就可进行一些基础操作。文中可能还有些不足以及 kernel 部分详细的加密操作都未详谈，欢迎各位指正补充。</p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FBE </tag>
            
            <tag> 文件级加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Time</title>
      <link href="/2018/07/12//linux-time.html/"/>
      <url>/2018/07/12//linux-time.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Linux时钟框架"><a href="#1、Linux时钟框架" class="headerlink" title="1、Linux时钟框架"></a>1、Linux时钟框架</h2><p><img src="/images/posts/2017/10/linux_time_profile.png" alt="image"><sup><a href="#fn_DroidPhoneo" id="reffn_DroidPhoneo">DroidPhoneo</a></sup></p><p>上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。</p><p>1、定时Timer</p><ul><li>这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对应的是SPI（Shared Peripheral Interrupt，即多个cpu共享同一个中断。</li><li>这类timer一般是32bit宽度count，最重要的它会频繁的溢出并产生timer到期中断。</li><li>这类timer服务于tick timer(低精度)或者hrtimer(高精度)。</li><li>低精度模式，local timer工作在PERIODIC模式。即timer以tick时间(1/HZ)周期性的产生中断。在tick timer中处理任务调度tick、低精度timer、其他时间更新和统计profile。在这种模式下，所有利用时间的进行的运算，精度都是以tick(1/HZ)为单位的，精度较低。比如HZ=1000，那么tick=1ms。</li><li>高精度模式，local timer工作在ONESHOT模式。即系统可以支持hrtimer(high resolution)高精度timer，精度为local timer的计数clk达到ns级别。这种情况下把tick timer也转换成一种hrtimer。</li></ul><p>2、时间戳Timer</p><ul><li>这类timer一个系统多个cpu共享一个，称为global timer。</li><li>这类timer一般是32bit/64bit宽度count，一般不会溢出产生中断，系统实时的去读取count的值来计算当前的时间戳。</li><li>这类timer服务于clocksource/timekeeper。</li></ul><blockquote><p>本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”</p></blockquote><h3 id="1-1、Exynos-MCT-Multi-Core-Timer"><a href="#1-1、Exynos-MCT-Multi-Core-Timer" class="headerlink" title="1.1、Exynos MCT(Multi-Core Timer)"></a>1.1、Exynos MCT(Multi-Core Timer)</h3><p>我们以samsung exynos架构为例来说明linux对timer的使用。</p><p><img src="/images/posts/2017/10/exynos_timer.png" alt="image"></p><p>从上图可以看到，exynos有1个64bit global timer用来做时间戳timer，有8个31bit localtimer用来做定时timer，每个cpu拥有一个localtimer。</p><p><img src="/images/posts/2017/10/exynos_mct_initflow.png" alt="image"></p><p>上图是exynos driver的初始化流程，mct_init_dt()中包含了主要的初始化流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __init mct_init_dt(struct device_node *np, unsigned int int_type)</span><br><span class="line">&#123;</span><br><span class="line">exynos4_timer_resources(np, of_iomap(np, 0)); &#x2F;&#x2F;(1)初始化localtimer，并将其注册成clockevent</span><br><span class="line">exynos4_clocksource_init(); &#x2F;&#x2F;(2)初始化globaltimer，并将其注册成clocksource</span><br><span class="line">exynos4_clockevent_init(); &#x2F;&#x2F;(3)将globaltimer的comparator 0注册成一个clockevent，一般不会使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面结合clocksource和clockevent的子系统的解析，再来详细描述exynos系统的具体实现。</p><h2 id="2、clocksource-amp-timekeeper"><a href="#2、clocksource-amp-timekeeper" class="headerlink" title="2、clocksource &amp; timekeeper"></a>2、clocksource &amp; timekeeper</h2><p><img src="/images/posts/2017/10/clocksource_timekeeper.png" alt="image"></p><p>上图描述的是clocksource和timekeeper的关系：</p><ul><li>一个global timer对应注册一个clocksource。</li><li>一个系统中可以有多个clocksource，timekeeper选择精度最高的那个来使用。</li><li>用户使用timekeeper提供的接口来获取系统的时间戳。</li><li>为了避免无人主动获取时间clocksource定时器的溢出，timekeeper需要定期的去获取clocksource的值来更新系统时间，一般是在tick处理中更新。</li></ul><h3 id="2-1、clocksource"><a href="#2-1、clocksource" class="headerlink" title="2.1、clocksource"></a>2.1、clocksource</h3><p>下面来看一看clocksource的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct clocksource mct_frc &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;mct-frc&quot;,</span><br><span class="line">&#x2F;* (1) .rating &#x3D; 精度，数值越大越好，</span><br><span class="line">       select_best会选择精度最大的clocksource给timekeeper使用 *&#x2F;</span><br><span class="line">.rating&#x3D; 400,  </span><br><span class="line">&#x2F;* (2) .read &#x3D; 读取clocksource的timer当前计数 *&#x2F;</span><br><span class="line">.read&#x3D; exynos4_frc_read,</span><br><span class="line">&#x2F;* (3) .mask &#x3D; timer的位宽 *&#x2F;</span><br><span class="line">.mask&#x3D; CLOCKSOURCE_MASK(32),</span><br><span class="line">.flags&#x3D; CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">.resume&#x3D; exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看一下clocksource的注册过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">static void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 启动global timer</span><br><span class="line">exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册timer_delay</span><br><span class="line">exynos4_delay_timer.read_current_timer &#x3D; &amp;exynos4_read_current_timer;</span><br><span class="line">exynos4_delay_timer.freq &#x3D; clk_rate;</span><br><span class="line">register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; (1) 注册clocksource</span><br><span class="line">if (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">panic(&quot;%s: can&#39;t register clocksource\n&quot;, mct_frc.name);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册sched_clock</span><br><span class="line">sched_clock_register(exynos4_read_sched_clock, 32, clk_rate);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)</span><br><span class="line">&#123;</span><br><span class="line">return __clocksource_register_scale(cs, 1, hz);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* Initialize mult&#x2F;shift and max_idle_ns *&#x2F;</span><br><span class="line">&#x2F;* (1.1) 根据timer的频率freq，计算cs-&gt;mult、cs-&gt;shift</span><br><span class="line">    这两个字段是用来把timer的计数转换成实际时间单位ns</span><br><span class="line">    ns &#x3D; (count * cs-&gt;mult) &gt;&gt; cs-&gt;shift *&#x2F;</span><br><span class="line">__clocksource_update_freq_scale(cs, scale, freq);</span><br><span class="line"></span><br><span class="line">&#x2F;* Add clocksource to the clocksource list *&#x2F;</span><br><span class="line">mutex_lock(&amp;clocksource_mutex);</span><br><span class="line">&#x2F;* (1.2) 将新的clocksource加入全局链表 *&#x2F;</span><br><span class="line">clocksource_enqueue(cs);</span><br><span class="line">clocksource_enqueue_watchdog(cs);</span><br><span class="line">&#x2F;* (1.3) 从全局链表中重新选择一个best</span><br><span class="line">    clocksource给timekeeper使用 *&#x2F;</span><br><span class="line">clocksource_select();</span><br><span class="line">clocksource_select_watchdog(false);</span><br><span class="line">mutex_unlock(&amp;clocksource_mutex);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line">u64 sec;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Default clocksources are *special* and self-define their mult&#x2F;shift.</span><br><span class="line"> * But, you&#39;re not special, so you should specify a freq value.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (freq) &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Calc the maximum number of seconds which we can run before</span><br><span class="line"> * wrapping around. For clocksources which have a mask &gt; 32-bit</span><br><span class="line"> * we need to limit the max sleep time to have a good</span><br><span class="line"> * conversion precision. 10 minutes is still a reasonable</span><br><span class="line"> * amount. That results in a shift value of 24 for a</span><br><span class="line"> * clocksource with mask &gt;&#x3D; 40-bit and f &gt;&#x3D; 4GHz. That maps to</span><br><span class="line"> * ~ 0.06ppm granularity for NTP.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (1.1.1) 计算timer计数器到溢出，</span><br><span class="line">    最大能计数多少秒 &#x3D; sec *&#x2F;</span><br><span class="line">sec &#x3D; cs-&gt;mask;</span><br><span class="line">do_div(sec, freq);</span><br><span class="line">do_div(sec, scale);</span><br><span class="line">if (!sec)</span><br><span class="line">sec &#x3D; 1;</span><br><span class="line">else if (sec &gt; 600 &amp;&amp; cs-&gt;mask &gt; UINT_MAX)</span><br><span class="line">sec &#x3D; 600;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1.1.2) 根据1s内的频率数freq，和1s内的ns数NSEC_PER_SEC</span><br><span class="line">            计算freq和ns之间的转换公式：</span><br><span class="line">            ns &#x3D; (freq * cs-&gt;mult) &gt;&gt; cs-&gt;shift </span><br><span class="line">            目的是把mult和shift算到最大值，最大可能的保留精度 *&#x2F;</span><br><span class="line">clocks_calc_mult_shift(&amp;cs-&gt;mult, &amp;cs-&gt;shift, freq,</span><br><span class="line">       NSEC_PER_SEC &#x2F; scale, sec * scale);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Ensure clocksources that have large &#39;mult&#39; values don&#39;t overflow</span><br><span class="line"> * when adjusted.</span><br><span class="line"> *&#x2F;</span><br><span class="line">cs-&gt;maxadj &#x3D; clocksource_max_adjustment(cs);</span><br><span class="line">while (freq &amp;&amp; ((cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult)</span><br><span class="line">|| (cs-&gt;mult - cs-&gt;maxadj &gt; cs-&gt;mult))) &#123;</span><br><span class="line">cs-&gt;mult &gt;&gt;&#x3D; 1;</span><br><span class="line">cs-&gt;shift--;</span><br><span class="line">cs-&gt;maxadj &#x3D; clocksource_max_adjustment(cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Only warn for *special* clocksources that self-define</span><br><span class="line"> * their mult&#x2F;shift values and don&#39;t specify a freq.</span><br><span class="line"> *&#x2F;</span><br><span class="line">WARN_ONCE(cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult,</span><br><span class="line">&quot;timekeeping: Clocksource %s might overflow on 11%% adjustment\n&quot;,</span><br><span class="line">cs-&gt;name);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.3) 根据mult和shift的值，计算最大能进入idle的时间max_idle_ns</span><br><span class="line">        才能保证idle时timer不会溢出*&#x2F;</span><br><span class="line">clocksource_update_max_deferment(cs);</span><br><span class="line"></span><br><span class="line">pr_info(&quot;%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n&quot;,</span><br><span class="line">cs-&gt;name, cs-&gt;mask, cs-&gt;max_cycles, cs-&gt;max_idle_ns);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">static void clocksource_select(void)</span><br><span class="line">&#123;</span><br><span class="line">__clocksource_select(false);</span><br><span class="line">&#125;</span><br><span class="line">static void __clocksource_select(bool skipcur)</span><br><span class="line">&#123;</span><br><span class="line">bool oneshot &#x3D; tick_oneshot_mode_active();</span><br><span class="line">struct clocksource *best, *cs;</span><br><span class="line"></span><br><span class="line">&#x2F;* Find the best suitable clocksource *&#x2F;</span><br><span class="line">&#x2F;* (1.3.1) 选择best clocksource *&#x2F;</span><br><span class="line">best &#x3D; clocksource_find_best(oneshot, skipcur);</span><br><span class="line">if (!best)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;* Check for the override clocksource. *&#x2F;</span><br><span class="line">list_for_each_entry(cs, &amp;clocksource_list, list) &#123;</span><br><span class="line">if (skipcur &amp;&amp; cs &#x3D;&#x3D; curr_clocksource)</span><br><span class="line">continue;</span><br><span class="line">if (strcmp(cs-&gt;name, override_name) !&#x3D; 0)</span><br><span class="line">continue;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Check to make sure we don&#39;t switch to a non-highres</span><br><span class="line"> * capable clocksource if the tick code is in oneshot</span><br><span class="line"> * mode (highres or nohz)</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (!(cs-&gt;flags &amp; CLOCK_SOURCE_VALID_FOR_HRES) &amp;&amp; oneshot) &#123;</span><br><span class="line">&#x2F;* Override clocksource cannot be used. *&#x2F;</span><br><span class="line">pr_warn(&quot;Override clocksource %s is not HRT compatible - cannot switch while in HRT&#x2F;NOHZ mode\n&quot;,</span><br><span class="line">cs-&gt;name);</span><br><span class="line">override_name[0] &#x3D; 0;</span><br><span class="line">&#125; else</span><br><span class="line">&#x2F;* Override clocksource can be used. *&#x2F;</span><br><span class="line">best &#x3D; cs;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.3.2) 通知timekeeper更新clocksource，tick-sched更新 *&#x2F;</span><br><span class="line">if (curr_clocksource !&#x3D; best &amp;&amp; !timekeeping_notify(best)) &#123;</span><br><span class="line">pr_info(&quot;Switched to clocksource %s\n&quot;, best-&gt;name);</span><br><span class="line">curr_clocksource &#x3D; best;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">||||→</span><br><span class="line">int timekeeping_notify(struct clocksource *clock)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line"></span><br><span class="line">if (tk-&gt;tkr_mono.clock &#x3D;&#x3D; clock)</span><br><span class="line">return 0;</span><br><span class="line">stop_machine(change_clocksource, clock, NULL);</span><br><span class="line">tick_clock_notify();</span><br><span class="line">return tk-&gt;tkr_mono.clock &#x3D;&#x3D; clock ? 0 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1、exynos4-clocksource-init"><a href="#2-1-1、exynos4-clocksource-init" class="headerlink" title="2.1.1、exynos4_clocksource_init()"></a>2.1.1、exynos4_clocksource_init()</h4><p>exynos将global timer注册成clocksource，虽然global timer拥有64bit的位宽，但是注册的时候把其当成32bit的clocksource注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static u32 notrace exynos4_read_count_32(void)</span><br><span class="line">&#123;</span><br><span class="line">return readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static cycle_t exynos4_frc_read(struct clocksource *cs)</span><br><span class="line">&#123;</span><br><span class="line">return exynos4_read_count_32();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct clocksource mct_frc &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;mct-frc&quot;,</span><br><span class="line">.rating&#x3D; 400,</span><br><span class="line">.read&#x3D; exynos4_frc_read,</span><br><span class="line">.mask&#x3D; CLOCKSOURCE_MASK(32),</span><br><span class="line">.flags&#x3D; CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">.resume&#x3D; exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">exynos4_delay_timer.read_current_timer &#x3D; &amp;exynos4_read_current_timer;</span><br><span class="line">exynos4_delay_timer.freq &#x3D; clk_rate;</span><br><span class="line">register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) exynos将global timer注册成clocksource *&#x2F;</span><br><span class="line">if (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">panic(&quot;%s: can&#39;t register clocksource\n&quot;, mct_frc.name);</span><br><span class="line"></span><br><span class="line">sched_clock_register(exynos4_read_sched_clock, 32, clk_rate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、timekeeper"><a href="#2-2、timekeeper" class="headerlink" title="2.2、timekeeper"></a>2.2、timekeeper</h3><p>timerkeeper提供了几种时间：xtime、monotonic time、raw monotonic time、boot time。</p><ul><li><strong>xtime</strong> 即是wall time，和RTC时间一样可以表示当前的时刻，它的起始时间是公元0世纪0秒，精度大于RTC时间；</li><li><strong>monotonic time</strong> 从系统开机后到现在的累计时间，不过不计算系统休眠的时间；</li><li><strong>raw monotonic time</strong> 和monotonic time含义一样，不过更纯粹，不会受到NTP时间调整的影响；</li><li><strong>boot time</strong> 在monotonic time的基础上加上了系统休眠的时间，它代表着系统上电后的总时间。</li></ul><div class="table-container"><table><thead><tr><th>时间种类</th><th>精度（统计单位）</th><th>访问速度</th><th>累计休眠时间</th><th>受NTP调整的影响</th><th>获取函数</th></tr></thead><tbody><tr><td>RTC</td><td>低</td><td>慢</td><td>Yes</td><td>Yes</td></tr><tr><td>xtime</td><td>高</td><td>快</td><td>Yes</td><td>Yes</td><td>do_gettimeofday()、ktime_get_real_ts()、ktime_get_real()</td></tr><tr><td>monotonic</td><td>高</td><td>快</td><td>No</td><td>Yes</td><td>ktime_get()、ktime_get_ts64()</td></tr><tr><td>raw monotonic</td><td>高</td><td>快</td><td>No</td><td>No</td><td>ktime_get_raw()、getrawmonotonic64()</td></tr><tr><td>boot time</td><td>高</td><td>快</td><td>Yes</td><td>Yes</td><td>ktime_get_boottime()</td></tr></tbody></table></div><h4 id="2-2-1、timekeeper的定义"><a href="#2-2-1、timekeeper的定义" class="headerlink" title="2.2.1、timekeeper的定义"></a>2.2.1、timekeeper的定义</h4><p>虽然clocksource定时器只有一个，但是timekeeper提供了xtime、monotonic time、raw time、boot time等几种时间，所以timekeeper结构体中定义了多个变量来记住这些差值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct timekeeper - Structure holding internal timekeeping values.</span><br><span class="line"> * @tkr_mono:The readout base structure for CLOCK_MONOTONIC</span><br><span class="line"> * @tkr_raw:The readout base structure for CLOCK_MONOTONIC_RAW</span><br><span class="line"> * @xtime_sec:Current CLOCK_REALTIME time in seconds</span><br><span class="line"> * @ktime_sec:Current CLOCK_MONOTONIC time in seconds</span><br><span class="line"> * @wall_to_monotonic:CLOCK_REALTIME to CLOCK_MONOTONIC offset</span><br><span class="line"> * @offs_real:Offset clock monotonic -&gt; clock realtime</span><br><span class="line"> * @offs_boot:Offset clock monotonic -&gt; clock boottime</span><br><span class="line"> * @offs_tai:Offset clock monotonic -&gt; clock tai</span><br><span class="line"> * @tai_offset:The current UTC to TAI offset in seconds</span><br><span class="line"> * @clock_was_set_seq:The sequence number of clock was set events</span><br><span class="line"> * @next_leap_ktime:CLOCK_MONOTONIC time value of a pending leap-second</span><br><span class="line"> * @raw_time:Monotonic raw base time in timespec64 format</span><br><span class="line"> * @cycle_interval:Number of clock cycles in one NTP interval</span><br><span class="line"> * @xtime_interval:Number of clock shifted nano seconds in one NTP</span><br><span class="line"> *interval.</span><br><span class="line"> * @xtime_remainder:Shifted nano seconds left over when rounding</span><br><span class="line"> *@cycle_interval</span><br><span class="line"> * @raw_interval:Raw nano seconds accumulated per NTP interval.</span><br><span class="line"> * @ntp_error:Difference between accumulated time and NTP time in ntp</span><br><span class="line"> *shifted nano seconds.</span><br><span class="line"> * @ntp_error_shift:Shift conversion between clock shifted nano seconds and</span><br><span class="line"> *ntp shifted nano seconds.</span><br><span class="line"> * @last_warning:Warning ratelimiter (DEBUG_TIMEKEEPING)</span><br><span class="line"> * @underflow_seen:Underflow warning flag (DEBUG_TIMEKEEPING)</span><br><span class="line"> * @overflow_seen:Overflow warning flag (DEBUG_TIMEKEEPING)</span><br><span class="line"> *</span><br><span class="line"> * Note: For timespec(64) based interfaces wall_to_monotonic is what</span><br><span class="line"> * we need to add to xtime (or xtime corrected for sub jiffie times)</span><br><span class="line"> * to get to monotonic time.  Monotonic is pegged at zero at system</span><br><span class="line"> * boot time, so wall_to_monotonic will be negative, however, we will</span><br><span class="line"> * ALWAYS keep the tv_nsec part positive so we can use the usual</span><br><span class="line"> * normalization.</span><br><span class="line"> *</span><br><span class="line"> * wall_to_monotonic is moved after resume from suspend for the</span><br><span class="line"> * monotonic time not to jump. We need to add total_sleep_time to</span><br><span class="line"> * wall_to_monotonic to get the real boot based time offset.</span><br><span class="line"> *</span><br><span class="line"> * wall_to_monotonic is no longer the boot time, getboottime must be</span><br><span class="line"> * used instead.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct timekeeper &#123;</span><br><span class="line">struct tk_read_basetkr_mono;   </span><br><span class="line">                &#x2F;&#x2F; tkr_mono.xtime_nsec：xtime&#x2F;monotonic time 的ns</span><br><span class="line">                &#x2F;&#x2F; tkr_mono.base：monotonic time的base部分</span><br><span class="line">struct tk_read_basetkr_raw;</span><br><span class="line">                &#x2F;&#x2F; tkr_mono.base：raw time的base部分</span><br><span class="line">u64xtime_sec;              &#x2F;&#x2F; xtime的sec</span><br><span class="line">unsigned longktime_sec;      &#x2F;&#x2F; monotonic time 的整sec</span><br><span class="line">struct timespec64wall_to_monotonic;  &#x2F;&#x2F; xtime + wall_to_monotonic &#x3D; monotonic time</span><br><span class="line">ktime_toffs_real;  &#x2F;&#x2F;  monotonic time + offs_real &#x3D; xtime，</span><br><span class="line">                                &#x2F;&#x2F; 和wall_to_monotonic是相反的值</span><br><span class="line">ktime_toffs_boot;  &#x2F;&#x2F;  monotonic time + offs_boot &#x3D; boot time</span><br><span class="line">ktime_toffs_tai;</span><br><span class="line">s32tai_offset;</span><br><span class="line">unsigned intclock_was_set_seq;</span><br><span class="line">ktime_tnext_leap_ktime;</span><br><span class="line">struct timespec64raw_time;   &#x2F;&#x2F; raw time</span><br><span class="line"></span><br><span class="line">&#x2F;* The following members are for timekeeping internal use *&#x2F;</span><br><span class="line">cycle_tcycle_interval;</span><br><span class="line">u64xtime_interval;</span><br><span class="line">s64xtime_remainder;</span><br><span class="line">u32raw_interval;</span><br><span class="line">&#x2F;* The ntp_tick_length() value currently being used.</span><br><span class="line"> * This cached copy ensures we consistently apply the tick</span><br><span class="line"> * length for an entire tick, as ntp_tick_length may change</span><br><span class="line"> * mid-tick, and we don&#39;t want to apply that new value to</span><br><span class="line"> * the tick in progress.</span><br><span class="line"> *&#x2F;</span><br><span class="line">u64ntp_tick;</span><br><span class="line">&#x2F;* Difference between accumulated time and NTP time in ntp</span><br><span class="line"> * shifted nano seconds. *&#x2F;</span><br><span class="line">s64ntp_error;</span><br><span class="line">u32ntp_error_shift;</span><br><span class="line">u32ntp_err_mult;</span><br><span class="line">#ifdef CONFIG_DEBUG_TIMEKEEPING</span><br><span class="line">longlast_warning;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * These simple flag variables are managed</span><br><span class="line"> * without locks, which is racy, but they are</span><br><span class="line"> * ok since we don&#39;t really care about being</span><br><span class="line"> * super precise about how many events were</span><br><span class="line"> * seen, just that a problem was observed.</span><br><span class="line"> *&#x2F;</span><br><span class="line">intunderflow_seen;</span><br><span class="line">intoverflow_seen;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-2、timekeeper的初始化"><a href="#2-2-2、timekeeper的初始化" class="headerlink" title="2.2.2、timekeeper的初始化"></a>2.2.2、timekeeper的初始化</h4><p>timekeeper在初始化的过程中，读取当前的RTC值和clocksource的值，来初始化xtime、monotonic time、raw time、boot time，以及各种offset。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void __init timekeeping_init(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">struct clocksource *clock;</span><br><span class="line">unsigned long flags;</span><br><span class="line">struct timespec64 now, boot, tmp;</span><br><span class="line"></span><br><span class="line">read_persistent_clock64(&amp;now);</span><br><span class="line">if (!timespec64_valid_strict(&amp;now)) &#123;</span><br><span class="line">pr_warn(&quot;WARNING: Persistent clock returned invalid value!\n&quot;</span><br><span class="line">&quot;         Check your CMOS&#x2F;BIOS settings.\n&quot;);</span><br><span class="line">now.tv_sec &#x3D; 0;</span><br><span class="line">now.tv_nsec &#x3D; 0;</span><br><span class="line">&#125; else if (now.tv_sec || now.tv_nsec)</span><br><span class="line">persistent_clock_exists &#x3D; true;</span><br><span class="line"></span><br><span class="line">read_boot_clock64(&amp;boot);</span><br><span class="line">if (!timespec64_valid_strict(&amp;boot)) &#123;</span><br><span class="line">pr_warn(&quot;WARNING: Boot clock returned invalid value!\n&quot;</span><br><span class="line">&quot;         Check your CMOS&#x2F;BIOS settings.\n&quot;);</span><br><span class="line">boot.tv_sec &#x3D; 0;</span><br><span class="line">boot.tv_nsec &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">ntp_init();</span><br><span class="line"></span><br><span class="line">clock &#x3D; clocksource_default_clock();</span><br><span class="line">if (clock-&gt;enable)</span><br><span class="line">clock-&gt;enable(clock);</span><br><span class="line">tk_setup_internals(tk, clock);</span><br><span class="line"></span><br><span class="line">tk_set_xtime(tk, &amp;now);</span><br><span class="line">tk-&gt;raw_time.tv_sec &#x3D; 0;</span><br><span class="line">tk-&gt;raw_time.tv_nsec &#x3D; 0;</span><br><span class="line">if (boot.tv_sec &#x3D;&#x3D; 0 &amp;&amp; boot.tv_nsec &#x3D;&#x3D; 0)</span><br><span class="line">boot &#x3D; tk_xtime(tk);</span><br><span class="line"></span><br><span class="line">set_normalized_timespec64(&amp;tmp, -boot.tv_sec, -boot.tv_nsec);</span><br><span class="line">tk_set_wall_to_mono(tk, tmp);</span><br><span class="line"></span><br><span class="line">timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timekeeper原理上的初始化是在timekeeping_init()函数中完成的，但是read_persistent_clock64()、read_boot_clock64()都是空函数，所以实际上的初始化是另外的路径：rtc_hctosys() -&gt; do_settimeofday64()，rtc初始化的时候重新配置timekeeper。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">static int __init rtc_hctosys(void)</span><br><span class="line">&#123;</span><br><span class="line">int err &#x3D; -ENODEV;</span><br><span class="line">struct rtc_time tm;</span><br><span class="line">struct timespec64 tv64 &#x3D; &#123;</span><br><span class="line">.tv_nsec &#x3D; NSEC_PER_SEC &gt;&gt; 1,</span><br><span class="line">&#125;;</span><br><span class="line">struct rtc_device *rtc &#x3D; rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line"></span><br><span class="line">if (rtc &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">pr_info(&quot;unable to open rtc device (%s)\n&quot;,</span><br><span class="line">CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line">goto err_open;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 读取当前的rtc时间 *&#x2F;</span><br><span class="line">err &#x3D; rtc_read_time(rtc, &amp;tm);</span><br><span class="line">if (err) &#123;</span><br><span class="line">dev_err(rtc-&gt;dev.parent,</span><br><span class="line">&quot;hctosys: unable to read the hardware clock\n&quot;);</span><br><span class="line">goto err_read;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tv64.tv_sec &#x3D; rtc_tm_to_time64(&amp;tm);</span><br><span class="line">tv64.tv_nsec &#x3D; tm.tm_cnt * (1000000000 &#x2F; 32768);</span><br><span class="line"></span><br><span class="line">&#x2F;* (2) 根据rtc时间配置xtime *&#x2F;</span><br><span class="line">err &#x3D; do_settimeofday64(&amp;tv64);</span><br><span class="line"></span><br><span class="line">dev_info(rtc-&gt;dev.parent,</span><br><span class="line">&quot;setting system clock to &quot;</span><br><span class="line">&quot;%d-%02d-%02d %02d:%02d:%02d UTC (%lld)\n&quot;,</span><br><span class="line">tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,</span><br><span class="line">tm.tm_hour, tm.tm_min, tm.tm_sec,</span><br><span class="line">(long long) tv64.tv_sec);</span><br><span class="line"></span><br><span class="line">err_read:</span><br><span class="line">rtc_class_close(rtc);</span><br><span class="line"></span><br><span class="line">err_open:</span><br><span class="line">rtc_hctosys_ret &#x3D; err;</span><br><span class="line"></span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">int do_settimeofday64(const struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">struct timespec64 ts_delta, xt;</span><br><span class="line">unsigned long flags;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (!timespec64_valid_strict(ts))</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 读取当前的xtime，计算rtc time和xtime之间的差值  *&#x2F;</span><br><span class="line">xt &#x3D; tk_xtime(tk);</span><br><span class="line">ts_delta.tv_sec &#x3D; ts-&gt;tv_sec - xt.tv_sec;</span><br><span class="line">ts_delta.tv_nsec &#x3D; ts-&gt;tv_nsec - xt.tv_nsec;</span><br><span class="line"></span><br><span class="line">if (timespec64_compare(&amp;tk-&gt;wall_to_monotonic, &amp;ts_delta) &gt; 0) &#123;</span><br><span class="line">ret &#x3D; -EINVAL;</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2) 将差值追加到offset；tk-&gt;wall_to_monotonic、tk-&gt;offs_real *&#x2F;</span><br><span class="line">tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, ts_delta));</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.3) 更新xtime *&#x2F;</span><br><span class="line">tk_set_xtime(tk, ts);</span><br><span class="line">out:</span><br><span class="line">timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">&#x2F;* signal hrtimers about time change *&#x2F;</span><br><span class="line">clock_was_set();</span><br><span class="line">notify_time_update();</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3、timekeeper的update"><a href="#2-2-3、timekeeper的update" class="headerlink" title="2.2.3、timekeeper的update"></a>2.2.3、timekeeper的update</h4><p>clocksource定时器的值要定时的读出来，并且把增量加到timekeeper中，不然clocksource定时器会溢出。这个定时更新的时间一般是1 tick，调用的函数是update_wall_time()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">void update_wall_time(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *real_tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;shadow_timekeeper;</span><br><span class="line">cycle_t offset;</span><br><span class="line">int shift &#x3D; 0, maxshift;</span><br><span class="line">unsigned int clock_set &#x3D; 0;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">&#x2F;* Make sure we&#39;re fully resumed: *&#x2F;</span><br><span class="line">if (unlikely(timekeeping_suspended))</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span><br><span class="line">offset &#x3D; real_tk-&gt;cycle_interval;</span><br><span class="line">#else</span><br><span class="line">    &#x2F;* (1) 获取clocksource和上一次update之间的offset *&#x2F;</span><br><span class="line">offset &#x3D; clocksource_delta(tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock),</span><br><span class="line">   tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;* Check if there&#39;s really nothing to do *&#x2F;</span><br><span class="line">if (offset &lt; real_tk-&gt;cycle_interval)</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">&#x2F;* Do some additional sanity checking *&#x2F;</span><br><span class="line">timekeeping_check_update(real_tk, offset);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * With NO_HZ we may have to accumulate many cycle_intervals</span><br><span class="line"> * (think &quot;ticks&quot;) worth of time at once. To do this efficiently,</span><br><span class="line"> * we calculate the largest doubling multiple of cycle_intervals</span><br><span class="line"> * that is smaller than the offset.  We then accumulate that</span><br><span class="line"> * chunk in one go, and then try to consume the next smaller</span><br><span class="line"> * doubled multiple.</span><br><span class="line"> *&#x2F;</span><br><span class="line">shift &#x3D; ilog2(offset) - ilog2(tk-&gt;cycle_interval);</span><br><span class="line">shift &#x3D; max(0, shift);</span><br><span class="line">&#x2F;* Bound shift to one less than what overflows tick_length *&#x2F;</span><br><span class="line">maxshift &#x3D; (64 - (ilog2(ntp_tick_length())+1)) - 1;</span><br><span class="line">shift &#x3D; min(shift, maxshift);</span><br><span class="line">&#x2F;* (2) 如果offset的值是多个cycle_interval，</span><br><span class="line">    不要一次update，使用2的n次方cycle_interval的方式逐个update。</span><br><span class="line">    tk-&gt;cycle_interval的值在tk_setup_internals()时被赋值，默认为1 tick *&#x2F;</span><br><span class="line">while (offset &gt;&#x3D; tk-&gt;cycle_interval) &#123;</span><br><span class="line">    &#x2F;* (3) 将offset更新到timekeeper中 *&#x2F;</span><br><span class="line">offset &#x3D; logarithmic_accumulation(tk, offset, shift,</span><br><span class="line">&amp;clock_set);</span><br><span class="line">if (offset &lt; tk-&gt;cycle_interval&lt;&lt;shift)</span><br><span class="line">shift--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* correct the clock when NTP error is too big *&#x2F;</span><br><span class="line">timekeeping_adjust(tk, offset);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * XXX This can be killed once everyone converts</span><br><span class="line"> * to the new update_vsyscall.</span><br><span class="line"> *&#x2F;</span><br><span class="line">old_vsyscall_fixup(tk);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Finally, make sure that after the rounding</span><br><span class="line"> * xtime_nsec isn&#39;t larger than NSEC_PER_SEC</span><br><span class="line"> *&#x2F;</span><br><span class="line">clock_set |&#x3D; accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Update the real timekeeper.</span><br><span class="line"> *</span><br><span class="line"> * We could avoid this memcpy by switching pointers, but that</span><br><span class="line"> * requires changes to all other timekeeper usage sites as</span><br><span class="line"> * well, i.e. move the timekeeper pointer getter into the</span><br><span class="line"> * spinlocked&#x2F;seqcount protected sections. And we trade this</span><br><span class="line"> * memcpy under the tk_core.seq against one before we start</span><br><span class="line"> * updating.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (4)  *&#x2F;</span><br><span class="line">timekeeping_update(tk, clock_set);</span><br><span class="line">memcpy(real_tk, tk, sizeof(*tk));</span><br><span class="line">&#x2F;* The memcpy must come last. Do not put anything here! *&#x2F;</span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">out:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">if (clock_set)</span><br><span class="line">&#x2F;* Have to call _delayed version, since in irq context*&#x2F;</span><br><span class="line">clock_was_set_delayed();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static cycle_t logarithmic_accumulation(struct timekeeper *tk, cycle_t offset,</span><br><span class="line">u32 shift,</span><br><span class="line">unsigned int *clock_set)</span><br><span class="line">&#123;</span><br><span class="line">cycle_t interval &#x3D; tk-&gt;cycle_interval &lt;&lt; shift;</span><br><span class="line">u64 raw_nsecs;</span><br><span class="line"></span><br><span class="line">&#x2F;* If the offset is smaller than a shifted interval, do nothing *&#x2F;</span><br><span class="line">if (offset &lt; interval)</span><br><span class="line">return offset;</span><br><span class="line"></span><br><span class="line">&#x2F;* Accumulate one shifted interval *&#x2F;</span><br><span class="line">offset -&#x3D; interval;</span><br><span class="line">&#x2F;* (3.1) 更新cycle_last *&#x2F;</span><br><span class="line">tk-&gt;tkr_mono.cycle_last +&#x3D; interval;</span><br><span class="line">tk-&gt;tkr_raw.cycle_last  +&#x3D; interval;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (3.2) 更新xtime：</span><br><span class="line">        tk-&gt;tkr_mono.xtime_nsec</span><br><span class="line">        tk-&gt;xtime_sec   *&#x2F;</span><br><span class="line">tk-&gt;tkr_mono.xtime_nsec +&#x3D; tk-&gt;xtime_interval &lt;&lt; shift;</span><br><span class="line">*clock_set |&#x3D; accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">&#x2F;* Accumulate raw time *&#x2F;</span><br><span class="line">&#x2F;* (3.3) 更新raw time：</span><br><span class="line">   tk-&gt;raw_time.tv_nsec</span><br><span class="line">   tk-&gt;raw_time.tv_sec *&#x2F;</span><br><span class="line">raw_nsecs &#x3D; (u64)tk-&gt;raw_interval &lt;&lt; shift;</span><br><span class="line">raw_nsecs +&#x3D; tk-&gt;raw_time.tv_nsec;</span><br><span class="line">if (raw_nsecs &gt;&#x3D; NSEC_PER_SEC) &#123;</span><br><span class="line">u64 raw_secs &#x3D; raw_nsecs;</span><br><span class="line">raw_nsecs &#x3D; do_div(raw_secs, NSEC_PER_SEC);</span><br><span class="line">tk-&gt;raw_time.tv_sec +&#x3D; raw_secs;</span><br><span class="line">&#125;</span><br><span class="line">tk-&gt;raw_time.tv_nsec &#x3D; raw_nsecs;</span><br><span class="line"></span><br><span class="line">&#x2F;* Accumulate error between NTP and clock interval *&#x2F;</span><br><span class="line">tk-&gt;ntp_error +&#x3D; tk-&gt;ntp_tick &lt;&lt; shift;</span><br><span class="line">tk-&gt;ntp_error -&#x3D; (tk-&gt;xtime_interval + tk-&gt;xtime_remainder) &lt;&lt;</span><br><span class="line">(tk-&gt;ntp_error_shift + shift);</span><br><span class="line"></span><br><span class="line">return offset;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void timekeeping_update(struct timekeeper *tk, unsigned int action)</span><br><span class="line">&#123;</span><br><span class="line">if (action &amp; TK_CLEAR_NTP) &#123;</span><br><span class="line">tk-&gt;ntp_error &#x3D; 0;</span><br><span class="line">ntp_clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tk_update_leap_state(tk);</span><br><span class="line">&#x2F;* (4.1) update monotonic time *&#x2F;</span><br><span class="line">tk_update_ktime_data(tk);</span><br><span class="line"></span><br><span class="line">update_vsyscall(tk);</span><br><span class="line">update_pvclock_gtod(tk, action &amp; TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">update_fast_timekeeper(&amp;tk-&gt;tkr_mono, &amp;tk_fast_mono);</span><br><span class="line">update_fast_timekeeper(&amp;tk-&gt;tkr_raw,  &amp;tk_fast_raw);</span><br><span class="line"></span><br><span class="line">if (action &amp; TK_CLOCK_WAS_SET)</span><br><span class="line">tk-&gt;clock_was_set_seq++;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * The mirroring of the data to the shadow-timekeeper needs</span><br><span class="line"> * to happen last here to ensure we don&#39;t over-write the</span><br><span class="line"> * timekeeper structure on the next update with stale data</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (action &amp; TK_MIRROR)</span><br><span class="line">memcpy(&amp;shadow_timekeeper, &amp;tk_core.timekeeper,</span><br><span class="line">       sizeof(tk_core.timekeeper));</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline void tk_update_ktime_data(struct timekeeper *tk)</span><br><span class="line">&#123;</span><br><span class="line">u64 seconds;</span><br><span class="line">u32 nsec;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * The xtime based monotonic readout is:</span><br><span class="line"> *nsec &#x3D; (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();</span><br><span class="line"> * The ktime based monotonic readout is:</span><br><span class="line"> *nsec &#x3D; base_mono + now();</span><br><span class="line"> * &#x3D;&#x3D;&gt; base_mono &#x3D; (xtime_sec + wtm_sec) * 1e9 + wtm_nsec</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (4.1.1) update tk-&gt;tkr_mono.base的值，</span><br><span class="line">   &#x3D; tk-&gt;xtime_sec +  tk-&gt;wall_to_monotonic,</span><br><span class="line">   tk-&gt;tkr_mono.xtime_nsec 没有计算到base中 *&#x2F;</span><br><span class="line">seconds &#x3D; (u64)(tk-&gt;xtime_sec + tk-&gt;wall_to_monotonic.tv_sec);</span><br><span class="line">nsec &#x3D; (u32) tk-&gt;wall_to_monotonic.tv_nsec;</span><br><span class="line">tk-&gt;tkr_mono.base &#x3D; ns_to_ktime(seconds * NSEC_PER_SEC + nsec);</span><br><span class="line"></span><br><span class="line">&#x2F;* Update the monotonic raw base *&#x2F;</span><br><span class="line">&#x2F;* (4.1.2) update tk-&gt;tkr_raw.base的值，</span><br><span class="line">   直接转换tk-&gt;raw_time *&#x2F;</span><br><span class="line">tk-&gt;tkr_raw.base &#x3D; timespec64_to_ktime(tk-&gt;raw_time);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * The sum of the nanoseconds portions of xtime and</span><br><span class="line"> * wall_to_monotonic can be greater&#x2F;equal one second. Take</span><br><span class="line"> * this into account before updating tk-&gt;ktime_sec.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (4.1.3) update tk-&gt;ktime_sec的值</span><br><span class="line">nsec +&#x3D; (u32)(tk-&gt;tkr_mono.xtime_nsec &gt;&gt; tk-&gt;tkr_mono.shift);</span><br><span class="line">if (nsec &gt;&#x3D; NSEC_PER_SEC)</span><br><span class="line">seconds++;</span><br><span class="line">tk-&gt;ktime_sec &#x3D; seconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4、timekeeper的获取"><a href="#2-2-4、timekeeper的获取" class="headerlink" title="2.2.4、timekeeper的获取"></a>2.2.4、timekeeper的获取</h4><ul><li><strong>xtime/wall time 的获取:</strong></li></ul><p>do_gettimeofday()、ktime_get_real_ts()最后调用的getnstimeofday64() -&gt; __getnstimeofday64()获取到xtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">int __getnstimeofday64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned long seq;</span><br><span class="line">s64 nsecs &#x3D; 0;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) sec直接从变量tk-&gt;xtime_sec获取到，</span><br><span class="line">            即上一tick更新的值 *&#x2F;</span><br><span class="line">ts-&gt;tv_sec &#x3D; tk-&gt;xtime_sec;</span><br><span class="line"></span><br><span class="line">&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">ts-&gt;tv_nsec &#x3D; 0;</span><br><span class="line">timespec64_add_ns(ts, nsecs);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Do not bail out early, in case there were callers still using</span><br><span class="line"> * the value, even in the face of the WARN_ON.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (unlikely(timekeeping_suspended))</span><br><span class="line">return -EAGAIN;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">cycle_t delta;</span><br><span class="line">s64 nsec;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 获取距离上一次tick更新，timer的delta值  *&#x2F;</span><br><span class="line">delta &#x3D; timekeeping_get_delta(tkr);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2) delta加上上一次的nsec tkr-&gt;xtime_nsec，</span><br><span class="line">        即为最新的ns值 *&#x2F;</span><br><span class="line">nsec &#x3D; (delta * tkr-&gt;mult + tkr-&gt;xtime_nsec) &gt;&gt; tkr-&gt;shift;</span><br><span class="line"></span><br><span class="line">&#x2F;* If arch requires, add in get_arch_timeoffset() *&#x2F;</span><br><span class="line">return nsec + arch_gettimeoffset();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline cycle_t timekeeping_get_delta(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">cycle_t now, last, mask, max, delta;</span><br><span class="line">unsigned int seq;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Since we&#39;re called holding a seqlock, the data may shift</span><br><span class="line"> * under us while we&#39;re doing the calculation. This can cause</span><br><span class="line"> * false positives, since we&#39;d note a problem but throw the</span><br><span class="line"> * results away. So nest another seqlock here to atomically</span><br><span class="line"> * grab the points we are checking with.</span><br><span class="line"> *&#x2F;</span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;* (2.1.1) 使用read函数读取当前timer的计数 *&#x2F;</span><br><span class="line">now &#x3D; tkr-&gt;read(tkr-&gt;clock);</span><br><span class="line">last &#x3D; tkr-&gt;cycle_last;</span><br><span class="line">mask &#x3D; tkr-&gt;mask;</span><br><span class="line">max &#x3D; tkr-&gt;clock-&gt;max_cycles;</span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1.2) 使用公式：(now - last) &amp; mask，</span><br><span class="line">        计算delta值 *&#x2F;</span><br><span class="line">delta &#x3D; clocksource_delta(now, last, mask);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Try to catch underflows by checking if we are seeing small</span><br><span class="line"> * mask-relative negative values.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (unlikely((~delta &amp; mask) &lt; (mask &gt;&gt; 3))) &#123;</span><br><span class="line">tk-&gt;underflow_seen &#x3D; 1;</span><br><span class="line">delta &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Cap delta value to the max_cycles values to avoid mult overflows *&#x2F;</span><br><span class="line">if (unlikely(delta &gt; max)) &#123;</span><br><span class="line">tk-&gt;overflow_seen &#x3D; 1;</span><br><span class="line">delta &#x3D; tkr-&gt;clock-&gt;max_cycles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ktime_get_real()使用monotonic time再加上差值timekeeper.offs_real的方法来获取xtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime_get_real(void)</span><br><span class="line">&#123;</span><br><span class="line">return ktime_get_with_offset(TK_OFFS_REAL);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static ktime_t *offsets[TK_OFFS_MAX] &#x3D; &#123;</span><br><span class="line">[TK_OFFS_REAL]&#x3D; &amp;tk_core.timekeeper.offs_real,</span><br><span class="line">[TK_OFFS_BOOT]&#x3D; &amp;tk_core.timekeeper.offs_boot,</span><br><span class="line">[TK_OFFS_TAI]&#x3D; &amp;tk_core.timekeeper.offs_tai,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ktime_t ktime_get_with_offset(enum tk_offsets offs)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned int seq;</span><br><span class="line">ktime_t base, *offset &#x3D; offsets[offs];</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line">WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;* (1) monotonic time &#x3D; tk-&gt;tkr_mono.base，</span><br><span class="line">   offset &#x3D; timekeeper.offs_real *&#x2F;</span><br><span class="line">base &#x3D; ktime_add(tk-&gt;tkr_mono.base, *offset);</span><br><span class="line">&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">return ktime_add_ns(base, nsecs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>monotonic time 的获取；</strong></li></ul><p>ktime_get()直接获取monotonic time：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime_get(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned int seq;</span><br><span class="line">ktime_t base;</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line">WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;* (1) monotonic time &#x3D; tk-&gt;tkr_mono.base *&#x2F;</span><br><span class="line">base &#x3D; tk-&gt;tkr_mono.base;</span><br><span class="line">&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">return ktime_add_ns(base, nsecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ktime_get_ts64()通过xtime加上差值tk-&gt;wall_to_monotonic的方法来获取monotonic time：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ktime_get_ts64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">struct timespec64 tomono;</span><br><span class="line">s64 nsec;</span><br><span class="line">unsigned int seq;</span><br><span class="line"></span><br><span class="line">WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;* (1) 获取xtime *&#x2F;</span><br><span class="line">ts-&gt;tv_sec &#x3D; tk-&gt;xtime_sec;</span><br><span class="line">nsec &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line">&#x2F;* (2) 加上xtime和monotonic之间的差值tk-&gt;wall_to_monotonic *&#x2F;</span><br><span class="line">tomono &#x3D; tk-&gt;wall_to_monotonic;</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">ts-&gt;tv_sec +&#x3D; tomono.tv_sec;</span><br><span class="line">ts-&gt;tv_nsec &#x3D; 0;</span><br><span class="line">timespec64_add_ns(ts, nsec + tomono.tv_nsec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>raw monotonic time 的获取；</strong></li></ul><p>ktime_get_raw()通过tk-&gt;tkr_raw.base获取raw monotonic time：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime_get_raw(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned int seq;</span><br><span class="line">ktime_t base;</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;* (1) raw monotonic time &#x3D; tk-&gt;tkr_raw.base *&#x2F;</span><br><span class="line">base &#x3D; tk-&gt;tkr_raw.base;</span><br><span class="line">&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_raw.xtime_nsec + delta</span><br><span class="line">    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_raw);</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">return ktime_add_ns(base, nsecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getrawmonotonic64()通过tk-&gt;raw_time获取raw monotonic time：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void getrawmonotonic64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">struct timespec64 ts64;</span><br><span class="line">unsigned long seq;</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_raw);</span><br><span class="line">ts64 &#x3D; tk-&gt;raw_time;</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">timespec64_add_ns(&amp;ts64, nsecs);</span><br><span class="line">*ts &#x3D; ts64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>boot time 的获取；</strong></li></ul><p>ktime_get_boottime()使用monotonic time再加上差值timekeeper.offs_boot的方法来获取boot time：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime_get_boottime(void)</span><br><span class="line">&#123;</span><br><span class="line">return ktime_get_with_offset(TK_OFFS_BOOT);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static ktime_t *offsets[TK_OFFS_MAX] &#x3D; &#123;</span><br><span class="line">[TK_OFFS_REAL]&#x3D; &amp;tk_core.timekeeper.offs_real,</span><br><span class="line">[TK_OFFS_BOOT]&#x3D; &amp;tk_core.timekeeper.offs_boot,</span><br><span class="line">[TK_OFFS_TAI]&#x3D; &amp;tk_core.timekeeper.offs_tai,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ktime_t ktime_get_with_offset(enum tk_offsets offs)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned int seq;</span><br><span class="line">ktime_t base, *offset &#x3D; offsets[offs];</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line">WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">&#x2F;* (1) monotonic time &#x3D; tk-&gt;tkr_mono.base，</span><br><span class="line">   offset &#x3D; timekeeper.offs_boot *&#x2F;</span><br><span class="line">base &#x3D; ktime_add(tk-&gt;tkr_mono.base, *offset);</span><br><span class="line">&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">return ktime_add_ns(base, nsecs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5、timekeeper-suspend"><a href="#2-2-5、timekeeper-suspend" class="headerlink" title="2.2.5、timekeeper suspend"></a>2.2.5、timekeeper suspend</h4><p>系统在进入suspend以后，clocksource不会再工作，这部分时间会计入xtime和boot time，但是不会计入monotonic time。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">void timekeeping_resume(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">struct clocksource *clock &#x3D; tk-&gt;tkr_mono.clock;</span><br><span class="line">unsigned long flags;</span><br><span class="line">struct timespec64 ts_new, ts_delta;</span><br><span class="line">cycle_t cycle_now, cycle_delta;</span><br><span class="line"></span><br><span class="line">sleeptime_injected &#x3D; false;</span><br><span class="line">read_persistent_clock64(&amp;ts_new);</span><br><span class="line"></span><br><span class="line">clockevents_resume();</span><br><span class="line">clocksource_resume();</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * After system resumes, we need to calculate the suspended time and</span><br><span class="line"> * compensate it for the OS time. There are 3 sources that could be</span><br><span class="line"> * used: Nonstop clocksource during suspend, persistent clock and rtc</span><br><span class="line"> * device.</span><br><span class="line"> *</span><br><span class="line"> * One specific platform may have 1 or 2 or all of them, and the</span><br><span class="line"> * preference will be:</span><br><span class="line"> *suspend-nonstop clocksource -&gt; persistent clock -&gt; rtc</span><br><span class="line"> * The less preferred source will only be tried if there is no better</span><br><span class="line"> * usable source. The rtc part is handled separately in rtc core code.</span><br><span class="line"> *&#x2F;</span><br><span class="line">cycle_now &#x3D; tk-&gt;tkr_mono.read(clock);</span><br><span class="line">if ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;</span><br><span class="line">cycle_now &gt; tk-&gt;tkr_mono.cycle_last) &#123;</span><br><span class="line">u64 num, max &#x3D; ULLONG_MAX;</span><br><span class="line">u32 mult &#x3D; clock-&gt;mult;</span><br><span class="line">u32 shift &#x3D; clock-&gt;shift;</span><br><span class="line">s64 nsec &#x3D; 0;</span><br><span class="line"></span><br><span class="line">cycle_delta &#x3D; clocksource_delta(cycle_now, tk-&gt;tkr_mono.cycle_last,</span><br><span class="line">tk-&gt;tkr_mono.mask);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * &quot;cycle_delta * mutl&quot; may cause 64 bits overflow, if the</span><br><span class="line"> * suspended time is too long. In that case we need do the</span><br><span class="line"> * 64 bits math carefully</span><br><span class="line"> *&#x2F;</span><br><span class="line">do_div(max, mult);</span><br><span class="line">if (cycle_delta &gt; max) &#123;</span><br><span class="line">num &#x3D; div64_u64(cycle_delta, max);</span><br><span class="line">nsec &#x3D; (((u64) max * mult) &gt;&gt; shift) * num;</span><br><span class="line">cycle_delta -&#x3D; num * max;</span><br><span class="line">&#125;</span><br><span class="line">nsec +&#x3D; ((u64) cycle_delta * mult) &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">ts_delta &#x3D; ns_to_timespec64(nsec);</span><br><span class="line">sleeptime_injected &#x3D; true;</span><br><span class="line">&#125; else if (timespec64_compare(&amp;ts_new, &amp;timekeeping_suspend_time) &gt; 0) &#123;</span><br><span class="line">ts_delta &#x3D; timespec64_sub(ts_new, timekeeping_suspend_time);</span><br><span class="line">sleeptime_injected &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (sleeptime_injected)</span><br><span class="line">__timekeeping_inject_sleeptime(tk, &amp;ts_delta);</span><br><span class="line"></span><br><span class="line">&#x2F;* Re-base the last cycle value *&#x2F;</span><br><span class="line">tk-&gt;tkr_mono.cycle_last &#x3D; cycle_now;</span><br><span class="line">tk-&gt;tkr_raw.cycle_last  &#x3D; cycle_now;</span><br><span class="line"></span><br><span class="line">tk-&gt;ntp_error &#x3D; 0;</span><br><span class="line">timekeeping_suspended &#x3D; 0;</span><br><span class="line">timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">touch_softlockup_watchdog();</span><br><span class="line"></span><br><span class="line">tick_resume();</span><br><span class="line">hrtimers_resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int timekeeping_suspend(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned long flags;</span><br><span class="line">struct timespec64delta, delta_delta;</span><br><span class="line">static struct timespec64old_delta;</span><br><span class="line"></span><br><span class="line">read_persistent_clock64(&amp;timekeeping_suspend_time);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * On some systems the persistent_clock can not be detected at</span><br><span class="line"> * timekeeping_init by its return value, so if we see a valid</span><br><span class="line"> * value returned, update the persistent_clock_exists flag.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)</span><br><span class="line">persistent_clock_exists &#x3D; true;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">timekeeping_forward_now(tk);</span><br><span class="line">timekeeping_suspended &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if (persistent_clock_exists) &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * To avoid drift caused by repeated suspend&#x2F;resumes,</span><br><span class="line"> * which each can add ~1 second drift error,</span><br><span class="line"> * try to compensate so the difference in system time</span><br><span class="line"> * and persistent_clock time stays close to constant.</span><br><span class="line"> *&#x2F;</span><br><span class="line">delta &#x3D; timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);</span><br><span class="line">delta_delta &#x3D; timespec64_sub(delta, old_delta);</span><br><span class="line">if (abs(delta_delta.tv_sec) &gt;&#x3D; 2) &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * if delta_delta is too large, assume time correction</span><br><span class="line"> * has occurred and set old_delta to the current delta.</span><br><span class="line"> *&#x2F;</span><br><span class="line">old_delta &#x3D; delta;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;* Otherwise try to adjust old_system to compensate *&#x2F;</span><br><span class="line">timekeeping_suspend_time &#x3D;</span><br><span class="line">timespec64_add(timekeeping_suspend_time, delta_delta);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timekeeping_update(tk, TK_MIRROR);</span><br><span class="line">halt_fast_timekeeper(tk);</span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">tick_suspend();</span><br><span class="line">clocksource_suspend();</span><br><span class="line">clockevents_suspend();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* sysfs resume&#x2F;suspend bits for timekeeping *&#x2F;</span><br><span class="line">static struct syscore_ops timekeeping_syscore_ops &#x3D; &#123;</span><br><span class="line">.resume&#x3D; timekeeping_resume,</span><br><span class="line">.suspend&#x3D; timekeeping_suspend,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和初始化一样的原因，理论上timekeeper的操作在timekeeping_resume()、timekeeping_suspend()，但是实际上在rtc的操作中执行rtc_suspend()、rtc_resume()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">static int rtc_suspend(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">struct rtc_device*rtc &#x3D; to_rtc_device(dev);</span><br><span class="line">struct rtc_timetm;</span><br><span class="line">struct timespec64delta, delta_delta;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">if (timekeeping_rtc_skipsuspend())</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">if (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) !&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* snapshot the current RTC and system time at suspend*&#x2F;</span><br><span class="line">&#x2F;* (1.1) 读取suspend时候的rtc时间 *&#x2F;</span><br><span class="line">err &#x3D; rtc_read_time(rtc, &amp;tm);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">pr_debug(&quot;%s:  fail to read rtc time\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 读取当前xtime *&#x2F;</span><br><span class="line">getnstimeofday64(&amp;old_system);</span><br><span class="line">old_rtc.tv_sec &#x3D; rtc_tm_to_time64(&amp;tm);</span><br><span class="line">old_rtc.tv_nsec &#x3D; tm.tm_cnt*(1000000000&#x2F;32768);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * To avoid drift caused by repeated suspend&#x2F;resumes,</span><br><span class="line"> * which each can add ~1 second drift error,</span><br><span class="line"> * try to compensate so the difference in system time</span><br><span class="line"> * and rtc time stays close to constant.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (1.3) 如果rtc时间和xtime有偏差，尝试纠正xtime *&#x2F;</span><br><span class="line">delta &#x3D; timespec64_sub(old_system, old_rtc);</span><br><span class="line">delta_delta &#x3D; timespec64_sub(delta, old_delta);</span><br><span class="line">if (delta_delta.tv_sec &lt; -2 || delta_delta.tv_sec &gt;&#x3D; 2) &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * if delta_delta is too large, assume time correction</span><br><span class="line"> * has occured and set old_delta to the current delta.</span><br><span class="line"> *&#x2F;</span><br><span class="line">old_delta &#x3D; delta;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;* Otherwise try to adjust old_system to compensate *&#x2F;</span><br><span class="line">old_system &#x3D; timespec64_sub(old_system, delta_delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int rtc_resume(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">struct rtc_device*rtc &#x3D; to_rtc_device(dev);</span><br><span class="line">struct rtc_timetm;</span><br><span class="line">struct timespec64new_system, new_rtc;</span><br><span class="line">struct timespec64sleep_time;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">if (timekeeping_rtc_skipresume())</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">rtc_hctosys_ret &#x3D; -ENODEV;</span><br><span class="line">if (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) !&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* snapshot the current rtc and system time at resume *&#x2F;</span><br><span class="line">&#x2F;* (2.1) 读取resume后的rtc时间和xtime *&#x2F;</span><br><span class="line">getnstimeofday64(&amp;new_system);</span><br><span class="line">err &#x3D; rtc_read_time(rtc, &amp;tm);</span><br><span class="line">if (err &lt; 0) &#123;</span><br><span class="line">pr_debug(&quot;%s:  fail to read rtc time\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_rtc.tv_sec &#x3D; rtc_tm_to_time64(&amp;tm);</span><br><span class="line">new_rtc.tv_nsec &#x3D; tm.tm_cnt*(1000000000&#x2F;32768);</span><br><span class="line"></span><br><span class="line">if (new_rtc.tv_sec &lt; old_rtc.tv_sec) &#123;</span><br><span class="line">pr_debug(&quot;%s:  time travel!\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* calculate the RTC time delta (sleep time)*&#x2F;</span><br><span class="line">&#x2F;* (2.2) 计算suspend和resume之间rtc的差值 *&#x2F;</span><br><span class="line">sleep_time &#x3D; timespec64_sub(new_rtc, old_rtc);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Since these RTC suspend&#x2F;resume handlers are not called</span><br><span class="line"> * at the very end of suspend or the start of resume,</span><br><span class="line"> * some run-time may pass on either sides of the sleep time</span><br><span class="line"> * so subtract kernel run-time between rtc_suspend to rtc_resume</span><br><span class="line"> * to keep things accurate.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.3) 使用上一步的差值，再减去，suspend和resume之间xtime的差值</span><br><span class="line">        得到实际的sleep时间*&#x2F;</span><br><span class="line">sleep_time &#x3D; timespec64_sub(sleep_time,</span><br><span class="line">timespec64_sub(new_system, old_system));</span><br><span class="line"></span><br><span class="line">if (sleep_time.tv_sec &gt;&#x3D; 0)</span><br><span class="line">    &#x2F;* (2.4) 将计算得到的sleep时间，加入到timekeeper中 *&#x2F;</span><br><span class="line">timekeeping_inject_sleeptime64(&amp;sleep_time);</span><br><span class="line">rtc_hctosys_ret &#x3D; 0;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void timekeeping_inject_sleeptime64(struct timespec64 *delta)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">__timekeeping_inject_sleeptime(tk, delta);</span><br><span class="line"></span><br><span class="line">timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">&#x2F;* signal hrtimers about time change *&#x2F;</span><br><span class="line">clock_was_set();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static void __timekeeping_inject_sleeptime(struct timekeeper *tk,</span><br><span class="line">   struct timespec64 *delta)</span><br><span class="line">&#123;</span><br><span class="line">if (!timespec64_valid_strict(delta)) &#123;</span><br><span class="line">printk_deferred(KERN_WARNING</span><br><span class="line">&quot;__timekeeping_inject_sleeptime: Invalid &quot;</span><br><span class="line">&quot;sleep delta value!\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* (2.4.1) 更新xtime *&#x2F;</span><br><span class="line">tk_xtime_add(tk, delta);</span><br><span class="line">&#x2F;* (2.4.2) 更新tk-&gt;wall_to_monotonic、tk-&gt;offs_real *&#x2F;</span><br><span class="line">tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, *delta));</span><br><span class="line">&#x2F;* (2.4.3) 更新tk-&gt;offs_boot *&#x2F;</span><br><span class="line">tk_update_sleep_time(tk, timespec64_to_ktime(*delta));</span><br><span class="line">tk_debug_account_sleep_time(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、clock-event"><a href="#3、clock-event" class="headerlink" title="3、clock_event"></a>3、clock_event</h2><p><img src="/images/posts/2017/10/clockevent.png" alt="image"></p><p>clock_event其实就是对local timer的使用，每个cpu对应一个本地local timer。global timer启动后不需要主动做任何事情，只需要等待timekepper的读取就可以了。而local timer需要触发中断，它的主要价值就体现在定时中断处理了，中断的时间可以是固定的(period mode)也或者是不固定的(oneshot mode)。</p><h3 id="3-1、clock-event的注册"><a href="#3-1、clock-event的注册" class="headerlink" title="3.1、clock_event的注册"></a>3.1、clock_event的注册</h3><h4 id="3-1-1、exynos-clock-event的注册"><a href="#3-1-1、exynos-clock-event的注册" class="headerlink" title="3.1.1、exynos clock_event的注册"></a>3.1.1、exynos clock_event的注册</h4><p>exynos clock_event的注册分为两部分：</p><ul><li>第一部分：localtimer中断的注册：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)</span><br><span class="line">&#123;</span><br><span class="line">int err, cpu;</span><br><span class="line">struct mct_clock_event_device *mevt &#x3D; this_cpu_ptr(&amp;percpu_mct_tick);</span><br><span class="line">struct clk *mct_clk, *tick_clk;</span><br><span class="line"></span><br><span class="line">tick_clk &#x3D; np ? of_clk_get_by_name(np, &quot;fin_pll&quot;) :</span><br><span class="line">clk_get(NULL, &quot;fin_pll&quot;);</span><br><span class="line">if (IS_ERR(tick_clk))</span><br><span class="line">panic(&quot;%s: unable to determine tick clock rate\n&quot;, __func__);</span><br><span class="line">clk_rate &#x3D; clk_get_rate(tick_clk);</span><br><span class="line"></span><br><span class="line">mct_clk &#x3D; np ? of_clk_get_by_name(np, &quot;mct&quot;) : clk_get(NULL, &quot;mct&quot;);</span><br><span class="line">if (IS_ERR(mct_clk))</span><br><span class="line">panic(&quot;%s: unable to retrieve mct clock instance\n&quot;, __func__);</span><br><span class="line">clk_prepare_enable(mct_clk);</span><br><span class="line"></span><br><span class="line">reg_base &#x3D; base;</span><br><span class="line">if (!reg_base)</span><br><span class="line">panic(&quot;%s: unable to ioremap mct address space\n&quot;, __func__);</span><br><span class="line"></span><br><span class="line">if (mct_int_type &#x3D;&#x3D; MCT_INT_PPI) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) 大部分的localtimer是PPI模式，</span><br><span class="line">            注册中断处理函数：exynos4_mct_tick_isr() *&#x2F;</span><br><span class="line">err &#x3D; request_percpu_irq(mct_irqs[MCT_L0_IRQ],</span><br><span class="line"> exynos4_mct_tick_isr, &quot;MCT&quot;,</span><br><span class="line"> &amp;percpu_mct_tick);</span><br><span class="line">WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,</span><br><span class="line">     mct_irqs[MCT_L0_IRQ], err);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">int mct_irq &#x3D; mct_irqs[MCT_L0_IRQ + cpu];</span><br><span class="line">struct mct_clock_event_device *pcpu_mevt &#x3D;</span><br><span class="line">per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span><br><span class="line"></span><br><span class="line">pcpu_mevt-&gt;evt.irq &#x3D; -1;</span><br><span class="line"></span><br><span class="line">irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span><br><span class="line">if (request_irq(mct_irq,</span><br><span class="line">exynos4_mct_tick_isr,</span><br><span class="line">IRQF_TIMER | IRQF_NOBALANCING,</span><br><span class="line">pcpu_mevt-&gt;name, pcpu_mevt)) &#123;</span><br><span class="line">pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span><br><span class="line">cpu);</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pcpu_mevt-&gt;evt.irq &#x3D; mct_irq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 注册cpu hotplug的notifier，</span><br><span class="line">        在其他cpu up时调用exynos4_local_timer_setup()注册clock_event *&#x2F;</span><br><span class="line">err &#x3D; register_cpu_notifier(&amp;exynos4_mct_cpu_nb);</span><br><span class="line">if (err)</span><br><span class="line">goto out_irq;</span><br><span class="line"></span><br><span class="line">&#x2F;* Immediately configure the timer on the boot CPU *&#x2F;</span><br><span class="line">&#x2F;* (3) 注册本cpu的clock_event *&#x2F;</span><br><span class="line">exynos4_local_timer_setup(mevt);</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">out_irq:</span><br><span class="line">free_percpu_irq(mct_irqs[MCT_L0_IRQ], &amp;percpu_mct_tick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static irqreturn_t exynos4_mct_tick_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">struct mct_clock_event_device *mevt &#x3D; dev_id;</span><br><span class="line">struct clock_event_device *evt &#x3D; &amp;mevt-&gt;evt;</span><br><span class="line"></span><br><span class="line">exynos4_mct_tick_clear(mevt);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (4) localtimer中断处理函数是固定的也是非常简单的，</span><br><span class="line">        调用本cpu clock_event_device的handler函数：evt-&gt;event_handler(evt) *&#x2F;</span><br><span class="line">evt-&gt;event_handler(evt);</span><br><span class="line"></span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二部分：clock_event_device注册：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int exynos4_local_timer_setup(struct mct_clock_event_device *mevt)</span><br><span class="line">&#123;</span><br><span class="line">struct clock_event_device *evt &#x3D; &amp;mevt-&gt;evt;</span><br><span class="line">unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">mevt-&gt;base &#x3D; EXYNOS4_MCT_L_BASE(cpu);</span><br><span class="line">snprintf(mevt-&gt;name, sizeof(mevt-&gt;name), &quot;mct_tick%d&quot;, cpu);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 初始化clock_event_device *&#x2F;</span><br><span class="line">evt-&gt;name &#x3D; mevt-&gt;name;</span><br><span class="line">evt-&gt;cpumask &#x3D; cpumask_of(cpu);         &#x2F;&#x2F; 本clock_event_device只服务于一个cpu</span><br><span class="line">evt-&gt;set_next_event &#x3D; exynos4_tick_set_next_event;</span><br><span class="line">evt-&gt;set_state_periodic &#x3D; set_state_periodic;</span><br><span class="line">evt-&gt;set_state_shutdown &#x3D; set_state_shutdown;</span><br><span class="line">evt-&gt;set_state_oneshot &#x3D; set_state_shutdown;</span><br><span class="line">evt-&gt;tick_resume &#x3D; set_state_shutdown;</span><br><span class="line">evt-&gt;features &#x3D; CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;</span><br><span class="line">evt-&gt;rating &#x3D; 450;</span><br><span class="line"></span><br><span class="line">exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);</span><br><span class="line"></span><br><span class="line">if (mct_int_type &#x3D;&#x3D; MCT_INT_SPI) &#123;</span><br><span class="line"></span><br><span class="line">if (evt-&gt;irq &#x3D;&#x3D; -1)</span><br><span class="line">return -EIO;</span><br><span class="line"></span><br><span class="line">irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span><br><span class="line">enable_irq(evt-&gt;irq);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* (2) 配置并注册clockevent *&#x2F;</span><br><span class="line">clockevents_config_and_register(evt, clk_rate &#x2F; (TICK_BASE_CNT + 1),</span><br><span class="line">0xf, 0x7fffffff);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2、clock-event-device的注册"><a href="#3-1-2、clock-event-device的注册" class="headerlink" title="3.1.2、clock_event_device的注册"></a>3.1.2、clock_event_device的注册</h4><p>我们来分析一下clock_event_device的注册过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">void clockevents_config_and_register(struct clock_event_device *dev,</span><br><span class="line">     u32 freq, unsigned long min_delta,</span><br><span class="line">     unsigned long max_delta)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;min_delta_ticks &#x3D; min_delta;   &#x2F;&#x2F; localtimer可配置的最小定时值</span><br><span class="line">dev-&gt;max_delta_ticks &#x3D; max_delta;   &#x2F;&#x2F; localtimer可配置的最大定时值，</span><br><span class="line">                                    &#x2F;&#x2F; 比如exynos是31bit的localtimer，最大值就是0x7fffffff</span><br><span class="line">&#x2F;* (1) 根据localtimer的freq，计算clock_event_device对应的mult、shift，</span><br><span class="line">    mult、shift的作用是用来做ns到localtimer cycle之间的转换，</span><br><span class="line">    与之相反的是，在clocksource中mult、shift用来转换localtimer cycle到ns *&#x2F;</span><br><span class="line">clockevents_config(dev, freq);</span><br><span class="line">&#x2F;* (2) 继续注册clock_event_device *&#x2F;</span><br><span class="line">clockevents_register_device(dev);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_config(struct clock_event_device *dev, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line">u64 sec;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1) 如果不支持oneshot模式，只是period模式，</span><br><span class="line">        定时周期是固定的，不需要动态计算ns到cycle的转换 *&#x2F;</span><br><span class="line">if (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Calculate the maximum number of seconds we can sleep. Limit</span><br><span class="line"> * to 10 minutes for hardware which can program more than</span><br><span class="line"> * 32bit ticks so we still get reasonable conversion values.</span><br><span class="line"> *&#x2F;</span><br><span class="line">sec &#x3D; dev-&gt;max_delta_ticks;</span><br><span class="line">do_div(sec, freq);</span><br><span class="line">if (!sec)</span><br><span class="line">sec &#x3D; 1;</span><br><span class="line">else if (sec &gt; 600 &amp;&amp; dev-&gt;max_delta_ticks &gt; UINT_MAX)</span><br><span class="line">sec &#x3D; 600;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 根据localtimer的freq，计算clock_event_device对应的mult、shift *&#x2F;</span><br><span class="line">clockevents_calc_mult_shift(dev, freq, sec);</span><br><span class="line">&#x2F;* (1.3) 转换min、max的cycle到ns *&#x2F;</span><br><span class="line">dev-&gt;min_delta_ns &#x3D; cev_delta2ns(dev-&gt;min_delta_ticks, dev, false);</span><br><span class="line">dev-&gt;max_delta_ns &#x3D; cev_delta2ns(dev-&gt;max_delta_ticks, dev, true);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_register_device(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">&#x2F;* Initialize state to DETACHED *&#x2F;</span><br><span class="line">clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line"></span><br><span class="line">if (!dev-&gt;cpumask) &#123;</span><br><span class="line">WARN_ON(num_possible_cpus() &gt; 1);</span><br><span class="line">dev-&gt;cpumask &#x3D; cpumask_of(smp_processor_id());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;clockevents_lock, flags);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 将clock_event_device加入到全局链表clockevent_devices中 *&#x2F;</span><br><span class="line">list_add(&amp;dev-&gt;list, &amp;clockevent_devices);</span><br><span class="line">&#x2F;* (2.2) 继续尝试向本cpu的tick_device中注册clock_event_device *&#x2F;</span><br><span class="line">tick_check_new_device(dev);</span><br><span class="line">clockevents_notify_released();</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">void tick_check_new_device(struct clock_event_device *newdev)</span><br><span class="line">&#123;</span><br><span class="line">struct clock_event_device *curdev;</span><br><span class="line">struct tick_device *td;</span><br><span class="line">int cpu;</span><br><span class="line"></span><br><span class="line">cpu &#x3D; smp_processor_id();</span><br><span class="line">td &#x3D; &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class="line">curdev &#x3D; td-&gt;evtdev;</span><br><span class="line"></span><br><span class="line">&#x2F;* cpu local device ? *&#x2F;</span><br><span class="line">&#x2F;* (2.2.1) 新的clock_event_device是否支持本cpu？  *&#x2F;</span><br><span class="line">if (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class="line">goto out_bc;</span><br><span class="line"></span><br><span class="line">&#x2F;* Preference decision *&#x2F;</span><br><span class="line">&#x2F;* (2.2.2) 新的clock_event_device是否比当前clock_event_device更适合？</span><br><span class="line">   1.如果curdev已经是oneshot模式，而newdev不支持oneshot，则切换</span><br><span class="line">   2.newdev的精度要大于curdev，精度 &#x3D; dev-&gt;rating *&#x2F;</span><br><span class="line">if (!tick_check_preferred(curdev, newdev))</span><br><span class="line">goto out_bc;</span><br><span class="line"></span><br><span class="line">if (!try_module_get(newdev-&gt;owner))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Replace the eventually existing device by the new</span><br><span class="line"> * device. If the current device is the broadcast device, do</span><br><span class="line"> * not give it back to the clockevents layer !</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (tick_is_broadcast_device(curdev)) &#123;</span><br><span class="line">clockevents_shutdown(curdev);</span><br><span class="line">curdev &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* (2.2.3) 关闭curdev、newdev *&#x2F;</span><br><span class="line">clockevents_exchange_device(curdev, newdev);</span><br><span class="line">&#x2F;* (2.2.4) 继续clock_event_device注册 *&#x2F;</span><br><span class="line">tick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class="line">if (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class="line">tick_oneshot_notify();</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">out_bc:</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Can the new device be used as a broadcast device ?</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.2.5) 如果newdev不适合注册成本cpu的td-&gt;evtdev,</span><br><span class="line">    尝试将其注册成broadcast clockevent *&#x2F;</span><br><span class="line">tick_install_broadcast_device(newdev);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">static void tick_setup_device(struct tick_device *td,</span><br><span class="line">      struct clock_event_device *newdev, int cpu,</span><br><span class="line">      const struct cpumask *cpumask)</span><br><span class="line">&#123;</span><br><span class="line">ktime_t next_event;</span><br><span class="line">void (*handler)(struct clock_event_device *) &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * First device setup ?</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (!td-&gt;evtdev) &#123;</span><br><span class="line">    &#x2F;* (2.2.4.1) 如果是tick_do_timer_cpu没有被设置，且没有使能tick_nohz_full_cpu</span><br><span class="line">        把tick_do_timer_cpu设置成本cpu，</span><br><span class="line">        tick_do_timer_cpu负责在tick中update jiffies、update_wall_time  *&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * If no cpu took the do_timer update, assign it to</span><br><span class="line"> * this cpu:</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (tick_do_timer_cpu &#x3D;&#x3D; TICK_DO_TIMER_BOOT) &#123;</span><br><span class="line">if (!tick_nohz_full_cpu(cpu))</span><br><span class="line">tick_do_timer_cpu &#x3D; cpu;</span><br><span class="line">else</span><br><span class="line">tick_do_timer_cpu &#x3D; TICK_DO_TIMER_NONE;</span><br><span class="line">tick_next_period &#x3D; ktime_get();</span><br><span class="line">tick_period &#x3D; ktime_set(0, NSEC_PER_SEC &#x2F; HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Startup in periodic mode first.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.2.4.2) 如果tick_device是第一次设置clock_event_device,</span><br><span class="line">    把tick_device设置成period模式 *&#x2F;</span><br><span class="line">td-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;* (2.2.4.3) 如果tick_device不是第一次设置clock_event_device,</span><br><span class="line">    备份原clock_event_deviced的event_handler和next_event *&#x2F;</span><br><span class="line">handler &#x3D; td-&gt;evtdev-&gt;event_handler;</span><br><span class="line">next_event &#x3D; td-&gt;evtdev-&gt;next_event;</span><br><span class="line">td-&gt;evtdev-&gt;event_handler &#x3D; clockevents_handle_noop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.4.4) 更新tick_device-&gt;evtdev到new clock_event_deviced  *&#x2F;</span><br><span class="line">td-&gt;evtdev &#x3D; newdev;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * When the device is not per cpu, pin the interrupt to the</span><br><span class="line"> * current cpu:</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (!cpumask_equal(newdev-&gt;cpumask, cpumask))</span><br><span class="line">irq_set_affinity(newdev-&gt;irq, cpumask);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * When global broadcasting is active, check if the current</span><br><span class="line"> * device is registered as a placeholder for broadcast mode.</span><br><span class="line"> * This allows us to handle this x86 misfeature in a generic</span><br><span class="line"> * way. This function also returns !&#x3D;0 when we keep the</span><br><span class="line"> * current active broadcast state for this CPU.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.2.4.5) 如果全局的brodcast clockevent服务已经启动，</span><br><span class="line">    本cpu的clockevent注册需要向brodcas服务，</span><br><span class="line">    这是为了解决x86的一个失误(misfeature)，其他架构不需要？ *&#x2F;</span><br><span class="line">if (tick_device_uses_broadcast(newdev, cpu))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.4.6) 根据td-&gt;mode安装clock_event_deviced的event_handler,并启动 *&#x2F;</span><br><span class="line">if (td-&gt;mode &#x3D;&#x3D; TICKDEV_MODE_PERIODIC)</span><br><span class="line">    &#x2F;* (2.2.4.7) period模式 *&#x2F;</span><br><span class="line">tick_setup_periodic(newdev, 0);</span><br><span class="line">else</span><br><span class="line">    &#x2F;* (2.2.4.8) oneshot模式 *&#x2F;</span><br><span class="line">tick_setup_oneshot(newdev, handler, next_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、tick-device的period-mode"><a href="#3-2、tick-device的period-mode" class="headerlink" title="3.2、tick_device的period mode"></a>3.2、tick_device的period mode</h3><p>接上节，在cpu第一次注册clock_event_deviced的时候，td-&gt;mode默认被设置成period模式。event_handler会被初始化成tick_handle_periodic：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void tick_setup_periodic(struct clock_event_device *dev, int broadcast)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1) 设置period模式下的event_handler *&#x2F;</span><br><span class="line">tick_set_periodic_handler(dev, broadcast);</span><br><span class="line"></span><br><span class="line">&#x2F;* Broadcast setup ? *&#x2F;</span><br><span class="line">if (!tick_device_is_functional(dev))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 如果dev支持period模式，则硬件上启动period模式:</span><br><span class="line">        tick_device-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC</span><br><span class="line">        clock_event_device-&gt;state_use_accessors &#x3D; CLOCK_EVT_STATE_PERIODIC *&#x2F;</span><br><span class="line">if ((dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC) &amp;&amp;</span><br><span class="line">    !tick_broadcast_oneshot_active()) &#123;</span><br><span class="line">clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">unsigned long seq;</span><br><span class="line">ktime_t next;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">next &#x3D; tick_next_period;</span><br><span class="line">&#125; while (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line"></span><br><span class="line">        &#x2F;* (3) 如果dev不支持period模式只支持oneshot模式，则硬件上启动one shot模式，</span><br><span class="line">            使用oneshot模式来模拟period模式：</span><br><span class="line">            tick_device-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC</span><br><span class="line">            clock_event_device-&gt;state_use_accessors &#x3D; CLOCK_EVT_STATE_ONESHOT *&#x2F;</span><br><span class="line">clockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">if (!clockevents_program_event(dev, next, false))</span><br><span class="line">return;</span><br><span class="line">next &#x3D; ktime_add(next, tick_period);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)</span><br><span class="line">&#123;</span><br><span class="line">if (!broadcast)</span><br><span class="line">    &#x2F;* (1.1) 设置period模式下的event_handler *&#x2F;</span><br><span class="line">dev-&gt;event_handler &#x3D; tick_handle_periodic;</span><br><span class="line">else</span><br><span class="line">dev-&gt;event_handler &#x3D; tick_handle_periodic_broadcast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析一下tick_handle_periodic：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void tick_handle_periodic(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">int cpu &#x3D; smp_processor_id();</span><br><span class="line">ktime_t next &#x3D; dev-&gt;next_event;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 周期性的tick任务 *&#x2F;</span><br><span class="line">tick_periodic(cpu);</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * The cpu might have transitioned to HIGHRES or NOHZ mode via</span><br><span class="line"> * update_process_times() -&gt; run_local_timers() -&gt;</span><br><span class="line"> * hrtimer_run_queues().</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (dev-&gt;event_handler !&#x3D; tick_handle_periodic)</span><br><span class="line">return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (!clockevent_state_oneshot(dev))</span><br><span class="line">return;</span><br><span class="line">&#x2F;* (2) 如果tick_device是period mode，而clockevent是oneshot模式,</span><br><span class="line">    编程oneshot模式clockevent在下一周期触发：</span><br><span class="line">        tick_device-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC</span><br><span class="line">        clock_event_device-&gt;state_use_accessors &#x3D; CLOCK_EVT_STATE_ONESHOT *&#x2F;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Setup the next period for devices, which do not have</span><br><span class="line"> * periodic mode:</span><br><span class="line"> *&#x2F;</span><br><span class="line">next &#x3D; ktime_add(next, tick_period);</span><br><span class="line"></span><br><span class="line">if (!clockevents_program_event(dev, next, false))</span><br><span class="line">return;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Have to be careful here. If we&#39;re in oneshot mode,</span><br><span class="line"> * before we call tick_periodic() in a loop, we need</span><br><span class="line"> * to be sure we&#39;re using a real hardware clocksource.</span><br><span class="line"> * Otherwise we could get trapped in an infinite</span><br><span class="line"> * loop, as the tick_periodic() increments jiffies,</span><br><span class="line"> * which then will increment time, possibly causing</span><br><span class="line"> * the loop to trigger again and again.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (timekeeping_valid_for_hres())</span><br><span class="line">tick_periodic(cpu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void tick_periodic(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1.1) 如果本cpu是tick_do_timer_cpu，更新全局时间戳类型的任务，</span><br><span class="line">        包括update jiffies、update_wall_time  *&#x2F;</span><br><span class="line">if (tick_do_timer_cpu &#x3D;&#x3D; cpu) &#123;</span><br><span class="line">write_seqlock(&amp;jiffies_lock);</span><br><span class="line"></span><br><span class="line">&#x2F;* Keep track of the next tick event *&#x2F;</span><br><span class="line">tick_next_period &#x3D; ktime_add(tick_next_period, tick_period);</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1.1.1) 更新jiffies *&#x2F;</span><br><span class="line">do_timer(1);</span><br><span class="line">write_sequnlock(&amp;jiffies_lock);</span><br><span class="line">&#x2F;* (1.1.2) 读取clocksource来更新timekeeper *&#x2F;</span><br><span class="line">update_wall_time();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 运行软件timer(run_local_timers())和运行调度tick任务(scheduler_tick()) *&#x2F;</span><br><span class="line">update_process_times(user_mode(get_irq_regs()));</span><br><span class="line">profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、运行Mode"><a href="#3-3、运行Mode" class="headerlink" title="3.3、运行Mode"></a>3.3、运行Mode</h3><p>关于mode，有几个结构涉及到：tick_device、clock_event_device、tick_sched、hrtimer_cpu_base、。组合起来有以下几种情况：</p><p><img src="/images/posts/2017/10/clockevent_mode.png" alt="image"></p><p>其实归结起来就3种mode：NOHZ_MODE_INACTIVE、NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。下面来逐个解析一下。</p><h4 id="3-3-1、NOHZ-MODE-INACTIVE"><a href="#3-3-1、NOHZ-MODE-INACTIVE" class="headerlink" title="3.3.1、NOHZ_MODE_INACTIVE"></a>3.3.1、NOHZ_MODE_INACTIVE</h4><p>NOHZ_MODE_INACTIVE就是系统初始化时的状态：“td=period模式, dev=period/oneshot模式, hrtimer=low res, noHz=dis”。</p><p><img src="/images/posts/2017/10/clockevent_NOHZ_MODE_INACTIVE.png" alt="image"></p><p>NOHZ_MODE_INACTIVE模式：</p><ul><li>tick_device工作在period模式，HW local timer工作在period/oneshot模式；</li><li>noHZ没有使能，进入idle会被tick timer中断打断；</li><li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li></ul><h4 id="3-3-2、NOHZ-MODE-LOWRES"><a href="#3-3-2、NOHZ-MODE-LOWRES" class="headerlink" title="3.3.2、NOHZ_MODE_LOWRES"></a>3.3.2、NOHZ_MODE_LOWRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，但是hrtimer高精度不能使能，即进入NOHZ_MODE_LOWRES模式：“td=period模式, dev=oneshot模式, hrtimer=low res, noHz=en”。</p><p><img src="/images/posts/2017/10/clockevent_NOHZ_MODE_LOWRES.png" alt="image"></p><p>NOHZ_MODE_LOWRES模式：</p><ul><li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li><li>noHZ使能，进入idle不会被tick timer中断打断；</li><li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li></ul><p>为了支持noHZ，tick_device必须切换成oneshot模式，在进入idle时停掉tick timer(tick_nohz_idle_enter() -&gt;　__tick_nohz_idle_enter() -&gt; tick_nohz_stop_sched_tick())，在离开idle时恢复tick timer(tick_nohz_idle_exit() -&gt; tick_nohz_restart_sched_tick())，这样idle过程就不会被tick中断。就实现了noHZ模式(tickless)。</p><p>NOHZ_MODE_LOWRES模式下，没有进入idle时tick_device还是以固定周期工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void tick_nohz_handler(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">struct pt_regs *regs &#x3D; get_irq_regs();</span><br><span class="line">ktime_t now &#x3D; ktime_get();</span><br><span class="line"></span><br><span class="line">dev-&gt;next_event.tv64 &#x3D; KTIME_MAX;</span><br><span class="line"></span><br><span class="line">tick_sched_do_timer(now);</span><br><span class="line">tick_sched_handle(ts, regs);</span><br><span class="line"></span><br><span class="line">&#x2F;* No need to reprogram if we are running tickless  *&#x2F;</span><br><span class="line">if (unlikely(ts-&gt;tick_stopped))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) HW local timer还是以固定周期发生中断 *&#x2F;</span><br><span class="line">hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line">tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3、NOHZ-MODE-HIGHRES"><a href="#3-3-3、NOHZ-MODE-HIGHRES" class="headerlink" title="3.3.3、NOHZ_MODE_HIGHRES"></a>3.3.3、NOHZ_MODE_HIGHRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，hrtimer高精度可以使能，即进入NOHZ_MODE_HIGHRES模式：“td=period模式, dev=oneshot模式, hrtimer=high res, noHz=en”。</p><p><img src="/images/posts/2017/10/clockevent_NOHZ_MODE_HIGHRES.png" alt="image"></p><p>NOHZ_MODE_HIGHRES：</p><ul><li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li><li>noHZ使能，进入idle不会被tick timer中断打断；</li><li>hrtimer工作在高精度模式，和硬件定时器(HWlocal timer)的精度一样，远大于低精度定时器tick精度；</li></ul><p>为了支持hrtimer的高精度模式，hrtimer必须直接使用tick_device的oneshot模式，而常规的tick timer转换成hrtimer的一个子timer。</p><p><img src="/images/posts/2017/10/ftrace_NOHZ_MODE_HIGHRES.png" alt="image"></p><p>上图是NOHZ_MODE_HIGHRES模式下，用ftrace抓取HW timer硬件中断和tick任务的执行情况：</p><ul><li>tick任务是以固定周期4ms固定执行的；</li><li>遇到tick任务超过4ms的间隔，这时就是进入了idle状态，且发生了noHZ(tickless)；</li><li>硬件timer中断的发生周期是不固定的，是和hrtimer绑定的；</li><li>发生tick的时候肯定发生了timer硬中断，因为tick是其中一个hrtimer；</li></ul><h4 id="3-3-4、Mode切换"><a href="#3-3-4、Mode切换" class="headerlink" title="3.3.4、Mode切换"></a>3.3.4、Mode切换</h4><p>系统初始状态工作在NOHZ_MODE_INACTIVE模式时，会动态检测是否可以进入更高级别的模式NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。这个检测工作是在这个路径中做的：tick_device工作在period模式：tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer_run_queues(void)</span><br><span class="line">&#123;</span><br><span class="line">struct hrtimer_cpu_base *cpu_base &#x3D; this_cpu_ptr(&amp;hrtimer_bases);</span><br><span class="line">ktime_t now;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (3) 如果hrtimer已经切换到高精度模式，</span><br><span class="line">        则不会从run_local_timers()低精度定时器路径来运行hrtimer *&#x2F;</span><br><span class="line">if (__hrtimer_hres_active(cpu_base))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * This _is_ ugly: We have to check periodically, whether we</span><br><span class="line"> * can switch to highres and &#x2F; or nohz mode. The clocksource</span><br><span class="line"> * switch happens with xtime_lock held. Notification from</span><br><span class="line"> * there only sets the check bit in the tick_oneshot code,</span><br><span class="line"> * otherwise we might deadlock vs. xtime_lock.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* (1) 如果hrtimer没有使能、noHZ使能，</span><br><span class="line">    则调用：tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz()，</span><br><span class="line">    切换到NOHZ_MODE_LOWRES模式 *&#x2F;</span><br><span class="line">if (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 如果hrtimer使能、noHZ使能，</span><br><span class="line">        则调用：hrtimer_switch_to_hres()，</span><br><span class="line">        切换到NOHZ_MODE_HIGHRES模式 *&#x2F;</span><br><span class="line">hrtimer_switch_to_hres();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock(&amp;cpu_base-&gt;lock);</span><br><span class="line">now &#x3D; hrtimer_update_base(cpu_base);</span><br><span class="line">&#x2F;* (4) 低精度hrtimer的运行函数 *&#x2F;</span><br><span class="line">__hrtimer_run_queues(cpu_base, now);</span><br><span class="line">raw_spin_unlock(&amp;cpu_base-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、noHZ"><a href="#4、noHZ" class="headerlink" title="4、noHZ"></a>4、noHZ</h2><p>系统在NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES两种模式下支持noHZ。noHZ是一个功耗优化的feature，在系统负载比较轻的时候没有任务需要调度cpu会进入idle状态，但是系统的tick任务(update_process_times())默认会以固定周期执行，这种固定周期会打断idle状态让系统恢复成正常耗电状态。</p><p>tick任务这种不管有没有任务都是固定周期运行的特性是需要改进的，noHZ就是为了解决这一问题而产生的：如果在idle状态的过程中tick任务没有到期需要处理的低精度timer和高精度timer，tick任务可以继续保持睡眠，直到真正有timer到期。</p><p>idle进程的主要执行序列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) 进入idle前,noHZ的处理 *&#x2F;</span><br><span class="line">tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">while (!need_resched()) &#123;</span><br><span class="line">check_pgt_cache();</span><br><span class="line">rmb();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (2) cpu hotplug之cpu_down()的处理 *&#x2F;</span><br><span class="line">if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line"></span><br><span class="line">arch_cpu_idle_dead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line">arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (3) cpu idle的进入 *&#x2F;</span><br><span class="line">if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line">cpu_idle_poll();</span><br><span class="line">else</span><br><span class="line">cpuidle_idle_call();</span><br><span class="line"></span><br><span class="line">arch_cpu_idle_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (4) 退出idle后,noHZ的处理 *&#x2F;</span><br><span class="line">tick_nohz_idle_exit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其中的关键在tick_nohz_idle_enter()/tick_nohz_idle_exit()函数。</p><h3 id="4-1、tick-nohz-idle-enter-exit"><a href="#4-1、tick-nohz-idle-enter-exit" class="headerlink" title="4.1、tick_nohz_idle_enter/exit()"></a>4.1、tick_nohz_idle_enter/exit()</h3><p>tick_nohz_idle_enter()的解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">ts-&gt;inidle &#x3D; 1;</span><br><span class="line">__tick_nohz_idle_enter(ts);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class="line">&#123;</span><br><span class="line">ktime_t now, expires;</span><br><span class="line">int cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">now &#x3D; tick_nohz_start_idle(ts);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 判断当前能否stop tick任务 *&#x2F;</span><br><span class="line">if (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class="line">int was_stopped &#x3D; ts-&gt;tick_stopped;</span><br><span class="line"></span><br><span class="line">ts-&gt;idle_calls++;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (2) 尝试stop tick任务 *&#x2F;</span><br><span class="line">expires &#x3D; tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class="line">if (expires.tv64 &gt; 0LL) &#123;</span><br><span class="line">ts-&gt;idle_sleeps++;</span><br><span class="line">ts-&gt;idle_expires &#x3D; expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!was_stopped &amp;&amp; ts-&gt;tick_stopped)</span><br><span class="line">ts-&gt;idle_jiffies &#x3D; ts-&gt;last_jiffies;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span><br><span class="line"> ktime_t now, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">struct clock_event_device *dev &#x3D; __this_cpu_read(tick_cpu_device.evtdev);</span><br><span class="line">u64 basemono, next_tick, next_tmr, next_rcu, delta, expires;</span><br><span class="line">unsigned long seq, basejiff;</span><br><span class="line">ktime_ttick;</span><br><span class="line"></span><br><span class="line">&#x2F;* Read jiffies and the time when jiffies were updated last *&#x2F;</span><br><span class="line">do &#123;</span><br><span class="line">seq &#x3D; read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">basemono &#x3D; last_jiffies_update.tv64;</span><br><span class="line">basejiff &#x3D; jiffies;</span><br><span class="line">&#125; while (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line">ts-&gt;last_jiffies &#x3D; basejiff;</span><br><span class="line"></span><br><span class="line">if (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span><br><span class="line">    arch_needs_cpu() || irq_work_needs_cpu()) &#123;</span><br><span class="line">next_tick &#x3D; basemono + TICK_NSEC;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Get the next pending timer. If high resolution</span><br><span class="line"> * timers are enabled this only takes the timer wheel</span><br><span class="line"> * timers into account. If high resolution timers are</span><br><span class="line"> * disabled this also looks at the next expiring</span><br><span class="line"> * hrtimer.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.1) 获取下一个timer的到期时间(包括低精度和高精度timer) *&#x2F;</span><br><span class="line">next_tmr &#x3D; get_next_timer_interrupt(basejiff, basemono);</span><br><span class="line">ts-&gt;next_timer &#x3D; next_tmr;</span><br><span class="line">&#x2F;* Take the next rcu event into account *&#x2F;</span><br><span class="line">next_tick &#x3D; next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * If the tick is due in the next period, keep it ticking or</span><br><span class="line"> * restart it proper.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.2) 如果差距小于一个tick，不需要进入noHZ模式 *&#x2F;</span><br><span class="line">delta &#x3D; next_tick - basemono;</span><br><span class="line">if (delta &lt;&#x3D; (u64)TICK_NSEC) &#123;</span><br><span class="line">tick.tv64 &#x3D; 0;</span><br><span class="line">if (!ts-&gt;tick_stopped)</span><br><span class="line">goto out;</span><br><span class="line">if (delta &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;* Tick is stopped, but required now. Enforce it *&#x2F;</span><br><span class="line">tick_nohz_restart(ts, now);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * If this cpu is the one which updates jiffies, then give up</span><br><span class="line"> * the assignment and let it be taken by the cpu which runs</span><br><span class="line"> * the tick timer next, which might be this cpu as well. If we</span><br><span class="line"> * don&#39;t drop this here the jiffies might be stale and</span><br><span class="line"> * do_timer() never invoked. Keep track of the fact that it</span><br><span class="line"> * was the one which had the do_timer() duty last. If this cpu</span><br><span class="line"> * is the one which had the do_timer() duty last, we limit the</span><br><span class="line"> * sleep time to the timekeeping max_deferement value.</span><br><span class="line"> * Otherwise we can sleep as long as we want.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* (2.3) 根据timekeeper的可能溢出的位宽，得到的idle最大值 *&#x2F;</span><br><span class="line">delta &#x3D; timekeeping_max_deferment();</span><br><span class="line">if (cpu &#x3D;&#x3D; tick_do_timer_cpu) &#123;</span><br><span class="line">tick_do_timer_cpu &#x3D; TICK_DO_TIMER_NONE;</span><br><span class="line">ts-&gt;do_timer_last &#x3D; 1;</span><br><span class="line">&#125; else if (tick_do_timer_cpu !&#x3D; TICK_DO_TIMER_NONE) &#123;</span><br><span class="line">delta &#x3D; KTIME_MAX;</span><br><span class="line">ts-&gt;do_timer_last &#x3D; 0;</span><br><span class="line">&#125; else if (!ts-&gt;do_timer_last) &#123;</span><br><span class="line">delta &#x3D; KTIME_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_FULL</span><br><span class="line">&#x2F;* Limit the tick delta to the maximum scheduler deferment *&#x2F;</span><br><span class="line">if (!ts-&gt;inidle)</span><br><span class="line">delta &#x3D; min(delta, scheduler_tick_max_deferment());</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;* Calculate the next expiry time *&#x2F;</span><br><span class="line">if (delta &lt; (KTIME_MAX - basemono))</span><br><span class="line">expires &#x3D; basemono + delta;</span><br><span class="line">else</span><br><span class="line">expires &#x3D; KTIME_MAX;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.4) 综合上面条件，得到合理的stop tick的时间 *&#x2F;</span><br><span class="line">expires &#x3D; min_t(u64, expires, next_tick);</span><br><span class="line">tick.tv64 &#x3D; expires;</span><br><span class="line"></span><br><span class="line">&#x2F;* Skip reprogram of event if its not changed *&#x2F;</span><br><span class="line">if (ts-&gt;tick_stopped &amp;&amp; (expires &#x3D;&#x3D; dev-&gt;next_event.tv64))</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * nohz_stop_sched_tick can be called several times before</span><br><span class="line"> * the nohz_restart_sched_tick is called. This happens when</span><br><span class="line"> * interrupts arrive which do not cause a reschedule. In the</span><br><span class="line"> * first call we save the current tick time, so we can restart</span><br><span class="line"> * the scheduler tick in nohz_restart_sched_tick.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (!ts-&gt;tick_stopped) &#123;</span><br><span class="line">nohz_balance_enter_idle(cpu);</span><br><span class="line">calc_load_enter_idle();</span><br><span class="line"></span><br><span class="line">ts-&gt;last_tick &#x3D; hrtimer_get_expires(&amp;ts-&gt;sched_timer);</span><br><span class="line">ts-&gt;tick_stopped &#x3D; 1;</span><br><span class="line">trace_tick_stop(1, &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * If the expiration time &#x3D;&#x3D; KTIME_MAX, then we simply stop</span><br><span class="line"> * the tick timer.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (unlikely(expires &#x3D;&#x3D; KTIME_MAX)) &#123;</span><br><span class="line">if (ts-&gt;nohz_mode &#x3D;&#x3D; NOHZ_MODE_HIGHRES)</span><br><span class="line">hrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.5) 实际的stop tick动作：</span><br><span class="line">      将local timer的周期改为大于一个tick的时间，将idle时间延长  *&#x2F;</span><br><span class="line">if (ts-&gt;nohz_mode &#x3D;&#x3D; NOHZ_MODE_HIGHRES)</span><br><span class="line">hrtimer_start(&amp;ts-&gt;sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">else</span><br><span class="line">tick_program_event(tick, 1);</span><br><span class="line">out:</span><br><span class="line">&#x2F;* Update the estimated sleep length *&#x2F;</span><br><span class="line">ts-&gt;sleep_length &#x3D; ktime_sub(dev-&gt;next_event, now);</span><br><span class="line">return tick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tick_nohz_idle_exit()的解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">ktime_t now;</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(!ts-&gt;inidle);</span><br><span class="line"></span><br><span class="line">ts-&gt;inidle &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (ts-&gt;idle_active || ts-&gt;tick_stopped)</span><br><span class="line">now &#x3D; ktime_get();</span><br><span class="line"></span><br><span class="line">if (ts-&gt;idle_active)</span><br><span class="line">tick_nohz_stop_idle(ts, now);</span><br><span class="line"></span><br><span class="line">if (ts-&gt;tick_stopped) &#123;</span><br><span class="line">    &#x2F;* (1) 重启tick任务 *&#x2F;</span><br><span class="line">tick_nohz_restart_sched_tick(ts, now);</span><br><span class="line">tick_nohz_account_idle_ticks(ts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Update jiffies first *&#x2F;</span><br><span class="line">tick_do_update_jiffies64(now);</span><br><span class="line">update_cpu_load_nohz();</span><br><span class="line"></span><br><span class="line">calc_load_exit_idle();</span><br><span class="line">touch_softlockup_watchdog();</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Cancel the scheduled timer and restore the tick</span><br><span class="line"> *&#x2F;</span><br><span class="line">ts-&gt;tick_stopped  &#x3D; 0;</span><br><span class="line">ts-&gt;idle_exittime &#x3D; now;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1) 重启local timer *&#x2F;</span><br><span class="line">tick_nohz_restart(ts, now);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)</span><br><span class="line">&#123;</span><br><span class="line">hrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class="line">hrtimer_set_expires(&amp;ts-&gt;sched_timer, ts-&gt;last_tick);</span><br><span class="line"></span><br><span class="line">&#x2F;* Forward the time to expire in the future *&#x2F;</span><br><span class="line">hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line"></span><br><span class="line">if (ts-&gt;nohz_mode &#x3D;&#x3D; NOHZ_MODE_HIGHRES)</span><br><span class="line">hrtimer_start_expires(&amp;ts-&gt;sched_timer, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">else</span><br><span class="line">tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-tick-nohz-irq-enter-exit"><a href="#4-2-tick-nohz-irq-enter-exit" class="headerlink" title="4.2 tick_nohz_irq_enter/exit()"></a>4.2 tick_nohz_irq_enter/exit()</h3><p>因为在idle退出执行完本tick需要处理的timer后又需要重新关闭tick，系统设计了tick_nohz_irq_enter()/tick_nohz_irq_exit()来处理这种操作。在本次中断处理完timer后，在tick_nohz_irq_exit()中判断是否重新关闭tick任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) 关闭tick *&#x2F;</span><br><span class="line">tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">while (!need_resched()) &#123;</span><br><span class="line">check_pgt_cache();</span><br><span class="line">rmb();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (2) cpu hotplug之cpu_down()的处理 *&#x2F;</span><br><span class="line">if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line"></span><br><span class="line">arch_cpu_idle_dead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* (3) 关中断 *&#x2F;</span><br><span class="line">local_irq_disable();</span><br><span class="line">arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (4) 进入idle，</span><br><span class="line">                cpu进入暂停状态 *&#x2F;</span><br><span class="line">if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line">cpu_idle_poll();</span><br><span class="line">else</span><br><span class="line">cpuidle_idle_call();</span><br><span class="line">    &#x2F;* (5) cpu被local timer中断唤醒退出idle状态，继续执行；</span><br><span class="line">        但是因为irq是disable状态，中断服务程序并不能马上得到执行*&#x2F;</span><br><span class="line">&#x2F;* (5.1) 退出idle，并且开中断 *&#x2F;</span><br><span class="line"></span><br><span class="line">                    &#x2F;* (6) 中断打开后，被阻塞的local timer中断服务得到执行，到期的软件timer得到执行；*&#x2F;</span><br><span class="line">                    &#x2F;* (6.1) 退出中断时调用tick_nohz_irq_exit()，重新计算一个tick可以被stop的值 *&#x2F;</span><br><span class="line">            </span><br><span class="line">arch_cpu_idle_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (7) 重启tick *&#x2F;</span><br><span class="line">tick_nohz_idle_exit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tick_nohz_irq_enter()/tick_nohz_irq_exit()的代码解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick_nohz_irq_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">ktime_t now;</span><br><span class="line"></span><br><span class="line">if (!ts-&gt;idle_active &amp;&amp; !ts-&gt;tick_stopped)</span><br><span class="line">return;</span><br><span class="line">now &#x3D; ktime_get();</span><br><span class="line">if (ts-&gt;idle_active)</span><br><span class="line">tick_nohz_stop_idle(ts, now);</span><br><span class="line"></span><br><span class="line">&#x2F;* (1) 基本就是空操作 *&#x2F;</span><br><span class="line">if (ts-&gt;tick_stopped) &#123;</span><br><span class="line">tick_nohz_update_jiffies(now);</span><br><span class="line">tick_nohz_kick_tick(ts, now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick_nohz_irq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line"></span><br><span class="line">if (ts-&gt;inidle)</span><br><span class="line">    &#x2F;* (2) 重新判断stop tick任务 *&#x2F;</span><br><span class="line">__tick_nohz_idle_enter(ts);</span><br><span class="line">else</span><br><span class="line">tick_nohz_full_update_tick(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、local-timer时钟被关闭时的处理"><a href="#4-3、local-timer时钟被关闭时的处理" class="headerlink" title="4.3、local timer时钟被关闭时的处理"></a>4.3、local timer时钟被关闭时的处理</h3><p>还有一种情况需要考虑，在系统进入深层次的idle状态时，local timer本身的时钟可能会被关闭。比如MTK平台进入soidle状态时，local timer本身会被停止，这时会用一个GPT timer来替代local timer继续工作。</p><p>核心函数是timer_setting_before_wfi()/timer_setting_after_wfi()：</p><ul><li>timer_setting_before_wfi()在进入idle前被调用，读出local timer的剩余值并配置到GPT timer中；</li><li>timer_setting_after_wfi()在退出idle后被调用，读出GPT timer的值来重新恢复local timer；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void timer_setting_before_wfi(bool f26m_off)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef USING_STD_TIMER_OPS</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">unsigned int timer_left &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 读出local timer的剩余值 *&#x2F;</span><br><span class="line">timer_left &#x3D; localtimer_get_counter();</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 根据GPT timer在不同状态下的频率，把剩余值配置到GPT中 *&#x2F;</span><br><span class="line">if ((int)timer_left &lt;&#x3D; 0)</span><br><span class="line">gpt_set_cmp(IDLE_GPT, 1); &#x2F;* Trigger idle_gpt Timeout imediately *&#x2F;</span><br><span class="line">else &#123;</span><br><span class="line">if (f26m_off)</span><br><span class="line">gpt_set_cmp(IDLE_GPT, div_u64(timer_left, 406.25));</span><br><span class="line">else</span><br><span class="line">gpt_set_cmp(IDLE_GPT, timer_left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (f26m_off)</span><br><span class="line">gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_RTC, GPT_CLK_DIV_1);</span><br><span class="line"></span><br><span class="line">start_gpt(IDLE_GPT);</span><br><span class="line">#else</span><br><span class="line">gpt_get_cnt(GPT1, &amp;timer_left);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void timer_setting_after_wfi(bool f26m_off)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef USING_STD_TIMER_OPS</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">    &#x2F;* (3) 判断当前退出idle状态是否是因为GPT到期引起的 *&#x2F;</span><br><span class="line">if (gpt_check_and_ack_irq(IDLE_GPT)) &#123;</span><br><span class="line">    &#x2F;* (3.1) 如果GPT时间已经到期，证明local timer也已经到期，</span><br><span class="line">        触发local timer在下一时钟执行 *&#x2F;</span><br><span class="line">localtimer_set_next_event(1);</span><br><span class="line">if (f26m_off)</span><br><span class="line">gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;* (4) 退出idle是因为GPT以外的中断源唤醒的 *&#x2F;</span><br><span class="line">&#x2F;* waked up by other wakeup source *&#x2F;</span><br><span class="line">unsigned int cnt, cmp;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (4.1) 读出GPT中的剩余到期值，重新配置到local timer中 *&#x2F;</span><br><span class="line">idle_gpt_get_cnt(IDLE_GPT, &amp;cnt);</span><br><span class="line">idle_gpt_get_cmp(IDLE_GPT, &amp;cmp);</span><br><span class="line">if (unlikely(cmp &lt; cnt)) &#123;</span><br><span class="line">idle_err(&quot;[%s]GPT%d: counter &#x3D; %10u, compare &#x3D; %10u\n&quot;,</span><br><span class="line">__func__, IDLE_GPT + 1, cnt, cmp);</span><br><span class="line">&#x2F;* BUG(); *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (f26m_off) &#123;</span><br><span class="line">localtimer_set_next_event((cmp - cnt) * 1625 &#x2F; 4);</span><br><span class="line">gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">localtimer_set_next_event(cmp - cnt);</span><br><span class="line">&#125;</span><br><span class="line">stop_gpt(IDLE_GPT);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别说明的是，这种GPT timer全局只有一个，进入soidle的状态时cpu也只有一个在线，所以能正常的工作。</p><h2 id="5、hrtimer"><a href="#5、hrtimer" class="headerlink" title="5、hrtimer"></a>5、hrtimer</h2><h3 id="5-1、hrtimer的组织"><a href="#5-1、hrtimer的组织" class="headerlink" title="5.1、hrtimer的组织"></a>5.1、hrtimer的组织</h3><p>hrtimer的组织相对来说还是比较简单的，每个cpu对应一个hrtimer_cpu_base，每个hrtimer_cpu_base中有4类clock_base代表4种时间类型(HRTIMER_BASE_REALTIME、HRTIMER_BASE_MONOTONIC、HRTIMER_BASE_BOOTTIME、HRTIMER_BASE_TAI)的hrtimer，每个clock_base是以红黑树来组织同一类型的hrtimer的：</p><p><img src="/images/posts/2017/10/hrtimer.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">.lock &#x3D; __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),</span><br><span class="line">.seq &#x3D; SEQCNT_ZERO(hrtimer_bases.seq),</span><br><span class="line">.clock_base &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">.index &#x3D; HRTIMER_BASE_MONOTONIC,</span><br><span class="line">.clockid &#x3D; CLOCK_MONOTONIC,</span><br><span class="line">.get_time &#x3D; &amp;ktime_get,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.index &#x3D; HRTIMER_BASE_REALTIME,</span><br><span class="line">.clockid &#x3D; CLOCK_REALTIME,</span><br><span class="line">.get_time &#x3D; &amp;ktime_get_real,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.index &#x3D; HRTIMER_BASE_BOOTTIME,</span><br><span class="line">.clockid &#x3D; CLOCK_BOOTTIME,</span><br><span class="line">.get_time &#x3D; &amp;ktime_get_boottime,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.index &#x3D; HRTIMER_BASE_TAI,</span><br><span class="line">.clockid &#x3D; CLOCK_TAI,</span><br><span class="line">.get_time &#x3D; &amp;ktime_get_clocktai,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES"><a href="#5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES" class="headerlink" title="5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)"></a>5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)</h3><p>前面几章已经详细描述了执行路径，在低精度模式下hrtimer的实际精度和低精度定时器是一样的，都是基于tick精度的。他的执行路径如下。</p><p>NOHZ_MODE_INACTIVE模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic()</span><br><span class="line">    ↓</span><br><span class="line">tick_periodic()</span><br><span class="line">    ↓</span><br><span class="line">update_process_times()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">hrtimer_run_queues()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure><p>NOHZ_MODE_LOWRES模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tick_nohz_handler()</span><br><span class="line">    ↓</span><br><span class="line">tick_sched_handle()</span><br><span class="line">    ↓</span><br><span class="line">update_process_times()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">hrtimer_run_queues()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure><h3 id="5-3、高精度模式-NOHZ-MODE-HIGHRES"><a href="#5-3、高精度模式-NOHZ-MODE-HIGHRES" class="headerlink" title="5.3、高精度模式(NOHZ_MODE_HIGHRES)"></a>5.3、高精度模式(NOHZ_MODE_HIGHRES)</h3><p>在高精度模式下hrtimer才能发挥出真正的精度，他的可以精确定时到小于一个tick，精度依赖于硬件local timer。</p><p>NOHZ_MODE_LOWRES模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_interrupt()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure><h2 id="6、低精度timer-lowres-timer"><a href="#6、低精度timer-lowres-timer" class="headerlink" title="6、低精度timer(lowres timer)"></a>6、低精度timer(lowres timer)</h2><p>低精度timer在系统中的应用范围更广，若非特别声明是hrtimer其他都是使用低精度timer，类如schedule_timeout()、msleep()。他有以下特点：</p><ul><li>精度低，以tick为单位计时；</li><li>执行上下文，低精度timer执行时是在softirq中，而hrtimer的实际执行是在中断当中。所以低精度的执行精度更小于hrtimer；</li><li>对系统的实时影响小，softirq比irq对系统的实时性影响更小；</li></ul><h3 id="6-1、低精度timer的组织"><a href="#6-1、低精度timer的组织" class="headerlink" title="6.1、低精度timer的组织"></a>6.1、低精度timer的组织</h3><p>低精度timer的组织形式和hrtimer类似，只是timer的链接不是采用红黑树，而是采用tv1 - tv5等一系列的链表。</p><p><img src="/images/posts/2017/10/lowres_timer.png" alt="image"></p><p>tv1 - tv5中保留着一系列槽位，每个槽位代表一个超时时间，把相同超时时间的低精度timer链接到同一槽位当中。</p><h3 id="6-2、低精度timer的执行路径"><a href="#6-2、低精度timer的执行路径" class="headerlink" title="6.2、低精度timer的执行路径"></a>6.2、低精度timer的执行路径</h3><p>低精度timer的实际执行时在softirq中执行的，在中断中的动作只是简单触发softirq。</p><p>中断中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic()&#x2F;tick_nohz_handler()&#x2F;hrtimer_interrupt()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">raise_softirq(TIMER_SOFTIRQ);</span><br></pre></td></tr></table></figure><p>软中断中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softirq()</span><br><span class="line">    ↓</span><br><span class="line">__run_timers()</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_DroidPhoneo"><sup>DroidPhoneo</sup>. <a href="http://blog.csdn.net/DroidPhone/article/category/1263459" target="_blank" rel="noopener">Linux 时间子系统</a><a href="#reffn_DroidPhoneo" title="Jump back to footnote [DroidPhoneo] in the text."> &#8617;</a></blockquote><blockquote id="fn_wowo"><sup>wowo</sup>. <a href="http://www.wowotech.net/timer_subsystem/time_subsystem_index.html" target="_blank" rel="noopener">wowotech time subsystem</a><a href="#reffn_wowo" title="Jump back to footnote [wowo] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hrtimer </tag>
            
            <tag> tickless </tag>
            
            <tag> clocksource </tag>
            
            <tag> timekeeper </tag>
            
            <tag> clockevent </tag>
            
            <tag> noHZ </tag>
            
            <tag> lowres timer </tag>
            
            <tag> wall time </tag>
            
            <tag> xtime </tag>
            
            <tag> monotonic time </tag>
            
            <tag> boottime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Device Tree 详解</title>
      <link href="/2018/03/21//device-tree.html/"/>
      <url>/2018/03/21//device-tree.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1、DTS语法"><a href="#1、DTS语法" class="headerlink" title="1、DTS语法"></a>1、DTS语法</h1><p>对于DeviceTree的来历和用处大部分人都已经非常了解了，DeviceTree发源于PowerPC架构，为了消除代码中冗余的各种device注册代码而产生的，现在已经成为了linux的通用机制。</p><p>DeviceTree的结构非常简单，由两种元素组成：Node(节点)、Property(属性)。下图是一个真实的简单的DeviceTree树形结构图。</p><p><img src="/images/posts/2018/03/DeviceTree.png" alt="image"></p><ul><li>Node节点。在DTS中使用一对花括号”node-name{}”来定义;</li><li>Property属性。在Node中使用”property-name=value”字符串来定义；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; &#123;</span><br><span class="line">model &#x3D; &quot;mt6799&quot;;</span><br><span class="line">compatible &#x3D; &quot;mediatek,mt6799&quot;;</span><br><span class="line">interrupt-parent &#x3D; &lt;&amp;gic&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;2&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;2&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;* chosen *&#x2F;</span><br><span class="line">chosen &#123;</span><br><span class="line">bootargs &#x3D; &quot;console&#x3D;tty0 console&#x3D;ttyMT0,921600n1 root&#x3D;&#x2F;dev&#x2F;ram&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中定义了一个根节点”/“和一个子节点“chosen”，其他的字符串“model = “mt6799”;”、“compatible = “mediatek,mt6799”;”都是property。</p><p>Node、Property的名字和值都是可以自定义的，没有太大限制。但是DeviceTree的标准还是预定义了一些标准的Node和Property，在标准Node和Property之间还定义了一些约束规则。关于这些描述在 <a href="https://www.devicetree.org/" target="_blank" rel="noopener">The DeviceTree Specification</a>官方spec中有详细描述。这里为了方便大家，还是重复做一些搬运。</p><h2 id="1-1、标准Property"><a href="#1-1、标准Property" class="headerlink" title="1.1、标准Property"></a>1.1、标准Property</h2><p>Property的格式为”property-name=value”，其中value的取值类型如下：</p><table border="1"><caption> Property values： </caption><tr><th style="width: 200px;">Value</th><th style="width: 600px;">Description</th></tr><tr><td> &#60;empty&#62; </td><td>Value is empty. Used for conveying true-false information, when the presence ofabsence of the property itself is sufficiently descriptive.<br /><br />Property值为空，用property本身出现或者不出现来表示一个treue/false值。</td></tr><tr><td> &#60;u32&#62; </td><td>A 32-bit integer in big-endian format. Example: the 32-bit value 0x11223344 would be represented in memory as: <br />address 11<br />address+1 22<br />address+2 33<br />address+3 44<br /><br />32bit的值，用大端格式存储。</td></tr><tr><td> &#60;u64&#62; </td><td>Represents a 64-bit integer in big-endian format. Consists of two &#60;u32&#62; values where the first value contains the most significant bits of the integer and the second value contains the least significant bits.<br />Example: the 64-bit value 0x1122334455667788 would be represented as two cells as: <0x11223344 0x55667788>. <br />The value would be represented in memory as:<br />address 11<br />address+1 22<br />address+2 33<br />address+3 44<br />address+4 55<br />address+5 66<br />address+6 77<br />address+7 88<br /><br />64bit的值，用大端格式存储。</td></tr><tr><td> &#60;string&#62; </td><td>Strings are printable and null-terminated. Example: the string “hello” would be represented in memory as:<br />address 68 'h'<br />address+1 65 'e'<br />address+2 6C 'l'<br />address+3 6C 'l'<br />address+4 6F 'o'<br />address+5 00 '\0'<br /><br />字符串。</td></tr><tr><td> &#60;prop-encoded-array&#62; </td><td>Format is specific to the property. See the property definition.<br /><br />混合编码，自定义property的值。</td></tr><tr><td> &#60;phandle&#62; </td><td>A &#60;u32&#62; value. A phandle value is a way to reference another node in the devicetree.<br />Any node that can be referenced defines a phandle property with a unique &#60;u32&#62;value. That number is used for the value of properties with a phandle value type.<br /><br />作为一个句柄指向一个Node，用来引用Node。</td></tr><tr><td> &#60;stringlist&#62; </td><td>A list of &#60;string&#62; values concatenated together.<br />Example: The string list “hello”,”world” would be represented in memory as:<br />address 68 'h'<br />address+1 65 'e'<br />address+2 6C 'l'<br />address+3 6C 'l'<br />address+4 6F 'o'<br />address+5 00 '\0'<br />address+6 77 'w'<br />address+7 6f 'o'<br />address+8 72 'r'<br />address+9 6C 'l'<br />address+10 64 'd'<br />address+11 00 '\0'<br /><br />字符串数组。</td></tr></table><h3 id="1-1-1、compatible"><a href="#1-1-1、compatible" class="headerlink" title="1.1.1、compatible"></a>1.1.1、compatible</h3><ul><li>“compatible”属性通常用来device和driver的适配，推荐的格式为”manufacturer,model”。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">compatible</td></tr><tr><td> Value type: </td><td> &#60;stringlist&#62; </td></tr><tr><td> Description: </td><td>The compatible property value consists of one or more strings that define the specific programming model for the device. This list of strings should be used by a client program for device driver selection. The property value consists of a concatenated list of null terminated strings, from most specific to most general. They allow a device to express its compatibility with a family of similar devices, potentially allowing a single device driver to match against several devices.<br />The recommended format is "manufacturer,model", where manufacturer is a string describing the name of the manufacturer (such as a stock ticker symbol), and model specifies the model number.<br /><br /></td></tr><tr><td> Example: </td><td>compatible = "fsl,mpc8641", "ns16550"; <br /><br />In this example, an operating system would first try to locate a device driver that supported fsl,mpc8641. If a driver was not found, it would then try to locate a driver that supported the more general ns16550 device type.<br /><br />在这个例子中，device首先尝试去适配"fsl,mpc8641"driver，如果失败再去尝试适配"ns16550"driver。</td></tr></table><h3 id="1-1-2、model"><a href="#1-1-2、model" class="headerlink" title="1.1.2、model"></a>1.1.2、model</h3><ul><li>“model”属性只是简单的表示型号，root节点用其来传递值给machine_desc_str。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">model</td></tr><tr><td> Value type: </td><td> &#60;stringlist&#62; </td></tr><tr><td> Description: </td><td>The model property value is a &#60;string&#62; that specifies the manufacturer’s model number of the device.<br />The recommended format is: "manufacturer,model", where manufacturer is a string describing the name of the manufacturer (such as a stock ticker symbol), and model specifies the model number.</td></tr><tr><td> Example: </td><td>model = "fsl,MPC8349EMITX";</td></tr></table><h3 id="1-1-3、phandle"><a href="#1-1-3、phandle" class="headerlink" title="1.1.3、phandle"></a>1.1.3、phandle</h3><ul><li>“phandle”属性通用一个唯一的id来标识一个Node，在property可以使用这个id来引用Node。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">phandle</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The phandle property specifies a numerical identifier for a node that is unique within the devicetree. The phandle property value is used by other nodes that need to refer to the node associated with the property.</td></tr><tr><td> Example: </td><td>See the following devicetree excerpt:<br />pic@10000000 {<br />phandle = <1>;<br />interrupt-controller;<br />};<br /><br />A phandle value of 1 is defined. Another device node could reference the pic node with a phandle value of 1:<br />another-device-node {<br />interrupt-parent = <1>;<br />};<br /><br />Node“pic@10000000”定义了一个phandle属性，这个phandle有唯一id = <1>，在property“interrupt-parent”通过<1>对Node“pic@10000000”进行引用。</td></tr></table><p>在DeviceTree中通过另一种方式进行phandle的定义和引用更加常见：</p><ul><li>定义一个“label：”来引用Node，在编译是系统会自动为node生成一个phandle属性。”cpu0”是一个label，用来引用node”cpu@0”：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpu0: cpu@0 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a35&quot;;</span><br><span class="line">reg &#x3D; &lt;0x000&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1248000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用”&amp;”来引用“label”，即是引用phandle。property”cpu”通过”&amp;cpu0”来对node”cpu@0”：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cpu-map &#123;</span><br><span class="line">cluster0 &#123;</span><br><span class="line">core0 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">core1 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core2 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core3 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu3&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-1-4、-address-cells-、-size-cells"><a href="#1-1-4、-address-cells-、-size-cells" class="headerlink" title="1.1.4、#address-cells 、 #size-cells"></a>1.1.4、#address-cells 、 #size-cells</h3><ul><li>“#address-cells, #size-cells”属性用来定义当前node的子node中”reg”属性的解析格式。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">#address-cells, #size-cells</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The #address-cells and #size-cells properties may be used in any device node that has children in the devicetree hierarchy and describes how child device nodes should be addressed. The #address-cells property defines the number of &#60;u32&#62; cells used to encode the address field in a child node’s reg property. The #size-cells property defines the number of &#60;u32&#62; cells used to encode the size field in a child node’s reg property.<br />The #address-cells and #size-cells properties are not inherited from ancestors in the devicetree. They shall be explicitly defined.<br />A DTSpec-compliant boot program shall supply #address-cells and #size-cells on all nodes that have children.<br />If missing, a client program should assume a default value of 2 for #address-cells, and a value of 1 for #size-cells.<br /></td></tr><tr><td> Example: </td><td>See the following devicetree excerpt:<br />soc {<br />#address-cells = <1>;<br />#size-cells = <1>;<br />&nbsp;&nbsp;&nbsp;&nbsp;serial {<br />&nbsp;&nbsp;&nbsp;&nbsp;compatible = "ns16550";<br />&nbsp;&nbsp;&nbsp;&nbsp;reg = <0x4600 0x100>;<br />&nbsp;&nbsp;&nbsp;&nbsp;clock-frequency = <0>;<br />&nbsp;&nbsp;&nbsp;&nbsp;interrupts = <0xA 0x8>;<br />&nbsp;&nbsp;&nbsp;&nbsp;interrupt-parent = <&ipic>;<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br />};<br /><br />In this example, the #address-cells and #size-cells properties of the soc node are both set to 1. This setting specifies that one cell is required to represent an address and one cell is required to represent the size of nodesthat are children of this node.<br />The serial device reg property necessarily follows this specification set in the parent (soc) node—the address is represented by a single cell (0x4600), and the size is represented by a single cell (0x100).<br /></td></tr></table><p>举例说明：</p><ul><li>1、如果node”soc”中”#address-cells=<1>“、”#size-cells=<1>“，那么子node”serial”中”reg”属性的解析为“addr1 = 0x0, size1 = 0x100, addr2 = 0x0, size2 = 0x200”：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">    serial &#123;</span><br><span class="line">        reg &#x3D; &lt;0x0 0x100 0x0 0x200&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、如果node”soc”中”#address-cells=<2>“、”#size-cells=<2>“，那么子node”serial”中”reg”属性的解析为“addr1 = 0x100, size1 = 0x200”：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells &#x3D; &lt;2&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;2&gt;;</span><br><span class="line">    serial &#123;</span><br><span class="line">        reg &#x3D; &lt;0x0 0x100 0x0 0x200&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、如果node”soc”中”#address-cells=<2>“、”#size-cells=<0>“，那么子node”serial”中”reg”属性的解析为“addr1 = 0x100, addr2 = 0x200”：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells &#x3D; &lt;2&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">    serial &#123;</span><br><span class="line">        reg &#x3D; &lt;0x0 0x100 0x0 0x200&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-5、reg"><a href="#1-1-5、reg" class="headerlink" title="1.1.5、reg"></a>1.1.5、reg</h3><ul><li>“reg”属性解析出”address,length”数字，解析格式依据父节点的”#address-cells、#size-cells”定义。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">reg</td></tr><tr><td> Value type: </td><td> &#60;prop-encoded-array&#62; encoded as an arbitrary number of (address, length) pairs. </td></tr><tr><td> Description: </td><td>The reg property describes the address of the device’s resources within the address space defined by its parent bus. Most commonly this means the offsets and lengths of memory-mapped IO register blocks, but may have a different meaning on some bus types. Addresses in the address space defined by the root node are CPU real addresses.<br />The value is a &#60;prop-encoded-array&#62;, composed of an arbitrary number of pairs of address and length, (address length). The number of &#60;u32&#62; cells required to specify the address and length are bus-specific and are specified by the #address-cells and #size-cells properties in the parent of the device node. If the parent node specifies a value of 0 for #size-cells, the length field in the value of reg shall be omitted.<br /></td></tr><tr><td> Example: </td><td>Suppose a device within a system-on-a-chip had two blocks of registers, a 32-byte block at offset 0x3000 in the SOC and a 256-byte block at offset 0xFE00. The reg property would be encoded as follows (assuming #address-cells and #size-cells values of 1):<br /><br />reg = <0x3000 0x20 0xFE00 0x100>;</td></tr></table><h3 id="1-1-6、ranges"><a href="#1-1-6、ranges" class="headerlink" title="1.1.6、ranges"></a>1.1.6、ranges</h3><ul><li>“ranges”属性用来做当前node和父node之间的地址映射，格式为(child-bus-address, parentbus-address, length)。其中child-bus-address的解析长度受当前node的#address-cells属性控制，parentbus-address的解析长度受父node的#address-cells属性控制length的解析长度受当前node的#size-cells属性控制。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">ranges</td></tr><tr><td> Value type: </td><td> &#60;empty&#62; or &#60;prop-encoded-array&#62; encoded as an arbitrary number of (child-bus-address, parentbus-address, length) triplets. </td></tr><tr><td> Description: </td><td>The ranges property provides a means of defining a mapping or translation between the address space of the bus (the child address space) and the address space of the bus node’s parent (the parent address space).<br />The format of the value of the ranges property is an arbitrary number of triplets of (child-bus-address, parentbus-address, length)<br />• The child-bus-address is a physical address within the child bus’ address space. The number of cells to represent the address is bus dependent and can be determined from the #address-cells of this node (the node in which the ranges property appears).<br />• The parent-bus-address is a physical address within the parent bus’ address space. The number of cells to represent the parent address is bus dependent and can be determined from the #address-cells property of the node that defines the parent’s address space.<br />• The length specifies the size of the range in the child’s address space. The number of cells to represent the size can be determined from the #size-cells of this node (the node in which the ranges property appears).<br />If the property is defined with an &#60;empty&#62; value, it specifies that the parent and child address space is identical, and no address translation is required.<br />If the property is not present in a bus node, it is assumed that no mapping exists between children of the node and the parent address space.</td></tr><tr><td> Example: </td><td>Address Translation Example:<br />soc {<br />compatible = "simple-bus";<br />#address-cells = <1>;<br />#size-cells = <1>;<br />ranges = <0x0 0xe0000000 0x00100000>;<br />serial {<br />device_type = "serial";<br />compatible = "ns16550";<br />reg = <0x4600 0x100>;<br />clock-frequency = <0>;<br />interrupts = <0xA 0x8>;<br />interrupt-parent = <&ipic>;<br />};<br />};<br /><br />The soc node specifies a ranges property of<br /><0x0 0xe0000000 0x00100000>;<br /><br />This property value specifies that for an 1024KB range of address space, a child node addressed at physical 0x0 maps to a parent address of physical 0xe0000000. With this mapping, the serial device node can be addressed by a load or store at address 0xe0004600, an offset of 0x4600 (specified in reg) plus the 0xe0000000mapping specified in ranges.</td><br /></tr></table><h3 id="1-1-7、interrupt-property"><a href="#1-1-7、interrupt-property" class="headerlink" title="1.1.7、interrupt property"></a>1.1.7、interrupt property</h3><p>和中断相关的node可以分成3种：</p><ul><li>“Interrupt Generating Devices”，中断发生设备，这种设备可以发生中断。</li><li>“Interrupt Controllers”，中断控制器，处理中断。</li><li>“Interrupt Nexus”，中断联结，路由中断给中断控制器。</li></ul><p><img src="/images/posts/2018/03/interrupt_tree.png" alt="image"></p><h4 id="1-1-7-1、Interrupt-Generating-Devices-Property"><a href="#1-1-7-1、Interrupt-Generating-Devices-Property" class="headerlink" title="1.1.7.1、Interrupt Generating Devices Property"></a>1.1.7.1、Interrupt Generating Devices Property</h4><ul><li>“interrupts”属性用来定义设备的中断解析，根据其”interrupt-parent”node中定义的“#interrupt-cells”来解析。比如#interrupt-cells=2，那根据2个cells为单位来解析”interrupts”属性。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupts</td></tr><tr><td> Value type: </td><td> &#60;prop-encoded-array&#62; encoded as arbitrary number of interrupt specifiers </td></tr><tr><td> Description: </td><td>The interrupts property of a device node defines the interrupt or interrupts that are generated by the device.<br />The value of the interrupts property consists of an arbitrary number of interrupt specifiers. The format of an interrupt specifier is defined by the binding of the interrupt domain root.<br />interrupts is overridden by the interrupts-extended property and normally only one or the other should be used.<br /></td></tr><tr><td> Example: </td><td>A common definition of an interrupt specifier in an open PIC–compatible interrupt domain consists of two cells; an interrupt number and level/sense information. See the following example, which defines a singleinterrupt specifier, with an interrupt number of 0xA and level/sense encoding of 8.<br /><br />interrupts = <0xA 8>;<br /></td><br /></tr></table><ul><li>“interrupt-parent”属性用来制定当前设备的Interrupt Controllers/Interrupt Nexus，phandle指向对应的node。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupt-parent</td></tr><tr><td> Value type: </td><td> &#60;phandle&#62; </td></tr><tr><td> Description: </td><td>Because the hierarchy of the nodes in the interrupt tree might not match the devicetree, the interrupt-parent property is available to make the definition of an interrupt parent explicit. The value is the phandle to the interrupt parent. If this property is missing from a device, its interrupt parent is assumed to be its devicetree parent.<br /></td></tr></table><h4 id="1-1-7-2、Interrupt-Controllers-Property"><a href="#1-1-7-2、Interrupt-Controllers-Property" class="headerlink" title="1.1.7.2、Interrupt Controllers Property"></a>1.1.7.2、Interrupt Controllers Property</h4><ul><li>“#interrupt-cells”属性用来规定连接到该中断控制器上的设备的”interrupts”属性的解析长度。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">#interrupt-cells</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The #interrupt-cells property defines the number of cells required to encode an interrupt specifier for an interrupt domain.<br /></td></tr></table><ul><li>“interrupt-controller”属性用来声明当前node为中断控制器。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupt-controller</td></tr><tr><td> Value type: </td><td> &#60;empty&#62; </td></tr><tr><td> Description: </td><td>The presence of an interrupt-controller property defines a node as an interrupt controller node.<br /></td></tr></table><h4 id="1-1-7-3、Interrupt-Nexus-Property"><a href="#1-1-7-3、Interrupt-Nexus-Property" class="headerlink" title="1.1.7.3、Interrupt Nexus Property"></a>1.1.7.3、Interrupt Nexus Property</h4><ul><li>“#interrupt-cells”属性用来规定连接到该中断控制器上的设备的”interrupts”属性的解析长度。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">#interrupt-cells</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The #interrupt-cells property defines the number of cells required to encode an interrupt specifier for an interrupt domain.<br /></td></tr></table><ul><li>“interrupt-map”属性用来描述interrupt nexus设备对中断的路由。解析格式为5元素序列“child unit address, child interrupt specifier, interrupt-parent, parent unit address, parent interrupt specifier”。</li></ul><p>其中：</p><p>“child unit address”的cells长度由子节点的“#address-cells”指定；<br>“child interrupt specifier”的cells长度由子节点的“#interrupt-cells”指定；<br>“interrupt-parent”phandle指向interrupt controller的引用；<br>“parent unit address”的cells长度由父节点的“#address-cells”指定；<br>“parent interrupt specifier”的cells长度由父节点的“#interrupt-cells”指定；</p><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupt-map</td></tr><tr><td> Value type: </td><td> &#60;prop-encoded-array&#62; encoded as an arbitrary number of interrupt mapping entries. </td></tr><tr><td> Description: </td><td>An interrupt-map is a property on a nexus node that bridges one interrupt domain with a set of parent interrupt domains and specifies how interrupt specifiers in the child domain are mapped to their respective parentdomains.<br />The interrupt map is a table where each row is a mapping entry consisting of five components: <i>child unit address, child interrupt specifier, interrupt-parent, parent unit address, parent interrupt specifier.</i><br /><b>child unit address</b> The unit address of the child node being mapped. The number of 32-bit cells required to specify this is described by the #address-cells property of the bus node on which the child is located.<br /><b>child interrupt specifier</b> The interrupt specifier of the child node being mapped. The number of 32-bit cells required to specify this component is described by the #interrupt-cells property of this node—the nexus node containing the interrupt-map property.<br /><b>interrupt-parent</b> A single &#60;phandle&#62; value that points to the interrupt parent to which the child domain is being mapped.<br /><b>parent unit address</b> The unit address in the domain of the interrupt parent. The number of 32-bit cells required to specify this address is described by the #address-cells property of the node pointed to by the interrupt-parent field.<br /><b>parent interrupt specifier</b> The interrupt specifier in the parent domain. The number of 32-bit cells required to specify this component is described by the #interrupt-cells property of the node pointed to by the interrupt-parent field.<br />Lookups are performed on the interrupt mapping table by matching a unit-address/interrupt specifier pair against the child components in the interrupt-map. Because some fields in the unit interrupt specifier may not be relevant, a mask is applied before the lookup is done. This mask is defined in the interrupt-map-mask property (see section 2.4.3.2).<br /></td></tr></table><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    compatible &#x3D; &quot;simple-bus&quot;;</span><br><span class="line">    #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">    open-pic &#123;</span><br><span class="line">        clock-frequency &#x3D; &lt;0&gt;;</span><br><span class="line">        interrupt-controller;</span><br><span class="line">        #address-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        #interrupt-cells &#x3D; &lt;2&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    pci &#123;</span><br><span class="line">        #interrupt-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        #size-cells &#x3D; &lt;2&gt;;</span><br><span class="line">        #address-cells &#x3D; &lt;3&gt;;</span><br><span class="line">        interrupt-map-mask &#x3D; &lt;0xf800 0 0 7&gt;;</span><br><span class="line">        interrupt-map &#x3D; &lt;</span><br><span class="line">        &#x2F;* IDSEL 0x11 - PCI slot 1 *&#x2F;</span><br><span class="line">        0x8800 0 0 1 &amp;open-pic 2 1 &#x2F;* INTA *&#x2F;</span><br><span class="line">        0x8800 0 0 2 &amp;open-pic 3 1 &#x2F;* INTB *&#x2F;</span><br><span class="line">        0x8800 0 0 3 &amp;open-pic 4 1 &#x2F;* INTC *&#x2F;</span><br><span class="line">        0x8800 0 0 4 &amp;open-pic 1 1 &#x2F;* INTD *&#x2F;</span><br><span class="line">        &#x2F;* IDSEL 0x12 - PCI slot 2 *&#x2F;</span><br><span class="line">        0x9000 0 0 1 &amp;open-pic 3 1 &#x2F;* INTA *&#x2F;</span><br><span class="line">        0x9000 0 0 2 &amp;open-pic 4 1 &#x2F;* INTB *&#x2F;</span><br><span class="line">        0x9000 0 0 3 &amp;open-pic 1 1 &#x2F;* INTC *&#x2F;</span><br><span class="line">        0x9000 0 0 4 &amp;open-pic 2 1 &#x2F;* INTD *&#x2F;</span><br><span class="line">        &gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• For example, the first row of the interrupt-map table specifies the mapping for INTA of slot 1. The components of that row are shown here</span><br><span class="line">    child unit address: 0x8800 0 0</span><br><span class="line">    child interrupt specifier: 1</span><br><span class="line">    interrupt parent: &amp;open-pic</span><br><span class="line">    parent unit address: (empty because #address-cells &#x3D; &lt;0&gt; in the open-pic node)</span><br><span class="line">    parent interrupt specifier: 2 1</span><br></pre></td></tr></table></figure><h2 id="1-2、标准Node"><a href="#1-2、标准Node" class="headerlink" title="1.2、标准Node"></a>1.2、标准Node</h2><p>Node Name常常由两部分组成“node-name@unit-address”，主要是为了防止Node Name重复冲突：</p><ul><li>“node-name”是node的名字；</li><li>“unit-address”是node中“reg”属性描述的开始地址；</li></ul><p>例如：”msdc@11240000”中node-name=“msdc”，unit-address=“11240000”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; &#123;</span><br><span class="line">model &#x3D; &quot;mt6799&quot;;</span><br><span class="line">compatible &#x3D; &quot;mediatek,mt6799&quot;;</span><br><span class="line">interrupt-parent &#x3D; &lt;&amp;gic&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;2&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;2&gt;;</span><br><span class="line"></span><br><span class="line">msdc0:msdc@11240000 &#123;</span><br><span class="line">compatible &#x3D; &quot;mediatek,msdc&quot;;</span><br><span class="line">reg &#x3D; &lt;0x0 0x11240000 0x0 0x10000</span><br><span class="line">       0x0 0x10000e84 0x0 0x2&gt;;    &#x2F;* FPGA PWR_GPIO, PWR_GPIO_EO *&#x2F;</span><br><span class="line">interrupts &#x3D; &lt;GIC_SPI 79 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面主要介绍一下一些预先定义的标准Node。</p><h3 id="1-2-1、Root-node"><a href="#1-2-1、Root-node" class="headerlink" title="1.2.1、Root node"></a>1.2.1、Root node</h3><p>每个DeviceTree只有一个根节点。根节点需要有以下必备属性：</p><table border="1"><caption>  Root Node Properties </caption><tr><th style="width: 150px;">Property Name</th><th style="width: 100px;">Usage</th><th style="width: 150px;">Value Type</th><th style="width: 600px;">Definition</th></tr><tr><td> #address-cells </td><td> R </td><td> &#60;u32&#62; </td><td> Specifies the number of &#60;u32&#62; cells to represent the address in the reg  property in children of root. </td></tr><tr><td> #size-cells </td><td> R </td><td> &#60;u32&#62; </td><td> Specifies the number of &#60;u32&#62; cells to represent the size in the reg property in children of root. </td></tr><tr><td> model </td><td> R </td><td> &#60;string&#62; </td><td> Specifies a string that uniquely identifies the model of the system board. The recommended format is “manufacturer,model-number”.</td></tr><tr><td> compatible </td><td> R </td><td> &#60;stringlist&#62; </td><td> Specifies a list of platform architectures with which this platform is compatible. This property can be used by operating systems in selectingplatform specific code. The recommended form of the property value is:<br />"manufacturer,model"<br /><br />For example:<br />compatible = "fsl,mpc8572ds"<br /></td></tr></table><h3 id="1-2-2、-aliases-node"><a href="#1-2-2、-aliases-node" class="headerlink" title="1.2.2、/aliases node"></a>1.2.2、/aliases node</h3><p>用来给一些绝对路径定义别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    serial0 &#x3D; &quot;&#x2F;simple-bus@fe000000&#x2F;serial@llc500&quot;;</span><br><span class="line">    ethernet0 &#x3D; &quot;&#x2F;simple-bus@fe000000&#x2F;ethernet@31c000&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-3、-memory-node"><a href="#1-2-3、-memory-node" class="headerlink" title="1.2.3、/memory node"></a>1.2.3、/memory node</h3><p>用来传递内存布局：</p><table border="1"><caption>  /memory Node Properties </caption><tr><th style="width: 150px;">Property Name</th><th style="width: 100px;">Usage</th><th style="width: 150px;">Value Type</th><th style="width: 600px;">Definition</th></tr><tr><td> device_type </td><td> R </td><td> &#60;string&#62; </td><td> Value shall be “memory”</td></tr><tr><td> reg </td><td> R </td><td> &#60;prop-encoded-array&#62; </td><td> Consists of an arbitrary number of address and size pairs that specify the physical address and size of the memory ranges.</td></tr><tr><td> initial-mapped-area </td><td> O </td><td> &#60;prop-encoded-array&#62; </td><td> Specifies the address and size of the Initial Mapped AreaIs a prop-encoded-array consisting of a triplet of (effective address, physical address, size).The effective and physical address shall each be 64-bit (&#60;u64&#62; value), and the size shall be 32-bits (&#60;u32&#62; value).</td></tr></table><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• RAM: starting address 0x0, length 0x80000000 (2GB)</span><br><span class="line">• RAM: starting address 0x100000000, length 0x100000000 (4GB)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\ &#123;</span><br><span class="line">    #address-cells &#x3D; &lt;2&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;2&gt;;</span><br><span class="line"></span><br><span class="line">    memory@0 &#123;</span><br><span class="line">        device_type &#x3D; &quot;memory&quot;;</span><br><span class="line">        reg &#x3D; &lt;0x000000000 0x00000000 0x00000000 0x80000000</span><br><span class="line">        0x000000001 0x00000000 0x00000001 0x00000000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4、-chosen-node"><a href="#1-2-4、-chosen-node" class="headerlink" title="1.2.4、/chosen node"></a>1.2.4、/chosen node</h3><p>其中“bootargs”属性用来传递cmdline参数，“stdout-path”属性用来指定标准输出设备，“stdin-path”属性用来指定标准输入设备。</p><table border="1"><caption>  /chosen Node Properties </caption><tr><th style="width: 150px;">Property Name</th><th style="width: 100px;">Usage</th><th style="width: 150px;">Value Type</th><th style="width: 600px;">Definition</th></tr><tr><td> bootargs </td><td> O </td><td> &#60;string&#62; </td><td> A string that specifies the boot arguments for the client program. The value could potentially be a null string if no boot arguments are required.</td></tr><tr><td> stdout-path </td><td> O </td><td> &#60;string&#62; </td><td> A string that specifies the full path to the node representing the device to be used for boot console output. If the character “:” is present in the value it terminates the path. The value may be an alias. If the stdin-path property isnot specified, stdout-path should be assumed to define the input device.</td></tr><tr><td> stdin-path </td><td> O </td><td> &#60;string&#62; </td><td> A string that specifies the full path to the node representing the device to be used for boot console input. If the character “:” is present in the value it terminates the path. The value may be an alias.</td></tr></table><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* chosen *&#x2F;</span><br><span class="line">chosen &#123;</span><br><span class="line">bootargs &#x3D; &quot;console&#x3D;tty0 console&#x3D;ttyMT0,921600n1 root&#x3D;&#x2F;dev&#x2F;ram&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-5、-cpus-node"><a href="#1-2-5、-cpus-node" class="headerlink" title="1.2.5、/cpus node"></a>1.2.5、/cpus node</h3><p>/cpus节点也是必须的，下面举个具体例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">cpu0: cpu@0 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a35&quot;;</span><br><span class="line">reg &#x3D; &lt;0x000&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1248000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu1: cpu@001 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a35&quot;;</span><br><span class="line">reg &#x3D; &lt;0x001&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1248000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu2: cpu@002 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a35&quot;;</span><br><span class="line">reg &#x3D; &lt;0x002&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1248000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu3: cpu@003 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a35&quot;;</span><br><span class="line">reg &#x3D; &lt;0x003&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1248000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu4: cpu@100 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a53&quot;;</span><br><span class="line">reg &#x3D; &lt;0x100&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1378000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu5: cpu@101 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a53&quot;;</span><br><span class="line">reg &#x3D; &lt;0x101&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1378000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu6: cpu@102 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a53&quot;;</span><br><span class="line">reg &#x3D; &lt;0x102&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1378000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu7: cpu@103 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a53&quot;;</span><br><span class="line">reg &#x3D; &lt;0x103&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1378000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu8: cpu@200 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a73&quot;;</span><br><span class="line">reg &#x3D; &lt;0x200&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1638000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu9: cpu@201 &#123;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">compatible &#x3D; &quot;arm,cortex-a73&quot;;</span><br><span class="line">reg &#x3D; &lt;0x201&gt;;</span><br><span class="line">enable-method &#x3D; &quot;psci&quot;;</span><br><span class="line">cpu-idle-states &#x3D; &lt;&amp;LEGACY_MCDI &amp;LEGACY_SODI &amp;LEGACY_SODI3 &amp;LEGACY_DPIDLE&gt;,</span><br><span class="line">  &lt;&amp;LEGACY_SUSPEND &amp;MCDI &amp;SODI &amp;SODI3 &amp;DPIDLE &amp;SUSPEND&gt;;</span><br><span class="line">cpu-release-addr &#x3D; &lt;0x0 0x40000200&gt;;</span><br><span class="line">clock-frequency &#x3D; &lt;1638000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu-map &#123;</span><br><span class="line">cluster0 &#123;</span><br><span class="line">core0 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">core1 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core2 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core3 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu3&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cluster1 &#123;</span><br><span class="line">core0 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu4&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core1 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu5&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core2 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu6&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core3 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu7&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cluster2 &#123;</span><br><span class="line">core0 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu8&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">core1 &#123;</span><br><span class="line">cpu &#x3D; &lt;&amp;cpu9&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">idle-states &#123;</span><br><span class="line">entry-method &#x3D; &quot;arm,psci&quot;;</span><br><span class="line"></span><br><span class="line">LEGACY_MCDI: legacy-mcdi &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x0000001&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;1200&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LEGACY_SODI: legacy-sodi &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x0000002&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;1200&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LEGACY_SODI3: legacy-sodi3 &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x0000003&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;1200&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LEGACY_DPIDLE: legacy-dpidle &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x0000004&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;1200&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LEGACY_SUSPEND: legacy-suspend &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x0000005&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;1200&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MCDI: mcdi &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x0010001&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;600&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;1200&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SODI: sodi &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x1010002&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;800&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;1000&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;2000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SODI3: sodi3 &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x1010003&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;800&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;1000&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;2000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DPIDLE: dpidle &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x1010004&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;800&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;1000&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;2000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SUSPEND: suspend &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,idle-state&quot;;</span><br><span class="line">arm,psci-suspend-param &#x3D; &lt;0x1010005&gt;;</span><br><span class="line">entry-latency-us &#x3D; &lt;800&gt;;</span><br><span class="line">exit-latency-us &#x3D; &lt;1000&gt;;</span><br><span class="line">min-residency-us &#x3D; &lt;2000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2、DTB"><a href="#2、DTB" class="headerlink" title="2、DTB"></a>2、DTB</h1><h2 id="2-1、DTB的编译"><a href="#2-1、DTB的编译" class="headerlink" title="2.1、DTB的编译"></a>2.1、DTB的编译</h2><p>DTB(Devicetree Blob)是DTS的二进制文件格式，Kernel使用DTC工具将DTS源文件编译成DTB，bootloader再将DTB文件传递给Kernel解析。</p><p>不遵守标准书写的DTS文件在编译的时候会报错。</p><h2 id="2-2、DTB的文件结构"><a href="#2-2、DTB的文件结构" class="headerlink" title="2.2、DTB的文件结构"></a>2.2、DTB的文件结构</h2><p><img src="/images/posts/2018/03/dtb_struct.png" alt="image"></p><p>DTB文件的结构如上图所示，主要在3部分：</p><ul><li>struct ftd_header。文件头结构；</li><li>structure block。存放含Node和Property的Value；</li><li>strings block。存放Property的Name；把Property Name单独分为一个区域的原因是，有很多Property Name是重复的，单独一个区域可以使用指针引用，节约空间。</li></ul><p>dtb中的fdt_header的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct fdt_header &#123;</span><br><span class="line">    uint32_t magic;</span><br><span class="line">    uint32_t totalsize;</span><br><span class="line">    uint32_t off_dt_struct;</span><br><span class="line">    uint32_t off_dt_strings;</span><br><span class="line">    uint32_t off_mem_rsvmap;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    uint32_t last_comp_version;</span><br><span class="line">    uint32_t boot_cpuid_phys;</span><br><span class="line">    uint32_t size_dt_strings;</span><br><span class="line">    uint32_t size_dt_struct;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dtb中node header的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct fdt_node_header &#123;</span><br><span class="line">fdt32_t tag;</span><br><span class="line">char name[0];   &#x2F;&#x2F; node name 存放在structure block</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dtb中property header的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct fdt_property &#123;</span><br><span class="line">fdt32_t tag;</span><br><span class="line">fdt32_t len;</span><br><span class="line">fdt32_t nameoff;    &#x2F;&#x2F; perperty name存放在strings block</span><br><span class="line">char data[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个文件使用5种token来分割出node和property：</p><ul><li>FDT_BEGIN_NODE (0x00000001)</li><li>FDT_END_NODE (0x00000002)</li><li>FDT_PROP (0x00000003)</li><li>FDT_NOP (0x00000004)</li><li>FDT_END (0x00000009)</li></ul><p>可以使用hex编辑器来查看DTB文件的结构：</p><p><img src="/images/posts/2018/03/dtb_hex_example.png" alt="image"></p><h2 id="2-3、Bootloader对DTB的传递"><a href="#2-3、Bootloader对DTB的传递" class="headerlink" title="2.3、Bootloader对DTB的传递"></a>2.3、Bootloader对DTB的传递</h2><p>没有仔细去看</p><h1 id="3、Kernel解析"><a href="#3、Kernel解析" class="headerlink" title="3、Kernel解析"></a>3、Kernel解析</h1><h2 id="3-1、DTB解析"><a href="#3-1、DTB解析" class="headerlink" title="3.1、DTB解析"></a>3.1、DTB解析</h2><h3 id="3-1-1-setup-machine-fdt"><a href="#3-1-1-setup-machine-fdt" class="headerlink" title="3.1.1 setup_machine_fdt()"></a>3.1.1 setup_machine_fdt()</h3><p>直接在dtb中解析根节点的一些属性和子节点给系统早期使用。</p><ul><li>解析”/“节点的model”属性给machine_desc赋值；</li><li>解析”/chosen”node中的”bootargs”属性给boot_command_line；</li><li>解析”/“节点的”#size-cells”、”#address-cells”属性；</li><li>解析”/memory”node中的”reg”属性，并将memory区域加入到系统；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; setup_arch() -&gt; setup_machine_fdt():</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void __init setup_machine_fdt(phys_addr_t dt_phys)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1) 映射dtb内存，到使之可以访问 *&#x2F;</span><br><span class="line">void *dt_virt &#x3D; fixmap_remap_fdt(dt_phys);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 早期扫描device tree中的一些node和property *&#x2F;</span><br><span class="line">if (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">pr_crit(&quot;\n&quot;</span><br><span class="line">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span><br><span class="line">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span><br><span class="line">&quot;\nPlease check your bootloader.&quot;,</span><br><span class="line">&amp;dt_phys, dt_virt);</span><br><span class="line"></span><br><span class="line">while (true)</span><br><span class="line">cpu_relax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (3) 使用device tree中root node的&quot;model&#x2F;compatible&quot;属性给machine_desc赋值 *&#x2F;</span><br><span class="line">machine_desc_set(of_flat_dt_get_machine_name());</span><br><span class="line">dump_stack_set_arch_desc(&quot;%s (DT)&quot;, of_flat_dt_get_machine_name());</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">bool __init early_init_dt_scan(void *params)</span><br><span class="line">&#123;</span><br><span class="line">bool status;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1)校验dtb数据 *&#x2F;</span><br><span class="line">status &#x3D; early_init_dt_verify(params);</span><br><span class="line">if (!status)</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2) *&#x2F;</span><br><span class="line">early_init_dt_scan_nodes();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void __init early_init_dt_scan_nodes(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (2.2.1) 解析&quot;&#x2F;chosen&quot;node中的&quot;bootargs&quot;属性 *&#x2F;</span><br><span class="line">&#x2F;* Retrieve various information from the &#x2F;chosen node *&#x2F;</span><br><span class="line">of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.2) 解析&quot;&#x2F;&quot;node中的&quot;#size-cells&quot;、&quot;#address-cells&quot;属性 *&#x2F;</span><br><span class="line">&#x2F;* Initialize &#123;size,address&#125;-cells info *&#x2F;</span><br><span class="line">of_scan_flat_dt(early_init_dt_scan_root, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.3) 解析&quot;&#x2F;memory&quot;node中的&quot;reg&quot;属性，并将memory区域加入到系统 *&#x2F;</span><br><span class="line">&#x2F;* Setup memory, calling early_init_dt_add_memory_arch *&#x2F;</span><br><span class="line">of_scan_flat_dt(early_init_dt_scan_memory, NULL);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">early_init_dt_scan_memory() -&gt; early_init_dt_add_memory_arch() -&gt; memblock_add()</span><br></pre></td></tr></table></figure><h3 id="3-1-2-unflatten-device-tree"><a href="#3-1-2-unflatten-device-tree" class="headerlink" title="3.1.2 unflatten_device_tree()"></a>3.1.2 unflatten_device_tree()</h3><p>将DTB完全解析为内核使用的的device_node、property结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; setup_arch() -&gt; unflatten_device_tree():</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">void __init unflatten_device_tree(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1) 解析dtb数据到kernel中 *&#x2F;</span><br><span class="line">__unflatten_device_tree(initial_boot_params, &amp;of_root,</span><br><span class="line">early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 扫描&quot;&#x2F;aliases&quot;、&quot;&#x2F;chosen&quot;节点来进行一些预制值的配置 *&#x2F;</span><br><span class="line">&#x2F;* Get pointer to &quot;&#x2F;chosen&quot; and &quot;&#x2F;aliases&quot; nodes for use everywhere *&#x2F;</span><br><span class="line">of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void __unflatten_device_tree(const void *blob,</span><br><span class="line">     struct device_node **mynodes,</span><br><span class="line">     void * (*dt_alloc)(u64 size, u64 align))</span><br><span class="line">&#123;</span><br><span class="line">unsigned long size;</span><br><span class="line">int start;</span><br><span class="line">void *mem;</span><br><span class="line"></span><br><span class="line">pr_debug(&quot; -&gt; unflatten_device_tree()\n&quot;);</span><br><span class="line"></span><br><span class="line">if (!blob) &#123;</span><br><span class="line">pr_debug(&quot;No device tree pointer\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(&quot;Unflattening device tree:\n&quot;);</span><br><span class="line">pr_debug(&quot;magic: %08x\n&quot;, fdt_magic(blob));</span><br><span class="line">pr_debug(&quot;size: %08x\n&quot;, fdt_totalsize(blob));</span><br><span class="line">pr_debug(&quot;version: %08x\n&quot;, fdt_version(blob));</span><br><span class="line"></span><br><span class="line">if (fdt_check_header(blob)) &#123;</span><br><span class="line">pr_err(&quot;Invalid device tree blob header\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1) 第一遍扫描，计算dtb解析需要的内存空间 *&#x2F;</span><br><span class="line">&#x2F;* First pass, scan for size *&#x2F;</span><br><span class="line">start &#x3D; 0;</span><br><span class="line">size &#x3D; (unsigned long)unflatten_dt_node(blob, NULL, &amp;start, NULL, NULL, 0, true);</span><br><span class="line">size &#x3D; ALIGN(size, 4);</span><br><span class="line"></span><br><span class="line">pr_debug(&quot;  size is %lx, allocating...\n&quot;, size);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 分配所需内存 *&#x2F;</span><br><span class="line">&#x2F;* Allocate memory for the expanded device tree *&#x2F;</span><br><span class="line">mem &#x3D; dt_alloc(size + 4, __alignof__(struct device_node));</span><br><span class="line">memset(mem, 0, size);</span><br><span class="line"></span><br><span class="line">*(__be32 *)(mem + size) &#x3D; cpu_to_be32(0xdeadbeef);</span><br><span class="line"></span><br><span class="line">pr_debug(&quot;  unflattening %p...\n&quot;, mem);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.3)第二遍扫描，在分配的内存中创建device_node、property树形结构来存储dtb的解析 *&#x2F;</span><br><span class="line">&#x2F;* Second pass, do actual unflattening *&#x2F;</span><br><span class="line">start &#x3D; 0;</span><br><span class="line">unflatten_dt_node(blob, mem, &amp;start, NULL, mynodes, 0, false);</span><br><span class="line">if (be32_to_cpup(mem + size) !&#x3D; 0xdeadbeef)</span><br><span class="line">pr_warning(&quot;End of tree marker overwritten: %08x\n&quot;,</span><br><span class="line">   be32_to_cpup(mem + size));</span><br><span class="line"></span><br><span class="line">pr_debug(&quot; &lt;- unflatten_device_tree()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void * unflatten_dt_node(const void *blob,</span><br><span class="line">void *mem,</span><br><span class="line">int *poffset,</span><br><span class="line">struct device_node *dad,</span><br><span class="line">struct device_node **nodepp,</span><br><span class="line">unsigned long fpsize,</span><br><span class="line">bool dryrun)</span><br><span class="line">&#123;</span><br><span class="line">const __be32 *p;</span><br><span class="line">struct device_node *np;</span><br><span class="line">struct property *pp, **prev_pp &#x3D; NULL;</span><br><span class="line">const char *pathp;</span><br><span class="line">unsigned int l, allocl;</span><br><span class="line">static int depth;</span><br><span class="line">int old_depth;</span><br><span class="line">int offset;</span><br><span class="line">int has_name &#x3D; 0;</span><br><span class="line">int new_format &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.1) 解析node，解析node中的name值 *&#x2F;</span><br><span class="line">pathp &#x3D; fdt_get_name(blob, *poffset, &amp;l);</span><br><span class="line">if (!pathp)</span><br><span class="line">return mem;</span><br><span class="line"></span><br><span class="line">allocl &#x3D; ++l;&#x2F;* l 为当前路径的长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* version 0x10 has a more compact unit name here instead of the full</span><br><span class="line"> * path. we accumulate the full path size using &quot;fpsize&quot;, we&#39;ll rebuild</span><br><span class="line"> * it later. We detect this because the first character of the name is</span><br><span class="line"> * not &#39;&#x2F;&#39;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if ((*pathp) !&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">new_format &#x3D; 1;</span><br><span class="line">if (fpsize &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;* root node: special case. fpsize accounts for path</span><br><span class="line"> * plus terminating zero. root node only has &#39;&#x2F;&#39;, so</span><br><span class="line"> * fpsize should be 2, but we want to avoid the first</span><br><span class="line"> * level nodes to have two &#39;&#x2F;&#39; so we use fpsize 1 here</span><br><span class="line"> *&#x2F;</span><br><span class="line">fpsize &#x3D; 1;</span><br><span class="line">allocl &#x3D; 2;</span><br><span class="line">l &#x3D; 1;</span><br><span class="line">pathp &#x3D; &quot;&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;* account for &#39;&#x2F;&#39; and path size minus terminal 0</span><br><span class="line"> * already in &#39;l&#39;</span><br><span class="line"> *&#x2F;</span><br><span class="line">fpsize +&#x3D; l;&#x2F;* 当前full path的长度 &#x3D; 上一次full path的长度 + 当前node nam的长度 l *&#x2F;</span><br><span class="line">allocl &#x3D; fpsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 计算解析当前node节点需要的内存大小 &#x3D; device_node + full path  *&#x2F;</span><br><span class="line">np &#x3D; unflatten_dt_alloc(&amp;mem, sizeof(struct device_node) + allocl,</span><br><span class="line">__alignof__(struct device_node));</span><br><span class="line">    &#x2F;*  dryrun &#x3D; true，只进行长度计算</span><br><span class="line">     dryrun &#x3D; fasle，进行实际的赋值  *&#x2F;</span><br><span class="line">if (!dryrun) &#123;</span><br><span class="line">char *fn;</span><br><span class="line">of_node_init(np);</span><br><span class="line">np-&gt;full_name &#x3D; fn &#x3D; ((char *)np) + sizeof(*np); &#x2F;* device_node-&gt;full_name，指向device_node结构体的结尾 *&#x2F; </span><br><span class="line">if (new_format) &#123;</span><br><span class="line">&#x2F;* rebuild full path for new format *&#x2F;</span><br><span class="line">if (dad &amp;&amp; dad-&gt;parent) &#123;</span><br><span class="line">                 &#x2F;* 先拷入上次的full name *&#x2F;</span><br><span class="line">strcpy(fn, dad-&gt;full_name);</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">if ((strlen(fn) + l + 1) !&#x3D; allocl) &#123;</span><br><span class="line">pr_debug(&quot;%s: p: %d, l: %d, a: %d\n&quot;,</span><br><span class="line">pathp, (int)strlen(fn),</span><br><span class="line">l, allocl);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">fn +&#x3D; strlen(fn);</span><br><span class="line">&#125;</span><br><span class="line">            &#x2F;* 再加上 &#39;&#x2F;&#39; *&#x2F;</span><br><span class="line">*(fn++) &#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">        &#x2F;* 最后加上当前node的name *&#x2F;</span><br><span class="line">memcpy(fn, pathp, l);</span><br><span class="line"></span><br><span class="line">prev_pp &#x3D; &amp;np-&gt;properties;</span><br><span class="line">        &#x2F;* node和node之间树形结构的创建 *&#x2F;</span><br><span class="line">if (dad !&#x3D; NULL) &#123;</span><br><span class="line">np-&gt;parent &#x3D; dad;</span><br><span class="line">np-&gt;sibling &#x3D; dad-&gt;child;</span><br><span class="line">dad-&gt;child &#x3D; np;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.2) 解析node中的property *&#x2F;</span><br><span class="line">&#x2F;* process properties *&#x2F;</span><br><span class="line">for (offset &#x3D; fdt_first_property_offset(blob, *poffset);</span><br><span class="line">     (offset &gt;&#x3D; 0);</span><br><span class="line">     (offset &#x3D; fdt_next_property_offset(blob, offset))) &#123;</span><br><span class="line">const char *pname;</span><br><span class="line">u32 sz;</span><br><span class="line"></span><br><span class="line">        &#x2F;* 解析一个property：</span><br><span class="line">          p：property中的data</span><br><span class="line">          pname：property的name指针，实际存储位置在dt_strings区域中</span><br><span class="line">         sz：property data的长度</span><br><span class="line">        *&#x2F;</span><br><span class="line">if (!(p &#x3D; fdt_getprop_by_offset(blob, offset, &amp;pname, &amp;sz))) &#123;</span><br><span class="line">offset &#x3D; -FDT_ERR_INTERNAL;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (pname &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">pr_info(&quot;Can&#39;t find property name in list !\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (strcmp(pname, &quot;name&quot;) &#x3D;&#x3D; 0)</span><br><span class="line">has_name &#x3D; 1;</span><br><span class="line">        &#x2F;* 计算解析当前property的内存大小 &#x3D; property *&#x2F;</span><br><span class="line">pp &#x3D; unflatten_dt_alloc(&amp;mem, sizeof(struct property),</span><br><span class="line">__alignof__(struct property));</span><br><span class="line">        &#x2F;* 实际的property赋值 *&#x2F;</span><br><span class="line">if (!dryrun) &#123;</span><br><span class="line">&#x2F;* We accept flattened tree phandles either in</span><br><span class="line"> * ePAPR-style &quot;phandle&quot; properties, or the</span><br><span class="line"> * legacy &quot;linux,phandle&quot; properties.  If both</span><br><span class="line"> * appear and have different values, things</span><br><span class="line"> * will get weird.  Don&#39;t do that. *&#x2F;</span><br><span class="line">            &#x2F;* 如果property为&quot;phandle&quot;，设置父node的device_node-&gt;phandle为当前属性的值 *&#x2F;</span><br><span class="line">if ((strcmp(pname, &quot;phandle&quot;) &#x3D;&#x3D; 0) ||</span><br><span class="line">    (strcmp(pname, &quot;linux,phandle&quot;) &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">if (np-&gt;phandle &#x3D;&#x3D; 0)</span><br><span class="line">np-&gt;phandle &#x3D; be32_to_cpup(p);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* And we process the &quot;ibm,phandle&quot; property</span><br><span class="line"> * used in pSeries dynamic device tree</span><br><span class="line"> * stuff *&#x2F;</span><br><span class="line">if (strcmp(pname, &quot;ibm,phandle&quot;) &#x3D;&#x3D; 0)</span><br><span class="line">np-&gt;phandle &#x3D; be32_to_cpup(p);</span><br><span class="line">            &#x2F;* 给property的其他字段赋值：（DTB的空间没有释放，被property成员指针引用）</span><br><span class="line">            property-&gt;name：指针指向dtb strings blcok区域中的属性name</span><br><span class="line">            property-&gt;length：属性data的长度</span><br><span class="line">            property-&gt;value：指针指向dtb stucture block区域中的属性data</span><br><span class="line">             *&#x2F;</span><br><span class="line">pp-&gt;name &#x3D; (char *)pname;</span><br><span class="line">pp-&gt;length &#x3D; sz;</span><br><span class="line">pp-&gt;value &#x3D; (__be32 *)p;</span><br><span class="line">*prev_pp &#x3D; pp;</span><br><span class="line">prev_pp &#x3D; &amp;pp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* with version 0x10 we may not have the name property, recreate</span><br><span class="line"> * it here from the unit name if absent</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (!has_name) &#123;</span><br><span class="line">const char *p1 &#x3D; pathp, *ps &#x3D; pathp, *pa &#x3D; NULL;</span><br><span class="line">int sz;</span><br><span class="line"></span><br><span class="line">while (*p1) &#123;</span><br><span class="line">if ((*p1) &#x3D;&#x3D; &#39;@&#39;)</span><br><span class="line">pa &#x3D; p1;</span><br><span class="line">if ((*p1) &#x3D;&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">ps &#x3D; p1 + 1;</span><br><span class="line">p1++;</span><br><span class="line">&#125;</span><br><span class="line">if (pa &lt; ps)</span><br><span class="line">pa &#x3D; p1;</span><br><span class="line">sz &#x3D; (pa - ps) + 1;</span><br><span class="line">pp &#x3D; unflatten_dt_alloc(&amp;mem, sizeof(struct property) + sz,</span><br><span class="line">__alignof__(struct property));</span><br><span class="line">if (!dryrun) &#123;</span><br><span class="line">pp-&gt;name &#x3D; &quot;name&quot;;</span><br><span class="line">pp-&gt;length &#x3D; sz;</span><br><span class="line">pp-&gt;value &#x3D; pp + 1;</span><br><span class="line">*prev_pp &#x3D; pp;</span><br><span class="line">prev_pp &#x3D; &amp;pp-&gt;next;</span><br><span class="line">memcpy(pp-&gt;value, ps, sz - 1);</span><br><span class="line">((char *)pp-&gt;value)[sz - 1] &#x3D; 0;</span><br><span class="line">pr_debug(&quot;fixed up name for %s -&gt; %s\n&quot;, pathp,</span><br><span class="line">(char *)pp-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;* 根据&quot;name&quot;、 &quot;device_type&quot;属性，来给device_node结构中的name、type成员赋值 *&#x2F;</span><br><span class="line">if (!dryrun) &#123;</span><br><span class="line">*prev_pp &#x3D; NULL;</span><br><span class="line">np-&gt;name &#x3D; of_get_property(np, &quot;name&quot;, NULL);</span><br><span class="line">np-&gt;type &#x3D; of_get_property(np, &quot;device_type&quot;, NULL);</span><br><span class="line"></span><br><span class="line">if (!np-&gt;name)</span><br><span class="line">np-&gt;name &#x3D; &quot;&lt;NULL&gt;&quot;;</span><br><span class="line">if (!np-&gt;type)</span><br><span class="line">np-&gt;type &#x3D; &quot;&lt;NULL&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.3)如果还有子node的存在，递归解析 *&#x2F;</span><br><span class="line">old_depth &#x3D; depth;</span><br><span class="line">*poffset &#x3D; fdt_next_node(blob, *poffset, &amp;depth);</span><br><span class="line">if (depth &lt; 0)</span><br><span class="line">depth &#x3D; 0;</span><br><span class="line">while (*poffset &gt; 0 &amp;&amp; depth &gt; old_depth)</span><br><span class="line">mem &#x3D; unflatten_dt_node(blob, mem, poffset, np, NULL,</span><br><span class="line">fpsize, dryrun);</span><br><span class="line"></span><br><span class="line">if (*poffset &lt; 0 &amp;&amp; *poffset !&#x3D; -FDT_ERR_NOTFOUND)</span><br><span class="line">pr_err(&quot;unflatten: error %d processing FDT\n&quot;, *poffset);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Reverse the child list. Some drivers assumes node order matches .dts</span><br><span class="line"> * node order</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (!dryrun &amp;&amp; np-&gt;child) &#123;</span><br><span class="line">struct device_node *child &#x3D; np-&gt;child;</span><br><span class="line">np-&gt;child &#x3D; NULL;</span><br><span class="line">while (child) &#123;</span><br><span class="line">struct device_node *next &#x3D; child-&gt;sibling;</span><br><span class="line">child-&gt;sibling &#x3D; np-&gt;child;</span><br><span class="line">np-&gt;child &#x3D; child;</span><br><span class="line">child &#x3D; next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (nodepp)</span><br><span class="line">*nodepp &#x3D; np;</span><br><span class="line"></span><br><span class="line">return mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2、Device创建"><a href="#3-2、Device创建" class="headerlink" title="3.2、Device创建"></a>3.2、Device创建</h2><h3 id="3-2-1-of-platform-populate"><a href="#3-2-1-of-platform-populate" class="headerlink" title="3.2.1 of_platform_populate()"></a>3.2.1 of_platform_populate()</h3><p>首先root节点下的第1级子节点创建成platform device。</p><ul><li>对root节点下的第1级子节点，如果有”compatible”属性创建对应platform device；</li><li>如果”compatible”属性等于of_default_bus_match_table(“simple-bus”/“simple-mfd”/“arm,amba-bus”)中任意一种，继续对其子节点进行platform device创建。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; ... -&gt;do_initcalls() -&gt; arm64_device_init():</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">const struct of_device_id of_default_bus_match_table[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;simple-bus&quot;, &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;simple-mfd&quot;, &#125;,</span><br><span class="line">#ifdef CONFIG_ARM_AMBA</span><br><span class="line">&#123; .compatible &#x3D; &quot;arm,amba-bus&quot;, &#125;,</span><br><span class="line">#endif &#x2F;* CONFIG_ARM_AMBA *&#x2F;</span><br><span class="line">&#123;&#125; &#x2F;* Empty terminated list *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init arm64_device_init(void)</span><br><span class="line">&#123;</span><br><span class="line">if (of_have_populated_dt()) &#123;</span><br><span class="line">of_iommu_init();</span><br><span class="line">of_platform_populate(NULL, of_default_bus_match_table,</span><br><span class="line">     NULL, NULL);</span><br><span class="line">&#125; else if (acpi_disabled) &#123;</span><br><span class="line">pr_crit(&quot;Device tree not populated\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int of_platform_populate(struct device_node *root,</span><br><span class="line">const struct of_device_id *matches,</span><br><span class="line">const struct of_dev_auxdata *lookup,</span><br><span class="line">struct device *parent)</span><br><span class="line">&#123;</span><br><span class="line">struct device_node *child;</span><br><span class="line">int rc &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 获取dts中的root node *&#x2F;</span><br><span class="line">root &#x3D; root ? of_node_get(root) : of_find_node_by_path(&quot;&#x2F;&quot;);</span><br><span class="line">if (!root)</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 对root node的child node进行platform device创建 *&#x2F;</span><br><span class="line">for_each_child_of_node(root, child) &#123;</span><br><span class="line">rc &#x3D; of_platform_bus_create(child, matches, lookup, parent, true);</span><br><span class="line">if (rc) &#123;</span><br><span class="line">of_node_put(child);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">of_node_put(root);</span><br><span class="line">return rc;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int of_platform_bus_create(struct device_node *bus,</span><br><span class="line">  const struct of_device_id *matches,</span><br><span class="line">  const struct of_dev_auxdata *lookup,</span><br><span class="line">  struct device *parent, bool strict)</span><br><span class="line">&#123;</span><br><span class="line">const struct of_dev_auxdata *auxdata;</span><br><span class="line">struct device_node *child;</span><br><span class="line">struct platform_device *dev;</span><br><span class="line">const char *bus_id &#x3D; NULL;</span><br><span class="line">void *platform_data &#x3D; NULL;</span><br><span class="line">int rc &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 确保要创建为platform device的node，拥有&quot;compatible&quot;属性 *&#x2F;</span><br><span class="line">&#x2F;* Make sure it has a compatible property *&#x2F;</span><br><span class="line">if (strict &amp;&amp; (!of_get_property(bus, &quot;compatible&quot;, NULL))) &#123;</span><br><span class="line">pr_debug(&quot;%s() - skipping %s, no compatible prop\n&quot;,</span><br><span class="line"> __func__, bus-&gt;full_name);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auxdata &#x3D; of_dev_lookup(lookup, bus);</span><br><span class="line">if (auxdata) &#123;</span><br><span class="line">bus_id &#x3D; auxdata-&gt;name;</span><br><span class="line">platform_data &#x3D; auxdata-&gt;platform_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (of_device_is_compatible(bus, &quot;arm,primecell&quot;)) &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Don&#39;t return an error here to keep compatibility with older</span><br><span class="line"> * device tree files.</span><br><span class="line"> *&#x2F;</span><br><span class="line">of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2) 对当前的node创建platform device *&#x2F;</span><br><span class="line">dev &#x3D; of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">    &#x2F;* (2.3) 根据of_default_bus_match_table，如果node中含有以下属性：</span><br><span class="line">    compatible &#x3D; &quot;simple-bus&quot;</span><br><span class="line">    compatible &#x3D; &quot;simple-mfd&quot;</span><br><span class="line">    compatible &#x3D; &quot;arm,amba-bus&quot;</span><br><span class="line">    则继续对node的子node进行platform device创建</span><br><span class="line">     *&#x2F;</span><br><span class="line">if (!dev || !of_match_node(matches, bus))</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.4) 递归对本node的child node进行platform device创建 *&#x2F;</span><br><span class="line">for_each_child_of_node(bus, child) &#123;</span><br><span class="line">pr_debug(&quot;   create child: %s\n&quot;, child-&gt;full_name);</span><br><span class="line">rc &#x3D; of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line">if (rc) &#123;</span><br><span class="line">of_node_put(child);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line">return rc;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct platform_device *of_platform_device_create_pdata(</span><br><span class="line">struct device_node *np,</span><br><span class="line">const char *bus_id,</span><br><span class="line">void *platform_data,</span><br><span class="line">struct device *parent)</span><br><span class="line">&#123;</span><br><span class="line">struct platform_device *dev;</span><br><span class="line"></span><br><span class="line">if (!of_device_is_available(np) ||</span><br><span class="line">    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line">return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.1) 分配node对应的platform_device结构，</span><br><span class="line">     并且解析node中的&quot;reg&quot;、&quot;interrupts&quot;属性，</span><br><span class="line">    作为platform_device-&gt;resource *&#x2F;</span><br><span class="line">dev &#x3D; of_device_alloc(np, bus_id, parent);</span><br><span class="line">if (!dev)</span><br><span class="line">goto err_clear_flag;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.2) device对应的bus为platform_bus_type  *&#x2F;</span><br><span class="line">dev-&gt;dev.bus &#x3D; &amp;platform_bus_type;</span><br><span class="line">dev-&gt;dev.platform_data &#x3D; platform_data;</span><br><span class="line">of_dma_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.3) 注册platform_device-&gt;dev为标准的device *&#x2F;</span><br><span class="line">if (of_device_add(dev) !&#x3D; 0) &#123;</span><br><span class="line">of_dma_deconfigure(&amp;dev-&gt;dev);</span><br><span class="line">platform_device_put(dev);</span><br><span class="line">goto err_clear_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">struct platform_device *of_device_alloc(struct device_node *np,</span><br><span class="line">  const char *bus_id,</span><br><span class="line">  struct device *parent)</span><br><span class="line">&#123;</span><br><span class="line">struct platform_device *dev;</span><br><span class="line">int rc, i, num_reg &#x3D; 0, num_irq;</span><br><span class="line">struct resource *res, temp_res;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.1.1) 分配platform_device空间  *&#x2F;</span><br><span class="line">dev &#x3D; platform_device_alloc(&quot;&quot;, -1);</span><br><span class="line">if (!dev)</span><br><span class="line">return NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.1.2) 计算node中&quot;reg&quot;属性中&quot;address、size&quot;resource的个数  *&#x2F;</span><br><span class="line">&#x2F;* count the io and irq resources *&#x2F;</span><br><span class="line">while (of_address_to_resource(np, num_reg, &amp;temp_res) &#x3D;&#x3D; 0)</span><br><span class="line">num_reg++;</span><br><span class="line">num_irq &#x3D; of_irq_count(np); &#x2F;* 计算node中&quot;interrupts&quot;属性中irq的个数 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.1.3) 给resource分配空间并解析值 *&#x2F;</span><br><span class="line">&#x2F;* Populate the resource table *&#x2F;</span><br><span class="line">if (num_irq || num_reg) &#123;</span><br><span class="line">res &#x3D; kzalloc(sizeof(*res) * (num_irq + num_reg), GFP_KERNEL);</span><br><span class="line">if (!res) &#123;</span><br><span class="line">platform_device_put(dev);</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev-&gt;num_resources &#x3D; num_reg + num_irq;</span><br><span class="line">dev-&gt;resource &#x3D; res;</span><br><span class="line">for (i &#x3D; 0; i &lt; num_reg; i++, res++) &#123;</span><br><span class="line">rc &#x3D; of_address_to_resource(np, i, res);</span><br><span class="line">WARN_ON(rc);</span><br><span class="line">&#125;</span><br><span class="line">if (of_irq_to_resource_table(np, res, num_irq) !&#x3D; num_irq)</span><br><span class="line">pr_debug(&quot;not all legacy IRQ resources mapped for %s\n&quot;,</span><br><span class="line"> np-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.1.4) 根据device能够找到of node  *&#x2F;</span><br><span class="line">dev-&gt;dev.of_node &#x3D; of_node_get(np);</span><br><span class="line">dev-&gt;dev.parent &#x3D; parent ? : &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.1.5) 配置device的那么，基本命名规则为：</span><br><span class="line">    dev_set_name(dev, dev_name(dev) ? &quot;%llx.%s:%s&quot; : &quot;%llx.%s&quot;,</span><br><span class="line">         (unsigned long long)addr, node-&gt;name,</span><br><span class="line">         dev_name(dev))</span><br><span class="line">    *&#x2F;</span><br><span class="line">if (bus_id)</span><br><span class="line">dev_set_name(&amp;dev-&gt;dev, &quot;%s&quot;, bus_id);</span><br><span class="line">else</span><br><span class="line">of_device_make_bus_id(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">return dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-mt-i2c-driver"><a href="#3-2-2-mt-i2c-driver" class="headerlink" title="3.2.2 mt_i2c_driver"></a>3.2.2 mt_i2c_driver</h3><p>因为第1级子节点会被注册成platform device，例如i2c/spi控制器，那么对应也需要注册platform driver。已i2c控制器驱动为例：</p><ul><li>控制器首先会创建对应platform driver，把adapter注册成i2c device；</li><li>在adapter的probe过程中，会调用of_i2c_register_devices()函数遍历控制器下挂的i2c设备的DTS节点，并将其注册成i2c_client；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">drivers\i2c\busses\i2c-mtk.c:</span><br><span class="line"></span><br><span class="line">static const struct of_device_id mtk_i2c_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;mediatek,mt6735-i2c&quot;, .data &#x3D; &amp;mt6735_compat &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;mediatek,mt6797-i2c&quot;, .data &#x3D; &amp;mt6797_compat &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;mediatek,mt6757-i2c&quot;, .data &#x3D; &amp;mt6757_compat &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;mediatek,mt6799-i2c&quot;, .data &#x3D; &amp;mt6799_compat &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;mediatek,elbrus-i2c&quot;, .data &#x3D; &amp;elbrus_compat &#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct platform_driver mt_i2c_driver &#x3D; &#123;</span><br><span class="line">.probe &#x3D; mt_i2c_probe,</span><br><span class="line">.remove &#x3D; mt_i2c_remove,</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.name &#x3D; I2C_DRV_NAME,</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.of_match_table &#x3D; of_match_ptr(mtk_i2c_of_match),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int mt_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">struct mt_i2c *i2c;</span><br><span class="line">unsigned int clk_src_in_hz;</span><br><span class="line">struct resource *res;</span><br><span class="line">const struct of_device_id *of_id;</span><br><span class="line"></span><br><span class="line">i2c &#x3D; devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct mt_i2c), GFP_KERNEL);</span><br><span class="line">if (i2c &#x3D;&#x3D; NULL)</span><br><span class="line">return -ENOMEM;</span><br><span class="line"></span><br><span class="line">ret &#x3D; mt_i2c_parse_dt(pdev-&gt;dev.of_node, i2c);</span><br><span class="line">if (ret)</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line"></span><br><span class="line">i2c-&gt;base &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">if (IS_ERR(i2c-&gt;base))</span><br><span class="line">return PTR_ERR(i2c-&gt;base);</span><br><span class="line"></span><br><span class="line">res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 1);</span><br><span class="line"></span><br><span class="line">i2c-&gt;pdmabase &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">if (IS_ERR(i2c-&gt;pdmabase))</span><br><span class="line">return PTR_ERR(i2c-&gt;pdmabase);</span><br><span class="line"></span><br><span class="line">i2c-&gt;irqnr &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">if (i2c-&gt;irqnr &lt;&#x3D; 0)</span><br><span class="line">return -EINVAL;</span><br><span class="line">init_waitqueue_head(&amp;i2c-&gt;wait);</span><br><span class="line"></span><br><span class="line">ret &#x3D; devm_request_irq(&amp;pdev-&gt;dev, i2c-&gt;irqnr, mt_i2c_irq,</span><br><span class="line">#ifdef CONFIG_MEIZU_BSP</span><br><span class="line">IRQF_NO_SUSPEND | IRQF_TRIGGER_NONE, I2C_DRV_NAME, i2c);</span><br><span class="line">#else</span><br><span class="line">IRQF_TRIGGER_NONE, I2C_DRV_NAME, i2c);</span><br><span class="line">#endif &#x2F;*CONFIG_MEIZU_BSP*&#x2F;</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev,</span><br><span class="line">&quot;Request I2C IRQ %d fail\n&quot;, i2c-&gt;irqnr);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">of_id &#x3D; of_match_node(mtk_i2c_of_match, pdev-&gt;dev.of_node);</span><br><span class="line">if (!of_id)</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">i2c-&gt;dev_comp &#x3D; of_id-&gt;data;</span><br><span class="line">i2c-&gt;adap.dev.of_node &#x3D; pdev-&gt;dev.of_node;</span><br><span class="line">i2c-&gt;dev &#x3D; &amp;i2c-&gt;adap.dev;</span><br><span class="line">i2c-&gt;adap.dev.parent &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line">i2c-&gt;adap.owner &#x3D; THIS_MODULE;</span><br><span class="line">i2c-&gt;adap.algo &#x3D; &amp;mt_i2c_algorithm;</span><br><span class="line">i2c-&gt;adap.algo_data &#x3D; NULL;</span><br><span class="line">i2c-&gt;adap.timeout &#x3D; 2 * HZ;</span><br><span class="line">i2c-&gt;adap.retries &#x3D; 1;</span><br><span class="line">i2c-&gt;adap.nr &#x3D; i2c-&gt;id;</span><br><span class="line">spin_lock_init(&amp;i2c-&gt;cg_lock);</span><br><span class="line"></span><br><span class="line">if (i2c-&gt;dev_comp-&gt;dma_support &#x3D;&#x3D; 2) &#123;</span><br><span class="line">if (dma_set_mask(&amp;pdev-&gt;dev, DMA_BIT_MASK(33))) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;dma_set_mask return error.\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (i2c-&gt;dev_comp-&gt;dma_support &#x3D;&#x3D; 3) &#123;</span><br><span class="line">if (dma_set_mask(&amp;pdev-&gt;dev, DMA_BIT_MASK(36))) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;dma_set_mask return error.\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if !defined(CONFIG_MT_I2C_FPGA_ENABLE)</span><br><span class="line">i2c-&gt;clk_main &#x3D; devm_clk_get(&amp;pdev-&gt;dev, &quot;main&quot;);</span><br><span class="line">if (IS_ERR(i2c-&gt;clk_main)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;cannot get main clock\n&quot;);</span><br><span class="line">return PTR_ERR(i2c-&gt;clk_main);</span><br><span class="line">&#125;</span><br><span class="line">i2c-&gt;clk_dma &#x3D; devm_clk_get(&amp;pdev-&gt;dev, &quot;dma&quot;);</span><br><span class="line">if (IS_ERR(i2c-&gt;clk_dma)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;cannot get dma clock\n&quot;);</span><br><span class="line">return PTR_ERR(i2c-&gt;clk_dma);</span><br><span class="line">&#125;</span><br><span class="line">i2c-&gt;clk_arb &#x3D; devm_clk_get(&amp;pdev-&gt;dev, &quot;arb&quot;);</span><br><span class="line">if (IS_ERR(i2c-&gt;clk_arb))</span><br><span class="line">i2c-&gt;clk_arb &#x3D; NULL;</span><br><span class="line">else</span><br><span class="line">dev_dbg(&amp;pdev-&gt;dev, &quot;i2c%d has the relevant arbitrator clk.\n&quot;, i2c-&gt;id);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (i2c-&gt;have_pmic) &#123;</span><br><span class="line">i2c-&gt;clk_pmic &#x3D; devm_clk_get(&amp;pdev-&gt;dev, &quot;pmic&quot;);</span><br><span class="line">if (IS_ERR(i2c-&gt;clk_pmic)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;cannot get pmic clock\n&quot;);</span><br><span class="line">return PTR_ERR(i2c-&gt;clk_pmic);</span><br><span class="line">&#125;</span><br><span class="line">clk_src_in_hz &#x3D; clk_get_rate(i2c-&gt;clk_pmic) &#x2F; i2c-&gt;clk_src_div;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">clk_src_in_hz &#x3D; clk_get_rate(i2c-&gt;clk_main) &#x2F; i2c-&gt;clk_src_div;</span><br><span class="line">&#125;</span><br><span class="line">dev_dbg(&amp;pdev-&gt;dev, &quot;clock source %p,clock src frequency %d\n&quot;,</span><br><span class="line">i2c-&gt;clk_main, clk_src_in_hz);</span><br><span class="line"></span><br><span class="line">strlcpy(i2c-&gt;adap.name, I2C_DRV_NAME, sizeof(i2c-&gt;adap.name));</span><br><span class="line">mutex_init(&amp;i2c-&gt;i2c_mutex);</span><br><span class="line">ret &#x3D; i2c_set_speed(i2c, clk_src_in_hz);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;Failed to set the speed\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ret &#x3D; mt_i2c_clock_enable(i2c);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;clock enable failed!\n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">mt_i2c_init_hw(i2c);</span><br><span class="line">mt_i2c_clock_disable(i2c);</span><br><span class="line">i2c-&gt;dma_buf.vaddr &#x3D; dma_alloc_coherent(&amp;pdev-&gt;dev,</span><br><span class="line">PAGE_SIZE, &amp;i2c-&gt;dma_buf.paddr, GFP_KERNEL);</span><br><span class="line">if (i2c-&gt;dma_buf.vaddr &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;dma_alloc_coherent fail\n&quot;);</span><br><span class="line">return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">i2c_set_adapdata(&amp;i2c-&gt;adap, i2c);</span><br><span class="line">&#x2F;* ret &#x3D; i2c_add_adapter(&amp;i2c-&gt;adap); *&#x2F;</span><br><span class="line">ret &#x3D; i2c_add_numbered_adapter(&amp;i2c-&gt;adap);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, &quot;Failed to add i2c bus to i2c core\n&quot;);</span><br><span class="line">free_i2c_dma_bufs(i2c);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">platform_set_drvdata(pdev, i2c);</span><br><span class="line"></span><br><span class="line">if (!map_cg_regs(i2c))</span><br><span class="line">pr_warn(&quot;Map cg regs successfully.\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">i2c_add_numbered_adapter() -&gt; __i2c_add_numbered_adapter() -&gt; </span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* Can&#39;t register until after driver model init *&#x2F;</span><br><span class="line">if (unlikely(WARN_ON(!i2c_bus_type.p))) &#123;</span><br><span class="line">res &#x3D; -EAGAIN;</span><br><span class="line">goto out_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Sanity checks *&#x2F;</span><br><span class="line">if (unlikely(adap-&gt;name[0] &#x3D;&#x3D; &#39;\0&#39;)) &#123;</span><br><span class="line">pr_err(&quot;i2c-core: Attempt to register an adapter with &quot;</span><br><span class="line">       &quot;no name!\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">if (unlikely(!adap-&gt;algo)) &#123;</span><br><span class="line">pr_err(&quot;i2c-core: Attempt to register adapter &#39;%s&#39; with &quot;</span><br><span class="line">       &quot;no algo!\n&quot;, adap-&gt;name);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">&#x2F;* Set default timeout to 1 second if not already set *&#x2F;</span><br><span class="line">if (adap-&gt;timeout &#x3D;&#x3D; 0)</span><br><span class="line">adap-&gt;timeout &#x3D; HZ;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册adapter为i2c_bus上的device *&#x2F;</span><br><span class="line">dev_set_name(&amp;adap-&gt;dev, &quot;i2c-%d&quot;, adap-&gt;nr);</span><br><span class="line">adap-&gt;dev.bus &#x3D; &amp;i2c_bus_type;</span><br><span class="line">adap-&gt;dev.type &#x3D; &amp;i2c_adapter_type;</span><br><span class="line">res &#x3D; device_register(&amp;adap-&gt;dev);</span><br><span class="line">if (res)</span><br><span class="line">goto out_list;</span><br><span class="line"></span><br><span class="line">dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);</span><br><span class="line"></span><br><span class="line">pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line">res &#x3D; class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">       adap-&gt;dev.parent);</span><br><span class="line">if (res)</span><br><span class="line">dev_warn(&amp;adap-&gt;dev,</span><br><span class="line"> &quot;Failed to create compatibility class link\n&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;* bus recovery specific initialization *&#x2F;</span><br><span class="line">if (adap-&gt;bus_recovery_info) &#123;</span><br><span class="line">struct i2c_bus_recovery_info *bri &#x3D; adap-&gt;bus_recovery_info;</span><br><span class="line"></span><br><span class="line">if (!bri-&gt;recover_bus) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;No recover_bus() found, not using recovery\n&quot;);</span><br><span class="line">adap-&gt;bus_recovery_info &#x3D; NULL;</span><br><span class="line">goto exit_recovery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Generic GPIO recovery *&#x2F;</span><br><span class="line">if (bri-&gt;recover_bus &#x3D;&#x3D; i2c_generic_gpio_recovery) &#123;</span><br><span class="line">if (!gpio_is_valid(bri-&gt;scl_gpio)) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;Invalid SCL gpio, not using recovery\n&quot;);</span><br><span class="line">adap-&gt;bus_recovery_info &#x3D; NULL;</span><br><span class="line">goto exit_recovery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (gpio_is_valid(bri-&gt;sda_gpio))</span><br><span class="line">bri-&gt;get_sda &#x3D; get_sda_gpio_value;</span><br><span class="line">else</span><br><span class="line">bri-&gt;get_sda &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">bri-&gt;get_scl &#x3D; get_scl_gpio_value;</span><br><span class="line">bri-&gt;set_scl &#x3D; set_scl_gpio_value;</span><br><span class="line">&#125; else if (!bri-&gt;set_scl || !bri-&gt;get_scl) &#123;</span><br><span class="line">&#x2F;* Generic SCL recovery *&#x2F;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;No &#123;get|set&#125;_gpio() found, not using recovery\n&quot;);</span><br><span class="line">adap-&gt;bus_recovery_info &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_recovery:</span><br><span class="line">&#x2F;* create pre-declared device nodes *&#x2F;</span><br><span class="line">    &#x2F;* 循环遍历adapter node下挂载的其他子node，注册成为i2c bus的device *&#x2F;</span><br><span class="line">of_i2c_register_devices(adap);</span><br><span class="line">acpi_i2c_register_devices(adap);</span><br><span class="line">acpi_i2c_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line">if (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">&#x2F;* Notify drivers *&#x2F;</span><br><span class="line">mutex_lock(&amp;core_lock);</span><br><span class="line">bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">mutex_lock(&amp;core_lock);</span><br><span class="line">idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">mutex_unlock(&amp;core_lock);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void of_i2c_register_devices(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">struct device_node *node;</span><br><span class="line"></span><br><span class="line">&#x2F;* Only register child devices if the adapter has a node pointer set *&#x2F;</span><br><span class="line">if (!adap-&gt;dev.of_node)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">dev_dbg(&amp;adap-&gt;dev, &quot;of_i2c: walking child nodes\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 遍历adapter node下的子node，并创建标准的i2c bus的device *&#x2F;</span><br><span class="line">for_each_available_child_of_node(adap-&gt;dev.of_node, node) &#123;</span><br><span class="line">if (of_node_test_and_set_flag(node, OF_POPULATED))</span><br><span class="line">continue;</span><br><span class="line">of_i2c_register_device(adap, node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,</span><br><span class="line"> struct device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">struct i2c_client *result;</span><br><span class="line">struct i2c_board_info info &#x3D; &#123;&#125;;</span><br><span class="line">struct dev_archdata dev_ad &#x3D; &#123;&#125;;</span><br><span class="line">const __be32 *addr_be;</span><br><span class="line">u32 addr;</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">dev_dbg(&amp;adap-&gt;dev, &quot;of_i2c: register %s\n&quot;, node-&gt;full_name);</span><br><span class="line"></span><br><span class="line">if (of_modalias_node(node, info.type, sizeof(info.type)) &lt; 0) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;of_i2c: modalias failure on %s\n&quot;,</span><br><span class="line">node-&gt;full_name);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr_be &#x3D; of_get_property(node, &quot;reg&quot;, &amp;len);</span><br><span class="line">if (!addr_be || (len &lt; sizeof(*addr_be))) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;of_i2c: invalid reg on %s\n&quot;,</span><br><span class="line">node-&gt;full_name);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr &#x3D; be32_to_cpup(addr_be);</span><br><span class="line">if (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">addr &amp;&#x3D; ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">info.flags |&#x3D; I2C_CLIENT_TEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123;</span><br><span class="line">addr &amp;&#x3D; ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">info.flags |&#x3D; I2C_CLIENT_SLAVE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (i2c_check_addr_validity(addr, info.flags)) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;of_i2c: invalid addr&#x3D;%x on %s\n&quot;,</span><br><span class="line">info.addr, node-&gt;full_name);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.addr &#x3D; addr;</span><br><span class="line">info.of_node &#x3D; of_node_get(node);</span><br><span class="line">info.archdata &#x3D; &amp;dev_ad;</span><br><span class="line"></span><br><span class="line">if (of_get_property(node, &quot;wakeup-source&quot;, NULL))</span><br><span class="line">info.flags |&#x3D; I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">result &#x3D; i2c_new_device(adap, &amp;info);</span><br><span class="line">if (result &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, &quot;of_i2c: Failure registering %s\n&quot;,</span><br><span class="line">node-&gt;full_name);</span><br><span class="line">of_node_put(node);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-mz-mag-driver"><a href="#3-2-1-mz-mag-driver" class="headerlink" title="3.2.1 mz_mag_driver"></a>3.2.1 mz_mag_driver</h3><p>具体的I2c设备驱动，在总线驱动使用of_i2c_register_devices()创建设备以后，就可以适配工作了。</p><p>dts：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">arch\arm64\boot\dts\mediatek\mt6799.dtsi:</span><br><span class="line">i2c1: i2c@11090000 &#123;</span><br><span class="line">compatible &#x3D; &quot;mediatek,mt6799-i2c&quot;;</span><br><span class="line">id &#x3D; &lt;1&gt;;</span><br><span class="line">reg &#x3D; &lt;0 0x11090000 0 0x1000&gt;,</span><br><span class="line">&lt;0 0x11000100 0 0x80&gt;;</span><br><span class="line">interrupts &#x3D; &lt;GIC_SPI 85 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;pericfg CLK_PERICFG_RG_I2C1_BCLK&gt;, &lt;&amp;pericfg CLK_PERICFG_RG_AP_DM&gt;;</span><br><span class="line">clock-names &#x3D; &quot;main&quot;, &quot;dma&quot;;</span><br><span class="line">clock-div &#x3D; &lt;5&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arch\arm64\boot\dts\mediatek\mz6799_6m_v2_2k_n.dtsi:</span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">apds9922:apds9922@53 &#123;</span><br><span class="line">compatible &#x3D; &quot;mediatek,apds9922&quot;;</span><br><span class="line">interrupt-parent &#x3D; &lt;&amp;eintc&gt;;</span><br><span class="line">interrupts &#x3D; &lt; 8 IRQ_TYPE_EDGE_FALLING&gt;;</span><br><span class="line">debounce &#x3D; &lt;8 0&gt;;</span><br><span class="line">gpio &#x3D; &lt; 8 &gt;;</span><br><span class="line">reg &#x3D; &lt;0x53&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>driver：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drivers\iio\magnetometer\mz_mag.c:</span><br><span class="line">static const struct i2c_device_id mz_mag_id[] &#x3D; &#123;</span><br><span class="line">&#123;&quot;mediatek,mmc3530&quot;, 0 &#125;,</span><br><span class="line">&#123;&quot;mediatek,akm09911&quot;, 1 &#125;,</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct i2c_driver mz_mag_driver &#x3D; &#123;</span><br><span class="line">.probe     &#x3D; mz_mag_probe,</span><br><span class="line">.id_table  &#x3D; mz_mag_id,</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.name  &#x3D; MZ_MAG_DEV_NAME,</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_OF</span><br><span class="line">    .of_match_table &#x3D; of_match_ptr(msensor_of_match),</span><br><span class="line">#endif</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DTS </tag>
            
            <tag> DTB </tag>
            
            <tag> DTC </tag>
            
            <tag> Node </tag>
            
            <tag> Property </tag>
            
            <tag> OpenFirmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEE 软件交互流程概述</title>
      <link href="/2017/12/27//tee.html/"/>
      <url>/2017/12/27//tee.html/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><ul><li>本文建立在你已经对 TEE 技术的基础知识有一定了解的基础之上，如需了解，可以阅读本博客的文章《指纹 TEE》<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</li><li>本文将基于 OP-TEE<sup><a href="#fn_2" id="reffn_2">2</a></sup> 开源 TEE 软件，介绍 TEE 软件中，REE 客户端访问 TEE 环境资源的具体调用流程。 为此，本文首先会介绍实现 REE 到 TEE 调用的各个基础组件组成以及各自功能，然后分析各个基础组件的交互流程时序，使读者对 TEE 软件的运行逻辑有大概的了解。</li></ul><h4 id="TEE-软件交互基础组件简介"><a href="#TEE-软件交互基础组件简介" class="headerlink" title="TEE 软件交互基础组件简介"></a><strong>TEE 软件交互基础组件简介</strong></h4><ul><li>TEE 系统软件从整体上包含 REE 和 TEE 两部分，各自对应的基础组件如图1所示。</li></ul><p><img src="./images/posts/2017/12/ca2ta_arch.png" alt="图1: TEE 系统软件组成" title="图1: TEE 系统软件组成"></p><ul><li>REE 部分 Client Applications（CA） 一般是指指纹录入，支付应用等上层应用，其通过调用 TEE Client API 接口来与 TEE 环境的 Trusted OS 进行交互，这里的 TEE Client API 包括 TEE 厂商自定义的一些接口或 GlobalPlatform（GP） 全球组织定义的通用 API，其目的是制定一套标准的编程接口，方便开发者在不同软硬件平台下使用同一套代码实现其功能。</li><li>TEE Client API 通过 ioctl 系统调用对 TEE Driver 进行操作，TEE Driver 是沟通 REE 和 TEE 的桥梁，其通过 SMC 指令，实现将上层的 OpenSession，InvokeCommand，CloseSession 等标准调用的请求转发到 TEE 环境，同时其也会处理来自 TEE 的请求，将请求转发到 TEE Helper Daemon 让其处理。</li><li><p>TEE Helper Daemon 是一个辅助进程，用于 TEE 请求 REE 的资源。 一般来说，TEE 需要获得存储在 EMMC 的数据文件（例如安全加密文件，TA 可执行镜像文件等），而读写 EMMC 操作需要复杂的内核驱动的支持，显然如果把读写 EMMC 的驱动放到 TEE 侧运行会使软件复杂度会变得很高，因此 REE 需要一个可以访问这些资源的辅助进程支持，这就是 TEE Helper Daemon 的基本功能。TEE Helper Daemon 在软件逻辑实现上比较简单，以 OP-TEE 的 tee-supplicant 辅助进程为例，整体上是一个循环流程: 其首先通过 ioctl 接口查询是否有来自 TEE 的请求，如果没有，则进入睡眠等待状态，等待 TEE Driver 的唤醒信号，当 TEE Driver 收到来自 TEE 的请求后，会唤醒 tee-supplicant 辅助进程，然后根据请求号进行相应处理（读写数据文件，读写 EMMC 设备分区等），最后返回结果到 TEE Driver，完成一次循环，具体实现可参照《OP-TEE 中 tee-supplicant 执行流程》<sup><a href="#fn_3" id="reffn_3">3</a></sup></p><ul><li>TEE 侧的 Secure Monitor 的主要作用是实现 REE 和 TEE 环境的切换，转发请求到 Trusted OS。当 Secure Monitor 收到 TEE Driver 的 SMC 请求后，会将 CPU 切换到 Secure 状态，然后转发请求到 Trusted OS 来处理，Trusted OS 会找到请求对应的 Trusted App（TA） 去处理请求，具体逻辑流程会在下一节中详细说明。 另外 Secure Monitor 还用于开机时候 Trusted OS 的引导工作，此内容不在本文的叙述范围，读者可以参看: 《Secure-EL1 Payloads and Dispatchers》<sup><a href="#fn_4" id="reffn_4">4</a></sup></li><li>Trusted OS 是运行在 TEE 侧的小型操作系统，简单来说，其作用是:<ul><li>构建满足 TA 运行的安全运行环境</li><li>提供安全外设（SPI，I2C，Timer 等）的驱动程序</li><li>根据 REE 的请求，调度相应 TA 处理请求</li><li>提供 TA 运行所需要的加解密，随机数生成，证书生成校验等通用函数库</li></ul></li><li>上文提到 GlobalPlatform（GP） 全球组织定义的通用 API，TEE Client API 供 REE 侧的 CA 使用，TEE Internal API 则是供 TA 调用 Trusted OS 资源的标准 API，同样是用于方便 TA 开发者在不同软硬件平台进行开发。</li></ul></li></ul><h4 id="TEE-软件交互流程"><a href="#TEE-软件交互流程" class="headerlink" title="TEE 软件交互流程"></a><strong>TEE 软件交互流程</strong></h4><p>上文对 REE 调用 TEE 软件交互所需要的基础组件及其基本作用进行了介绍，下面将对各个组件的交互流程进行介绍。</p><p>在 GP 标准中，CA 要与 TA 进行通信，需要建立如图2所示的软件逻辑流程:</p><ol><li>首先 CA 需要与 Trusted OS 之间建立一个 Context（InitializeContext），以后此 CA 与 TEE 环境的所有通信均基于此 Context。</li><li>然后 CA 会向 Trusted OS 申请与请求的 TA 建立一个 Session（OpenSession）。</li><li>CA 与 TA 之间的 Session 建立完成后，CA 就可以向 TA 发送 Command（InvokeCommand）。</li><li>Command 及其参数会通过共享内存的方式传递，TA 从共享内存中获取到 CA 的请求以及请求参数。</li><li>TA 在 TEE 环境下执行处理，得到的处理结果重新填充到共享内存中，CA 通过共享内存就可以获取到处理结果。</li><li>获得处理结果后，如不需要进一步请求，则由 CA 发起关闭 Session 的请求（CloseSession），Trusted OS 回收 TA 相关资源，最后 CA 发起销毁 Context 的请求（FinalizeContext），完成一次完整交互。</li></ol><p><img src="./images/posts/2017/12/arch-of-tee-plat-de.png" alt="图2: TEE 软件交互逻辑" title="图2: TEE 软件交互逻辑"></p><p>从以上流程可以看到，整个交互流程主要涉及 InitializeContext，OpenSession，InvokeCommand，CloseSession 和 FinalizeContext 5个操作。<br>InitializeContext 用于 Trusted OS 分配 TA 运行需要的安全内存，FinalizeContext 则是销毁相应内存，具体流程分别与 OpenSession 和 CloseSession 类似，本文将不对这两个操作赘述。<br>下面看看 OpenSession，InvokeCommand 和 CloseSession 这几个操作下，各个基础组件的交互时序。</p><p>OpenSession 时序如图3所示，操作步骤如下:</p><p><img src="./images/posts/2017/12/ca2ta_os.png" alt="图3: OpenSession 时序图" title="图3: OpenSession 时序图"></p><ol><li>CA 经过 TEE Client API 向 TEE Driver 发送 OpenSession 请求。</li><li>TEE Driver 发送 OpenSession SMC 请求到 Trusted OS，此请求中包含要请求 TA 的唯一标识号（UUID）。</li><li>Trusted OS 会根据 TA 的 UUID 查找 TA 是否已经加载了，如果已经加载了，则执行步骤6，否则执行步骤4。</li><li>若请求的 TA 未加载，则 Trusted OS 会向 TEE Helper Daemon 进程发送 Load TA 命令请求，TEE Helper Daemon 收到请求后，会根据要加载的 TA 的 UUID，从文件系统指定路径下找到 TA 镜像文件，并将其加载到预先分配的共享内存中，最后将共享内存的地址回传给 Trusted OS（这次地址回传实际需要经过 TEE Driver 进行虚拟地址与物理地址转换）。</li><li>Trusted OS 从回传的共享地址拷贝 TA 镜像到安全内存中，然后对安全内存中的 TA 镜像的 ELF 格式头，签名信息进行校验，校验通过则加载成功，否则返回错误信息给 CA。</li><li>TA 加载成功后，Trusted OS 分配一个 Session 操作句柄，并定位到已加载镜像的 TA_OpenSessionEntryPoint 函数入口执行。</li><li>最后，Trusted OS 将分配的 Session 句柄逐级返回，最终 CA 拿到 Session 句柄，以后的 InvokeCommand 将需要依赖此句柄进行调用。</li></ol><p>InvokeCommand 和 CloseSession 的流程与 OpenSession 流程相似，差别在于少了 load TA 的流程，时序图如图4和图5所示。</p><p><img src="./images/posts/2017/12/ca2ta_ic.png" alt="图4: InvokeCommand 时序图" title="图4: InvokeCommand 时序图"></p><p><img src="./images/posts/2017/12/ca2ta_cs.png" alt="图5: CloseSession 时序图" title="图5: CloseSession 时序图"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><blockquote id="fn_1"><sup>1</sup>. <a href="http://kernel.meizu.com/2017/08/17-33-25-tee_fp.html">指纹 TEE</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://github.com/OP-TEE/optee_os/blob/master/documentation/optee_design.md" target="_blank" rel="noopener">OP-TEE design</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="http://blog.csdn.net/shuaifengyun/article/details/72912238" target="_blank" rel="noopener">OP-TEE中tee-supplicant执行流程</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://github.com/ARM-software/arm-trusted-firmware/blob/master/docs/firmware-design.rst#secure-el1-payloads-and-dispatchers" target="_blank" rel="noopener">Secure-EL1 Payloads and Dispatchers</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> Trusted Execution Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理 —— ION</title>
      <link href="/2017/11/18//memory%20management%20-%20ion.html/"/>
      <url>/2017/11/18//memory%20management%20-%20ion.html/</url>
      
        <content type="html"><![CDATA[<p>ION 是当前 Android 流行的内存分配管理机制，在多媒体部分中使用的最多，例如从 Camera 到 Display，从 Mediaserver 到 Surfaceflinger，都会利用 ION 进行内存分配管理。<br>ION 的前任是 PMEM，关于 PMEM 我在 M030/M04X 项目中有接触过，后来由于 PMEM 的一些局限性，Google 推出了 ION 来取代 PMEM，当前 ION 已经融合到 Linux 主线，被广泛使用。<br>对于魅族，从 M65 项目开始，相机的内存分配管理就已经利用 ION 进行了，本文会结合 M65、M76 和 M86 项目开发介绍下我对 ION 内存管理机制的理解和感悟。</p><h2 id="ION-基本概念"><a href="#ION-基本概念" class="headerlink" title="ION 基本概念"></a>ION 基本概念</h2><p>ION，最显著的特点是它可以被用户空间的进程之间或者内核空间的模块之间进行内存共享，而且这种共享可以是零拷贝的。在实际使用中，ION 和 VIDEOBUF2、DMA-BUF、V4L2 等结合的很紧密。本文主要介绍 ION，其它子系统感兴趣的话后续会陆续进行介绍。</p><p>ION 是在各种 heaps 上分配内存，通过 ion_buffer 来描述所分配的内存。</p><p>下图展示了 ION 的基本框架。图中 PID1、PID2、PID3 表示用户空间进程。ION core 表示 ION 核心层，它提供设备创建、注册等服务，同时提供统一的接口给用户使用。ION Driver 利用 ION core 对相应功能进行实现，可以说它是具体平台相关的，例如 SAMSUNG 平台、QUALCOMM 平台和 MTK 平台都会依据自己的特性开发相应的 ION Driver。</p><p><img src="/images/posts/2017/11/ION_ARCHI.png" alt="ION_ARCHI"></p><p>上图虽然描述的是用户空间进程使用 ION 的情形，但实际上，在内核空间同样可以直接使用 ION 来分配、管理内存。例如 M76、M86 平台的相机驱动，都有直接使用 ION 分配和管理内存。</p><h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><p>数据结构是程序设计的基础，代码看的多了，其实可以从数据结构看出其能提供的基本功能和大致用法。<br>为了抓住纲领，本文将抓住 ION 的主要数据结构进行介绍。</p><h3 id="ion-device"><a href="#ion-device" class="headerlink" title="ion_device"></a>ion_device</h3><p>ion_device 是 ION 很重要很基础的数据结构，用 struct ion_device 结构体描述，一般在一个系统中只有一个本实例。例如在 M86 中，就是在 exynos_ion_v2.c 的 exynos_ion_probe() 函数中创建了系统唯一的本实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">buffers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">buffer_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plist_head</span> <span class="title">heaps</span>;</span></span><br><span class="line"><span class="keyword">long</span> (*custom_ioctl)(struct ion_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">clients</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debug_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">heaps_debug_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">clients_debug_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">vm_sem</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> page_idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">reserved_vm_area</span>;</span></span><br><span class="line"><span class="keyword">pte_t</span> **pte;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct ion_device 其实是 ION 的核心结构，不过由于对于使用 ION 的用户而言是屏蔽的，即如果是单纯使用 ION，不需要直接和本结构打交道。但是想完全的理解 ION，需要对其有所了解。<br>struct ion_device 是由 ion_device_create() [ion.c] 分配、初始化。</p><ul><li>dev 成员，是 struct miscdevice 类型，所以可想而知 ION 是作为 MISC 设备注册进系统的。从这点还可以看出来，用户空间使用 ION 时必定需要使用 open 啊，ioctl 啊系统调用。事实也正是如此。</li><li>heaps 成员，在 M86 使用过的 KERNEL LINUX 3.10 中是 struct plist_head 类型，但是在此之前并不是此类型，例如在 M65 使用过的 KERNEL LINUX 3.4 中是 struct rb_root 类型。可见随着 KERNEL 和 ION 的演进，struct ion_device 的实现会有所改变。本字段管理的是属于本 struct ion_device 的所有 struct ion_heap 实例。</li><li>clients 成员，是 struct rb_root 类型，struct rb_root 是红黑树，属于二叉树的一种。本字段管理的是 struct ion_client 实例。</li></ul><h3 id="ion-client"><a href="#ion-client" class="headerlink" title="ion_client"></a>ion_client</h3><p>struct ion_client 是由 ion_client_create() [ion.c] 创建，在创建时必须指定上文提到的 struct ion_device 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_client</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">handles</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">char</span> *display_name;</span><br><span class="line"><span class="keyword">int</span> display_serial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debug_root</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>node 成员，是 struct rb_node 结构类型，用于将本 struct ion_client 实例加入到 struct ion_device，具体的是 struct ion_device::clients。</li><li>device 成员，是 struct ion_device 指针结构类型，指向所属的 struct ion_device 实例。</li><li>handles 成员，是 struct rb_root 结构类型，管理其所拥有的 handle，即 struct ion_handle 实例。一个 struct ion_handle 实例表示一个 buffer，即 struct ion_buffer 实例。而 struct ion_buffer 就是从 heap，即 struct ion_heap 中分配的内存。</li></ul><h3 id="ion-heap"><a href="#ion-heap" class="headerlink" title="ion_heap"></a>ion_heap</h3><p>struct ion_heap 表示 ION 中的重要概念 heap。系统会通过链表或者红黑树，这取决与你所使用的 KERNEL 版本，来管理所有的 heap，这些 heap 可用 struct ion_device::heaps 字段来寻找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plist_node</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">enum</span> ion_heap_type type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">shrinker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> free_list_size;</span><br><span class="line"><span class="keyword">spinlock_t</span> free_lock;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> waitqueue;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*debug_show)(struct ion_heap *heap, struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>node 成员，是 struct plist_node 结构，用于将本 heap 实例加入到 struct ion_device 所管理的链表中，详情可以参见 ion_device_add_heap() [ion.c] 函数。</li><li>dev 成员，是 struct ion_device 结构体指针类型，用于指示本 heap 挂在哪一个 struct ion_device 实例下了。</li><li>type 成员，是 enum ion_heap_type 类型，用于表示本 heap 属于哪种类型。用户在使用 ION 分配内存时需要指定 heap 的种类。关于本字段，后续会结合使用方法进行更详细的介绍。</li><li>ops 成员，是 struct ion_heap_ops 类型，它很重要！本字段提供的回调函数是用于从本 heap 中分配内存时所时用的。请参见 ion_buffer_create() [ion.c]，它会调用 struct ion_heap_ops::allocate() 等回调函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> (*allocate)(struct ion_heap *heap,</span><br><span class="line">struct ion_buffer *buffer, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">free</span>)(struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">int</span> (*phys)(struct ion_heap *heap, struct ion_buffer *buffer,</span><br><span class="line">    <span class="keyword">ion_phys_addr_t</span> *addr, <span class="keyword">size_t</span> *len);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> * (*<span class="title">map_dma</span>)(<span class="title">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>,</span></span><br><span class="line"><span class="class">     <span class="title">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span>);</span></span><br><span class="line"><span class="keyword">void</span> (*unmap_dma)(struct ion_heap *heap, struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">void</span> * (*map_kernel)(struct ion_heap *heap, struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">void</span> (*unmap_kernel)(struct ion_heap *heap, struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">int</span> (*map_user)(struct ion_heap *mapper, struct ion_buffer *buffer,</span><br><span class="line">struct vm_area_struct *vma);</span><br><span class="line"><span class="keyword">int</span> (*shrink)(struct ion_heap *heap, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">int</span> nr_to_scan);</span><br><span class="line"><span class="keyword">void</span> (*preload) (struct ion_heap *heap, <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct ion_preload_object obj[]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>id 成员，也很重要，它可表示优先级，在分配内存时选择哪一个 heap 有关，必须唯一。</li></ul><h3 id="ion-handle"><a href="#ion-handle" class="headerlink" title="ion_handle"></a>ion_handle</h3><p>struct ion_handle 其实就是表示 buffer，用户空间常用它来表示 buffer。本结构通过 ion_handle_create() [ion.c] 分配、初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_handle</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_client</span> *<span class="title">client</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> kmap_cnt;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ref 成员，是 struct kref 结构类型，它在内核中被广泛的用来表示引用计数。ion_handle 的创建和销毁都与其有关，下文会有介绍。</li><li>client 成员，是 struct ion_client 指针类型，指向其所述的 ion_client 实例。</li><li>buffer 成员，是 struct ion_buffer 指针类型，指向真正的 buffer 所在，它可以说是 stuct ion_handle 的核心成员了。</li></ul><p>下面就来介绍 struct ion_buffer 结构。在分配内存时，也是先通过 ion_buffer_create() 创建 ion_buffer 实例，然后交给 ion_handle_create() 创建 ion_handle 实例。</p><h3 id="ion-buffer"><a href="#ion-buffer" class="headerlink" title="ion_buffer"></a>ion_buffer</h3><p>struct ion_buffer 很重要，通过 ION 分配的内存就是通过它表示的。它和上面提到的 ion_handle 的区别主要在于一个是用户空间使用的，一个是内核空间使用的。即虽然常用的接口函数中使用的是 struct ion_handle，但实际上真正表示内存的其实是 struct ion_buffer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> private_flags;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">void</span> *priv_virt;</span><br><span class="line"><span class="keyword">ion_phys_addr_t</span> priv_phys;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="keyword">int</span> kmap_cnt;</span><br><span class="line"><span class="keyword">void</span> *vaddr;</span><br><span class="line"><span class="keyword">int</span> dmap_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> *<span class="title">sg_table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">vmas</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">iovas</span>;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ref 成员，是 struct kref 结构实例，维护了本 ion_buffer 的引用计数。当引用计数为 0 时会释放该 buffer，即 struct ion_heap_ops::free 会被调用。分配用 ION_IOC_ALLOC 型 ioctl 系统调用，相应的释放用 ION_IOC_FREE 型 ioctl 系统调用。</li><li>size 成员，当然是本 buffer 所表示的空间的大小，用字节表示。</li><li>priv_virt 成员，是所分配内存的虚拟地址啦，它常与 struct sg_table，或者封装它的结构，有关。它不是我们在内核中读写时所需的内核虚拟地址啦，内核虚拟地址使用 vaddr 成员来表示的。一般而言，物理内存不连续的，使用本字段；否则使用下面的 priv_phys 字段，如 struct ion_heap_ops contig_heap_ops。</li><li>priv_phys 成员，表示所分配的内存的物理地址。它适用于分配的物理内存是连续的 ion heap。这种连续的物理内存：在将其映射到用户空间时，即获取用户空间虚拟地址，可以使用 remap_pfn_range() [memory.c] 这个方便的接口；在将其映射到内核空间时，即获取内核虚拟地址，可以使用 vmap() [vmalloc.c] 这个方便的接口。例子详见 struct ion_heap_ops contig_heap_ops [exynos_ion.c]。priv_virt 成员和 priv_phys 成员组成了一个联合体，其实都表示地址，只不过不同的场景下具体用的不一样而已。</li><li>kmap_cnt 成员，记录本 buffer 被映射到内核空间的次数。</li><li>vaddr 成员，是本 buffer 对应的内核虚拟地址。当 kmap_cnt 不为 0 时有效。可以通过 ion_map_kernel() [ion.c] 来获取本 buffer 对应的内核虚拟地址。ion_map_kernel() [ion.c] 实际上调用的是相应 struct ion_heap_ops::map_kernel 回调函数获取相应的虚拟地址的。</li><li>dmap_cnt 成员，记录本 buffer 被 mapped for DMA 的次数。</li><li>sg_table 成员，是 struct sg_table 结构体类型的指针。本字段与 DMA 操作有关，而且仅仅在 dmap_cnt 成员变量不为 0 时是有效的。可以通过 ion_buffer_create() [ion.c] 来初始化本成员变量，该函数实际上是调用相应 ion_heap 所属的 struct ion_heap_ops::map_dma 回调函数获取本字段的值的。</li><li>dirty 成员，表示 bitmask。即以位图表示本 buffer 的哪一个 page 是 dirty 的，即不能直接用于 DMA。dirty 表示 DMA 的不一致性，即 CPU 缓存中的内容与内存中的实际内容不一样。</li></ul><p>事实上，ION 涉及到的数据结构还有很多，这里列举的都是一些非常重要的。<br>下图展示了上文介绍到的数据结构的基本关系。</p><p><img src="/images/posts/2017/11/ION_RELAT.png" alt="ION_RELAT"></p><h2 id="重要函数分析"><a href="#重要函数分析" class="headerlink" title="重要函数分析"></a>重要函数分析</h2><p>函数对数据进行处理，完成特定的任务，体现算法的具体实现。</p><h3 id="ion-device-create"><a href="#ion-device-create" class="headerlink" title="ion_device_create"></a>ion_device_create</h3><p>前面分析 ION 的一些核心数据结构时曾经指出，ION 会注册进 MISC 设备，这样用户空间就可以像使用 MISC 设备一样使用 ION 进行内存分配了。<br>先来看 ION 是如何注册进 MISC 子系统的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ion_device *<span class="title">ion_device_create</span><span class="params">(<span class="keyword">long</span> (*custom_ioctl)</span></span></span><br><span class="line"><span class="function"><span class="params">     (struct ion_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">idev</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 分配 struct ion_device 实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">idev = kzalloc(<span class="keyword">sizeof</span>(struct ion_device), GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如前面所说，dev 成员是 struct miscdevice 结构体类型，</span></span><br><span class="line"><span class="comment">* 这里初始化其相关字段，名字指定为 ”ion”，所以提供</span></span><br><span class="line"><span class="comment">* 给用户空间调用的设备节点名为 /dev/ion。</span></span><br><span class="line"><span class="comment">* 用户空间操作该设备节点时，ION 驱动中响应的函数集位于</span></span><br><span class="line"><span class="comment">* ion_fops</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">idev-&gt;dev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">idev-&gt;dev.name = <span class="string">"ion"</span>;</span><br><span class="line">idev-&gt;dev.fops = &amp;ion_fops;</span><br><span class="line">idev-&gt;dev.parent = <span class="literal">NULL</span>;</span><br><span class="line">ret = misc_register(&amp;idev-&gt;dev);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册调试信息接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">idev-&gt;debug_root = debugfs_create_dir(<span class="string">"ion"</span>, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line">idev-&gt;heaps_debug_root = debugfs_create_dir(<span class="string">"heaps"</span>, idev-&gt;debug_root);</span><br><span class="line">...</span><br><span class="line">idev-&gt;clients_debug_root = debugfs_create_dir(<span class="string">"clients"</span>,</span><br><span class="line">idev-&gt;debug_root);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">debugfs_done:</span><br><span class="line"></span><br><span class="line">idev-&gt;custom_ioctl = custom_ioctl;</span><br><span class="line">idev-&gt;buffers = RB_ROOT;</span><br><span class="line">mutex_init(&amp;idev-&gt;buffer_lock);</span><br><span class="line">init_rwsem(&amp;idev-&gt;lock);</span><br><span class="line">plist_head_init(&amp;idev-&gt;heaps);</span><br><span class="line">idev-&gt;clients = RB_ROOT;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* backup of ion device: assumes there is only one ion device */</span></span><br><span class="line">g_idev = idev;</span><br><span class="line"><span class="keyword">return</span> idev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本函数最重要的是分配并初始化了核心 struct ion_device 实例，并将其和 MISC 设备结合起来，这样用户空间就可以通过 open()、ioctl() 等系统调用使用它了。</p><h3 id="ion-open"><a href="#ion-open" class="headerlink" title="ion_open"></a>ion_open</h3><p>用户空间要想使用 ION 进行内存分配，首先必须对设备节点 /dev/ion 进行 open() 系统调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ion_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> *<span class="title">miscdev</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span> = <span class="title">container_of</span>(<span class="title">miscdev</span>, <span class="title">struct</span> <span class="title">ion_device</span>, <span class="title">dev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_client</span> *<span class="title">client</span>;</span></span><br><span class="line"><span class="keyword">char</span> debug_name[<span class="number">64</span>];</span><br><span class="line">…</span><br><span class="line"><span class="built_in">snprintf</span>(debug_name, <span class="number">64</span>, <span class="string">"%u"</span>, task_pid_nr(current-&gt;group_leader));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建struct ion_client 实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">client = ion_client_create(dev, debug_name);</span><br><span class="line">...</span><br><span class="line">file-&gt;private_data = client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ion_open() 函数最重要的作用就是创建了 struct ion_client 实例。这样，后续就可以利用 ioctl 系统调用从其中分配内存了。</p><p>ION 系统提供的 ioctl 类型有很多，常用的有 ION_IOC_ALLOC、ION_IOC_FREE、ION_IOC_SHARE 和 ION_IOC_IMPORT 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_ALLOC_IOWR(ION_IOC_MAGIC, 0, struct ion_allocation_data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_FREE_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_SHARE_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)</span></span><br></pre></td></tr></table></figure><p>下面就抽出几个典型的进行分析。</p><h3 id="ion-alloc"><a href="#ion-alloc" class="headerlink" title="ion_alloc"></a>ion_alloc</h3><p>这是当用户空间执行 ION_IOC_ALLOC 型 ioctl() 系统调用时所执行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ion_handle *<span class="title">ion_alloc</span><span class="params">(struct ion_client *client, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">int</span> heap_id_mask,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span> = <span class="title">client</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* len 是用户空间想分配的内存大小，驱动中会将其进行页对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">len = PAGE_ALIGN(len);</span><br><span class="line">...</span><br><span class="line">down_read(&amp;dev-&gt;lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用户空间会指定其想从哪种 heap 分配内存，ION 驱动</span></span><br><span class="line"><span class="comment">* 会对其进行检查并找到最合适的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">heap_id_mask = ion_parse_heap_id(heap_id_mask, flags);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从系统所有的 heap 中找到最合适的 heap 并分配内存，</span></span><br><span class="line"><span class="comment">* 创建 struct ion_buffer 实例。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">plist_for_each_entry(heap, &amp;dev-&gt;heaps, node) &#123;</span><br><span class="line"><span class="comment">/* if the caller didn't specify this heap id */</span></span><br><span class="line"><span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; heap-&gt;id) &amp; heap_id_mask))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">buffer = ion_buffer_create(heap, dev, len, align, flags);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(buffer))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">up_read(&amp;dev-&gt;lock);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在对创建的 ion_buffer 实例进行了一系列的 sanity 检查后</span></span><br><span class="line"><span class="comment">* 利用其创建 struct ion_handle 实例。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">handle = ion_handle_create(client, buffer);</span><br><span class="line">...</span><br><span class="line">mutex_lock(&amp;client-&gt;lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将 struct ion_handle 实例加入到其所属的 struct ion_client</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ret = ion_handle_add(client, handle);</span><br><span class="line">mutex_unlock(&amp;client-&gt;lock);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ion-free"><a href="#ion-free" class="headerlink" title="ion_free"></a>ion_free</h3><p>这是当用户空间执行 ION_IOC_FREE 型 ioctl() 系统调用时所执行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ion_free</span><span class="params">(struct ion_client *client, struct ion_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> valid_handle;</span><br><span class="line"></span><br><span class="line">BUG_ON(client != handle-&gt;client);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;client-&gt;lock);</span><br><span class="line">valid_handle = ion_handle_validate(client, handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!valid_handle) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">"%s: invalid handle passed to free.\n"</span>, __func__);</span><br><span class="line">mutex_unlock(&amp;client-&gt;lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;client-&gt;lock);</span><br><span class="line">ion_handle_put(client, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数比较简单，重点就是通过 ion_handle_put() 来对上文提到的 struct ion_handle::ref 这个 reference count 减一，当 ref 减到 0 时，就会调用 ion_handle_destroy() 来销毁 ion_handle 实例。</p><p>从前文的分析可知，用户空间在利用 ION 分配内存时，需要指定具体的 heap mask，即告知 ION 想从哪种 heap 分配内存。<br>下面就来介绍下。</p><h2 id="HEAP-种类"><a href="#HEAP-种类" class="headerlink" title="HEAP 种类"></a>HEAP 种类</h2><p>以下是通过 ION 分配内存时，可能会使用到的 heap mask。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_SYSTEM_MASK            (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_SYSTEM_CONTIG_MASK     (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_EXYNOS_CONTIG_MASK     (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_EXYNOS_MASK            (1 &lt;&lt; 5)</span></span><br></pre></td></tr></table></figure><p>以 M65 项目为例，系统定义了 4 种 heap，见 dev-ion.c。</p><h3 id="ION-HEAP-TYPE-SYSTEM"><a href="#ION-HEAP-TYPE-SYSTEM" class="headerlink" title="ION_HEAP_TYPE_SYSTEM"></a>ION_HEAP_TYPE_SYSTEM</h3><p>本 heap 的名字为：”ion_noncontig_heap”。相应的 heap mask 为 1，即 ION_HEAP_SYSTEM_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops system_heap_ops [ion_system_heap.c]<br>其内存可以从 HIGHMEM 中分配，所以其物理内存可能不连续。<br>在调试 M65 CAMERA 的 HDR 功能时，一开始发现其写入速度很慢很慢，经过调查，后来在通过 ION 分配内存时指定 ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC | ION_FLAG_PRESERVE_KMAP 标志后速度得到明显提高。</p><h3 id="ION-HEAP-TYPE-SYSTEM-CONTIG"><a href="#ION-HEAP-TYPE-SYSTEM-CONTIG" class="headerlink" title="ION_HEAP_TYPE_SYSTEM_CONTIG"></a>ION_HEAP_TYPE_SYSTEM_CONTIG</h3><p>本 heap 的名字为：”ion_contig_heap”，相应的 heap mask 为 2，即 ION_HEAP_SYSTEM_CONTIG_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops kmalloc_ops [ion_system_heap.c]<br>其内存分配 allocate 回调函数为：ion_system_contig_heap_allocate() [ion_system_heap.c]，该函数很简单，就是利用 kzalloc() 分配内存。</p><h3 id="ION-HEAP-TYPE-EXYNOS"><a href="#ION-HEAP-TYPE-EXYNOS" class="headerlink" title="ION_HEAP_TYPE_EXYNOS"></a>ION_HEAP_TYPE_EXYNOS</h3><p>本 heap 的名字为：”exynos_noncontig_heap”，相应的 heap mask 为 32，即 ION_HEAP_EXYNOS_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops vmheap_ops [exynos_ion.c]<br>其内存可以从 HIGHMEM 中分配，所以其物理内存不一定连续。详情可以见其 allocate 回调函数 ion_exynos_heap_allocate() [exynos_ion.c]。</p><h3 id="ION-HEAP-TYPE-EXYNOS-CONTIG"><a href="#ION-HEAP-TYPE-EXYNOS-CONTIG" class="headerlink" title="ION_HEAP_TYPE_EXYNOS_CONTIG"></a>ION_HEAP_TYPE_EXYNOS_CONTIG</h3><p>本 heap 的名字为：”exynos_contig_heap”。相应的 heap mask 为 16，即 ION_HEAP_EXYNOS_CONTIG_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops contig_heap_ops [exynos_ion.c]<br>内存由 CMA 分配，所以可以保证其物理地址是连续的。详情可以参见其 allocate 回调函数 ion_exynos_contig_heap_allocate() [exynos_ion.c]。<br>因为本函数是利用 CMA 分配内存，所以可以推测肯定有地方预留了 CMA 所需的物理内存。分析代码后可以发现，这个地方就位于 mach-m65.c 文件。<br>M65 的相机驱动使用了本 ION_HEAP_TYPE_EXYNOS_CONTIG 类型的 heap 来分配内存。<br>按道理，当用户空间获取了 struct ion_handle 实例后，就已经完成了 ION 内存的分配任务。但实际上，为了在不同的进程间，甚至在用户空间和内核空间共享这段内存使用，用户空间还通常需要调用 ION_IOC_SHARE 型ioctl()，获取 ion buffer 相关的 fd，这就和 dma_buf 子系统联系起来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ion_share_dma_buf_fd</span><span class="params">(struct ion_client *client, struct ion_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_buf</span> *<span class="title">dmabuf</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 前面已经说过 struct ion_handle 其实就是对 struct ion_buffer</span></span><br><span class="line"><span class="comment">* 的封装，这里利用 struct ion_client 实例和 struct ion_handle 实例</span></span><br><span class="line"><span class="comment">* 创建了一个 dma_buf。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dmabuf = ion_share_dma_buf(client, handle);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 重要，这样就将 struct ion_buffer 对应的内存转化</span></span><br><span class="line"><span class="comment">* 为文件描述符了。将文件描述符传递给其它进程或者</span></span><br><span class="line"><span class="comment">* 传给内核空间，其它进程或者内核空间就可以使用其内存了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fd = dma_buf_fd(dmabuf, O_CLOEXEC);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，ION 使用过程中涉及到的重要函数都已经介绍完全。当然要完全理解这些函数的细节，需要用户对 dma_buffer 有一定的了解。对 dma_buffer 的介绍不属于本文的范围，有兴趣的话可以参见我写的其它相关文档。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于 Android ION 内存管理机制的介绍就到这里。本文先介绍了什么是 ION，为什么要用 ION。ION 是为了解决内存碎片管理而引入的通用内存管理器，用于取代 PMEM 机制。然后介绍了下 ION 中的重要数据结构，对 struct ion_device、struct ion_client、struct ion_heap、struct ion_handle 和 struct ion_buffer 进行了详细的介绍，并对它们之间的关系进行了阐述。接着，从使用 ION 的场景出发，介绍了一些重要的函数，例如 ion_alloc()，并以实际的相机开发为例介绍了系统中各个 ion_heap 的种类和各自的内存特性。本文还对进程之间、内核空间和用户空间之间的内存共享进行了介绍。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lwn.net/Articles/480055/" target="_blank" rel="noopener">The Android ION memory allocator</a></li><li><a href="https://lwn.net/Articles/565469/" target="_blank" rel="noopener">Integrating the ION memory allocator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 多媒体 </tag>
            
            <tag> ION </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android MTP 分析</title>
      <link href="/2017/11/06/11-52-11-mtp/"/>
      <url>/2017/11/06/11-52-11-mtp/</url>
      
        <content type="html"><![CDATA[<h2 id="mtp简介"><a href="#mtp简介" class="headerlink" title="mtp简介"></a>mtp简介</h2><p>MTP，全称是 Media Transfer Protocol（媒体传输协议）。它是微软的一个为计算机和便携式设备之间传输图像、音乐等所定制的协议。</p><p>Android 从3.0开始支持 MTP。MTP 的应用分两种角色，一个是作为 Initiator，另一个作为 Responder 。以”Android 平板电脑”连接 PC 为例，他们的关系如图所示。</p><p><img src="/images/posts/2017/11/2.png" alt="mtp_2"></p><p>Initiator —— 在 MTP 中所有的请求都有 Initiator 发起。例如，PC 请求获取 Android 平板电脑上的文件数据。</p><p>Responder —— 它会处理 Initiator 的请求；除此之外，Responder 也会发送 Event 事件。</p><p>这里要注意的是：对于一个 MTP 事件，比如从 PC 拷贝数据到 Android 手机中，整个数据处理是双向通信的。</p><h2 id="mtp-框架"><a href="#mtp-框架" class="headerlink" title="mtp 框架"></a>mtp 框架</h2><p>来张经典的 Android 框架图：</p><p><img src="/images/posts/2017/11/1.jpg" alt="mtp_frame"></p><p>从图中可以看到，在 kernel 层中分为 MTP 驱动和 USB 驱动，其实呢，真正和底层直接通信的依然是 USB 驱动负责，MTP 驱动只是负责将数据进行打包封装，然后作为一层分别与上层和 USB 之间进行通信。</p><p>再来看一下 JNI 层，那，如果要对 MTP 进行定制化的开发，这一层就需要额外的关注了。相关的源码位置位于：frameworks/av/media/mtp frameworks/base/media/jni/目录下</p><p>在 JNI 层，MtpServer 会不断地监听 Kernel 的消息”MTP 请求”，并对相应的消息进行相关处理。同时，MTP 的 Event 事件也是通过 MtpServer 发送给 MTP 驱动的。 MtpStorage 对应一个”存储单元”；例如，SD 卡就对应一个 MtpStorage。 MtpPacket 和 MtpEventPacket 负责对 MTP 消息进行打包。android_mtp_MtpServer 是一个 JNI 类，它是”JNI 层的 MtpServer 和 Java 层的 MtpServer “沟通的桥梁。android_mtp_MtpDatabase 也是一个 JNI 类，JNI 层通过它实现了对 MtpDatabase (Framework 层)的操作。</p><p>在 Framework 层，MtpServer 相当于一个服务器，它通过和底层进行通信从而提供了 MTP 的相关服务。MtpDatabase 充当着数据库的功能，但它本身并没有数据库对数据进行保存，本质上是通过 MediaProvider 数据库获取所需要的数据。MtpStorage 对应一个”存储单元”，它和”JNI 层的 MtpStorage”相对应。</p><p>在 Apiplication 层，MtpReceiver 负责接收广播，接收到广播后会启动/关闭 MtpService；例如，MtpReceiver 收到 “Android 设备和 PC 连上”的消息时，会启动 MtpService。 MtpService 的作用是提供管理 MTP 的服务，它会启动 MtpServer，以及将本地存储内容和MTP的内容同步。 MediaProvider 在 MTP 中的角色，是本地存储内容查找和本地内容同步；例如，本地新增一个文件时，MediaProvider 会通知 MtpServer 从而进行 MTP 数据同步。</p><h2 id="mtp-移植教程"><a href="#mtp-移植教程" class="headerlink" title="mtp 移植教程"></a>mtp 移植教程</h2><p>说了那么多，那如何在 linux 中移植 MTP 协议呢？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pipe(mtppipe) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    LOGE(<span class="string">"Error creating MTP pipe\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* To enable MTP debug, use the twrp command line feature to</span></span><br><span class="line"><span class="comment"> * twrp set tw_mtp_debug 1</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="comment">//DIR* source=opendir("/tmp");</span></span><br><span class="line"><span class="comment">//DIR* destination=opendir("/data/media/0/backup");</span></span><br><span class="line"><span class="comment">//copy_folder("/tmp","/data/media/0/backup");</span></span><br><span class="line">twrpMtp *mtp = <span class="keyword">new</span> twrpMtp(<span class="number">0</span>);</span><br><span class="line">mtppid = mtp-&gt;forkserver(mtppipe);</span><br><span class="line"><span class="comment">//property_set("sys.usb.config", "mtp,adb");</span></span><br><span class="line"><span class="keyword">if</span> (mtppid) &#123;</span><br><span class="line">    close(mtppipe[<span class="number">0</span>]); <span class="comment">// Host closes read side</span></span><br><span class="line">    mtp_write_fd = mtppipe[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//DataManager::SetValue("tw_mtp_enabled", 1);</span></span><br><span class="line">    <span class="comment">//Add_All_MTP_Storage();</span></span><br><span class="line">    Add_Remove_MTP_Storage(MTP_MESSAGE_ADD_STORAGE);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(mtppipe[<span class="number">0</span>]);</span><br><span class="line">    close(mtppipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//gui_err("mtp_fail=Failed to enable MTP");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先 fork 了进程，通过管道进行通信。那先来看一下父进程做了什么？很简单，初始化了 mtp_message 这个结构体，然后写进 mtp_write_fd ，供子进程读取。该结构体便是控制设备在 PC 端的显示 storage_id 表示该 MTP 设备的 ID 号，path 表示挂载的目录，maxFileSize 表示文件挂载的大小，该值为0表示挂载的大小不做限制，display 是该设备在 PC 端显示的名称<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LOGI(<span class="string">"a[] = %s\n"</span>,a);</span><br><span class="line">LOGI(<span class="string">"mtp_display = %s\n"</span>,mtp_display);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mtp_test=a;</span><br><span class="line">mtp_message.message_type = MTP_MESSAGE_ADD_STORAGE;</span><br><span class="line">mtp_message.storage_id = <span class="number">1</span>;</span><br><span class="line">mtp_message.path = <span class="string">"/data/media/0"</span>;</span><br><span class="line">mtp_message.maxFileSize = <span class="number">0</span>;</span><br><span class="line">mtp_message.display = PROJECT_NAME;</span><br><span class="line">LOGI(<span class="string">"TEST MTP_DISPLAy\n"</span>);</span><br><span class="line">LOGI(<span class="string">"sending message to add %i '%s' '%s'\n"</span>, mtp_message.storage_id, mtp_message.path, mtp_message.display);</span><br><span class="line"><span class="keyword">if</span> (write(mtp_write_fd, &amp;mtp_message, <span class="keyword">sizeof</span>(mtp_message)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    LOGI(<span class="string">"error sending message to add storage %i\n"</span>, mtp_message.storage_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGI(<span class="string">"Message sent, add storage ID: %i\n"</span>,mtp_message.storage_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>分析了父进程的流程，再来分析一下子进程所做的事情，MTP 的整个流程都在这了，很简单，主要就几句代码，可是就这几句代码，揭示了 MTP 的大致思想。首先实例化了一个 twmtp_MtpServer，这里的 twmtp_MtpServer 是个性化制定的设备信息（mtp_MtpServer.cpp 和 MtpServer.cpp 的区别）。之后 set_storages，注意了，就是这里，父进程中的写进去的 mtp_message 就是从这里开始读了，上文我们说道了 MtpStorage 对应一个”存储单元”就是在这里体现了,之后会调用 add_storage 函数将父进程读到的信息写入，这样子一个 MtpStorage 就创建。set_read_pipe 指定了读取的管道，这样子就和父进程建立起了链接，之后 mtp-&gt;start，开始启动 MTP 服务了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twrpMtp::start</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    MTPI(<span class="string">"Starting MTP\n"</span>);</span><br><span class="line">    twmtp_MtpServer *mtp = <span class="keyword">new</span> twmtp_MtpServer();</span><br><span class="line">    mtp-&gt;set_storages(mtpstorages);</span><br><span class="line">    mtp-&gt;set_read_pipe(mtp_read_pipe);</span><br><span class="line">    mtp-&gt;start();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来看一下 start 函数，是否使用 PTP（英语“图片传输协议(picture transfer protocol)”的缩写，手机连接之后可选，用于传输图片），实例化一个 MtpDatabase ，MtpDatabase 在 MTP 中，充当着数据库的功能。但它本身并没有数据库对数据进行保存，本质上是通过 MediaProvider 数据库获取所需要的数据。例如，当在 PC 上，需要读取某个文件时，MtpDatabase 会在 MediaProvider 数据库中查询出文件的相关信息(包括文件名、大小、扩展名等)；然后将这些信息交给 MtpServer，MtpServer 将消息传递给 JNI，在 JNI 中会通过文件名打开，然后再文件句柄等信息传递给 Kernel；Kernel 根据文件句柄读取文件信息，并传给 PC。</p><p>之后打开 mtp 驱动创建的设备节点 /dev/mtp_usb ，底层驱动我们待会分析。</p><p>然后<code>server = new MtpServer(mtpdb, usePtp, 0, 0664, 0775);</code>到这里，终于看到 MTP 协议相关的 server 了，整个 MTP 定义的协议都在这个 class 当中了，这个是 MTP 最核心的东西了。</p><p>add_storage();前文提到，就是在这里将我们初始化的 MtpStorage 加入咯</p><p><code>ThreadPtr mtpptr = &amp;twmtp_MtpServer::mtppipe_thread;</code>喏，这里就是读取那个 mtp_message 了，通过创建了一个线程，用于不断读取管道的数据来添加 mtp 设备<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twmtp_MtpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    usePtp =  <span class="literal">false</span>;</span><br><span class="line">    MyMtpDatabase* mtpdb = <span class="keyword">new</span> MyMtpDatabase();</span><br><span class="line">    <span class="comment">/* Sleep for a bit before we open the MTP USB device because some</span></span><br><span class="line"><span class="comment">     * devices are not ready due to the kernel not responding to our</span></span><br><span class="line"><span class="comment">     * sysfs requests right away.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    usleep(<span class="number">800000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USB_MTP_DEVICE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIFY(x) #x </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND(x) STRINGIFY(x)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mtp_device = EXPAND(USB_MTP_DEVICE);</span><br><span class="line">    MTPI(<span class="string">"Using '%s' for MTP device.\n"</span>, EXPAND(USB_MTP_DEVICE));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>   </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mtp_device = <span class="string">"/dev/mtp_usb"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//fp_mtp =fopen( "/recovery/mtp.log", "a+" );</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(mtp_device, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        MTPE(<span class="string">"could not open MTP driver, errno: %d\n"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    MTPD(<span class="string">"fd: %d\n"</span>, fd);</span><br><span class="line">    server = <span class="keyword">new</span> MtpServer(mtpdb, usePtp, <span class="number">0</span>, <span class="number">0664</span>, <span class="number">0775</span>);</span><br><span class="line">    refserver = server;</span><br><span class="line">    MTPI(<span class="string">"created new mtpserver object\n"</span>);</span><br><span class="line">    add_storage();</span><br><span class="line">    MTPD(<span class="string">"Starting add / remove mtppipe monitor thread\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    ThreadPtr mtpptr = &amp;twmtp_MtpServer::mtppipe_thread;</span><br><span class="line">    PThreadPtr p = *(PThreadPtr*)&amp;mtpptr;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, p, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// This loop restarts the MTP process if the device is unplugged and replugged in</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        server-&gt;run(fd);</span><br><span class="line">        fd = open(mtp_device, O_RDWR);</span><br><span class="line">        usleep(<span class="number">800000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看看 run(fd);函数中的上半段，首先调用 read 函数从 /dev/mtp_usb 中读取数据存入到 mBuffer（实际调用的是 MtpDataPacket::read 函数，该函数还初始化了 mPacketSize，mOffset 两个变量），之后调用了<code>mRequest.getOperationCode</code> <code>mRequest.getTransactionID()</code>两个函数，打开看一下，其实就是对 mBuffer 里面的数据进行处理，要分析为什么这么来的，那就得看 MTP 数据包协议了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MtpServer::run</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mFD = fd;</span><br><span class="line">    MTPI(<span class="string">"MtpServer::run fd: %d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        MTPD(<span class="string">"About to read device...\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = mRequest.read(fd);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ECANCELED) &#123;</span><br><span class="line">                <span class="comment">// return to top of loop and wait for next command</span></span><br><span class="line">                MTPD(<span class="string">"request read returned %d ECANCELED, starting over\n"</span>, ret);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MTPE(<span class="string">"request read returned %d, errno: %d, exiting MtpServer::run loop\n"</span>, ret, errno);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MtpOperationCode operation = mRequest.getOperationCode();</span><br><span class="line">        MtpTransactionID transaction = mRequest.getTransactionID();</span><br><span class="line"></span><br><span class="line">        MTPD(<span class="string">"operation: %s"</span>, MtpDebug::getOperationCodeName(operation));</span><br><span class="line">        mRequest.dump();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// FIXME need to generalize this</span></span><br><span class="line">        <span class="keyword">bool</span> dataIn = (operation == MTP_OPERATION_SEND_OBJECT_INFO</span><br><span class="line">                    || operation == MTP_OPERATION_SET_OBJECT_REFERENCES</span><br><span class="line">                    || operation == MTP_OPERATION_SET_OBJECT_PROP_VALUE</span><br><span class="line">                    || operation == MTP_OPERATION_SET_DEVICE_PROP_VALUE);</span><br><span class="line">        <span class="keyword">if</span> (dataIn) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = mData.read(fd);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == ECANCELED) &#123;</span><br><span class="line">                    <span class="comment">// return to top of loop and wait for next command</span></span><br><span class="line">                    MTPD(<span class="string">"data read returned %d ECANCELED, starting over\n"</span>, ret);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                MTPD(<span class="string">"data read returned %d, errno: %d, exiting MtpServer::run loop\n"</span>, ret, errno);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MTPD(<span class="string">"received data:"</span>);</span><br><span class="line">            mData.dump();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mData.reset();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之后 handleRequest 函数用于处理读到的不同的操作进行不同的操作，每个函数内容都比较多，这里就分析一下从 PC 端拷贝一个数据到手机上的操作，主要做了以下操作,打开看一下，其实都是一些用于解析数据头，之后解析数据的问题了，有兴趣去了解 MTP 协议相关的东西，可以参考去查看一下<a href="https://en.wikipedia.org/wiki/Media_Transfer_Protocol" target="_blank" rel="noopener">mtp wiki</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MTP_OPERATION_SEND_OBJECT_INFO:</span><br><span class="line">    MTPE(<span class="string">"about to call doSendObjectInfo()\n"</span>);</span><br><span class="line">    <span class="comment">//response = MTP_RESPONSE_OBJECT_WRITE_PROTECTED;</span></span><br><span class="line">    response = doSendObjectInfo();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MTP_OPERATION_SEND_OBJECT:</span><br><span class="line">    MTPE(<span class="string">"about to call doSendObject()\n"</span>);</span><br><span class="line">    <span class="comment">//response = MTP_RESPONSE_OBJECT_WRITE_PROTECTED;</span></span><br><span class="line">    response = doSendObject();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><h2 id="mtp-与-kernel-层通信"><a href="#mtp-与-kernel-层通信" class="headerlink" title="mtp 与 kernel 层通信"></a>mtp 与 kernel 层通信</h2><p>kernel 层 MTP 相关的代码在<code>drivers/usb/gadget/function/f_mtp.c</code>中，通过这部分代码，成功创建了 /dev/mtp_usb 节点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file operations for /dev/mtp_usb */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mtp_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read = mtp_read,</span><br><span class="line">    .write = mtp_write,</span><br><span class="line">    .unlocked_ioctl = mtp_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_ioctl = compat_mtp_ioctl,</span><br><span class="line">#endif</span><br><span class="line">    .open = mtp_open,</span><br><span class="line">    .release = mtp_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">mtp_device</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = mtp_shortname,</span><br><span class="line">    .fops = &amp;mtp_fops,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __mtp_setup(struct mtp_instance *fi_mtp)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = misc_register(&amp;mtp_device);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 file_operations 可以知道，上层调用的 write 函数在 kernel 层实则调用的是 mtp_write 函数。现在我们主要来关注一下 mtp_read、mtp_write 这两个函数的实现。</p><ul><li>先来看一下 mtp_write()，主要的几个处理 copy_from_user(req-&gt;buf, buf, xfer) 首先会将用户空间的请求传入到 req-&gt;buf 中，之后通过 usb_ep_queue 函数将 req 中的消息传入到 USB 消息队列中，由 USB 驱动进行之后的数据传送，至于 mtp_write 函数的其他部分都是些对数据处理的过程。总的来说，mtp_write 会将”用户空间”发来的消息拷贝到”内核空间”，并将该消息打包；然后，将打包好的消息添加到 USB 消息队列中。USB 驱动负责将消息队列中的消息传递给 PC<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mtp_write</span><span class="params">(struct file *fp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span> || sendZLP) &#123;</span><br><span class="line"><span class="keyword">if</span> (xfer &amp;&amp; copy_from_user(req-&gt;buf, buf, xfer)) &#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">ret = usb_ep_queue(dev-&gt;ep_in, req, GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>再来看一下 mtp_read() 函数,其实就是 mtp_write() 的逆过程，先从 usb 消息队列中读取 pc 发送给 Android 设备的请求并保存在 req 中，之后等待 read_wq 工作队列将已有的消息处理完毕，最后将 pc 的请求数据通过 copy_to_user 拷贝到用户空间。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mtp_read</span><span class="params">(struct file *fp, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">ret = usb_ep_queue(dev-&gt;ep_out, req, GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">ret = wait_event_interruptible(dev-&gt;read_wq,</span><br><span class="line">                dev-&gt;rx_done || dev-&gt;state != STATE_BUSY);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, req-&gt;buf, xfer))</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>其实通过全文的分析，MTP 协议并没有想象中那么复杂，只是对数据进行了封装，整个数据的传送过程实质还是通过 USB 协议进行的。至于在开发中碰到的数据处理问题，需要的是多去了解 MTP 协议的具体内容而已。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>samsung uboot fastboot command</title>
      <link href="/2017/09/07//samsun-uboot-fastboot-command.html/"/>
      <url>/2017/09/07//samsun-uboot-fastboot-command.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1-fastboot协议"><a href="#1-fastboot协议" class="headerlink" title="1 fastboot协议"></a>1 fastboot协议</h2><p>fastboot 协议是一种通过 usb 连接 pc 和 bootloader 的机制。他被设计的非常容易实现，能够用于多种设备和运行于 Linux、Windows 或者 OSX 的主机。下面将会讲述 pc 和 bootloader 如何通信，以 fastboot flash 命令举例。</p><h3 id="1-1-pc-端"><a href="#1-1-pc-端" class="headerlink" title="1.1 pc 端"></a>1.1 pc 端</h3><p>假设烧写的镜像名为 uboot.bin，烧写的分区名为 bootloader。fastboot flash 命令并会被解析为多个命令。<br>步骤一：pc 发送命令 getvar:partition-type:bootloader<br>pc 发送的第一个命令，获取分区类型，如果你是某种特殊的类型，如 “ext4”。那么 pc 端会发送擦除这个分区的命令，然后在烧写一个 ext4 的类型的镜像进去。此处要烧写的分区是 bootloader，他没有特殊的格式，那么 uboot 就没有回应。<br>步骤二：pc 发送命令 getvar:max-download-size<br>在bootloader 中有一个接受数据的 buffer。这条命令就是获取这个 buffer 的大小。如果 buffer 太小那么 pc 就会把镜像拆分，分段发送。<br>步骤三：pc 发送命令 download:01fbe8b2<br>给出这条命令的时候就是告诉 bootloader，我（pc）现在要发送数据了。接着就是数据的传输过程了。download 命令后面的数据表示发送的数据的大小。<br>步骤四：pc 发送命令 flash:bootloader<br>告诉 bootloader 将发送的数据写到 bootloader 分区中去。如果在写数据的时候发现分区大小比数据大小要小，那么此时就会报错。</p><h3 id="1-2-bootloader-的回应"><a href="#1-2-bootloader-的回应" class="headerlink" title="1.2 bootloader 的回应"></a>1.2 bootloader 的回应</h3><p>bootloader 是被动响应 pc 发送过来的指令。它给 pc 回应信息是一个不大于 64 个字节的包响应， 响应包开头四个字节是 “OKAY”、“FAIL”、“DATA” 或者 “INFO”。<br>        a.INFO：表示信心应该被显示<br>        b.FAIL ：表示命令执行失败<br>        c.OKAY：表示命令执行成功<br>        d.DATA：表示请求的命令已经为数据阶段做好准备<br>对于 pc 端发送过来的命令，bootloader 都会发送响应消息。响应消息的头部就是上述4个中的一个，具体用哪个是具体情况而定。</p><h2 id="2-fastboot-命令"><a href="#2-fastboot-命令" class="headerlink" title="2 fastboot 命令"></a>2 fastboot 命令</h2><p>github 上的 uboot 源码中是没有实现 fastboot 的。这部分是由芯片厂商提供的。此处说的是三星在 uboot 中实现的 fastboot 命令。命令的入口函数为 do_fastboot。因为 usb 设备方面的初始化由芯片厂商完成，所以 usb初始化部分将不是本次讨论的重点。我们将重点关注 fastboot 的流程和其 download 机制。</p><h3 id="2-1-fastboot-的-main-loop"><a href="#2-1-fastboot-的-main-loop" class="headerlink" title="2.1 fastboot 的 main loop"></a>2.1 fastboot 的 main loop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">continue_from_disconnect &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* Initialize the board specific support *&#x2F;</span><br><span class="line">if (0 &#x3D;&#x3D; fastboot_init(&amp;interface))</span><br><span class="line">&#123;</span><br><span class="line">int poll_status, board_poll_status;</span><br><span class="line"></span><br><span class="line">&#x2F;* If we got this far, we are a success *&#x2F;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">timeout_endtime &#x3D; get_ticks();</span><br><span class="line">timeout_endtime +&#x3D; timeout_ticks;</span><br><span class="line"></span><br><span class="line">LCD_turnon();</span><br><span class="line"></span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">uint64_t current_time &#x3D; 0;</span><br><span class="line">poll_status &#x3D; fastboot_poll();</span><br><span class="line"></span><br><span class="line">if (1 &#x3D;&#x3D; check_timeout)</span><br><span class="line">current_time &#x3D; get_ticks();</span><br><span class="line"></span><br><span class="line">&#x2F;* Check if the user wanted to terminate with ^C *&#x2F;</span><br><span class="line">if ( ((poll_status !&#x3D; FASTBOOT_OK) &amp;&amp; (ctrlc())) || gflag_reboot)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Fastboot ended by user\n&quot;);</span><br><span class="line">continue_from_disconnect &#x3D; 0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (FASTBOOT_ERROR &#x3D;&#x3D; poll_status)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Error *&#x2F;</span><br><span class="line">printf(&quot;Fastboot error \n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else if (FASTBOOT_DISCONNECT &#x3D;&#x3D; poll_status)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* break, cleanup and re-init *&#x2F;</span><br><span class="line">printf(&quot;Fastboot disconnect detected\n&quot;);</span><br><span class="line">continue_from_disconnect &#x3D; 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else if ((1 &#x3D;&#x3D; check_timeout) &amp;&amp;</span><br><span class="line">   (FASTBOOT_INACTIVE &#x3D;&#x3D; poll_status))</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* No activity *&#x2F;</span><br><span class="line">if (current_time &gt;&#x3D; timeout_endtime)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Fastboot inactivity detected\n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Something happened *&#x2F;</span><br><span class="line">&#x2F;* Actual works of parsing are done by rx_handler *&#x2F;</span><br><span class="line">if (1 &#x3D;&#x3D; check_timeout)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Update the timeout endtime *&#x2F;</span><br><span class="line">timeout_endtime &#x3D; current_time;</span><br><span class="line">timeout_endtime +&#x3D; timeout_ticks;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">board_poll_status &#x3D; board_fastboot_poll();</span><br><span class="line">if (BOARD_FASTBOOT_DISCONNECT &#x3D;&#x3D; board_poll_status)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Fastboot disconnect detected by board action\n&quot;);</span><br><span class="line">continue_from_disconnect &#x3D; 0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; &#x2F;* while (1) *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Reset the board specific support *&#x2F;</span><br><span class="line">fastboot_shutdown();</span><br><span class="line"></span><br><span class="line">LCD_setfgcolor(0x000010);</span><br><span class="line">LCD_setleftcolor(0x000010);</span><br><span class="line">LCD_setprogress(100);</span><br><span class="line"></span><br><span class="line">&#x2F;* restart the loop if a disconnect was detected *&#x2F;</span><br><span class="line">&#125; while (continue_from_disconnect);</span><br></pre></td></tr></table></figure><p>上面是 do_fastboot() 函数的主体部分。当调用 do_fastbboot() 函数时给出了第三个参数时候，那么这个值将被解析为超时时间，但是一般都没有传入第三个参数，所以关于超时的检测可以自动屏蔽了。fastboot_init() 函数，完成 usb 硬件设备相关的的初始化。设置了 serial number 以及接受数据的 buffer 的大小。此处的 buffer 和在 rx_handler() 中提及的 buffer 不同。</p><p>while(1) 循环是一直在运行的，除非是检测到了 ctrl+c。通过检测某个中断位是否置 1，判断 pc 是否有消息发送过来，若是有命令发送过来那么将执行 rx_handler() 函数。这个功能是通过函数 fastboot_poll() 函数来实现的。</p><h3 id="2-2-rx-handler"><a href="#2-2-rx-handler" class="headerlink" title="2.2 rx_handler()"></a>2.2 rx_handler()</h3><p>这个函数有两个参数，第一个参数 const unsigned char *buffer 表示接收到的数据在内存中的地址,第二个参数 unsigned int buffer_size 表示接收到的数据大小。 从这个函数的结构来看，它起初并不知道传进来的是命令还是数据，所以命令和数据都是通过一个 buffer 来接受的。那么他是如何实现下载这项功能的呢？</p><h4 id="2-2-1-数据下载"><a href="#2-2-1-数据下载" class="headerlink" title="2.2.1 数据下载"></a>2.2.1 数据下载</h4><p>在前面说过 pc 端在发送数据之前先发送了 download:01fbe8b2 命令，后面接的是即将发送的数据的大小。  rx_handler() 函数会去处理 download 命令，将即将接收的数据大小放在静态变量 download_size 中。 download 命令处理完成，rx_handler() 函数返回。pc 端开始发送数据，buffer 填充满了之后再调用 rx_handler()函数，此时 download_size 的值不为 0，那么就代表此时接收到的是数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">if (download_size)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Something to download *&#x2F;</span><br><span class="line"></span><br><span class="line">if (buffer_size)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Handle possible overflow *&#x2F;</span><br><span class="line">unsigned int transfer_size &#x3D; download_size - download_bytes;</span><br><span class="line"></span><br><span class="line">if (buffer_size &lt; transfer_size)</span><br><span class="line">transfer_size &#x3D; buffer_size;</span><br><span class="line"></span><br><span class="line">&#x2F;* Save the data to the transfer buffer *&#x2F;</span><br><span class="line">memcpy (interface.transfer_buffer + download_bytes,</span><br><span class="line">buffer, transfer_size);</span><br><span class="line"></span><br><span class="line">download_bytes +&#x3D; transfer_size;</span><br><span class="line"></span><br><span class="line">&#x2F;* Check if transfer is done *&#x2F;</span><br><span class="line">if (download_bytes &gt;&#x3D; download_size)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Reset global transfer variable, Keep download_bytes because it will be used in the next possible flashing command *&#x2F;</span><br><span class="line">download_size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (download_error)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* There was an earlier error *&#x2F;</span><br><span class="line">sprintf(response, &quot;ERROR&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Everything has transferred,</span><br><span class="line">   send the OK response *&#x2F;</span><br><span class="line">sprintf(response, &quot;OKAY&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fastboot_tx_status(response, strlen(response), FASTBOOT_TX_ASYNC);</span><br><span class="line"></span><br><span class="line">printf(&quot;\ndownloading of %d bytes finished\n&quot;, download_bytes);</span><br><span class="line">LCD_setprogress(0);</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_RAMDUMP_MODE)</span><br><span class="line">if (is_ramdump) &#123;</span><br><span class="line">is_ramdump &#x3D; 0;</span><br><span class="line">start_ramdump((void *)buffer);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Provide some feedback *&#x2F;</span><br><span class="line">if (download_bytes &amp;&amp; download_size &amp;&amp; 0 &#x3D;&#x3D; (download_bytes &amp; (0x100000 - 1)))</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Some feeback that the download is happening *&#x2F;</span><br><span class="line">if (download_error)</span><br><span class="line">printf(&quot;X&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;.&quot;);</span><br><span class="line">if (0 &#x3D;&#x3D; (download_bytes % (80 * 0x100000))) printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">LCD_setfgcolor(0x2E8B57);</span><br><span class="line">LCD_setprogress(download_bytes &#x2F; (download_size&#x2F;100));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* Ignore empty buffers *&#x2F;</span><br><span class="line">printf(&quot;Warning empty download buffer\n&quot;);</span><br><span class="line">printf(&quot;Ignoring\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面是 fastboot 下载数据代码的一部分，其中 download_bytes 表示已经接收的数据的大小。当 download_bytes 大于或等于 download_size 表示数据接收完成，此时将 download_size 置为0，那么就退出了数据接收模式。因为接收数据和接收命令使用的是同一个 buffer，导致buffer不可能太大，所以在接收比较大的image的时候就比较慢，例如刷入system.img。通过修改 buffer 的大小或者在 download 命令中完成数据的接收工作，如此就可以解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> Bootloader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指纹 TEE </title>
      <link href="/2017/08/08/17-33-25-tee_fp/"/>
      <url>/2017/08/08/17-33-25-tee_fp/</url>
      
        <content type="html"><![CDATA[<h1 id="指纹-TEE"><a href="#指纹-TEE" class="headerlink" title="指纹 TEE"></a>指纹 TEE</h1><hr><ul><li><h3 id="TEE-介绍"><a href="#TEE-介绍" class="headerlink" title="TEE 介绍"></a>TEE 介绍</h3><ul><li>TEE 架构</li><li>TEE 启动流程</li><li>TEE 应用场景以及前景</li></ul></li><li><h3 id="指纹硬件原理"><a href="#指纹硬件原理" class="headerlink" title="指纹硬件原理"></a>指纹硬件原理</h3><ul><li>指纹硬件原理</li><li>指纹通信接口与硬件资源</li></ul></li><li><h3 id="指纹软件框架"><a href="#指纹软件框架" class="headerlink" title="指纹软件框架"></a>指纹软件框架</h3><ul><li>指纹TEE软件框架</li><li>指纹软件机制</li></ul></li></ul><h2 id="一、TEE-介绍"><a href="#一、TEE-介绍" class="headerlink" title="一、TEE 介绍"></a>一、TEE 介绍</h2><hr><h3 id="1-TEE-架构"><a href="#1-TEE-架构" class="headerlink" title="1. TEE 架构"></a>1. TEE 架构</h3><p>TEE(Trusted Execution Environment) 是基于 ARM TrustZone 技术拓展而来的，TrustZone 技术是基于 ARM 架构系统级别层次的对 service  以及 device 进行保护的一项技术, 为了支撑该保护技术, ARMV8 本身支持名为 secure mode 的模式，用来区分 normal mode， 其通过设置 Secure Configuration Register 系统寄存器来使能该模式的支持，该寄存器的最后 1 bit 为 0 的话，则表示当前 CPU 处于为 secure mode，如下图所示，并且 ARM 本身支持将系统资源配置成 secure 状态，通过操作 TZPC 控制寄存器可以将系统总线、内存、DMA、cache 等资源配置成 secure  态，配置成 secure 态之后，normal 端运行的程序无法访问其硬件资源。</p><p><img src="/images/posts/2017/08/tz_two_worlds.png" alt="tz_two_worlds"></p><p>说完 ARMV8 本身支持 secure 模式以及系统硬件资源可配之后，讲解一下 ARMV8 架构。</p><p>ARMv8-a 架构的主要特性包括：</p><blockquote><p>1）新增一套 64-bit 的指令集，称作 A64。</p><p>2）由于需要向前兼容 ARMv7，所以同时支持现存的 32-bit 指令集，称作 A32 和 T32</p><p>3）定义 AArch64 和 AArch32 两套运行环境（称作 Execution state ），分别执行 64-bit 和 32-bit 指令集。软件可以在需要的时候，切换 Execution state。</p><p>4）AArch64 最大的改动，使用新的概念（exception level），重新解释了 processor mode、privilege level 等概念</p><p>5）在 ARMv7 security extension 的基础上，新增 security model，支持安全相关的应用需求。</p><p>6）在 ARMv7 virtualization extension 的基础上，提供完整的 virtualization 框架，从硬件上支持虚拟化。</p></blockquote><p>其中跟 TEE 密切相关的就是 ARMv8-a 实现的 exception level 以及 security 特性。</p><p>ARMV7 架构上，处理器可以工作在多种模式（称作 processor mode）下，包括 User、FIQ、IRQ、Abort、Undefined、System 等, 等于把 ARMV8 架构上 processor mode 的概念去掉了，取而代之的是 4 个固定的 Exception level，简称 EL0-EL3。同时，也淡化了 privilege level 的概念。Exception level 本身就已经包好了 privilege 的信息，即 ELn 的 privilege 随着 n 的增大而增大。类似地，可以将 EL0 归属于 non-privilege level，EL1/2/3 属于 privilege level。</p><p><img src="/images/posts/2017/08/armv8-a_execution_level.gif" alt="armv8-a_execution_level"></p><p>Exception level 简介:</p><blockquote><p>Application 位于特权等级最低的 EL0，Guest OS（Linux kernel 等）位于 EL1，提供虚拟化支持的 Hypervisor 位于 EL2，提供 Security 支持的 Seurity Monitor 位于 EL3，EL3 的等级最高，其拥有的权限也是最高．</p><p>等级低的 EL 想要陷入到较高等级的 EL 需要通过产生异常，只有异常发生时，才能切换 EL， 并且异常发生时只能是跳转到更高等级的 EL，或是停留在当前 EL．同理，异常处理返回时，只能回到低等级 EL 或是停留在当前 EL。</p><p>其中跟 TEE 运行环境密切相关的就是 EL3，其架构层级所处位置为 security 提供了一个安全环境，首先 EL0 跟 EL1 不能直接访问到 EL3，其次在物理资源(内存 cache 总线等)访问上，不同 security 状态下，可以访问的物理资源是不同的，EL3 具备访问 security 跟 non-security 资源，主要目的保护一些安全应用的数据，例如支付等。</p></blockquote><p>security 简介：<br>ARMv8-a 架构有两个 security state，Security 和  non-Security。主要的功效是物理地址的区隔，以及一些 system control  寄存器的访问控制</p><blockquote><p>在 Security 状态下，处理器可以访问所有的 Secure physical address space 以及 Non-secure physical address space</p><p>在 Non-security 状态下，只能访问 Non-secure physical address space，且不能访问 Secure system control resources</p></blockquote><h3 id="2-TEE-启动流程"><a href="#2-TEE-启动流程" class="headerlink" title="2. TEE 启动流程"></a>2. TEE 启动流程</h3><p><img src="/images/posts/2017/08/ATF.png" alt="secure_boot"></p><p>TEE 的启动流程是跟手机启动流程密切相关的，如上图所示，上图主要是描述各阶段镜像校验进行，手机芯片出厂时会固化一个启动程序在 IROM(BL1) 里边，里边会存储一把用于校验下一个启动镜像(BL2)的公钥，BL2 镜像会使用对应 BL1 里边公钥的私钥进行签名， 以此类推， BL2 镜像会存有下一个镜像的公钥，用于校验后续的镜像。</p><p>Arm 为 trustzone 提供了一个通用的 Firmware 层 ATF(ARM Trusted Firmware)。ATF 包含了 service router、PSCI、Interrupt Handler 等功能， 该项目是开源的， 相关代码可以参考 GitHub：<a href="https://github.com/ARM-software/arm-trusted-firmware" target="_blank" rel="noopener">https://github.com/ARM-software/arm-trusted-firmware</a></p><p>ATF 会有几个阶段需要进行，分别叫做  BL1、BL2、BL31、BL32、BL33，下面依据自己对源码的理解，简单描述一下各个阶段所做的事情。</p><p>BL1： 上面介绍了 ARM-V8a 的层级关系，为了保证 secure boot，所以 BL1 阶段的启动必须是处于 secure-EL3 层级， 该阶段会做一些架构上的初始化工作，比如说初始化 EL3 异常向量表(比如说跟 TEE 相关的 SMC 异常向量表)、初始化 cpu(cpu0)、控制系统寄存器(EL3层级)设置、使能MMU、配置 storage、 设置传递参数并加载下一阶段镜像。</p><p>BL2： 该镜像运行在 secure-EL1 环境( BL1 会设置一些参数并传递给 BL2，用来设置其运行初始环境)，该阶段会设置 EL1 异常向量表、使能 MMU、配置 storage、设置传递参数 bl2_to_bl31_params、 bl2_to_bl32_params、bl2_to_bl33_params 并加载下阶段的镜像、 发送 SMC 指令陷入到 BL1 初始化好的 SMC 异常向量处理函数，用于设置 BL31 运行的系统环境。</p><p>BL31：该阶段跟 TEE 密切相关， 由于 world-switch 必须是要在 EL3 阶段下才能完成，所以该阶段的进行是需要在 EL3 的环境下执行的， BL2 在加载 BL31 后，会发送一条 SMC 指令(“smc(BL1_SMC_RUN_IMAGE, (unsigned long)bl31_ep_info, 0, 0, 0, 0, 0, 0)”)，并将 BL31 入口参数 (bl31_ep_info) 也传递到 SMC handler 里边进行配置，主要设置当前为 secure-EL3 层级以及 BL31 镜像的 PC 值，进而让 BL31 镜像处于 EL3 层级下运行。 这个阶段会初始化中断GIC、初始化并使能系统计时器， 并且会实现 runtime service init， 这个 runtime service 则是跟 TEE 密切关联的， 该步骤会初始化一系列跟 SMC handler 相关的入口， 其中就包括 TEE 的入口，当然也有跟 CPU 电源管理相关的 PSCI，厂家也可以定制一些入口， 并且会将这个入口地址存放在一个代码段地址上， SMC handler 会依据 SMC CALL 参数来判断，进而从上述代码段地址上选出要进入的处理入口， 其中第三方的 TEE 厂家也会在该阶段进行入口初始化。<br>(SMC CALL 参数规则可以参考  <a href="http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf</a> )</p><p>BL32：该阶段会依据BL2阶段设置的启动参数来配置当前运行环境，BL32 运行于 secure-EL1 层级， 针对 TEE 而言，其会初始化好 world-switch 的系统环境，比如说 world-switch 前后的栈保护以及恢复工作。</p><p>BL33： 该阶段会依据BL2阶段设置的启动参数来配置当前运行环境， BL33 运行于 normal-EL1 层级， 该阶段的工作主要是完成 lead kernel 以及 load tee os 镜像的工作。</p><p>至此， TEE 核心部分已经集成并启动完成，TEE 运行依赖已经成功搭建，已经具备了 world-switch 的机制支持， 后续上层的应用则会在这 world-switch 的机制基础上进行交互，下图为基本的 normal-secure 交互框架图</p><p><img src="/images/posts/2017/08/normal_secure_framework.png" alt="normal-secure-framework"></p><p>应用交互框架主要包含两部分， normal world 的 service &amp; kernel 支持， secure world 的 trusted application(TA) &amp; secure driver。</p><p>normal world 部分， kernel 部分主要是定义了一套 SMC CALL 接口，提供给上层 service 使用。</p><p>secure world 部分，会简单的区分逻辑层(TA)跟驱动层， 驱动层会操作实际的硬件资源，比如说 SPI、I2C总线已经内存资源等。TA 主要是响应来自 normal world 的逻辑需求。</p><p>所有跟私密数据相关，比如说支付密码、指纹数据、鉴权秘钥等不让 normal world 访问的资源，都可以放在 secure world 端进行处理，secure world 可以将数据总线、内存、DMA等硬件资源都保护起来，normal world 无法通过访问硬件通信接口获得数据。</p><p>有了这一套框架的存在，secure world 下的应用程序或是资源，normal world 下正常应用是无法进行访问的，所以只有与 TA 相对应的 normal world 应用，通过定义好的 SMC CALL 规则接口才能切换至 secure world，完成跟 TA 的交互。</p><p>安全防护上，TA 需要校验签名通过方可加载，给 TA 签名的秘钥一般由 OEM 厂家制定，normal world 这边的应用则会受 selinux 权限限制， 无法获得访问 kernel 提供的 SMC CALL 接口权限。</p><h3 id="3-TEE-应用场景以及前景"><a href="#3-TEE-应用场景以及前景" class="headerlink" title="3. TEE 应用场景以及前景"></a>3. TEE 应用场景以及前景</h3><p>TEE 其实是一个安全载体，在业界也有很多安全测试机构对其进行测试评估，就目前而言，还是很多产品、方案厂家承认其安全性的，在移动支付盛行的时代，越来越多在线支付产品会选择使用 TEE 作为安全支持，像现在流行的支付宝、微信支付等都采用了 TEE 方案作为其支付安全保障。</p><p>在未来，相信在身份认证这一领域上，会有越来越多的产品采用 TEE 方案，而其认证形式可能会涉及到指纹、虹膜、人脸等生物识别技术。</p><h2 id="二、指纹硬件环境"><a href="#二、指纹硬件环境" class="headerlink" title="二、指纹硬件环境"></a>二、指纹硬件环境</h2><p>上述介绍了 TEE 的硬件支持、安全启动以及一套完整的应用框架支持，接下来会针对现在市面较为流行的指纹识别技术，简单介绍指纹识别技术以及指纹跟 TEE 的结合。</p><hr><h3 id="1-指纹硬件原理"><a href="#1-指纹硬件原理" class="headerlink" title="1. 指纹硬件原理"></a>1. 指纹硬件原理</h3><p>电容式指纹识别解决方案，是基于电容检测原理而自主开发的按压式指纹识别技术。如下图所示，当 Finger 与 Cover 的接触时，指纹的嵴和峪与 Pixel Array  间会形成不同的耦合电容。 驱动信号由指纹芯片的信号驱动模块产生，通过检测 Finger 与 Sensor 所形成的耦合电容，通过 AD 转换将采集到的数据发送给 Host，从而 Host 可以根据不同的信号耦合量，探测到嵴和峪的位置；指纹 sensor 采集点以阵列式分布,收集实际指纹触碰到的采集点的数据，从而形成指纹图像数据。</p><p><img src="/images/posts/2017/08/fp.png" alt="fp"></p><h3 id="2-指纹通信接口与硬件资源"><a href="#2-指纹通信接口与硬件资源" class="headerlink" title="2. 指纹通信接口与硬件资源"></a>2. 指纹通信接口与硬件资源</h3><p>(1). 电源：1.8V ~ 3.0V</p><p>(2). 通信总线：SPI 总线。全双工三线同步串行外围接口，采用主从模式（Master Slave）架构；支持多 slave 模式应用，一般仅支持单 Master。时钟由 Master 控制，在时钟移位脉冲下，数据按位传输，高位在前，低位在后，SPI 接口有 2 根单向数据线，为全双工通信。</p><h2 id="三、指纹软件"><a href="#三、指纹软件" class="headerlink" title="三、指纹软件"></a>三、指纹软件</h2><hr><h3 id="1-指纹TEE软件框架"><a href="#1-指纹TEE软件框架" class="headerlink" title="1. 指纹TEE软件框架"></a>1. 指纹TEE软件框架</h3><p><img src="/images/posts/2017/08/fp_tee_framework.png" alt="fp_tee_framework"></p><p>(1)TA: 处于 secure 端，实现一些基本的硬件操作逻辑功能，如指纹 back  采图等逻辑。</p><p>(2)client: 处于 normal 端，实现安卓上的一些基本接口，如指纹的录入 识别接口等。</p><p>(3)secure driver: 处于 secure 端，主要实现一些总线硬件接口的驱动。如 spi DMA 等。</p><p>(4)secure deamon: 处于 normal 端，响应 client 端需求，桥接 client 跟 kernel 的通信，kernel 端产生异常陷入 EL3，将 client 端指令传至 secure  端。</p><p>(5)secure os: 维持 secure 端 OS 正常运作调度以及提供系统接口给 TA 以及 secure driver 使用。</p><p>简单流程： client 端发起请求(采图、back 中断处理等) —&gt; 经由 secure daemon 到 kernel， 并由 kernel 发起 SMC CALL —&gt;  陷入到EL3，switch 到 secure world —&gt; TA 接收请求 —&gt; secure driver 执行spi数据通信。</p><h3 id="2-指纹软件机制"><a href="#2-指纹软件机制" class="headerlink" title="2. 指纹软件机制"></a>2. 指纹软件机制</h3><p>魅族指纹产品支持两种模式， 一种是 mback 模式，该模式自魅族手机带指纹功能以来就一直存在，具体为轻触返回上一级功能，另一种模式是指纹采图模式，具体为指纹录入识别功能。</p><p>mback 模式下，手指触碰到 pixel 或是 ring 环时，会根据 pixel 或是 ring 的容抗变化阈值来判断<br>是否产生 back 中断，并且会依据变化阈值大小来判断 down 或是 up，down 中断的话，pixel 或是 ring 其中一个达到阈值变化要求，都会产生，如果同时触碰到了 ring 跟 pixel， up中断必须需要 ring 以及 pixel 的阈值变化都达到要<br>求才会产生。</p><p>采图模式下，芯片会定时扫描检测 sensor 区域是否有手指触摸，该扫描周期可以通过配置参数进行调整。当检测到有手指触摸时，会进行指纹数据的扫描，然后会发送中断通知主控读取数据，指纹数据帧以 FIFO 形式边扫描边读取， 采集到的 raw data，首先会经过图像预处理，并且会对图像进行打分，预处理失败该帧图像不会进行进一步的算法处理，在采集流程上，<br>状态为 down irq -&gt; image irq -&gt; image<br>capture -&gt; up irq</p><p><img src="/images/posts/2017/08/fp_capture.png" alt="fp_capture_image"></p><p>采图模式下，采集完成 raw data 之后需要进行图像算法匹配，其中跟匹配密切相关的是 finger base，finger base 可以简单理解为采集 raw data 后，用来作为比较的原始数据，算法构造指纹数字图像的基准，理想的 finger base 是没有手指在芯片模组上采集的 pixel数据，后续手指置于芯片上采集的 raw data，算法会将采集到的 raw data 跟 finger base 进行对比，从而得出每个 pixel 上的差值，手指的嵴和峪数据会因此不一样，最终会构造出接近真实手指的数字图像。finger base 尤其重要，一般来说，指纹服务开机启动时，由于此时安卓还没有完全启动，此时手指放置于芯片上面的概率最小，默认会采集一帧图像作为原始 finger base，并且会储存在某个位置，后续无论是指纹录入或是指纹匹配都会以这个作为比较基准。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h4 id="http-www-wowotech-net-armv8a-arch-armv8-a-overview-html"><a href="#http-www-wowotech-net-armv8a-arch-armv8-a-overview-html" class="headerlink" title="http://www.wowotech.net/armv8a_arch/armv8-a_overview.html"></a><a href="http://www.wowotech.net/armv8a_arch/armv8-a_overview.html" target="_blank" rel="noopener">http://www.wowotech.net/armv8a_arch/armv8-a_overview.html</a></h4><h4 id="http-genode-org-documentation-articles-trustzone"><a href="#http-genode-org-documentation-articles-trustzone" class="headerlink" title="http://genode.org/documentation/articles/trustzone"></a><a href="http://genode.org/documentation/articles/trustzone" target="_blank" rel="noopener">http://genode.org/documentation/articles/trustzone</a></h4><h4 id="http-www-arm-com-products-security-on-arm-trustzone"><a href="#http-www-arm-com-products-security-on-arm-trustzone" class="headerlink" title="http://www.arm.com/products/security-on-arm/trustzone"></a><a href="http://www.arm.com/products/security-on-arm/trustzone" target="_blank" rel="noopener">http://www.arm.com/products/security-on-arm/trustzone</a></h4>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> Trusted Execution Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dump_stack 实现分析</title>
      <link href="/2017/03/06/18-40-19-dump_stack/"/>
      <url>/2017/03/06/18-40-19-dump_stack/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>说起 <code>dump_stack()</code> ，相信从事 Linux 内核或者驱动相关开发的同行对于此函数肯定不陌生。我们经常会用到此函数来对自己的代码进行 debug，可以快速帮助开发者理清函数调用流程，或者说解决 bug…… 首先我们来看一下 dump_stack 的打印，相信很多人都遇到过 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[    4.778339] &lt;1&gt;-(1)[258:charger_thread]CPU: 1 PID: 258 Comm: charger_thread Tainted: G        W       4.4.15+ #50</span><br><span class="line"></span><br><span class="line">[    4.778342] &lt;1&gt;-(1)[258:charger_thread]Hardware name: MT67XX</span><br><span class="line"></span><br><span class="line">[    4.778345] &lt;1&gt;-(1)[258:charger_thread]Call trace:</span><br><span class="line"></span><br><span class="line">[    4.778347] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc00008a40c&gt;] dump_backtrace+0x0&#x2F;0x14c</span><br><span class="line"></span><br><span class="line">[    4.778354] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc00008a56c&gt;] show_stack+0x14&#x2F;0x1c</span><br><span class="line"></span><br><span class="line">[    4.778358] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc000368930&gt;] dump_stack+0x8c&#x2F;0xb0</span><br><span class="line"></span><br><span class="line">[    4.778364] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc000852140&gt;] ipanic_die+0x50&#x2F;0x104</span><br><span class="line"></span><br><span class="line">[    4.778368] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc0000bfd94&gt;] notifier_call_chain+0x88&#x2F;0x2d4</span><br><span class="line"></span><br><span class="line">[    4.778374] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc0000c08d4&gt;] notify_die+0x48&#x2F;0x5c</span><br><span class="line"></span><br><span class="line">[    4.778377] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc00008a60c&gt;] die+0x98&#x2F;0x1b8</span><br><span class="line"></span><br><span class="line">[    4.778381] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc000099ab4&gt;] __do_kernel_fault.part.6+0x74&#x2F;0x90</span><br><span class="line"></span><br><span class="line">[    4.778386] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc000097cbc&gt;] do_page_fault+0x2e8&#x2F;0x2f8</span><br><span class="line"></span><br><span class="line">[    4.778392] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc000097d84&gt;] do_translation_fault+0xb8&#x2F;0xe0</span><br><span class="line"></span><br><span class="line">[    4.778396] &lt;1&gt;-(1)[258:charger_thread][&lt;ffffffc0000822bc&gt;] do_mem_abort+0x40&#x2F;0xa0</span><br></pre></td></tr></table></figure><p>从打印可以清晰的了解程序到底发生了什么，这是一个很好用的函数，那么今天我们就来透过现象看本质，看看这个函数到底是何方神圣，怎么来实现这种功能的。</p><h2 id="2-实现分析"><a href="#2-实现分析" class="headerlink" title="2 实现分析"></a>2 实现分析</h2><p>通过 grep，发现 dump_stack 函数原型存在于 kernel/lib/dump_stack.c 文件中（注：笔者使用的是 4.4 版本的代码）。它的实现流程如下图所示：</p><p><img src="/images/posts/2017/03/dump_stack.png" alt="dump_stack"></p><p>可以看到关键的两个函数分别是 dump_stack_print_info 和 show_stack 。其中第一个函数是用来打印 info 信息的，而第二个函数是用来打印 Call trace 的。</p><p><strong>Step 1: dump_stack_print_info</strong></p><p>第一部分主要实现 print info ，函数比较简单，我们直接看代码：</p><pre><code>void dump_stack_print_info(const char *log_lvl){    printk("%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n",        log_lvl, raw_smp_processor_id(), current->pid, current->comm,        print_tainted(), init_utsname()->release,        (int)strcspn(init_utsname()->version, " "),        init_utsname()->version);    if (dump_stack_arch_desc_str[0] != '\0')        printk("%sHardware name: %s\n",        log_lvl, dump_stack_arch_desc_str);    print_worker_info(log_lvl, current);} </code></pre><p>其实 print info 的关键信息就是一句代码实现的：</p><pre><code>printk(&quot;%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n&quot;，     log_lvl, raw_smp_processor_id(), current-&gt;pid, current-&gt;comm,     print_tainted(), init_utsname()-&gt;release,    (int)strcspn(init_utsname()-&gt;version, &quot; &quot;),    init_utsname()-&gt;version);</code></pre><p> current 指针指向的是当前进程，那么这句代码就是分别打印出了：log_level, CPU id, command, kernel taint state, kernel version,  这样就和前面例子中的打印信息对上了 ~</p><p>关于这个 <code>print_tainted()</code> 函数，笔者也不甚了解，通过函数的注释可以知其一二：</p><pre><code>/**  *  print_tainted - return a string to represent the kernel taint state.  *  *  'P' - Proprietary module has been loaded.  *  'F' - Module has been forcibly loaded.  *  'S' - SMP with CPUs not designed for SMP.  *  'R' - User forced a module unload.  *  'M' - System experienced a machine check exception.  *  'B' - System has hit bad_page.  *  'U' - Userspace-defined naughtiness.  *  'D' - Kernel has oopsed before  *  'A' - ACPI table overridden.  *  'W' - Taint on warning.  *  'C' - modules from drivers/staging are loaded.  *  'I' - Working around severe firmware bug.  *  'O' - Out-of-tree module has been loaded.  *  'E' - Unsigned module has been loaded.  *  'L' - A soft lockup has previously occurred.  *  'K' - Kernel has been live patched.  *  *  The string is overwritten by the next call to print_tainted().  */</code></pre><p><strong>Step 2: show_stack</strong></p><p>第二部分的主要功能是实现 Call trace ，它的执行流程如下：</p><p><img src="/images/posts/2017/03/show_dump.png" alt="show_stack"></p><p> unwind_frame 是判断是否到达栈底的函数，一个线程堆栈大小为 THREAD_SIZE，SP 寄存器存储的是栈顶，由此可以找到对应的栈底，如果没有到堆栈底部，则每次持续打印出相关的函数调用列表。</p><p>接下来就是另一个关键函数 dump_backtrace_entry ，看一下它的代码：</p><pre><code>static void dump_backtrace_entry(unsigned long where){    /*  * Note that 'where' can have a physical address, but it's not handled.  */    print_ip_sym(where);}static inline void print_ip_sym(unsigned long ip){    printk("[<%p>] %pS\n", (void *) ip, (void *) ip);}</code></pre><p>可以看到真正的打印函数也就一句代码，这个是真正的精髓所在：</p><pre><code>printk(&quot;[&lt;%p&gt;] %pS\n&quot;, (void *) ip, (void *) ip);</code></pre><p>把 %pS 作为格式化参数传递给 printk，printk 将负责把对应地址的函数名打印出来。由此看来，如何从地址转换到函数名这个最复杂的工作内核已经帮你做好了，dump stack 直接去用做好的轮子就行了。</p><h2 id="3-关于堆栈"><a href="#3-关于堆栈" class="headerlink" title="3 关于堆栈"></a>3 关于堆栈</h2><p>关于堆栈，首先要从 CPU 说起，以 ARM 32bit 为例来说，我们知道它有很多种 mode，usr/fiq/irq/svc/abt/und/sys。对于每一种 mode 都存在自己的堆栈，并由 SP 寄存器指定，由于进行模式切换就需要保护现场，因此不同 mode 的 SP 要设置为不同值。在内核态使用的都是 svc mode 的堆栈，那如何把不同线程的堆栈分开呢，实际上内核针对不同线程会分配不同的堆栈地址，而堆栈地址都被存在 task_struct 中，这样每次线程调度时就可以把相应的地址设置给 SP 寄存器，由此实现不同内核线程堆栈的切换。</p><p>再来说中断，不管 CPU 是在 usr mode 还是在 svc mode，只要中断到来都会使 CPU 进入到 irq mode，这是一种硬件行为，不过在这之后的处理就属于软件范畴了，kernel 中只是把 irq mode 作为一个中转状态，只存在了很短暂的时间，甚至中断处理程序都不再 irq mode 里执行。根据代码可知，经过短暂的 irq mode 中转后，CPU 会进入到 svc mode 来处理中断服务程序，此时使用的堆栈就是当前被中断进程的内核 svc 堆栈。</p><p>综上所述，dump_stack 其实就是根据当前 svc mode 的 SP 寄存器，打印出堆栈中的函数信息的。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>dump_stack 的实现流程其实都是基于如下两条关键代码：</p><pre><code>printk(&quot;%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n&quot;，     log_lvl, raw_smp_processor_id(), current-&gt;pid, current-&gt;comm,     print_tainted(), init_utsname()-&gt;release,    (int)strcspn(init_utsname()-&gt;version, &quot; &quot;),    init_utsname()-&gt;version);</code></pre><p>以及</p><pre><code>printk(&quot;[&lt;%p&gt;] %pS\n&quot;, (void *) ip, (void *) ip);</code></pre><p>  有了这两个作为基础，其实对于我们来说，实现一个自己的 dump stack 函数又有何难呢？这个任务就交给读者练习吧，相信一定会收获更多的！</p>]]></content>
      
      
      <categories>
          
          <category> 性能与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dump_stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 搭建 Jenkins 服务指南 </title>
      <link href="/2016/10/16//configure-jenkins-guide.html/"/>
      <url>/2016/10/16//configure-jenkins-guide.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果常常需要给其他相关部门输出固件验证问题，那么用 Jenkins 搭建一个自动化的编译环境会是一个不错的选择。这篇文章简单的介绍了 Jenkins 的基本使用，及如何利用插件进行权限的管理，邮件的发送设置。</p><h3 id="一-在-Ubuntu-上搭建-jenkins"><a href="#一-在-Ubuntu-上搭建-jenkins" class="headerlink" title="一 .  在 Ubuntu 上搭建 jenkins"></a>一 .  在 Ubuntu 上搭建 jenkins</h3><ol><li><p>在终端上执行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - http:&#x2F;&#x2F;pkg.jenkins-ci.org&#x2F;debian&#x2F;jenkins-ci.org.key | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>在 /etc/apt/sources.list 加上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;pkg.jenkins-ci.org&#x2F;debian binary&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>更新 package 然后安装 jenkins</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install jenkins</span><br></pre></td></tr></table></figure></li><li><p>访问 jenkins 页面</p><ul><li>本地：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li><li>局域网其他电脑：<a href="http://172.16.132.37:8080" target="_blank" rel="noopener">http://172.16.132.37:8080</a></li></ul></li><li><p>终端 Jenkins 操作基本指令</p><ul><li><code>sudo service jenkins status</code> - 查看运行状态</li><li><code>sudo service jenkins start</code> - 启动</li><li><code>sudo service jenkins stop</code> - 停止</li><li><code>sudo service jenkins restart</code> - 重启</li></ul></li></ol><h2 id="二-启用-Jenkins-功能扩展插件"><a href="#二-启用-Jenkins-功能扩展插件" class="headerlink" title="二 . 启用 Jenkins 功能扩展插件"></a>二 . 启用 Jenkins 功能扩展插件</h2><p>Jenkins 提供了很多插件扩展功能，安装插件有两种方式：</p><ol><li>在系统管理 -&gt; 插件管理 -&gt; 可选插件，勾选需要的插件 , 安装重启即可</li><li>安装某些插件，时常会出现网络异常问题，可通过下载安装包，手动安装。<br> 系统管理 -&gt; 插件管理 -&gt; 高级，上传已下载的 hpi 后缀的插件文件，安装重启即可</li></ol><p>安装插件如下：</p><ul><li>Email Extension Plugin ：扩展的邮件功能<br>Jenkins 有内置的邮件功能，但每次只能发送给固定的对象，且格式单一。所以需要使用插件进行扩展。</li></ul><p>扩展的插件可根据构建的结果，选择是否需要发送报告，也可自定义邮件的格式，指定接收对象。</p><p>设置发送配置：在系统设置，邮件通知中，添加 Jenkins 发送人信息。需注意的是，这里使用 SMTP 认证的邮件用户名应与 Jenkins Location 中的系统管理员邮件地址一致，否则会无法使用。设置后可通过发送测试邮件测试配置，</p><p>如能正常受到邮件，则账户设置成功。</p><p>设置邮件默认格式：系统设置中找到 Extended E-mail Notification 配置发送信息</p><p><img src="images/posts/2016/10/defalut_Notification.png" alt="默认邮件配置"></p><p>其中 Default Recipients 为默认的邮件接收对象，Default Subject 为邮件标题，Default Content 为邮件内容。</p><p>变量是一个以 $( 美元符号 ) 开始，并以空格结束的字符串。当一个邮件触发时，主题和内容主体字段的所有变量都会通过真实的值动态地替换。同样，变量中的“值”能包含其它的变量，都将被替换成真实的内容。</p><p>常用的属性如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;PROJECT_NAME&#125;：显示项目的全名</span><br><span class="line">$&#123;BUILD_NUMBER&#125;: 显示当前构建的编号</span><br><span class="line">$&#123;CAUSE&#125;: 显示此次构建的触发用户</span><br><span class="line">$&#123;JENKINS_URL&#125;： 显示 Jenkins 服务器的 url 地址（可在系统设置页面修改）</span><br><span class="line">$&#123;BUILD_LOG&#125;： 显示最终构建的日志</span><br><span class="line">$&#123;BUILD_STATUS&#125;：显示当前构建的状态 ( 失败、成功等 )</span><br><span class="line">$&#123;CHANGES &#125; ：显示上一次构建之后的变化</span><br></pre></td></tr></table></figure><p>项目配置中选择构建后操作 Editable Email Notification，如果不设置，则使用系统的默认设置，</p><p>也可在高级设置中，设置触发邮件发送的条件及接收人。</p><ul><li>Environment Injector Plugin :  自定义用户变量如上图邮件默认内容中的 <code>$BUILD_VERSION_FAC</code>,<code>$FIRMWARE_ADDRESS</code> 就是利用这个插件定义的变量</li></ul><p>安装此插件后，可在项目配置中的构建环境勾选 Inject environment variables to the build process，使用自定义的变量。设置后可在系统管理的系统信息里查看当前环境变量信息</p><ul><li>Role-based Authorization Strategy : 用户权限管理插件<br>安装此插件后，需在系统管理的 Configure Global Security 中的授权策略勾选 Role-Based Strategy，在系统管理页面会多出一个 Manage and Assign Roles 选项，点击该选项，可以看到 Manage Roles 和 Assign Roles 这两个选项，通过它俩，便可以根据需求设置用户的相关权限。</li></ul><p>首先设置各角色的权限，点击 Manage Roles，如下图</p><p><img src="images/posts/2016/10/manage_roles.png" alt="角色权限管理"></p><p>需要注意的是在 Global roles 的权限设置会覆盖 Project roles 中的权限，例如一个账户的 Global roles 具有 Job 的 read 权限 ，那么不管这个账户的 Project roles 怎么设置，它都会具备所有 Job 的 read 权限。在 Project roles 有个 Pattern 选项，该选项可设置角色对不同项目的访问权限，如填写 M.* ，表示设置的权限仅对项目名以 M 开头的有效。</p><p>在 Manage Roles 中设置完角色权限后，方可进入 Assign Roles 界面，给用户分配角色，如下图</p><p><img src="images/posts/2016/10/Assign_roles.png" alt="角色分配"></p><h2 id="三-建立项目"><a href="#三-建立项目" class="headerlink" title="三 . 建立项目"></a>三 . 建立项目</h2><p>以建立可以实现 Android 系统编译的项目为例，简单介绍项目的建立过程</p><ul><li><p>新建项目，选择“构建一个自由风格的软件项目”</p></li><li><p>在项目配置中，如需用户输入，如编译选项，账户密码或上传文件作为构建参数，则勾选 “参数化构建过程”，根据参数的类型添加参数。</p></li><li><p>源码管理选择 Gerrit Repo，在高级设置里填写源码 repo 的基本信息即可</p></li><li><p>增加构建步骤，选择 Execute Shell，在此处可以执行编译脚本。注意用 bash 执行</p></li><li><p>增加构建后操作步骤，选择 Editable Email Notification , 发送构建结果邮件。</p></li></ul><p>完成以上步骤后，一个简单的用来编译 Android 源码的项目就完成了</p>]]></content>
      
      
      <categories>
          
          <category> 系统管理和维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的设计模式 —— 单例模式</title>
      <link href="/2016/09/19/./android-design-pattern-singleton.html/"/>
      <url>/2016/09/19/./android-design-pattern-singleton.html/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>当我们讨论设计模式的时候，其实我们在讨论面向对象的设计问题。</p><p>软件设计中很多问题都会一次又一次的重复出现，而经过一定的总结之后会有一些优秀的解法沉淀下来，可以用于以后出现的类似问题，我们把这些解法叫做设计模式。</p><p>软件的生命周期决定了其设计要尽可能地面对（需求）改变，所以在开发和维护过程中，面临的较大问题，除了解决问题的关键点，另一个就是解决需求变更和扩展所带来的代码结构变化问题。而设计模式刚好可以让我们的设计更加灵活，在解决问题的基础上，也使得后期的功能扩展对原有结构的影响尽可能小。</p><p><strong>推荐书籍：</strong></p><ol><li>[ 设计模式：可复用面向对象软件的基础 ] [ 推荐书籍 1]</li><li>[Head First 设计模式 ] [ 推荐书籍 2]</li></ol><p>[ 推荐书籍 1]: <a href="http://item.jd.com/10057319.html" target="_blank" rel="noopener">http://item.jd.com/10057319.html</a> ‘ 设计模式：可复用面向对象软件的基础 ‘</p><p>[ 推荐书籍 2]: <a href="http://item.jd.com/10100236.html" target="_blank" rel="noopener">http://item.jd.com/10100236.html</a> ‘Head First 设计模式 ‘</p><h2 id="面向对象软件设计原则"><a href="#面向对象软件设计原则" class="headerlink" title="面向对象软件设计原则"></a>面向对象软件设计原则</h2><p>[《Head First 设计模式》] [ 推荐书籍 2] 一书里面提炼了很多 OO 设计的原则，在这里分析其中的一些。</p><ol><li><strong>找出需求中“可能变化”之处，把它们独立出来。</strong> 这样，新需求对原架构的影响就会减小很多。这个是程序设计最基本的原则，也可以说成，让每次的变化，尽可能地影响最少的代码。</li><li><strong>针对接口编程，而不是针对实现编程。</strong> 这里的接口，可以是 Interface，也可以是 base class，最关键的是，当行为改变时，对使用该接口的地方来讲是透明的。也就是说，要有效利用多态的特性。</li><li><strong>多用组合、少用继承。</strong> 为什么要少用继承？个人的理解是，继承都需要用在能表现多态的地方。</li><li><strong>为了交互对象之间的松耦合设计而努力。</strong> 这个好像不用解释。</li><li><strong>要依赖抽象，不要依赖具体类。</strong> 一旦依赖了具体类，就没办法低耦合了。</li><li><strong>一个类只应该有一个引起变化的原因。</strong> 这是我们奋斗的目标，但是有时候需要综合其他的原则一起考虑。</li></ol><p>还有一些其他原则，有待在实践中不断深化，这里不一一列举了。</p><h2 id="设计模式举例"><a href="#设计模式举例" class="headerlink" title="设计模式举例"></a>设计模式举例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式应该是最简单的一个模式，因为它不涉及和其他类交互的问题。但是写好单例模式并不容易，特别是在多线程环境下，单例模式有时候并不好写。</p><p>当确定系统只需要某个对象的唯一实例时，就需要使用单例模式。</p><p>先看看关系图如下：</p><p><img src="http://i.imgur.com/qAjcNLz.jpg" alt=" 单例模式 UML 类图 "></p><p>最简单的写法就是只提供一个 private 的构造方法，一个 static 的对象和获取这个对象的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> private static Singleton singleton &#x3D; null;</span><br><span class="line"> private Singleton()&#123;&#125;</span><br><span class="line"> public Singleton getInstance()&#123;</span><br><span class="line">if(singleton &#x3D;&#x3D; null)&#123;</span><br><span class="line">singleton &#x3D; new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return singleton;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种写法即使是在笔试的时候，也的不了多少分的。</p><h4 id="实际应用举例"><a href="#实际应用举例" class="headerlink" title="实际应用举例"></a>实际应用举例</h4><p>一个比较过关的写法是考虑多线程的情况下能够正常运行，并且尽可能推迟生成实例（在生成实例代价较大的情况下比较有用）。以下是一个具体的场景：要根据手机屏幕的亮灭来控制手机 LED 灯的亮灭，这样可以在无屏幕的状态下根据 LED 的情况判断手机是否处于开机状态。</p><p>因为 Framework 中 <code>DisplayPowerState</code> 这个类有在 <code>PowerManagerService</code> 里面更新屏幕的状态，如果不用单例模式，会出现生成多个控制 LED 灯的对象，导致 LED 在指定状态下是一闪一闪的状态，无法达到指定需求。所以考虑使用单例模式来写 LED 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static class LightHandler extends Handler&#123;</span><br><span class="line">private static final Object mLock &#x3D; new Object();</span><br><span class="line">private volatile static LightHandler mlightHandler &#x3D; null;</span><br><span class="line">private LightHandler()&#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">private LightHandler(Looper looper)&#123;</span><br><span class="line">super(looper);</span><br><span class="line">&#125;</span><br><span class="line">public static LightHandler getInstance(Looper looper)&#123;</span><br><span class="line">if(mlightHandler &#x3D;&#x3D; null)&#123;</span><br><span class="line">synchronized(mLock)&#123;</span><br><span class="line">if(mlightHandler &#x3D;&#x3D; null)</span><br><span class="line">mlightHandler &#x3D; new LightHandler(looper);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mlightHandler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑目前的 Android 版本使用的 java 都在 1.6 以上，所以 <code>volatile</code> 关键字可以有效使用。实测该方法可以有效控制 LED 灯不再闪烁。</p><h4 id="Framework-层代码使用单例模式的例子"><a href="#Framework-层代码使用单例模式的例子" class="headerlink" title="Framework 层代码使用单例模式的例子"></a>Framework 层代码使用单例模式的例子</h4><p>github 上有一个很完整的例子：<a href="https://github.com/simple-Android-framework/android_design_patterns_analysis/tree/master/singleton/mr.simple" target="_blank" rel="noopener" title="Framework 中的单例模式 ">Framework 中的单例模式</a></p><p>这个例子里面解释了 <code>LayoutInflater</code> 使用单例的情况，写得非常详细。里面也提到了 Framework 层的很多  Serivce 都是单例模式，那这里就去看看源代码吧。</p><p><code>.frameworks/base/core/java/com/Android/server/LocalServices.java</code> 这个文件就是典型的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import android.util.ArrayMap;</span><br><span class="line"></span><br><span class="line">public final class LocalServices &#123;</span><br><span class="line">private LocalServices() &#123;&#125;</span><br><span class="line">private static final ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects &#x3D;</span><br><span class="line">new ArrayMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public static &lt;T&gt; T getService(Class&lt;T&gt; type) &#123;</span><br><span class="line">synchronized (sLocalServiceObjects) &#123;</span><br><span class="line">return (T) sLocalServiceObjects.get(type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123;</span><br><span class="line">synchronized (sLocalServiceObjects) &#123;</span><br><span class="line">if (sLocalServiceObjects.containsKey(type)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Overriding service registration&quot;);</span><br><span class="line">&#125;</span><br><span class="line">sLocalServiceObjects.put(type, service);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次添加 Service 的时候，都是往 <code>ArrayMap</code> 里面添加一个 <code>key-value</code> 对，通过控制这个数据结构来达到单例的要求。所有的 <code>LoacalServices</code> 在系统中都保持只有一个实例，需要用到的时候，使用 <code>getService()</code> 函数获取即可。可以看到以下一些使用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;VibratorService.java:230: mPowerManagerInternal &#x3D; LocalServices.getService(PowerManagerInternal.class);</span><br><span class="line">.&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;power&#x2F;Notifier.java:141:mActivityManagerInternal &#x3D; LocalServices.getService(ActivityManagerInternal.class);</span><br><span class="line">.&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemService.java:197:        return LocalServices.getService(SystemServiceManager.class);</span><br></pre></td></tr></table></figure><p>这些都是需要使用 <code>LoacalServices</code> 的例子。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android M 外部存储剖析 </title>
      <link href="/2016/09/12//android-m-external-storage.html/"/>
      <url>/2016/09/12//android-m-external-storage.html/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是建立在你已经对 Android 外部存储的基础知识有一定了解的基础之上，如果之前并不是太了解这个部分，阅读起来可能会比较费劲，可以先阅读参考下面文章：<a href="http://blog.csdn.net/zjbpku/article/details/25161131" target="_blank" rel="noopener">http://blog.csdn.net/zjbpku/article/details/25161131</a></p></blockquote><h2 id="Android-M-外部存储的变化"><a href="#Android-M-外部存储的变化" class="headerlink" title="Android M 外部存储的变化"></a>Android M 外部存储的变化</h2><p>从 Android 6.0 开始，Android 支持移动存储（adoptable storage），例如 SD 卡或者 USB 。移动存储可以像内部存储一样加密和格式化，可以存储所有类型的应用数据。</p><h3 id="权限变化"><a href="#权限变化" class="headerlink" title="权限变化"></a>权限变化</h3><p>是否访问外部存储由各种 Android 权限保护。</p><ul><li>从 Android 1.0 开始，写访问需要 <code>WRITE_EXTERNAL_STORAGE</code> 权限。</li><li>从 Android 4.0 开始，读访问需要 <code>READ_EXTERNAL_STORAGE</code> 权限。</li><li>从 Android 4.4 开始，外部存储设备上的文件，也能够基于目录结构来合成（ synthesized ）不同的 DAC 权限（ owner，group，mode ）。这允许应用能够在外部存储上管理一个包相关的目录，而无需 <code>WRITE_EXTERNAL_STORAGE</code> 权限。例如， 应用 com.example.foo 可以自由访问外部存储上的 Android/data/com.example.foo/ 。这种合成权限是通过 fuse 守护来包裹原始存储设备来完成的。</li><li>Android 6.0 引入了新的运行时权限（runtime permissions ）模型，用于应用在运行中必要时申请权限。由于新模型包含了 READ/WRITE_EXTERNAL_STORAGE ，因此平台需要在不杀死或者重启运行中的应用的前提下，动态对存储访问授权。</li></ul><h4 id="关于运行时权限"><a href="#关于运行时权限" class="headerlink" title="关于运行时权限"></a>关于运行时权限</h4><p>Android 6.0 引入了一个新的应用权限模型，期望对用户更容易理解，更易用和更安全。该模型将标记为危险的权限从安装时权限 ( Install Time Permission ) 模型移动到运行时权限模型（ Runtime Permissions ）:</p><ul><li>安装时权限模型 ( Android 5.1 以及更早 )。用户在应用安装和更新时，对危险权限授权。但是 OEM 和运行商预装的应用将自动预授权。</li><li>运行时权限 ( Android 6.0 及以后 )。用户在应用运行时，对应用授予危险权限。由应用决定何时去申请权限（例如，在应用启动时或者用户访问某个特性时），但必须允许用户来授予或者拒绝应用对特定权限组的访问。OEM 和运营商可以预装应用，但是不能对权限进行预授权（例外情况请看这里 Create exception ）。</li></ul><p>运行时权限提供给用户关于应用所需权限更多的相关上下文和可视性，这也让开发者帮助用户更好的理解：为什么应用需要所请求的权限，授权将有什么样的好处，拒绝将有何种不便。用户可以通过设置中的菜单来撤销应用的权限。</p><h3 id="目录的变化"><a href="#目录的变化" class="headerlink" title="目录的变化"></a>目录的变化</h3><p><strong>Android L:</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">on init</span><br><span class="line">    <span class="comment"># See storage config details at http://source.android.com/tech/storage/</span></span><br><span class="line">    mkdir /mnt/shell/emulated 0700 shell shell</span><br><span class="line">    mkdir /storage/emulated 0555 root root</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> EXTERNAL_STORAGE /storage/emulated/legacy</span><br><span class="line">    <span class="built_in">export</span> EMULATED_STORAGE_SOURCE /mnt/shell/emulated</span><br><span class="line">    <span class="built_in">export</span> EMULATED_STORAGE_TARGET /storage/emulated</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Support legacy paths</span></span><br><span class="line">    symlink /storage/emulated/legacy /sdcard</span><br><span class="line">    symlink /storage/emulated/legacy /mnt/sdcard</span><br><span class="line">    symlink /storage/emulated/legacy /storage/sdcard0</span><br><span class="line">    symlink /mnt/shell/emulated/0 /storage/emulated/legacy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@mx5:&#x2F;mnt # ls -l</span><br><span class="line">drwxr-xr-x root     system            2016-07-08 16:20 asec</span><br><span class="line">dr-xr-xr-x root     root              2014-08-14 20:41 cd-rom</span><br><span class="line">drwx------ media_rw media_rw          2016-07-08 16:20 media_rw</span><br><span class="line">drwxr-xr-x root     system            2016-07-08 16:20 obb</span><br><span class="line">lrwxrwxrwx root     root              2016-07-08 16:20 sdcard -&gt; &#x2F;storage&#x2F;emulated&#x2F;legacy</span><br><span class="line">lrwxrwxrwx root     root              2016-07-08 16:20 sdcard2 -&gt; &#x2F;storage&#x2F;sdcard1</span><br><span class="line">drwx------ root     root              2016-07-08 16:20 secure</span><br><span class="line">drwxr-x--- shell    sdcard_r          2016-07-08 16:20 shell</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@mx5:&#x2F;sdcard # ls -l</span><br><span class="line">drwxrwx--x root     sdcard_r          2016-07-07 10:33 Android</span><br><span class="line">drwxrwx--- root     sdcard_r          2015-01-01 00:00 Customize</span><br><span class="line">drwxrwx--- root     sdcard_r          2015-01-01 00:00 DCIM</span><br><span class="line">drwxrwx--- root     sdcard_r          2016-07-05 19:55 Download</span><br><span class="line">drwxrwx--- root     sdcard_r          2015-01-01 00:00 Movies</span><br><span class="line">drwxrwx--- root     sdcard_r          2015-01-01 00:00 Music</span><br><span class="line">drwxrwx--- root     sdcard_r          2015-01-01 00:00 Pictures</span><br></pre></td></tr></table></figure><p>在 Android L 上 , 访问 sdcard 的安全主要是通过用户组和权限来控制，详细介绍可以阅读本文开头的链接，这里就不赘述了。</p><p><strong>Android M:</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set up the global environment</span></span><br><span class="line">on init</span><br><span class="line">    <span class="built_in">export</span> ANDROID_STORAGE /storage</span><br><span class="line">    <span class="built_in">export</span> EXTERNAL_STORAGE /sdcard</span><br><span class="line">    <span class="built_in">export</span> ASEC_MOUNTPOINT /mnt/asec</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx root     root              1970-10-09 20:28 sdcard -&gt; &#x2F;storage&#x2F;self&#x2F;primary</span><br></pre></td></tr></table></figure><p>所以，在 Android M 上 , <strong>/storage/self</strong> 是访问 sdcard 的关键路径。这个路径非常重要，会在后面的原理介绍中讲到。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="Step-1-sdcard-挂载"><a href="#Step-1-sdcard-挂载" class="headerlink" title="Step 1: sdcard 挂载"></a>Step 1: sdcard 挂载</h4><p>不得已，首先得挂一串代码出来：<em>/system/core/sdcard/sdcard.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fuse_setup</span><span class="params">(struct fuse* fuse, <span class="keyword">gid_t</span> gid, <span class="keyword">mode_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> opts[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    fuse-&gt;fd = <span class="built_in">open</span>(<span class="string">"/dev/fuse"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fuse-&gt;fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to open fuse device: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umount2(fuse-&gt;dest_path, MNT_DETACH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(opts, <span class="keyword">sizeof</span>(opts),</span><br><span class="line">            <span class="string">"fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d"</span>,</span><br><span class="line">            fuse-&gt;fd, fuse-&gt;global-&gt;uid, fuse-&gt;global-&gt;gid);</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">"/dev/fuse"</span>, fuse-&gt;dest_path, <span class="string">"fuse"</span>, MS_NOSUID | MS_NODEV | MS_NOEXEC |</span><br><span class="line">            MS_NOATIME, opts) != <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to mount fuse filesystem: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fuse-&gt;gid = gid;</span><br><span class="line">    fuse-&gt;mask = mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* source_path, <span class="keyword">const</span> <span class="keyword">char</span>* label, <span class="keyword">uid_t</span> uid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">gid_t</span> gid, <span class="keyword">userid_t</span> userid, <span class="keyword">bool</span> multi_user, <span class="keyword">bool</span> full_write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_global</span> <span class="title">global</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse</span> <span class="title">fuse_default</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse</span> <span class="title">fuse_read</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse</span> <span class="title">fuse_write</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_handler</span> <span class="title">handler_default</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_handler</span> <span class="title">handler_read</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_handler</span> <span class="title">handler_write</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_default;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_read;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;global, <span class="number">0</span>, <span class="keyword">sizeof</span>(global));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fuse_default, <span class="number">0</span>, <span class="keyword">sizeof</span>(fuse_default));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fuse_read, <span class="number">0</span>, <span class="keyword">sizeof</span>(fuse_read));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fuse_write, <span class="number">0</span>, <span class="keyword">sizeof</span>(fuse_write));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;handler_default, <span class="number">0</span>, <span class="keyword">sizeof</span>(handler_default));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;handler_read, <span class="number">0</span>, <span class="keyword">sizeof</span>(handler_read));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;handler_write, <span class="number">0</span>, <span class="keyword">sizeof</span>(handler_write));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;global.lock, <span class="literal">NULL</span>);</span><br><span class="line">    global.package_to_appid = hashmapCreate(<span class="number">256</span>, str_hash, str_icase_equals);</span><br><span class="line">    global.uid = uid;</span><br><span class="line">    global.gid = gid;</span><br><span class="line">    global.multi_user = multi_user;</span><br><span class="line">    global.next_generation = <span class="number">0</span>;</span><br><span class="line">    global.inode_ctr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;global.root, <span class="number">0</span>, <span class="keyword">sizeof</span>(global.root));</span><br><span class="line">    global.root.nid = FUSE_ROOT_ID; <span class="comment">/* 1 */</span></span><br><span class="line">    global.root.refcount = <span class="number">2</span>;</span><br><span class="line">    global.root.namelen = <span class="built_in">strlen</span>(source_path);</span><br><span class="line">    global.root.name = strdup(source_path);</span><br><span class="line">    global.root.userid = userid;</span><br><span class="line">    global.root.uid = AID_ROOT;</span><br><span class="line">    global.root.under_android = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(global.source_path, source_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multi_user) &#123;</span><br><span class="line">        global.root.perm = PERM_PRE_ROOT;</span><br><span class="line">        <span class="built_in">snprintf</span>(global.obb_path, <span class="keyword">sizeof</span>(global.obb_path), <span class="string">"%s/obb"</span>, source_path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        global.root.perm = PERM_ROOT;</span><br><span class="line">        <span class="built_in">snprintf</span>(global.obb_path, <span class="keyword">sizeof</span>(global.obb_path), <span class="string">"%s/Android/obb"</span>, source_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fuse_default.global = &amp;global;</span><br><span class="line">    fuse_read.global = &amp;global;</span><br><span class="line">    fuse_write.global = &amp;global;</span><br><span class="line"></span><br><span class="line">    global.fuse_default = &amp;fuse_default;</span><br><span class="line">    global.fuse_read = &amp;fuse_read;</span><br><span class="line">    global.fuse_write = &amp;fuse_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(fuse_default.dest_path, PATH_MAX, <span class="string">"/mnt/runtime/default/%s"</span>, label);</span><br><span class="line">    <span class="built_in">snprintf</span>(fuse_read.dest_path, PATH_MAX, <span class="string">"/mnt/runtime/read/%s"</span>, label);</span><br><span class="line">    <span class="built_in">snprintf</span>(fuse_write.dest_path, PATH_MAX, <span class="string">"/mnt/runtime/write/%s"</span>, label);</span><br><span class="line"></span><br><span class="line">    handler_default.fuse = &amp;fuse_default;</span><br><span class="line">    handler_read.fuse = &amp;fuse_read;</span><br><span class="line">    handler_write.fuse = &amp;fuse_write;</span><br><span class="line"></span><br><span class="line">    handler_default.token = <span class="number">0</span>;</span><br><span class="line">    handler_read.token = <span class="number">1</span>;</span><br><span class="line">    handler_write.token = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multi_user) &#123;</span><br><span class="line">        <span class="comment">/* Multi-user storage is fully isolated per user, so "other"</span></span><br><span class="line"><span class="comment">         * permissions are completely masked off. */</span></span><br><span class="line">        <span class="keyword">if</span> (fuse_setup(&amp;fuse_default, AID_SDCARD_RW, <span class="number">0006</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_read, AID_EVERYBODY, <span class="number">0027</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_write, AID_EVERYBODY, full_write ? <span class="number">0007</span> : <span class="number">0027</span>)) &#123;</span><br><span class="line">            ERROR(<span class="string">"failed to fuse_setup\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Physical storage is readable by all users on device, but</span></span><br><span class="line"><span class="comment">         * the Android directories are masked off to a single user</span></span><br><span class="line"><span class="comment">         * deep inside attr_from_stat(). */</span></span><br><span class="line">        <span class="keyword">if</span> (fuse_setup(&amp;fuse_default, AID_SDCARD_RW, <span class="number">0006</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_read, AID_EVERYBODY, full_write ? <span class="number">0027</span> : <span class="number">0022</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_write, AID_EVERYBODY, full_write ? <span class="number">0007</span> : <span class="number">0022</span>)) &#123;</span><br><span class="line">            ERROR(<span class="string">"failed to fuse_setup\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Drop privs */</span></span><br><span class="line">    <span class="keyword">if</span> (setgroups(<span class="keyword">sizeof</span>(kGroups) / <span class="keyword">sizeof</span>(kGroups[<span class="number">0</span>]), kGroups) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot setgroups: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setgid(gid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot setgid: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setuid(uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot setuid: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multi_user) &#123;</span><br><span class="line">        fs_prepare_dir(global.obb_path, <span class="number">0775</span>, uid, gid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_default, <span class="literal">NULL</span>, start_handler, &amp;handler_default)</span><br><span class="line">            || pthread_create(&amp;thread_read, <span class="literal">NULL</span>, start_handler, &amp;handler_read)</span><br><span class="line">            || pthread_create(&amp;thread_write, <span class="literal">NULL</span>, start_handler, &amp;handler_write)) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to pthread_create\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watch_package_list(&amp;global);</span><br><span class="line">    ERROR(<span class="string">"terminated prematurely\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sdcard service 是 fuse 的守护进程，在 4.0 以后的 android 版本上，sdcard 都是通过 sdcard 服务来挂载和访问的，而且该服务程序还提供额外的权限控制。</p><p>上述代码是 sdcard 的挂载部分，关键代码即根据 vold 传过来的参数来准备好 uid/gid/userid 等信息，并且根据是否为多用户 ( multi_user )，是否 full_write 来准备好下面三个目录的用户组及其对应的权限：</p><ul><li>/mnt/runtime/default/emulated</li><li>/mnt/runtime/read/emulated</li><li>/mnt/runtime/write/emulated</li></ul><h4 id="Step-2-三视图"><a href="#Step-2-三视图" class="headerlink" title="Step 2: 三视图"></a>Step 2: 三视图</h4><p>在第一步结束后，所有挂载的存储设备都会维护三个不同视图：</p><ul><li><strong>/mnt/runtime/default</strong> - 对所有的应用、root 命名空间（adb 和其他系统组件）可见，而无需任何权限</li><li><strong>/mnt/runtime/read</strong> - 对有 <code>READ_EXTERNAL_STORAGE</code> 权限的应用可见。</li><li><strong>/mnt/runtime/write</strong> - 对有 <code>WRITE_EXTERNAL_STORAGE</code> 权限的应用可见。</li></ul><blockquote><p>为什么这样，请一直看到文章结尾，自然知晓原理。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@bullhead:&#x2F;mnt&#x2F;runtime&#x2F;default&#x2F;emulated # ls -l</span><br><span class="line">drwxrwx--x root     sdcard_rw          1970-03-04 02:51 0</span><br><span class="line">drwxrwx--x root     sdcard_rw          1970-03-04 02:51 obb</span><br><span class="line"></span><br><span class="line">root@bullhead:&#x2F;mnt&#x2F;runtime&#x2F;read&#x2F;emulated # ls -l</span><br><span class="line">drwxr-x--- root     everybody          1970-03-04 02:51 0</span><br><span class="line">drwxr-x--- root     everybody          1970-03-04 02:51 obb</span><br><span class="line"></span><br><span class="line">root@bullhead:&#x2F;mnt&#x2F;runtime&#x2F;write&#x2F;emulated # ls -l</span><br><span class="line">drwxrwx--- root     everybody          1970-03-04 02:51 0</span><br><span class="line">drwxrwx--- root     everybody          1970-03-04 02:51 obb</span><br></pre></td></tr></table></figure><p>上述 <strong>default/read/write</strong> 三个目录下的 <strong>0</strong> 和 <strong>obb</strong> 目录所赋予的用户组和权限各不相同。<br>这将为后面不同应用程序的运行时权限打下了基础。</p><blockquote><p>注意，这里的 0 代表用户 0 , 这里需要特别说明一下，从 4.0 后 android 也同时逐步引入了多用户的支持。</p></blockquote><h4 id="Step-3-应用程序启动授权"><a href="#Step-3-应用程序启动授权" class="headerlink" title="Step 3: 应用程序启动授权"></a>Step 3: 应用程序启动授权</h4><p>在 zygote fork app 时，我们为每个运行中的应用创建一个 mount 名字空间，并在其中 bind mount 合适的初始视图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a private mount namespace and bind mount appropriate emulated</span></span><br><span class="line"><span class="comment">// storage for the given user.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> bool <span class="title">MountEmulatedStorage</span><span class="params">(uid_t uid, jint mount_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">        bool force_mount_namespace)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See storage config details at http://source.android.com/tech/storage/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a second private mount namespace for our process</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNS) == -<span class="number">1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to unshare(): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unmount storage provided by root namespace and mount requested view</span></span><br><span class="line">    UnmountTree(<span class="string">"/storage"</span>);</span><br><span class="line"></span><br><span class="line">    String8 storageSource;</span><br><span class="line">    <span class="keyword">if</span> (mount_mode == MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">        storageSource = <span class="string">"/mnt/runtime/default"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mount_mode == MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">        storageSource = <span class="string">"/mnt/runtime/read"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mount_mode == MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">        storageSource = <span class="string">"/mnt/runtime/write"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Sane default of no storage visible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(storageSource.string(), <span class="string">"/storage"</span>,</span><br><span class="line">            NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to mount %s to /storage: %s"</span>, storageSource.string(), strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mount user-specific symlink helper into place</span></span><br><span class="line">    userid_t user_id = multiuser_get_user_id(uid);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> String8 <span class="title">userSource</span><span class="params">(String8::format(<span class="string">"/mnt/user/%d"</span>, user_id)</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (fs_prepare_dir(userSource.string(), <span class="number">0751</span>, <span class="number">0</span>, <span class="number">0</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(userSource.string(), <span class="string">"/storage/self"</span>,</span><br><span class="line">            NULL, MS_BIND, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to mount %s to /storage/self: %s"</span>, userSource.string(), strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仔细的分析这段代码做了些什么：</p><ol><li><p>根据 mount mode 从上面三个已经准备好的路径中选择一个默认的挂载路径，并将这个路径挂到 <code>/storage</code> 上去。注意：这里带的是 <code>MS_BIND | MS_REC | MS_SLAVE</code> 参数，这意味着会拷贝命名空间，所以，每个 app 进入的 <code>/storage</code> 都是私有的。</p></li><li><p>再根据当前的 user_id ，将 <code>/mnt/user/user_id</code> bind 到当前 <code>/storage</code> 的 self 目录上。</p></li></ol><p><strong>经过上述两步之后，达到了一个什么目的呢？</strong></p><p><strong><em>每个 app 都根据自己的授权，选择了不同权限的 runtime 目录进行访问，而不同用户访问的目录也跟去当前用户的 id 区分开了。</em></strong></p><blockquote><p>一切都完美的工作起来了，好像可以结束了！</p></blockquote><h4 id="Step-4-应用程序-runtime-授权"><a href="#Step-4-应用程序-runtime-授权" class="headerlink" title="Step 4: 应用程序 runtime 授权"></a>Step 4: 应用程序 runtime 授权</h4><blockquote><p>回到我们文章开头介绍的 runtime 权限，我们发现，到目前为止，我们似乎并不能 runtime 控制权限？那我们要如何做呢？</p></blockquote><p>其实方法特别简单，当被授予运行时权限时，vold 在运行中的应用的名字空间上，通过 bind mount 来更新视图。</p><ul><li>我猜测 runtime 授权的入口代码是这个：<br>  <em>/frameworks/base/services/core/java/com/android/server/pm/PermissionsState.java</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grantRuntimePermission</span><br><span class="line">  -&gt; onExternalStoragePolicyChanged</span><br><span class="line">    --&gt;remountUidExternalStorage</span><br><span class="line">    mConnector.execute(<span class="string">"volume"</span>, <span class="string">"remount_uid"</span>, uid, modeName);</span><br></pre></td></tr></table></figure><ul><li>然后 <em>/system/vold/CommandListener.cpp</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CommandListener::VolumeCmd::runCommand</span><br><span class="line">  -&gt;sendGenericOkFail(cli, vm-&gt;remountUid(uid, mode));</span><br></pre></td></tr></table></figure><ul><li>重点 <em>/system/vold/VolumeManager.cpp</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> VolumeManager::remountUid(uid_t uid, <span class="keyword">const</span> std::string&amp; mode) &#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"Remounting "</span> &lt;&lt; uid &lt;&lt; <span class="string">" as mode "</span> &lt;&lt; mode;</span><br><span class="line"></span><br><span class="line">    DIR* dir;</span><br><span class="line">    struct dirent* de;</span><br><span class="line">    <span class="keyword">char</span> rootName[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> pidName[PATH_MAX];</span><br><span class="line">    <span class="keyword">int</span> pidFd;</span><br><span class="line">    <span class="keyword">int</span> nsFd;</span><br><span class="line">    struct stat sb;</span><br><span class="line">    pid_t child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(dir = opendir(<span class="string">"/proc"</span>))) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to opendir"</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out root namespace to compare against below</span></span><br><span class="line">    <span class="keyword">if</span> (sane_readlinkat(dirfd(dir), <span class="string">"1/ns/mnt"</span>, rootName, PATH_MAX) == -<span class="number">1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to readlink"</span>;</span><br><span class="line">        closedir(dir);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poke through all running PIDs look for apps running as UID</span></span><br><span class="line">    <span class="keyword">while</span> ((de = readdir(dir))) &#123;</span><br><span class="line">        pidFd = -<span class="number">1</span>;</span><br><span class="line">        nsFd = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        pidFd = openat(dirfd(dir), de-&gt;d_name, O_RDONLY | O_DIRECTORY | O_CLOEXEC);</span><br><span class="line">        <span class="keyword">if</span> (pidFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fstat(pidFd, &amp;sb) != <span class="number">0</span>) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">"Failed to stat "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.st_uid != uid) &#123;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Matches so far, but refuse to touch if in root namespace</span></span><br><span class="line">        LOG(DEBUG) &lt;&lt; <span class="string">"Found matching PID "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span> (sane_readlinkat(pidFd, <span class="string">"ns/mnt"</span>, pidName, PATH_MAX) == -<span class="number">1</span>) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">"Failed to read namespace for "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!strcmp(rootName, pidName)) &#123;</span><br><span class="line">            LOG(WARNING) &lt;&lt; <span class="string">"Skipping due to root namespace"</span>;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We purposefully leave the namespace open across the fork</span></span><br><span class="line">        nsFd = openat(pidFd, <span class="string">"ns/mnt"</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (nsFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">"Failed to open namespace for "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(child = fork())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setns(nsFd, CLONE_NEWNS) != <span class="number">0</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Failed to setns for "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            unmount_tree(<span class="string">"/storage"</span>);</span><br><span class="line"></span><br><span class="line">            std::string storageSource;</span><br><span class="line">            <span class="keyword">if</span> (mode == <span class="string">"default"</span>) &#123;</span><br><span class="line">                storageSource = <span class="string">"/mnt/runtime/default"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">"read"</span>) &#123;</span><br><span class="line">                storageSource = <span class="string">"/mnt/runtime/read"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">"write"</span>) &#123;</span><br><span class="line">                storageSource = <span class="string">"/mnt/runtime/write"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Sane default of no storage visible</span></span><br><span class="line">                _exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(storageSource.c_str(), <span class="string">"/storage"</span>,</span><br><span class="line">                    NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Failed to mount "</span> &lt;&lt; storageSource &lt;&lt; <span class="string">" for "</span></span><br><span class="line">                        &lt;&lt; de-&gt;d_name;</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mount user-specific symlink helper into place</span></span><br><span class="line">            userid_t user_id = multiuser_get_user_id(uid);</span><br><span class="line">            std::<span class="function">string <span class="title">userSource</span><span class="params">(StringPrintf(<span class="string">"/mnt/user/%d"</span>, user_id)</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(userSource.c_str(), <span class="string">"/storage/self"</span>,</span><br><span class="line">                    NULL, MS_BIND, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Failed to mount "</span> &lt;&lt; userSource &lt;&lt; <span class="string">" for "</span></span><br><span class="line">                        &lt;&lt; de-&gt;d_name;</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child == -<span class="number">1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"Failed to fork"</span>;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TEMP_FAILURE_RETRY(waitpid(child, nullptr, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">        close(nsFd);</span><br><span class="line">        close(pidFd)</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述核心代码和 zygote 中很类似，不再赘述，至此，才算彻底搞清楚了 Androd M 在外置存储上权限控制的改变和多用户多进程下的安全原理。</p><blockquote><p>系统使用 <code>setns()</code> 函数来实现上述特性，这要求 Linux 3.8 , 不过 Linux 3.4 加上补丁上也可以支持该功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 外置存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Interrupt</title>
      <link href="/2016/09/02//linux-interrupt.html/"/>
      <url>/2016/09/02//linux-interrupt.html/</url>
      
        <content type="html"><![CDATA[<p>在面试的时候我们常常被问及一个问题：几种中断下半部机制 softirq、tasklet、workqueue 有什么区别？Linux 为什么要设计这几种机制？真正能够回答清楚的人还是少数的。下面我们就详细分析一下这其中的区别。</p><blockquote><p>本文的代码分析基于 Linux kernel 3.18.22 和 arm64 架构，最好的学习方法还是 “RTFSC”</p></blockquote><h2 id="1-Linux-中断"><a href="#1-Linux-中断" class="headerlink" title="1. Linux 中断"></a>1. Linux 中断</h2><p>arm64 和其他所有 CPU 架构的中断处理流程都是一样：正常执行流程被打断进入中断服务程序，保护现场、处理中断、恢复现场：</p><p><img src="/images/posts/2016/09/int_handler.png" alt=" 中断处理"><sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><p>在整个中断处理过程中，arm64 的 CPU 全局中断是自动 disable 的 (PSTATE 寄存器中的 interrupt bit 被 masks)。如果用户想支持 interrupt nested，需要自己在中断服务程序中使能中断。Linux 现在是不使用中断嵌套的。</p><p><img src="/images/posts/2016/09/int_nested_handler.png" alt=" 中断嵌套处理 "><sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><h3 id="1-1-CPU-中断打开-关闭"><a href="#1-1-CPU-中断打开-关闭" class="headerlink" title="1.1 CPU 中断打开 / 关闭"></a>1.1 CPU 中断打开 / 关闭</h3><p>arm64 关闭和打开本地 CPU 的全局中断的方法，是操作 SPSR(Saved Process Status Register) 寄存器 IRQ mask bit。</p><p><img src="/images/posts/2016/09/int_arm64_spsr.png" alt="Arm64 SPSR"><sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><p>Linux 中 arm64 关闭和打开本地 CPU 中断的函数实现。</p><ul><li>arch/arm64/include/asm/irqflags.h:</li><li><code>local_irq_disable()</code> -&gt; <code>raw_local_irq_disable()</code> -&gt; <code>arch_local_irq_disable()</code></li><li><code>local_irq_enable()</code> -&gt; <code>raw_local_irq_enable()</code> -&gt; <code>arch_local_irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_local_irq_enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (1) 清除 DAIF 中的 bit2 I 标志位，打开中断</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"msrdaifclr, #2// arch_local_irq_enable"</span></span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_local_irq_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (2) 设置 DAIF 中的 bit2 I 标志位，关闭中断</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"msrdaifset, #2// arch_local_irq_disable"</span></span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_local_irq_save</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (3) 备份 DAIF 标志</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mrs%0, daif// arch_local_irq_save\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"msrdaifset, #2"</span></span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"=r"</span> (flags)</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_local_save_flags</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (4) 恢复 DAIF 标志</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mrs%0, daif// arch_local_save_flags"</span></span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"=r"</span> (flags)</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-中断控制器-GIC"><a href="#1-2-中断控制器-GIC" class="headerlink" title="1.2 中断控制器 GIC"></a>1.2 中断控制器 GIC</h3><p>上面描述了 CPU 对全局中断的处理，但是还有一个工作需要有人去做：就是把外部中断、内部中断、CPU 间中断等各种中断按照优先级、亲和力、私有性等发送给多个 CPU。负责这个工作的就是中断控制器 GIC(Generic Interrupt Controller)。</p><p><img src="/images/posts/2016/09/int_gic400.gif" alt="GIC400"><sup><a href="#fn_GICANALY" id="reffn_GICANALY">GICANALY</a></sup></p><p>从软件角度上看，GIC 可以分成两个功能模块：<sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><ul><li>Distributor。负责连接系统中所有的中断源，通过寄存器可以独立的配置每个中断的属性：priority、state、security、outing information、enable status。定义哪些中断可以转发到 CPU core。</li><li>CPU Interface。CPU core 用来接收中断，寄存器主要提供的功能：mask、 identify 、control states of interrupts forwarded to that core。每个 CPU core 拥有自己的 CPU interface。</li></ul><p>对 GIC 来说，中断可以分成以下几种类型：<sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><ul><li>SGI(Software Generated Interrupt)，Interrupt IDs 0-15。系统一般用其来实现 IPI 中断。</li><li>PPI(Private Peripheral Interrupt)，Interrupt IDs16-31。私有中断，这种中断对每个 CPU 都是独立一份的，比如 per-core timer 中断。</li><li>SPI(Shared Peripheral Interrupt)，Interrupt numbers 32-1020。最常用的外设中断，中断可以发给一个或者多个 CPU。</li><li>LPI(Locality-specific Peripheral Interrupt)。基于 message 的中断，GICv2 和 GICv1 中不支持。</li></ul><p>GIC 从原理上理解并不难，但是如果涉及到级联等技术细节，整个初始化过程还是比较复杂。大家可以自行下载 GIC 手册：<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0471b/index.html" target="_blank" rel="noopener">GIC-400</a>、<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0516e/index.html" target="_blank" rel="noopener">GIC-500</a> 学习，<a href="http://www.wowotech.net/irq_subsystem/gic_driver.html" target="_blank" rel="noopener">GIC 代码分析 </a> 也是一篇很不错的分析文章。</p><p>一款 GIC 相关的操作函数都会集中到 irq_chip 数据结构中，以 GIC-400 为例，它的相关操作函数如下：</p><ul><li>drivers/irqchip/irq-gic.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> <span class="title">gic_chip</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"GIC"</span>,</span><br><span class="line">.irq_mask= gic_mask_irq,</span><br><span class="line">.irq_unmask= gic_unmask_irq,</span><br><span class="line">.irq_eoi= gic_eoi_irq,</span><br><span class="line">.irq_set_type= gic_set_type,</span><br><span class="line">.irq_retrigger= gic_retrigger,</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">.irq_set_affinity= gic_set_affinity,</span><br><span class="line">#endif</span><br><span class="line">.irq_set_wake= gic_set_wake,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-Linux-中断处理流程"><a href="#1-3-Linux-中断处理流程" class="headerlink" title="1.3 Linux 中断处理流程"></a>1.3 Linux 中断处理流程</h3><p>从代码上看 Linux 中断的处理流程大概是这样的：</p><p><img src="/images/posts/2016/09/int_handle_flow.png" alt="Linux 中断处理基本流程 "></p><p>从处理流程上看，对于 gic 的每个中断源，Linux 系统分配一个 irq_desc 数据结构与之对应。irq_desc 结构中有两个中断处理函数 <code>desc-&gt;handle_irq()</code> 和 <code>desc-&gt;action-&gt;handler()</code>，这两个函数代表中断处理的两个层级：</p><ul><li><p><code>desc-&gt;handle_irq()</code>。第一层次的中断处理函数，这个是系统在初始化时根据中断源的特征统一分配的，不同类型的中断源的 gic 操作是不一样的，把这些通用 gic 操作提取出来就是第一层次的操作函数。具体实现包括：</p><ul><li><code>handle_fasteoi_irq()</code></li><li><code>handle_simple_irq()</code></li><li><code>handle_edge_irq()</code></li><li><code>handle_level_irq()</code></li><li><code>handle_percpu_irq()</code></li><li><code>handle_percpu_devid_irq()</code></li></ul></li><li><p><code>desc-&gt;action-&gt;handler()</code> 第二层次的中断处理函数，由用户注册实现具体设备的驱动服务程序，都是和 GIC 操作无关的代码。同时一个中断源可以多个设备共享，所以一个 desc 可以挂载多个 action，由链表结构组织起来。</p></li></ul><p><img src="/images/posts/2016/09/int_handler_action.png" alt="Linux 中断处理层级 "></p><h3 id="1-4-中断服务注册"><a href="#1-4-中断服务注册" class="headerlink" title="1.4 中断服务注册"></a>1.4 中断服务注册</h3><p>从上一节的中断二层结构中可以看到第二层的中断处理函数 desc-&gt;action-&gt;handler 是由用户来注册的，下面我们来分析具体注册过程：</p><ul><li>kernel/irq/manage.c:</li><li><code>request_irq()</code> -&gt; <code>request_threaded_irq()</code> -&gt; <code>__setup_irq()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __must_check</span><br><span class="line">request_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment"> * otherwise we'll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment"> * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment"> * logic etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 根据中断号找到对应的 desc 结构</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 如果 action-&gt;handler 为空，那么用户是想创建一个线程化中断</span></span><br><span class="line"><span class="comment">// 将线程化中断的 action-&gt;handler 初始化为 irq_default_primary_handler()</span></span><br><span class="line"><span class="comment">// irq_default_primary_handler() 非常简单，只是返回一个 IRQ_WAKE_THREAD 值</span></span><br><span class="line"><span class="keyword">if</span> (!handler) &#123;</span><br><span class="line"><span class="keyword">if</span> (!thread_fn)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">handler = irq_default_primary_handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 分配新的 action 数据结构</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(struct irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;</span><br><span class="line">action-&gt;thread_fn = thread_fn;</span><br><span class="line">action-&gt;flags = irqflags;</span><br><span class="line">action-&gt;name = devname;</span><br><span class="line">action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">chip_bus_lock(desc);</span><br><span class="line"><span class="comment">// (4) 将新的 action 结构安装到 desc 中</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br><span class="line">chip_bus_sync_unlock(desc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">kfree(action);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line"><span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It's a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment"> * to happen immediately, so let's make sure....</span></span><br><span class="line"><span class="comment"> * We disable the irq to make sure that a 'real' IRQ doesn't</span></span><br><span class="line"><span class="comment"> * run in parallel with our fake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">disable_irq(irq);</span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">enable_irq(irq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__setup_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_desc *desc, struct irqaction *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">old</span>, **<span class="title">old_ptr</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags, thread_mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret, nested, shared = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">cpumask_var_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip == &amp;no_irq_chip)</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(desc-&gt;owner))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether the interrupt nests into another interrupt</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nested = irq_settings_is_nested_thread(desc);</span><br><span class="line"><span class="comment">// (4.1) 判断中断是否是支持嵌套</span></span><br><span class="line"><span class="keyword">if</span> (nested) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>-&gt;thread_fn) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Replace the primary handler which was provided from</span></span><br><span class="line"><span class="comment"> * the driver for non nested interrupt handling by the</span></span><br><span class="line"><span class="comment"> * dummy function which warns when called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span>-&gt;handler = irq_nested_primary_handler;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (4.2) 判断中断是否可以被线程化</span></span><br><span class="line"><span class="comment">// 如果中断没有设置 _IRQ_NOTHREAD 标志 &amp; 强制中断线程化标志被设置 (force_irqthreads=1)</span></span><br><span class="line"><span class="comment">// 强制把中断线程化：</span></span><br><span class="line"><span class="comment">// new-&gt;thread_fn = new-&gt;handler;new-&gt;handler = irq_default_primary_handler;</span></span><br><span class="line"><span class="keyword">if</span> (irq_settings_can_thread(desc))</span><br><span class="line">irq_setup_forced_threading(<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a handler thread when a thread function is supplied</span></span><br><span class="line"><span class="comment"> * and the interrupt does not nest into another interrupt</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.3) 如果是线程化中断，创建线程化中断对应的线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span></span><br><span class="line">.sched_priority = MAX_USER_RT_PRIO/<span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">t = kthread_create(irq_thread, <span class="keyword">new</span>, <span class="string">"irq/%d-%s"</span>, irq,</span><br><span class="line">   <span class="keyword">new</span>-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(t)) &#123;</span><br><span class="line">ret = PTR_ERR(t);</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sched_setscheduler_nocheck(t, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We keep the reference to the task struct even if</span></span><br><span class="line"><span class="comment"> * the thread dies to avoid that the interrupt code</span></span><br><span class="line"><span class="comment"> * references an already freed task_struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">get_task_struct(t);</span><br><span class="line"><span class="comment">// 赋值给 -&gt;thread 成员</span></span><br><span class="line"><span class="keyword">new</span>-&gt;thread = t;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell the thread to set its affinity. This is</span></span><br><span class="line"><span class="comment"> * important for shared interrupt handlers as we do</span></span><br><span class="line"><span class="comment"> * not invoke setup_affinity() for the secondary</span></span><br><span class="line"><span class="comment"> * handlers as everything is already set up. Even for</span></span><br><span class="line"><span class="comment"> * interrupts marked with IRQF_NO_BALANCE this is</span></span><br><span class="line"><span class="comment"> * correct as we want the thread to move to the cpu(s)</span></span><br><span class="line"><span class="comment"> * on which the requesting code placed the interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_bit(IRQTF_AFFINITY, &amp;<span class="keyword">new</span>-&gt;thread_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!alloc_cpumask_var(&amp;mask, GFP_KERNEL)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Drivers are often written to work w/o knowledge about the</span></span><br><span class="line"><span class="comment"> * underlying irq chip implementation, so a request for a</span></span><br><span class="line"><span class="comment"> * threaded irq without a primary hard irq context handler</span></span><br><span class="line"><span class="comment"> * requires the ONESHOT flag to be set. Some irq chips like</span></span><br><span class="line"><span class="comment"> * MSI based interrupts are per se one shot safe. Check the</span></span><br><span class="line"><span class="comment"> * chip flags, so we can avoid the unmask dance at the end of</span></span><br><span class="line"><span class="comment"> * the threaded handler for those.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)</span><br><span class="line"><span class="keyword">new</span>-&gt;flags &amp;= ~IRQF_ONESHOT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following block of code has to be executed atomically</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.4) 找到最后一个 action 结构</span></span><br><span class="line">raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</span><br><span class="line">old_ptr = &amp;desc-&gt;action;</span><br><span class="line">old = *old_ptr;</span><br><span class="line"><span class="keyword">if</span> (old) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Can't share interrupts unless both agree to and are</span></span><br><span class="line"><span class="comment"> * the same type (level, edge, polarity). So both flag</span></span><br><span class="line"><span class="comment"> * fields must have IRQF_SHARED set and the bits which</span></span><br><span class="line"><span class="comment"> * set the trigger type must match. Also all must</span></span><br><span class="line"><span class="comment"> * agree on ONESHOT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!((old-&gt;flags &amp; <span class="keyword">new</span>-&gt;flags) &amp; IRQF_SHARED) ||</span><br><span class="line">    ((old-&gt;flags ^ <span class="keyword">new</span>-&gt;flags) &amp; IRQF_TRIGGER_MASK) ||</span><br><span class="line">    ((old-&gt;flags ^ <span class="keyword">new</span>-&gt;flags) &amp; IRQF_ONESHOT))</span><br><span class="line"><span class="keyword">goto</span> mismatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All handlers must agree on per-cpuness */</span></span><br><span class="line"><span class="keyword">if</span> ((old-&gt;flags &amp; IRQF_PERCPU) !=</span><br><span class="line">    (<span class="keyword">new</span>-&gt;flags &amp; IRQF_PERCPU))</span><br><span class="line"><span class="keyword">goto</span> mismatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* add new interrupt at end of irq queue */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Or all existing action-&gt;thread_mask bits,</span></span><br><span class="line"><span class="comment"> * so we can find the next zero bit for this</span></span><br><span class="line"><span class="comment"> * new action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">thread_mask |= old-&gt;thread_mask;</span><br><span class="line">old_ptr = &amp;old-&gt;next;</span><br><span class="line">old = *old_ptr;</span><br><span class="line">&#125; <span class="keyword">while</span> (old);</span><br><span class="line"><span class="comment">// 如果有多个 action，共享标志设为 1</span></span><br><span class="line">shared = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the thread mask for this irqaction for ONESHOT. For</span></span><br><span class="line"><span class="comment"> * !ONESHOT irqs the thread mask is 0 so we can avoid a</span></span><br><span class="line"><span class="comment"> * conditional in irq_wake_thread().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_ONESHOT) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unlikely to have 32 resp 64 irqs sharing one line,</span></span><br><span class="line"><span class="comment"> * but who knows.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (thread_mask == ~<span class="number">0U</span>L) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The thread_mask for the action is or'ed to</span></span><br><span class="line"><span class="comment"> * desc-&gt;thread_active to indicate that the</span></span><br><span class="line"><span class="comment"> * IRQF_ONESHOT thread handler has been woken, but not</span></span><br><span class="line"><span class="comment"> * yet finished. The bit is cleared when a thread</span></span><br><span class="line"><span class="comment"> * completes. When all threads of a shared interrupt</span></span><br><span class="line"><span class="comment"> * line have completed desc-&gt;threads_active becomes</span></span><br><span class="line"><span class="comment"> * zero and the interrupt line is unmasked. See</span></span><br><span class="line"><span class="comment"> * handle.c:irq_wake_thread() for further information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no thread is woken by primary (hard irq context)</span></span><br><span class="line"><span class="comment"> * interrupt handlers, then desc-&gt;threads_active is</span></span><br><span class="line"><span class="comment"> * also checked for zero to unmask the irq line in the</span></span><br><span class="line"><span class="comment"> * affected hard irq flow handlers</span></span><br><span class="line"><span class="comment"> * (handle_[fasteoi|level]_irq).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The new action gets the first zero bit of</span></span><br><span class="line"><span class="comment"> * thread_mask assigned. See the loop above which or's</span></span><br><span class="line"><span class="comment"> * all existing action-&gt;thread_mask bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span>-&gt;thread_mask = <span class="number">1</span> &lt;&lt; ffz(thread_mask);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;handler == irq_default_primary_handler &amp;&amp;</span><br><span class="line">   !(desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The interrupt was requested with handler = NULL, so</span></span><br><span class="line"><span class="comment"> * we use the default primary handler for it. But it</span></span><br><span class="line"><span class="comment"> * does not have the oneshot flag set. In combination</span></span><br><span class="line"><span class="comment"> * with level interrupts this is deadly, because the</span></span><br><span class="line"><span class="comment"> * default primary handler just wakes the thread, then</span></span><br><span class="line"><span class="comment"> * the irq lines is reenabled, but the device still</span></span><br><span class="line"><span class="comment"> * has the level irq asserted. Rinse and repeat....</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * While this works for edge type interrupts, we play</span></span><br><span class="line"><span class="comment"> * it safe and reject unconditionally because we can't</span></span><br><span class="line"><span class="comment"> * say for sure which type this interrupt really</span></span><br><span class="line"><span class="comment"> * has. The type flags are unreliable as the</span></span><br><span class="line"><span class="comment"> * underlying chip implementation can override them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pr_err(<span class="string">"Threaded irq requested with handler=NULL and !ONESHOT for irq %d\n"</span>,</span><br><span class="line">       irq);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.5) 如果是第一个 action，做一些初始化工作</span></span><br><span class="line"><span class="keyword">if</span> (!shared) &#123;</span><br><span class="line">ret = irq_request_resources(desc);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">"Failed to request resources for %s (irq %d) on irqchip %s\n"</span>,</span><br><span class="line">       <span class="keyword">new</span>-&gt;name, irq, desc-&gt;irq_data.chip-&gt;name);</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_waitqueue_head(&amp;desc-&gt;wait_for_threads);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup the type (level, edge polarity) if configured: */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK) &#123;</span><br><span class="line">ret = __irq_set_trigger(desc, irq,</span><br><span class="line"><span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \</span><br><span class="line">  IRQS_ONESHOT | IRQS_WAITING);</span><br><span class="line">irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_PERCPU) &#123;</span><br><span class="line">irqd_set(&amp;desc-&gt;irq_data, IRQD_PER_CPU);</span><br><span class="line">irq_settings_set_per_cpu(desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_ONESHOT)</span><br><span class="line">desc-&gt;istate |= IRQS_ONESHOT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq_settings_can_autoenable(desc))</span><br><span class="line">irq_startup(desc, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* Undo nested disables: */</span></span><br><span class="line">desc-&gt;depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exclude IRQ from balancing if requested */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_NOBALANCING) &#123;</span><br><span class="line">irq_settings_set_no_balancing(desc);</span><br><span class="line">irqd_set(&amp;desc-&gt;irq_data, IRQD_NO_BALANCING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断亲和力</span></span><br><span class="line"><span class="comment">/* Set default affinity mask once everything is setup */</span></span><br><span class="line">setup_affinity(irq, desc, mask);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nmsk = <span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> omsk = irq_settings_get_trigger_mask(desc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nmsk != omsk)</span><br><span class="line"><span class="comment">/* hope the handler works with current  trigger mode */</span></span><br><span class="line">pr_warning(<span class="string">"irq %d uses trigger mode %u; requested %u\n"</span>,</span><br><span class="line">   irq, nmsk, omsk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.6) 将新的 action 插入到 desc 链表中</span></span><br><span class="line"><span class="keyword">new</span>-&gt;irq = irq;</span><br><span class="line">*old_ptr = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">irq_pm_install_action(desc, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset broken irq detection when installing new handler */</span></span><br><span class="line">desc-&gt;irq_count = <span class="number">0</span>;</span><br><span class="line">desc-&gt;irqs_unhandled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether we disabled the irq via the spurious handler</span></span><br><span class="line"><span class="comment"> * before. Reenable it and give it another chance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.7) 如果中断之前被虚假 disable 了，重新 enable 中断</span></span><br><span class="line"><span class="keyword">if</span> (shared &amp;&amp; (desc-&gt;istate &amp; IRQS_SPURIOUS_DISABLED)) &#123;</span><br><span class="line">desc-&gt;istate &amp;= ~IRQS_SPURIOUS_DISABLED;</span><br><span class="line">__enable_irq(desc, irq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Strictly no need to wake it up, but hung_task complains</span></span><br><span class="line"><span class="comment"> * when no hard interrupt wakes the thread up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.8) 唤醒线程化中断对应的线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread)</span><br><span class="line">wake_up_process(<span class="keyword">new</span>-&gt;thread);</span><br><span class="line"></span><br><span class="line">register_irq_proc(irq, desc);</span><br><span class="line"><span class="keyword">new</span>-&gt;dir = <span class="literal">NULL</span>;</span><br><span class="line">register_handler_proc(irq, <span class="keyword">new</span>);</span><br><span class="line">free_cpumask_var(mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mismatch:</span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">new</span>-&gt;flags &amp; IRQF_PROBE_SHARED)) &#123;</span><br><span class="line">pr_err(<span class="string">"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\n"</span>,</span><br><span class="line">       irq, <span class="keyword">new</span>-&gt;flags, <span class="keyword">new</span>-&gt;name, old-&gt;flags, old-&gt;name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SHIRQ</span></span><br><span class="line">dump_stack();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"></span><br><span class="line">out_mask:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line">free_cpumask_var(mask);</span><br><span class="line"></span><br><span class="line">out_thread:</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span> = <span class="title">new</span>-&gt;<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;thread = <span class="literal">NULL</span>;</span><br><span class="line">kthread_stop(t);</span><br><span class="line">put_task_struct(t);</span><br><span class="line">&#125;</span><br><span class="line">out_mput:</span><br><span class="line">module_put(desc-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-中断线程化"><a href="#1-5-中断线程化" class="headerlink" title="1.5 中断线程化"></a>1.5 中断线程化</h3><p>从上一节可以看到，使用 <code>request_irq()</code> 注册的是传统中断，而直接使用 <code>request_threaded_irq()</code> 注册的是线程化中断。线程化中断的主要目的是把中断上下文的任务迁移到线程中，减少系统关中断的时间，增强系统的实时性。</p><p>中断对应的线程命名规则为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = kthread_create(irq_thread, <span class="keyword">new</span>, <span class="string">"irq/%d-%s"</span>, irq, <span class="keyword">new</span>-&gt;name);</span><br></pre></td></tr></table></figure><p>我们通过 ps 命令查看系统中的中断线程，注意这些线程是实时线程 SCHED_FIFO：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@:/ <span class="meta"># ps | grep <span class="meta-string">"irq/"</span></span></span><br><span class="line">root      <span class="number">171</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">389</span>-charger</span><br><span class="line">root      <span class="number">239</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">296</span>-PS_int-</span><br><span class="line">root      <span class="number">247</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">297</span><span class="number">-1124000</span></span><br><span class="line">root      <span class="number">1415</span>  <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">293</span>-goodix_</span><br><span class="line">root@a0255:/ #</span><br></pre></td></tr></table></figure><p>线程化中断的创建和处理任务流程如下：</p><p><img src="/images/posts/2016/09/int_thread_irq.png" alt="Linux 线程化中断 "></p><p>线程和 action 是一一对应的，即用户注册一个中断处理程序对应一个中断线程。</p><h3 id="1-6-外设中断打开-关闭"><a href="#1-6-外设中断打开-关闭" class="headerlink" title="1.6 外设中断打开 / 关闭"></a>1.6 外设中断打开 / 关闭</h3><p>前面的章节讲述了本地 CPU 全局中断的 enable/disable。如果要操作单个中断源的 enable/disable，使用 <code>enable_irq()</code>/<code>disable_irq()</code> 函数。最后调用主要是 GIC chip 相关的函数：</p><ul><li>kernel/irq/manage.c:</li><li><code>enable_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_get_desc_buslock</span>(<span class="title">irq</span>, &amp;<span class="title">flags</span>, <span class="title">IRQ_GET_DESC_CHECK_GLOBAL</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (WARN(!desc-&gt;irq_data.chip,</span><br><span class="line"> KERN_ERR <span class="string">"enable_irq before setup/request_irq: irq %u\n"</span>, irq))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">__enable_irq(desc, irq);</span><br><span class="line">out:</span><br><span class="line">irq_put_desc_busunlock(desc, flags);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">void</span> __enable_irq(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (desc-&gt;depth) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> err_out:</span><br><span class="line">WARN(<span class="number">1</span>, KERN_WARNING <span class="string">"Unbalanced enable for IRQ %d\n"</span>, irq);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_SUSPENDED)</span><br><span class="line"><span class="keyword">goto</span> err_out;</span><br><span class="line"><span class="comment">/* Prevent probing on this irq: */</span></span><br><span class="line">irq_settings_set_noprobe(desc);</span><br><span class="line">irq_enable(desc);</span><br><span class="line">check_irq_resend(desc, irq);</span><br><span class="line"><span class="comment">/* fall-through */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">desc-&gt;depth--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_enable</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 操作 GIC chip 对应的函数</span></span><br><span class="line">irq_state_clr_disabled(desc);</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;irq_enable)</span><br><span class="line">desc-&gt;irq_data.chip-&gt;irq_enable(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">desc-&gt;irq_data.chip-&gt;irq_unmask(&amp;desc-&gt;irq_data);</span><br><span class="line">irq_state_clr_masked(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kernel/irq/manage.c:</li><li><code>enable_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!__disable_irq_nosync(irq))</span><br><span class="line">synchronize_irq(irq);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __disable_irq_nosync(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_get_desc_buslock</span>(<span class="title">irq</span>, &amp;<span class="title">flags</span>, <span class="title">IRQ_GET_DESC_CHECK_GLOBAL</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">__disable_irq(desc, irq);</span><br><span class="line">irq_put_desc_busunlock(desc, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">void</span> __disable_irq(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!desc-&gt;depth++)</span><br><span class="line">irq_disable(desc);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_disable</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 操作 GIC chip 对应的函数</span></span><br><span class="line">irq_state_set_disabled(desc);</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;irq_disable) &#123;</span><br><span class="line">desc-&gt;irq_data.chip-&gt;irq_disable(&amp;desc-&gt;irq_data);</span><br><span class="line">irq_state_set_masked(desc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_to_desc</span>(<span class="title">irq</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc) &#123;</span><br><span class="line">__synchronize_hardirq(desc);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We made sure that no hardirq handler is</span></span><br><span class="line"><span class="comment"> * running. Now verify that no threaded handlers are</span></span><br><span class="line"><span class="comment"> * active.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果是线程化中断，需要等到线程执行完成</span></span><br><span class="line">wait_event(desc-&gt;wait_for_threads,</span><br><span class="line">   !atomic_read(&amp;desc-&gt;threads_active));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-中断亲和力"><a href="#1-7-中断亲和力" class="headerlink" title="1.7 中断亲和力"></a>1.7 中断亲和力</h3><p>同样基于 GIC chip 提供的能力，我们能配置中断源对 CPU 的亲和力。</p><ul><li>kernel/irq/manage.c:</li><li><code>enable_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">irq_set_affinity(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">const</span> struct cpumask *cpumask)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __irq_set_affinity(irq, cpumask, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">int</span> __irq_set_affinity(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">const</span> struct cpumask *mask, <span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_to_desc</span>(<span class="title">irq</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</span><br><span class="line">ret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq_set_affinity_locked</span><span class="params">(struct irq_data *data, <span class="keyword">const</span> struct cpumask *mask,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> = <span class="title">irq_data_get_irq_chip</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_data_to_desc</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!chip || !chip-&gt;irq_set_affinity)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq_can_move_pcntxt(data)) &#123;</span><br><span class="line">ret = irq_do_set_affinity(data, mask, force);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">irqd_set_move_pending(data);</span><br><span class="line">irq_copy_pending(desc, mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;affinity_notify) &#123;</span><br><span class="line">kref_get(&amp;desc-&gt;affinity_notify-&gt;kref);</span><br><span class="line">schedule_work(&amp;desc-&gt;affinity_notify-&gt;work);</span><br><span class="line">&#125;</span><br><span class="line">irqd_set(data, IRQD_AFFINITY_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq_do_set_affinity</span><span class="params">(struct irq_data *data, <span class="keyword">const</span> struct cpumask *mask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_data_to_desc</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> = <span class="title">irq_data_get_irq_chip</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作 GIC chip 对应的函数</span></span><br><span class="line">ret = chip-&gt;irq_set_affinity(data, mask, force);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> IRQ_SET_MASK_OK:</span><br><span class="line"><span class="keyword">case</span> IRQ_SET_MASK_OK_DONE:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_IRQ_NEW_DESIGN</span></span><br><span class="line">update_affinity_settings(desc, mask, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">cpumask_copy(data-&gt;affinity, mask);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">case</span> IRQ_SET_MASK_OK_NOCOPY:</span><br><span class="line">irq_set_thread_affinity(desc);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Linux-中断下半部"><a href="#2-Linux-中断下半部" class="headerlink" title="2. Linux 中断下半部"></a>2. Linux 中断下半部</h2><p>接下来就是大名鼎鼎的中断下半部了，包括：softirq、tasklet、workqueue。中断下半部的主要目的就是减少系统关中断的时间，把关键代码放在中断中做，大部分处理代码放到不用关中断的空间去做。</p><p>上面有最激进的方法中断线程化，但是大部分时候还是需要用到中断上、下半部的方法。</p><p>workqueue 在另外文章中已经有详细解析，本处只解析 softirq、tasklet。</p><h3 id="2-1-preempt-count"><a href="#2-1-preempt-count" class="headerlink" title="2.1 preempt_count"></a>2.1 preempt_count</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline int preempt_count(void)</span><br><span class="line">&#123;</span><br><span class="line">return current_thread_info()-&gt;preempt_count;&#x2F;* 0 &#x3D;&gt; preemptable, &lt;0 &#x3D;&gt; bug *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始之前先了解一下 preempt_count 这个背景知识，preempt_count 是 thread_info 结构中的一个字段，用来表示当前进程能否被抢占。</p><p>所谓的抢占：是指在进程在内核空间运行，如果主动不释放 CPU，在时间片用完或者高优先级任务就绪的情况下，会被强行剥夺掉 CPU 的使用权。</p><p>但是进程可能在做一些关键操作，不能被抢占，被抢占后系统会出错。所以 Linux 设计了 preempt_count 字段，=0 可以被抢占，&gt;0 不能被抢占。</p><p>进程在中断返回内核态时，做是否可抢占的检查：</p><ul><li>arch/arm64/kernel/entry.s:</li><li><code>el1_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.align<span class="number">6</span></span><br><span class="line">el1_irq:</span><br><span class="line">kernel_entry <span class="number">1</span></span><br><span class="line">enable_dbg</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_off</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">bl  MT_trace_hardirqs_off</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">irq_handler</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">get_thread_info tsk</span><br><span class="line">ldrw24, [tsk, #TI_PREEMPT]<span class="comment">// get preempt count</span></span><br><span class="line"><span class="comment">// (1) 如果 preempt_count!=0，不进行可抢占判断</span></span><br><span class="line">cbnzw24, <span class="number">1f</span><span class="comment">// preempt count != 0</span></span><br><span class="line">ldrx0, [tsk, #TI_FLAGS]<span class="comment">// get flags</span></span><br><span class="line"><span class="comment">// (2) 如果 preempt_count==0 &amp; TIF_NEED_RESCHED 被置位</span></span><br><span class="line"><span class="comment">// 进行调度</span></span><br><span class="line">tbzx0, #TIF_NEED_RESCHED, <span class="number">1f</span><span class="comment">// needs rescheduling?</span></span><br><span class="line">blel1_preempt</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">bl  MT_trace_hardirqs_on</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_on</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">kernel_exit <span class="number">1</span></span><br><span class="line">ENDPROC(el1_irq)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">el1_preempt:</span><br><span class="line">movx24, lr</span><br><span class="line"><span class="comment">// (3) 抢占调度</span></span><br><span class="line"><span class="number">1</span>:blpreempt_schedule_irq<span class="comment">// irq en/disable is done inside</span></span><br><span class="line">ldrx0, [tsk, #TI_FLAGS]<span class="comment">// get new tasks TI_FLAGS</span></span><br><span class="line">tbnzx0, #TIF_NEED_RESCHED, <span class="number">1b</span><span class="comment">// needs rescheduling?</span></span><br><span class="line">retx24</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">| →</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">preempt_schedule_irq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> ctx_state prev_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Catch callers which need to be fixed */</span></span><br><span class="line">BUG_ON(preempt_count() || !irqs_disabled());</span><br><span class="line"></span><br><span class="line">prev_state = exception_enter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">__preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">local_irq_enable();</span><br><span class="line">__schedule();</span><br><span class="line">local_irq_disable();</span><br><span class="line">__preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check again in case we missed a preemption opportunity</span></span><br><span class="line"><span class="comment"> * between schedule and now.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">barrier();</span><br><span class="line">&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line"></span><br><span class="line">exception_exit(prev_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 preempt_count&gt;0 就是禁止抢占，Linux 进一步按照各种场景对 preempt_count bit 进行了资源划分：</p><div class="table-container"><table><thead><tr><th>reserved bits</th><th style="text-align:center">bit21</th><th style="text-align:center">bit20</th><th style="text-align:center">bit19-bit16</th><th style="text-align:center">bit15-bit8</th><th style="text-align:center">bit7-bit0</th></tr></thead><tbody><tr><td></td><td style="text-align:center">PREEMPT_ACTIVE</td><td style="text-align:center">NMI</td><td style="text-align:center">HARDIRQ</td><td style="text-align:center">SOFTIRQ</td><td style="text-align:center">PREEMPT</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * PREEMPT_MASK:0x000000ff</span><br><span class="line"> * SOFTIRQ_MASK:0x0000ff00</span><br><span class="line"> * HARDIRQ_MASK:0x000f0000</span><br><span class="line"> *     NMI_MASK:0x00100000</span><br><span class="line"> * PREEMPT_ACTIVE:0x00200000</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define PREEMPT_BITS8</span><br><span class="line">#define SOFTIRQ_BITS8</span><br><span class="line">#define HARDIRQ_BITS4</span><br><span class="line">#define NMI_BITS1</span><br></pre></td></tr></table></figure><p>各场景分别利用各自的 bit 来 disable/enable 抢占：</p><ul><li>普通场景 (PREEMPT_MASK)。对应函数 <code>preempt_disable()</code>、<code>preempt_enable()</code>。</li><li>软中断场景 (SOFTIRQ_MASK)。对应函数 <code>local_bh_disable()</code>、<code>local_bh_enable()</code>。</li><li>普通中断场景 (HARDIRQ_MASK)。对应函数 <code>__irq_enter()</code>、<code>__irq_exit()</code>。</li><li>NMI 中断场景 (NMI_MASK)。对应函数 <code>nmi_enter()</code>、<code>nmi_exit()</code>。</li></ul><p>所以反过来，我们也可以通过 preempt_count 的值来判断当前在什么场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define in_irq()(hardirq_count())</span><br><span class="line">#define in_softirq()(softirq_count())</span><br><span class="line">#define in_interrupt()(irq_count())</span><br><span class="line">#define in_serving_softirq()(softirq_count() &amp; SOFTIRQ_OFFSET)</span><br><span class="line">#define in_nmi()(preempt_count() &amp; NMI_MASK)</span><br><span class="line"></span><br><span class="line">#define hardirq_count()(preempt_count() &amp; HARDIRQ_MASK)</span><br><span class="line">#define softirq_count()(preempt_count() &amp; SOFTIRQ_MASK)</span><br><span class="line">#define irq_count()(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line"> | NMI_MASK))</span><br></pre></td></tr></table></figure><h3 id="2-2-softirq"><a href="#2-2-softirq" class="headerlink" title="2.2 softirq"></a>2.2 softirq</h3><p>回到中断上下半部的架构，linux 系统虽然将大部分工作移出了中断上下文，不关闭中断。但是它也希望移出的工作能够很快的得到执行，软中断为了保证自己能很快执行，使用 <code>__local_bh_disable_ip()</code> 禁止抢占。</p><p>softirq 的具体实现机制如下：</p><ul><li>系统支持固定的几种软中断，softirq_vec 数组用来记录这些软中断执行函数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">HI_SOFTIRQ&#x3D;0,</span><br><span class="line">TIMER_SOFTIRQ,</span><br><span class="line">NET_TX_SOFTIRQ,</span><br><span class="line">NET_RX_SOFTIRQ,</span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ,</span><br><span class="line">SCHED_SOFTIRQ,</span><br><span class="line">HRTIMER_SOFTIRQ,</span><br><span class="line">RCU_SOFTIRQ,    &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</span><br><span class="line"></span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册软中断的服务程序</span><br><span class="line">void open_softirq(int nr, void (*action)(struct softirq_action *))</span><br><span class="line">&#123;</span><br><span class="line">softirq_vec[nr].action &#x3D; action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;TASKLET_SOFTIRQ、HI_SOFTIRQ 两个软中断用来给 tasklet 服务。</span><br><span class="line">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br></pre></td></tr></table></figure><ul><li>使用 irq_stat[cpu].__softirq_pending 来记录每个 cpu 上所有 softirq 的 pending 状态，<code>raise_softirq()</code> 用来置位一个 softirq pending：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void raise_softirq(unsigned int nr)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">raise_softirq_irqoff(nr);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line">inline void raise_softirq_irqoff(unsigned int nr)</span><br><span class="line">&#123;</span><br><span class="line">__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">if (!in_interrupt())</span><br><span class="line">wakeup_softirqd();</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line">void __raise_softirq_irqoff(unsigned int nr)</span><br><span class="line">&#123;</span><br><span class="line">trace_softirq_raise(nr);</span><br><span class="line">or_softirq_pending(1UL &lt;&lt; nr);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line">#define or_softirq_pending(x)  (local_softirq_pending() |&#x3D; (x))</span><br><span class="line"></span><br><span class="line">#ifndef __ARCH_IRQ_STAT</span><br><span class="line">extern irq_cpustat_t irq_stat[];&#x2F;* defined in asm&#x2F;hardirq.h *&#x2F;</span><br><span class="line">#define __IRQ_STAT(cpu, member)(irq_stat[cpu].member)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* arch independent irq_stat fields *&#x2F;</span><br><span class="line">#define local_softirq_pending() \</span><br><span class="line">__IRQ_STAT(smp_processor_id(), __softirq_pending)</span><br></pre></td></tr></table></figure><ul><li>softirq 的执行有两个时刻：在退出中断 <code>irq_exit()</code> 时或者在 softirqd 线程当中：</li></ul><p><img src="/images/posts/2016/09/int_softirq_flow.png" alt="linux 软中断流程 "></p><p>软中断使用 <code>smpboot_register_percpu_thread()</code> 函数，给每个 cpu 上创建了对应的 softirqd 线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@:&#x2F; # ps | grep softirq</span><br><span class="line">root      3     2     0      0     smpboot_th 0000000000 S ksoftirqd&#x2F;0</span><br><span class="line">root      12    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;1</span><br><span class="line">root      16    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;2</span><br><span class="line">root      20    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;3</span><br><span class="line">root      24    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;4</span><br><span class="line">root      28    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;5</span><br><span class="line">root      32    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;6</span><br><span class="line">root      36    2     0      0     __kthread_ 0000000000 R ksoftirqd&#x2F;7</span><br></pre></td></tr></table></figure><p>软中断优先在 <code>irq_exit()</code> 中执行，如果超过时间等条件转为 softirqd 线程中执行。满足以下任一条件软中断在 softirqd 线程中执行：</p><ul><li>在 <code>irq_exit()</code>-&gt;<code>__do_softirq()</code> 中运行，时间超过 2ms。</li><li>在 <code>irq_exit()</code>-&gt;<code>__do_softirq()</code> 中运行，轮询软中断超过 10 次。</li><li>在 <code>irq_exit()</code>-&gt;<code>__do_softirq()</code> 中运行，本线程需要被调度。</li><li>调用 <code>raise_softirq()</code> 唤醒软中断时，不在中断环境中。</li></ul><p>我们也看到，软中断处理是按照优先级逐个调用 softirq_vec[] 数组中的软中断处理函数，所以前面的软中断是可以阻塞后面的软中断的。这个在我们写程序的时候需要注意。</p><h3 id="2-3-tasklet"><a href="#2-3-tasklet" class="headerlink" title="2.3 tasklet"></a>2.3 tasklet</h3><p>Linux 已经有了 softirq 机制，为什么还需要 tasklet 机制？最主要的原因是 softirq 是多 cpu 执行的，可能碰到很多重入的问题，而 tasklet 同一时刻只能在一个 cpu 上执行，不需要处理重入互斥问题。另外 Linux 也不建议用户去添加新的软中断。</p><p>下面我们来具体分析一下 tasklet 的实现机制：</p><ul><li>per-cpu 变量 tasklet_vec/tasklet_hi_vec 以链表的形式记录了当前 cpu 需要处理的 tasklet 任务：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="comment">// (1)tasklet_vec 为低优先级的 tasklet 链表</span></span><br><span class="line">per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line"><span class="comment">// (2)tasklet_hi_vec 为高优先级的 tasklet 链表</span></span><br><span class="line">per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>push 一个 tasklet 任务：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"><span class="comment">// (1) 将新的 tasklet 插入到本 cpu 链表尾部</span></span><br><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line"><span class="comment">// (2)raise 软中断来处理 tasklet</span></span><br><span class="line">raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理一个 tasklet 任务：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tasklet_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="comment">// (1)list 取出当前链表中所有已有的 tasklet</span></span><br><span class="line"><span class="built_in">list</span> = __this_cpu_read(tasklet_vec.head);</span><br><span class="line"><span class="comment">// (2)tasklet_vec.head 和 tasklet_vec.tail 返回初始化状态，继续接收新的 tasklet</span></span><br><span class="line">__this_cpu_write(tasklet_vec.head, <span class="literal">NULL</span>);</span><br><span class="line">__this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&amp;tasklet_vec.head));</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 逐个处理取出的 list 链表中的 tasklet</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> = <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4)tasklet 互斥锁，保证 tasklet 同时只能在一个 cpu 上执行</span></span><br><span class="line"><span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!atomic_read(&amp;t-&gt;count)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 在 tasklet 运行前清除 TASKLET_STATE_SCHED 标志</span></span><br><span class="line"><span class="comment">// 这个时候 tasklet 可以重新加入新的队列了，但是还不能执行</span></span><br><span class="line"><span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED,</span><br><span class="line">&amp;t-&gt;state))</span><br><span class="line">BUG();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (7) 执行实际的 tasklet 处理函数</span></span><br><span class="line">t-&gt;func(t-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8) 释放 tasklet 锁，其他 cpu 可以运行这个 tasklet 了</span></span><br><span class="line">tasklet_unlock(t);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">tasklet_unlock(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="comment">// (5) 如果获取 tasklet 互斥锁失败，先加入到 cpu tasklet_vec 链表中</span></span><br><span class="line"><span class="comment">// 下次执行</span></span><br><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">__raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_ARMPG"><sup>ARMPG</sup>. <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/index.html" target="_blank" rel="noopener">ARM Cortex-A Series Programmer’s Guide for ARMv8-A</a><a href="#reffn_ARMPG" title="Jump back to footnote [ARMPG] in the text."> &#8617;</a></blockquote><blockquote id="fn_GICANALY"><sup>GICANALY</sup>. <a href="http://www.wowotech.net/irq_subsystem/gic_driver.html" target="_blank" rel="noopener">GIC 代码分析 </a><a href="#reffn_GICANALY" title="Jump back to footnote [GICANALY] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中断管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gic </tag>
            
            <tag>  中断线程化  </tag>
            
            <tag> softirq </tag>
            
            <tag> tasklet </tag>
            
            <tag> linux 中断  </tag>
            
            <tag> linux interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Workqueue</title>
      <link href="/2016/08/21//linux-workqueue.html/"/>
      <url>/2016/08/21//linux-workqueue.html/</url>
      
        <content type="html"><![CDATA[<p>Workqueue 是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务 (work) 都不会自己起一个线程来处理，而是扔到 Workqueue 中处理。Workqueue 的主要工作就是用进程上下文来处理内核中大量的小任务。</p><p>所以 Workqueue 的主要设计思想：一个是并行，多个 work 不要相互阻塞；另外一个是节省资源，多个 work 尽量共享资源 ( 进程、调度、内存 )，不要造成系统过多的资源浪费。</p><p>为了实现的设计思想，workqueue 的设计实现也更新了很多版本。最新的 workqueue 实现叫做 CMWQ(Concurrency Managed Workqueue)，也就是用更加智能的算法来实现“并行和节省”。新版本的 workqueue 创建函数改成 <code>alloc_workqueue()</code>，旧版本的函数 <code>create_workqueue()</code> 逐渐会被被废弃。</p><blockquote><p>本文的代码分析基于 Linux kernel 3.18.22，最好的学习方法还是 “read the fucking source code”</p></blockquote><h2 id="1-CMWQ-的几个基本概念"><a href="#1-CMWQ-的几个基本概念" class="headerlink" title="1.CMWQ 的几个基本概念"></a>1.CMWQ 的几个基本概念</h2><p>关于 workqueue 中几个概念都是 work 相关的数据结构非常容易混淆，大概可以这样来理解：</p><ul><li>work        ：工作。</li><li>workqueue    ：工作的集合。workqueue 和 work 是一对多的关系。</li><li>worker    ：工人。在代码中 worker 对应一个 <code>work_thread()</code> 内核线程。</li><li>worker_pool：工人的集合。worker_pool 和 worker 是一对多的关系。</li><li>pwq(pool_workqueue)：中间人 / 中介，负责建立起 workqueue 和 worker_pool 之间的关系。workqueue 和 pwq 是一对多的关系，pwq 和 worker_pool 是一对一的关系。</li></ul><p><img src="/images/posts/2016/08/wq_topology.png" alt="normal wq_topology"></p><p>最终的目的还是把 work( 工作 ) 传递给 worker( 工人 ) 去执行，中间的数据结构和各种关系目的是把这件事组织的更加清晰高效。</p><h3 id="1-1-worker-pool"><a href="#1-1-worker-pool" class="headerlink" title="1.1 worker_pool"></a>1.1 worker_pool</h3><p>每个执行 work 的线程叫做 worker，一组 worker 的集合叫做 worker_pool。CMWQ 的精髓就在 worker_pool 里面 worker 的动态增减管理上 <code>manage_workers()</code>。</p><p>CMWQ 对 worker_pool 分成两类：</p><ul><li>normal worker_pool，给通用的 workqueue 使用；</li><li>unbound worker_pool，给 WQ_UNBOUND 类型的的 workqueue 使用；</li></ul><h4 id="1-1-1-normal-worker-pool"><a href="#1-1-1-normal-worker-pool" class="headerlink" title="1.1.1 normal worker_pool"></a>1.1.1 normal worker_pool</h4><p>默认 work 是在 normal worker_pool 中处理的。系统的规划是每个 CPU 创建两个 normal worker_pool：一个 normal 优先级 (nice=0)、一个高优先级 (nice=HIGHPRI_NICE_LEVEL)，对应创建出来的 worker 的进程 nice 不一样。</p><p>每个 worker 对应一个 <code>worker_thread()</code> 内核线程，一个 worker_pool 包含一个或者多个 worker，worker_pool 中 worker 的数量是根据 worker_pool 中 work 的负载来动态增减的。</p><p>我们可以通过 <code>ps | grep kworker</code> 命令来查看所有 worker 对应的内核线程，normal worker_pool 对应内核线程 (<code>worker_thread()</code>) 的命名规则是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line"> pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure><p>so 类似名字是 normal worker_pool：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell@PRO5:&#x2F; $ ps | grep &quot;kworker&quot;</span><br><span class="line">root      14    2     0      0     worker_thr 0000000000 S kworker&#x2F;1:0H&#x2F;&#x2F; cpu1 高优先级 worker_pool 的第 0 个 worker 进程</span><br><span class="line">root      17    2     0      0     worker_thr 0000000000 S kworker&#x2F;2:0&#x2F;&#x2F; cpu2 低优先级 worker_pool 的第 0 个 worker 进程</span><br><span class="line">root      18    2     0      0     worker_thr 0000000000 S kworker&#x2F;2:0H&#x2F;&#x2F; cpu2 高优先级 worker_pool 的第 0 个 worker 进程</span><br><span class="line">root      23699 2     0      0     worker_thr 0000000000 S kworker&#x2F;0:1&#x2F;&#x2F; cpu0 低优先级 worker_pool 的第 1 个 worker 进程</span><br></pre></td></tr></table></figure><p><img src="/images/posts/2016/08/wq_worker_pool.png" alt="normal worker_pool"></p><p>对应的拓扑图如下：</p><p><img src="/images/posts/2016/08/wq_normal_wq_topology.png" alt="normal worker_pool topology"></p><p>以下是 normal worker_pool 详细的创建过程代码分析：</p><ul><li>kernel/workqueue.c:</li><li><code>init_workqueues()</code> -&gt; <code>init_worker_pool()</code>/<code>create_worker()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line"><span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 给每个 cpu 创建对应的 worker_pool</span></span><br><span class="line"><span class="comment">/* initialize CPU pools */</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">BUG_ON(init_worker_pool(pool));</span><br><span class="line"><span class="comment">// 指定 cpu</span></span><br><span class="line">pool-&gt;cpu = cpu;</span><br><span class="line">cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line"><span class="comment">// 指定进程优先级 nice</span></span><br><span class="line">pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alloc pool ID */</span></span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 给每个 worker_pool 创建第一个 worker</span></span><br><span class="line"><span class="comment">/* create the initial worker */</span></span><br><span class="line">for_each_online_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">BUG_ON(!create_worker(pool));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_worker_pool</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">spin_lock_init(&amp;pool-&gt;lock);</span><br><span class="line">pool-&gt;id = <span class="number">-1</span>;</span><br><span class="line">pool-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">pool-&gt;node = NUMA_NO_NODE;</span><br><span class="line">pool-&gt;flags |= POOL_DISASSOCIATED;</span><br><span class="line"><span class="comment">// (1.1) worker_pool 的 work list，各个 workqueue 把 work 挂载到这个链表上，</span></span><br><span class="line"><span class="comment">// 让 worker_pool 对应的多个 worker 来执行</span></span><br><span class="line">INIT_LIST_HEAD(&amp;pool-&gt;worklist);</span><br><span class="line"><span class="comment">// (1.2) worker_pool 的 idle worker list，</span></span><br><span class="line"><span class="comment">// worker 没有活干时，不会马上销毁，先进入 idle 状态备选</span></span><br><span class="line">INIT_LIST_HEAD(&amp;pool-&gt;idle_list);</span><br><span class="line"><span class="comment">// (1.3) worker_pool 的 busy worker list，</span></span><br><span class="line"><span class="comment">// worker 正在干活，在执行 work</span></span><br><span class="line">hash_init(pool-&gt;busy_hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4) 检查 idle 状态 worker 是否需要 destroy 的 timer</span></span><br><span class="line">init_timer_deferrable(&amp;pool-&gt;idle_timer);</span><br><span class="line">pool-&gt;idle_timer.function = idle_worker_timeout;</span><br><span class="line">pool-&gt;idle_timer.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.5) 在 worker_pool 创建新的 worker 时，检查是否超时的 timer</span></span><br><span class="line">setup_timer(&amp;pool-&gt;mayday_timer, pool_mayday_timeout,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool);</span><br><span class="line"></span><br><span class="line">mutex_init(&amp;pool-&gt;manager_arb);</span><br><span class="line">mutex_init(&amp;pool-&gt;attach_mutex);</span><br><span class="line">INIT_LIST_HEAD(&amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">ida_init(&amp;pool-&gt;worker_ida);</span><br><span class="line">INIT_HLIST_NODE(&amp;pool-&gt;hash_node);</span><br><span class="line">pool-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* shouldn't fail above this point */</span></span><br><span class="line">pool-&gt;attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!pool-&gt;attrs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">id = ida_simple_get(&amp;pool-&gt;worker_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">worker = alloc_worker(pool-&gt;node);</span><br><span class="line"><span class="keyword">if</span> (!worker)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">worker-&gt;pool = pool;</span><br><span class="line">worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment">// (2.1) 给 normal worker_pool 的 worker 构造进程名</span></span><br><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line"> pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// (2.2) 给 unbound worker_pool 的 worker 构造进程名</span></span><br><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.3) 创建 worker 对应的内核进程</span></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">"kworker/%s"</span>, id_buf);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.4) 设置内核进程对应的优先级 nice</span></span><br><span class="line">set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prevent userland from meddling with cpumask of workqueue workers */</span></span><br><span class="line">worker-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5) 将 worker 和 worker_pool 绑定</span></span><br><span class="line"><span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6) 将 worker 初始状态设置成 idle，</span></span><br><span class="line"><span class="comment">// wake_up_process 以后，worker 自动 leave idle 状态</span></span><br><span class="line"><span class="comment">/* start the newly created worker */</span></span><br><span class="line">spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">worker_enter_idle(worker);</span><br><span class="line">wake_up_process(worker-&gt;task);</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"><span class="keyword">if</span> (id &gt;= <span class="number">0</span>)</span><br><span class="line">ida_simple_remove(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">kfree(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker_attach_to_pool</span><span class="params">(struct worker *worker,</span></span></span><br><span class="line"><span class="function"><span class="params">   struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5.1) 将 worker 线程和 cpu 绑定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any</span></span><br><span class="line"><span class="comment"> * online CPUs.  It'll be re-applied when any of the CPUs come up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_cpus_allowed_ptr(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pool-&gt;attach_mutex ensures %POOL_DISASSOCIATED remains</span></span><br><span class="line"><span class="comment"> * stable across this function.  See the comments above the</span></span><br><span class="line"><span class="comment"> * flag definition for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;flags &amp; POOL_DISASSOCIATED)</span><br><span class="line">worker-&gt;flags |= WORKER_UNBOUND;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5.2) 将 worker 加入 worker_pool 链表</span></span><br><span class="line">list_add_tail(&amp;worker-&gt;node, &amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-unbound-worker-pool"><a href="#1-1-2-unbound-worker-pool" class="headerlink" title="1.1.2 unbound worker_pool"></a>1.1.2 unbound worker_pool</h4><p>大部分的 work 都是通过 normal worker_pool 来执行的 ( 例如通过 <code>schedule_work()</code>、<code>schedule_work_on()</code> 压入到系统 workqueue(system_wq) 中的 work)，最后都是通过 normal worker_pool 中的 worker 来执行的。这些 worker 是和某个 CPU 绑定的，work 一旦被 worker 开始执行，都是一直运行到某个 CPU 上的不会切换 CPU。</p><p>unbound worker_pool 相对应的意思，就是 worker 可以在多个 CPU 上调度的。但是他其实也是绑定的，只不过它绑定的单位不是 CPU 而是 node。所谓的 node 是对 NUMA(Non Uniform Memory Access Architecture) 系统来说的，NUMA 可能存在多个 node，每个 node 可能包含一个或者多个 CPU。</p><p>unbound worker_pool 对应内核线程 (<code>worker_thread()</code>) 的命名规则是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure><p>so 类似名字是 unbound worker_pool：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell@PRO5:&#x2F; $ ps | grep &quot;kworker&quot;</span><br><span class="line">root      23906 2     0      0     worker_thr 0000000000 S kworker&#x2F;u20:2&#x2F;&#x2F; unbound pool 20 的第 2 个 worker 进程</span><br><span class="line">root      24564 2     0      0     worker_thr 0000000000 S kworker&#x2F;u20:0&#x2F;&#x2F; unbound pool 20 的第 0 个 worker 进程</span><br><span class="line">root      24622 2     0      0     worker_thr 0000000000 S kworker&#x2F;u21:1&#x2F;&#x2F; unbound pool 21 的第 1 个 worker 进程</span><br></pre></td></tr></table></figure><p>unbound worker_pool 也分成两类：</p><ul><li>unbound_std_wq。每个 node 对应一个 worker_pool，多个 node 就对应多个 worker_pool;</li></ul><p><img src="/images/posts/2016/08/wq_unbound_std_wq.png" alt="unbound worker_pool: unbound_std_wq"></p><p>对应的拓扑图如下：</p><p><img src="/images/posts/2016/08/wq_unboundstd_wq_topology.png" alt="unbound_std_wq topology"></p><ul><li>ordered_wq。所有 node 对应一个 default worker_pool；</li></ul><p><img src="/images/posts/2016/08/wq_ordered_wq.png" alt="unbound worker_pool: ordered_wq"></p><p>对应的拓扑图如下：</p><p><img src="/images/posts/2016/08/wq_ordered_wq_topology.png" alt="ordered_wq topology"></p><p>以下是 unbound worker_pool 详细的创建过程代码分析：</p><ul><li>kernel/workqueue.c:</li><li><code>init_workqueues()</code> -&gt; unbound_std_wq_attrs/ordered_wq_attrs</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 初始化 normal 和 high nice 对应的 unbound attrs</span></span><br><span class="line"><span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) unbound_std_wq_attrs</span></span><br><span class="line">BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">attrs-&gt;nice = std_nice[i];</span><br><span class="line">unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment"> * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment"> * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (3) ordered_wq_attrs，no_numa = true;</span></span><br><span class="line">BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">attrs-&gt;nice = std_nice[i];</span><br><span class="line">attrs-&gt;no_numa = <span class="literal">true</span>;</span><br><span class="line">ordered_wq_attrs[i] = attrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kernel/workqueue.c:</li><li><code>__alloc_workqueue_key()</code> -&gt; <code>alloc_and_link_pwqs()</code> -&gt; <code>apply_workqueue_attrs()</code> -&gt; <code>alloc_unbound_pwq()</code>/<code>numa_pwq_tbl_install()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">       <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">       <span class="title">int</span> <span class="title">max_active</span>,</span></span><br><span class="line"><span class="class">       <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate wq and format name */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 分配 workqueue_struct 数据结构</span></span><br><span class="line">wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wq)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">wq-&gt;unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line"><span class="keyword">goto</span> err_free_wq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">va_start(args, lock_name);</span><br><span class="line">vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">va_end(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) pwq 最多放到 worker_pool 中的 work 数</span></span><br><span class="line">max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init wq */</span></span><br><span class="line">wq-&gt;flags = flags;</span><br><span class="line">wq-&gt;saved_max_active = max_active;</span><br><span class="line">mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">lockdep_init_map(&amp;wq-&gt;lockdep_map, lock_name, key, <span class="number">0</span>);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 给 workqueue 分配对应的 pool_workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 将 workqueue 和 worker_pool 链接起来</span></span><br><span class="line"><span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_free_wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果是 WQ_MEM_RECLAIM 类型的 workqueue</span></span><br><span class="line"><span class="comment">// 创建对应的 rescuer_thread() 内核进程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Workqueues which may be used during memory reclaim should</span></span><br><span class="line"><span class="comment"> * have a rescuer to guarantee forward progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; WQ_MEM_RECLAIM) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"></span><br><span class="line">rescuer = alloc_worker(NUMA_NO_NODE);</span><br><span class="line"><span class="keyword">if</span> (!rescuer)</span><br><span class="line"><span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">rescuer-&gt;rescue_wq = wq;</span><br><span class="line">rescuer-&gt;task = kthread_create(rescuer_thread, rescuer, <span class="string">"%s"</span>,</span><br><span class="line">       wq-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rescuer-&gt;task)) &#123;</span><br><span class="line">kfree(rescuer);</span><br><span class="line"><span class="keyword">goto</span> err_destroy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wq-&gt;rescuer = rescuer;</span><br><span class="line">rescuer-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line">wake_up_process(rescuer-&gt;task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) 如果是需要，创建 workqueue 对应的 sysfs 文件</span></span><br><span class="line"><span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line"><span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment"> * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment"> * list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">for_each_pwq(pwq, wq)</span><br><span class="line">pwq_adjust_max_active(pwq);</span><br><span class="line">mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 将新的 workqueue 加入到全局链表 workqueues 中</span></span><br><span class="line">list_add(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_free_wq:</span><br><span class="line">free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">kfree(wq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">destroy_workqueue(wq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line"><span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3.1) normal workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line"><span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line"><span class="comment">// 给 workqueue 的每个 cpu 分配对应的 pool_workqueue，赋值给 wq-&gt;cpu_pwqs</span></span><br><span class="line">wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line"><span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line"><span class="class"><span class="title">per_cpu_ptr</span>(<span class="title">wq</span>-&gt;<span class="title">cpu_pwqs</span>, <span class="title">cpu</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line"><span class="class"><span class="title">per_cpu</span>(<span class="title">cpu_worker_pools</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将初始化时已经创建好的 normal worker_pool，赋值给 pool_workqueue</span></span><br><span class="line">init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line"><span class="comment">// 将 pool_workqueue 和 workqueue 链接起来</span></span><br><span class="line">link_pwq(pwq);</span><br><span class="line">mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line"><span class="comment">// (3.2) unbound ordered_wq workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line">ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line"><span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">     <span class="string">"ordering guarantee broken for workqueue %s\n"</span>, wq-&gt;name);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (3.3) unbound unbound_std_wq workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line"><span class="keyword">return</span> apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply_workqueue_attrs</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3.2.1) 根据的 ubound 的 ordered_wq_attrs/unbound_std_wq_attrs</span></span><br><span class="line"><span class="comment">// 创建对应的 pool_workqueue 和 worker_pool</span></span><br><span class="line"><span class="comment">// 其中 worker_pool 不是默认创建好的，是需要动态创建的，对应的 worker 内核进程也要重新创建</span></span><br><span class="line"><span class="comment">// 创建好的 pool_workqueue 赋值给 pwq_tbl[node]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If something goes wrong during CPU up/down, we'll fall back to</span></span><br><span class="line"><span class="comment"> * the default pwq covering whole @attrs-&gt;cpumask.  Always create</span></span><br><span class="line"><span class="comment"> * it even if we don't use it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dfl_pwq = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line"><span class="keyword">if</span> (!dfl_pwq)</span><br><span class="line"><span class="keyword">goto</span> enomem_pwq;</span><br><span class="line"></span><br><span class="line">for_each_node(node) &#123;</span><br><span class="line"><span class="keyword">if</span> (wq_calc_node_cpumask(attrs, node, <span class="number">-1</span>, tmp_attrs-&gt;cpumask)) &#123;</span><br><span class="line">pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);</span><br><span class="line"><span class="keyword">if</span> (!pwq_tbl[node])</span><br><span class="line"><span class="keyword">goto</span> enomem_pwq;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfl_pwq-&gt;refcnt++;</span><br><span class="line">pwq_tbl[node] = dfl_pwq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* save the previous pwq and install the new one */</span></span><br><span class="line"><span class="comment">// (3.2.2) 将临时 pwq_tbl[node] 赋值给 wq-&gt;numa_pwq_tbl[node]</span></span><br><span class="line">for_each_node(node)</span><br><span class="line">pwq_tbl[node] = numa_pwq_tbl_install(wq, node, pwq_tbl[node]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pool_workqueue *<span class="title">alloc_unbound_pwq</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3.2.1.1) 如果对应 attrs 已经创建多对应的 unbound_pool，则使用已有的 unbound_pool</span></span><br><span class="line"><span class="comment">// 否则根据 attrs 创建新的 unbound_pool</span></span><br><span class="line">pool = get_unbound_pool(attrs);</span><br><span class="line"><span class="keyword">if</span> (!pool)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);</span><br><span class="line"><span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">put_unbound_pool(pool);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_pwq(pwq, wq, pool);</span><br><span class="line"><span class="keyword">return</span> pwq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-worker"><a href="#1-2-worker" class="headerlink" title="1.2 worker"></a>1.2 worker</h3><p>每个 worker 对应一个 <code>worker_thread()</code> 内核线程，一个 worker_pool 对应一个或者多个 worker。多个 worker 从同一个链表中 worker_pool-&gt;worklist 获取 work 进行处理。</p><p>所以这其中有几个重点：</p><ul><li>worker 怎么处理 work；</li><li>worker_pool 怎么动态管理 worker 的数量；</li></ul><h4 id="1-2-1-worker-处理-work"><a href="#1-2-1-worker-处理-work" class="headerlink" title="1.2.1 worker 处理 work"></a>1.2.1 worker 处理 work</h4><p>处理 work 的过程主要在 <code>worker_thread()</code> -&gt; <code>process_one_work()</code> 中处理，我们具体看看代码的实现过程。</p><ul><li>kernel/workqueue.c:</li><li><code>worker_thread()</code> -&gt; <code>process_one_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = __<span class="title">worker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 是否 die</span></span><br><span class="line"><span class="comment">/* am I supposed to die? */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">set_task_comm(worker-&gt;task, <span class="string">"kworker/dying"</span>);</span><br><span class="line">ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">worker_detach_from_pool(worker, pool);</span><br><span class="line">kfree(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 脱离 idle 状态</span></span><br><span class="line"><span class="comment">// 被唤醒之前 worker 都是 idle 状态</span></span><br><span class="line">worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 如果需要本 worker 继续执行则继续，否则进入 idle 状态</span></span><br><span class="line"><span class="comment">// need more worker 的条件： (pool-&gt;worklist != 0) &amp;&amp; (pool-&gt;nr_running == 0)</span></span><br><span class="line"><span class="comment">// worklist 上有 work 需要执行，并且现在没有处于 running 的 work</span></span><br><span class="line"><span class="comment">/* no more worker necessary? */</span></span><br><span class="line"><span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line"><span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果 (pool-&gt;nr_idle == 0)，则启动创建更多的 worker</span></span><br><span class="line"><span class="comment">// 说明 idle 队列中已经没有备用 worker 了，先创建 一些 worker 备用</span></span><br><span class="line"><span class="comment">/* do we need to manage? */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line"><span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment"> * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment"> * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finish PREP stage.  We're guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment"> * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment"> * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment"> * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment"> * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// (5) 如果 pool-&gt;worklist 不为空，从其中取出一个 work 进行处理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line"><span class="class"><span class="title">list_first_entry</span>(&amp;<span class="title">pool</span>-&gt;<span class="title">worklist</span>,</span></span><br><span class="line"><span class="class"> <span class="title">struct</span> <span class="title">work_struct</span>, <span class="title">entry</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line"><span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line"><span class="comment">// (6) 执行正常的 work</span></span><br><span class="line">process_one_work(worker, work);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">process_scheduled_works(worker);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (7) 执行系统特意 scheduled 给某个 worker 的 work</span></span><br><span class="line"><span class="comment">// 普通的 work 是放在池子的公共 list 中的 pool-&gt;worklist</span></span><br><span class="line"><span class="comment">// 只有一些特殊的 work 被特意派送给某个 worker 的 worker-&gt;scheduled</span></span><br><span class="line"><span class="comment">// 包括：1、执行 flush_work 时插入的 barrier work；</span></span><br><span class="line"><span class="comment">// 2、collision 时从其他 worker 推送到本 worker 的 work</span></span><br><span class="line">move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">process_scheduled_works(worker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (8) worker keep_working 的条件：</span></span><br><span class="line"><span class="comment">// pool-&gt;worklist 不为空 &amp;&amp; (pool-&gt;nr_running &lt;= 1)</span></span><br><span class="line">&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">worker_set_flags(worker, WORKER_PREP);supposed</span><br><span class="line">sleep:</span><br><span class="line"><span class="comment">// (9) worker 进入 idle 状态</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pool-&gt;lock is held and there's no work to process and no need to</span></span><br><span class="line"><span class="comment"> * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment"> * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment"> * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment"> * event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">worker_enter_idle(worker);</span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> = <span class="title">get_work_pwq</span>(<span class="title">work</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"><span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"><span class="keyword">int</span> work_color;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It is permissible to free the struct work_struct from</span></span><br><span class="line"><span class="comment"> * inside the function that is called from it, this we need to</span></span><br><span class="line"><span class="comment"> * take into account for lockdep too.  To avoid bogus "held</span></span><br><span class="line"><span class="comment"> * lock freed" warnings as well as problems when looking into</span></span><br><span class="line"><span class="comment"> * work-&gt;lockdep_map, make a copy and use that here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"></span><br><span class="line">lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* ensure we're on the correct CPU */</span></span><br><span class="line">WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.1) 如果 work 已经在 worker_pool 的其他 worker 上执行，</span></span><br><span class="line"><span class="comment">// 将 work 放入对应 worker 的 scheduled 队列中延后执行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A single work shouldn't be executed concurrently by</span></span><br><span class="line"><span class="comment"> * multiple workers on a single cpu.  Check whether anyone is</span></span><br><span class="line"><span class="comment"> * already processing the work.  If so, defer the work to the</span></span><br><span class="line"><span class="comment"> * currently executing one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">collision = find_worker_executing_work(pool, work);</span><br><span class="line"><span class="keyword">if</span> (unlikely(collision)) &#123;</span><br><span class="line">move_linked_works(work, &amp;collision-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.2) 将 worker 加入 busy 队列 pool-&gt;busy_hash</span></span><br><span class="line"><span class="comment">/* claim and dequeue */</span></span><br><span class="line">debug_work_deactivate(work);</span><br><span class="line">hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)work);</span><br><span class="line">worker-&gt;current_work = work;</span><br><span class="line">worker-&gt;current_func = work-&gt;func;</span><br><span class="line">worker-&gt;current_pwq = pwq;</span><br><span class="line">work_color = get_work_color(work);</span><br><span class="line"></span><br><span class="line">list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.3) 如果 work 所在的 wq 是 cpu 密集型的 WQ_CPU_INTENSIVE</span></span><br><span class="line"><span class="comment">// 则当前 work 的执行脱离 worker_pool 的动态调度，成为一个独立的线程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment"> * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment"> * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment"> * execution of the pending work items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.4) 在 UNBOUND 或者 CPU_INTENSIVE work 中判断是否需要唤醒 idle worker</span></span><br><span class="line"><span class="comment">// 普通 work 不会执行这个操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment"> * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment"> * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment"> * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment"> * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment"> * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment"> * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment"> * disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">trace_workqueue_execute_start(work);</span><br><span class="line"><span class="comment">// (8.5) 执行 work 函数</span></span><br><span class="line">worker-&gt;current_func(work);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While we must be careful to not use "work" after this, the trace</span></span><br><span class="line"><span class="comment"> * point will only record its address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_workqueue_execute_end(work);</span><br><span class="line">lock_map_release(&amp;lockdep_map);</span><br><span class="line">lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">pr_err(<span class="string">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"</span></span><br><span class="line">       <span class="string">"     last function: %pf\n"</span>,</span><br><span class="line">       current-&gt;comm, preempt_count(), task_pid_nr(current),</span><br><span class="line">       worker-&gt;current_func);</span><br><span class="line">debug_show_held_locks(current);</span><br><span class="line">dump_stack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following prevents a kworker from hogging CPU on !PREEMPT</span></span><br><span class="line"><span class="comment"> * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment"> * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment"> * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment"> * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment"> * the same condition doesn't freeze RCU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cond_resched_rcu_qs();</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear cpu intensive status */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we're done with it, release */</span></span><br><span class="line">hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;desc_valid = <span class="literal">false</span>;</span><br><span class="line">pwq_dec_nr_in_flight(pwq, work_color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-worker-pool-动态管理-worker"><a href="#1-2-2-worker-pool-动态管理-worker" class="headerlink" title="1.2.2 worker_pool 动态管理 worker"></a>1.2.2 worker_pool 动态管理 worker</h4><p>worker_pool 怎么来动态增减 worker，这部分的算法是 CMWQ 的核心。其思想如下：</p><ul><li>worker_pool 中的 worker 有 3 种状态：idle、running、suspend；</li><li>如果 worker_pool 中有 work 需要处理，保持至少一个 running worker 来处理；</li><li>running worker 在处理 work 的过程中进入了阻塞 suspend 状态，为了保持其他 work 的执行，需要唤醒新的 idle worker 来处理 work；</li><li>如果有 work 需要执行且 running worker 大于 1 个，会让多余的 running worker 进入 idle 状态；</li><li>如果没有 work 需要执行，会让所有 worker 进入 idle 状态；</li><li>如果创建的 worker 过多，destroy_worker 在 300s(IDLE_WORKER_TIMEOUT) 时间内没有再次运行的 idle worker。</li></ul><p><img src="/images/posts/2016/08/wq_worker_statusmachine.png" alt="worker status machine"></p><p>详细代码可以参考上节 <code>worker_thread()</code> -&gt; <code>process_one_work()</code> 的分析。</p><p>为了追踪 worker 的 running 和 suspend 状态，用来动态调整 worker 的数量。wq 使用在进程调度中加钩子函数的技巧：</p><ul><li>追踪 worker 从 suspend 进入 running 状态：<code>ttwu_activate()</code> -&gt; <code>wq_worker_waking_up()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wq_worker_waking_up</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">WARN_ON_ONCE(worker-&gt;pool-&gt;cpu != cpu);</span><br><span class="line"><span class="comment">// 增加 worker_pool 中 running 的 worker 数量</span></span><br><span class="line">atomic_inc(&amp;worker-&gt;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>追踪 worker 从 running 进入 suspend 状态：<code>__schedule()</code> -&gt; <code>wq_worker_sleeping()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">wq_worker_sleeping</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>), *<span class="title">to_wakeup</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Rescuers, which may not have all the fields set up like normal</span></span><br><span class="line"><span class="comment"> * workers, also reach here, let's not access anything before</span></span><br><span class="line"><span class="comment"> * checking NOT_RUNNING.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (worker-&gt;flags &amp; WORKER_NOT_RUNNING)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this can only happen on the local cpu */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(cpu != raw_smp_processor_id() || pool-&gt;cpu != cpu))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The counterpart of the following dec_and_test, implied mb,</span></span><br><span class="line"><span class="comment"> * worklist not empty test sequence is in insert_work().</span></span><br><span class="line"><span class="comment"> * Please read comment there.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOT_RUNNING is clear.  This means that we're bound to and</span></span><br><span class="line"><span class="comment"> * running on the local cpu w/ rq lock held and preemption</span></span><br><span class="line"><span class="comment"> * disabled, which in turn means that none else could be</span></span><br><span class="line"><span class="comment"> * manipulating idle_list, so dereferencing idle_list without pool</span></span><br><span class="line"><span class="comment"> * lock is safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 减少 worker_pool 中 running 的 worker 数量</span></span><br><span class="line"><span class="comment">// 如果 worklist 还有 work 需要处理，唤醒第一个 idle worker 进行处理</span></span><br><span class="line"><span class="keyword">if</span> (atomic_dec_and_test(&amp;pool-&gt;nr_running) &amp;&amp;</span><br><span class="line">    !list_empty(&amp;pool-&gt;worklist))</span><br><span class="line">to_wakeup = first_idle_worker(pool);</span><br><span class="line"><span class="keyword">return</span> to_wakeup ? to_wakeup-&gt;task : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 worker_pool 的调度思想是：如果有 work 需要处理，保持一个 running 状态的 worker 处理，不多也不少。</p><p>但是这里有一个问题如果 work 是 CPU 密集型的，它虽然也没有进入 suspend 状态，但是会长时间的占用 CPU，让后续的 work 阻塞太长时间。</p><p>为了解决这个问题，CMWQ 设计了 WQ_CPU_INTENSIVE，如果一个 wq 声明自己是 CPU_INTENSIVE，则让当前 worker 脱离动态调度，像是进入了 suspend 状态，那么 CMWQ 会创建新的 worker，后续的 work 会得到执行。</p><ul><li>kernel/workqueue.c:</li><li><code>worker_thread()</code> -&gt; <code>process_one_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 设置当前 worker 的 WORKER_CPU_INTENSIVE 标志</span></span><br><span class="line"><span class="comment">// nr_running 会被减 1</span></span><br><span class="line"><span class="comment">// 对 worker_pool 来说，当前 worker 相当于进入了 suspend 状态</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment"> * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment"> * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment"> * execution of the pending work items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 接上一步，判断是否需要唤醒新的 worker 来处理 work</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment"> * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment"> * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment"> * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment"> * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 执行 work</span></span><br><span class="line">worker-&gt;current_func(work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 执行完，清理当前 worker 的 WORKER_CPU_INTENSIVE 标志</span></span><br><span class="line"><span class="comment">// 当前 worker 重新进入 running 状态</span></span><br><span class="line"><span class="comment">/* clear cpu intensive status */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WORKER_NOT_RUNNING= WORKER_PREP | WORKER_CPU_INTENSIVE |</span><br><span class="line">  WORKER_UNBOUND | WORKER_REBOUND,</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> worker_set_flags(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">struct worker_pool *pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If transitioning into NOT_RUNNING, adjust nr_running. */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;</span><br><span class="line">    !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">atomic_dec(&amp;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">worker_clr_flags</span><span class="params">(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> oflags = worker-&gt;flags;</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">worker-&gt;flags &amp;= ~flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If transitioning out of NOT_RUNNING, increment nr_running.  Note</span></span><br><span class="line"><span class="comment"> * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask</span></span><br><span class="line"><span class="comment"> * of multiple flags, not a single flag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp; (oflags &amp; WORKER_NOT_RUNNING))</span><br><span class="line"><span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">atomic_inc(&amp;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-CPU-hotplug-处理"><a href="#1-2-3-CPU-hotplug-处理" class="headerlink" title="1.2.3 CPU hotplug 处理"></a>1.2.3 CPU hotplug 处理</h4><p>从上几节可以看到，系统会创建和 CPU 绑定的 normal worker_pool 和不绑定 CPU 的 unbound worker_pool，worker_pool 又会动态的创建 worker。</p><p>那么在 CPU hotplug 的时候，会怎么样动态的处理 worker_pool 和 worker 呢？来看具体的代码分析：</p><ul><li>kernel/workqueue.c:</li><li><code>workqueue_cpu_up_callback()</code>/<code>workqueue_cpu_down_callback()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);</span><br><span class="line">hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_down_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpu = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">unbind_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line"><span class="keyword">case</span> CPU_DOWN_PREPARE:</span><br><span class="line"><span class="comment">/* unbinding per-cpu workers should happen on the local CPU */</span></span><br><span class="line">INIT_WORK_ONSTACK(&amp;unbind_work, wq_unbind_fn);</span><br><span class="line"><span class="comment">// (1) cpu down_prepare</span></span><br><span class="line"><span class="comment">// 把和当前 cpu 绑定的 normal worker_pool 上的 worker 停工</span></span><br><span class="line"><span class="comment">// 随着当前 cpu 被 down 掉，这些 worker 会迁移到其他 cpu 上</span></span><br><span class="line">queue_work_on(cpu, system_highpri_wq, &amp;unbind_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) unbound wq 对 cpu 变化的更新</span></span><br><span class="line"><span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">wq_update_unbound_numa(wq, cpu, <span class="literal">false</span>);</span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wait for per-cpu unbinding to finish */</span></span><br><span class="line">flush_work(&amp;unbind_work);</span><br><span class="line">destroy_work_on_stack(&amp;unbind_work);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_up_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> CPU = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"><span class="keyword">int</span> pi;</span><br><span class="line"><span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line"><span class="keyword">case</span> CPU_UP_PREPARE:</span><br><span class="line">for_each_cpu_worker_pool(pool, CPU) &#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;nr_workers)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!create_worker(pool))</span><br><span class="line"><span class="keyword">return</span> NOTIFY_BAD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CPU_DOWN_FAILED:</span><br><span class="line"><span class="keyword">case</span> CPU_ONLINE:</span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"><span class="comment">// (3) CPU up</span></span><br><span class="line">for_each_pool(pool, pi) &#123;</span><br><span class="line">mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"><span class="comment">// 如果和当前 CPU 绑定的 normal worker_pool 上，有 WORKER_UNBOUND 停工的 worker</span></span><br><span class="line"><span class="comment">// 重新绑定 worker 到 worker_pool</span></span><br><span class="line"><span class="comment">// 让这些 worker 开工，并绑定到当前 CPU</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;CPU == CPU)</span><br><span class="line">rebind_workers(pool);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pool-&gt;CPU &lt; <span class="number">0</span>)</span><br><span class="line">restore_unbound_workers_cpumask(pool, CPU);</span><br><span class="line">mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">wq_update_unbound_numa(wq, CPU, <span class="literal">true</span>);</span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-workqueue"><a href="#1-3-workqueue" class="headerlink" title="1.3 workqueue"></a>1.3 workqueue</h3><p>workqueue 就是存放一组 work 的集合，基本可以分为两类：一类系统创建的 workqueue，一类是用户自己创建的 workqueue。</p><p>不论是系统还是用户的 workqueue，如果没有指定 WQ_UNBOUND，默认都是和 normal worker_pool 绑定。</p><h4 id="1-3-1-系统-workqueue"><a href="#1-3-1-系统-workqueue" class="headerlink" title="1.3.1 系统 workqueue"></a>1.3.1 系统 workqueue</h4><p>系统在初始化时创建了一批默认的 workqueue：system_wq、system_highpri_wq、system_long_wq、system_unbound_wq、system_freezable_wq、system_power_efficient_wq、system_freezable_power_efficient_wq。</p><p>像 system_wq，就是 schedule_work() 默认使用的。</p><ul><li>kernel/workqueue.c:</li><li>init_workqueues()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int __init init_workqueues(void)</span><br><span class="line">&#123;</span><br><span class="line">system_wq &#x3D; alloc_workqueue(&quot;events&quot;, 0, 0);</span><br><span class="line">system_highpri_wq &#x3D; alloc_workqueue(&quot;events_highpri&quot;, WQ_HIGHPRI, 0);</span><br><span class="line">system_long_wq &#x3D; alloc_workqueue(&quot;events_long&quot;, 0, 0);</span><br><span class="line">system_unbound_wq &#x3D; alloc_workqueue(&quot;events_unbound&quot;, WQ_UNBOUND,</span><br><span class="line">    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">system_freezable_wq &#x3D; alloc_workqueue(&quot;events_freezable&quot;,</span><br><span class="line">      WQ_FREEZABLE, 0);</span><br><span class="line">system_power_efficient_wq &#x3D; alloc_workqueue(&quot;events_power_efficient&quot;,</span><br><span class="line">      WQ_POWER_EFFICIENT, 0);</span><br><span class="line"></span><br><span class="line">system_freezable_power_efficient_wq &#x3D; alloc_workqueue(&quot;events_freezable_power_efficient&quot;,</span><br><span class="line">      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">      0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-workqueue-创建"><a href="#1-3-2-workqueue-创建" class="headerlink" title="1.3.2 workqueue 创建"></a>1.3.2 workqueue 创建</h4><p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p><h4 id="1-3-3-flush-workqueue"><a href="#1-3-3-flush-workqueue" class="headerlink" title="1.3.3 flush_workqueue()"></a>1.3.3 flush_workqueue()</h4><p>这一部分的逻辑，wq-&gt;work_color、wq-&gt;flush_color 换来换去的逻辑实在看的头晕。看不懂暂时不想看，放着以后看吧，或者有谁看懂了教我一下。：）</p><h3 id="1-4-pool-workqueue"><a href="#1-4-pool-workqueue" class="headerlink" title="1.4 pool_workqueue"></a>1.4 pool_workqueue</h3><p>pool_workqueue 只是一个中介角色。</p><p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p><h3 id="1-5-work"><a href="#1-5-work" class="headerlink" title="1.5 work"></a>1.5 work</h3><p>描述一份待执行的工作。</p><h4 id="1-5-1-queue-work"><a href="#1-5-1-queue-work" class="headerlink" title="1.5.1 queue_work()"></a>1.5.1 queue_work()</h4><p>将 work 压入到 workqueue 当中。</p><ul><li>kernel/workqueue.c:</li><li>queue_work() -&gt; queue_work_on() -&gt; __queue_work()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line"> struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">worklist</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> work_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While a work item is PENDING &amp;&amp; off queue, a task trying to</span></span><br><span class="line"><span class="comment"> * steal the PENDING will busy-loop waiting for it to either get</span></span><br><span class="line"><span class="comment"> * queued or lose PENDING.  Grabbing PENDING and queueing should</span></span><br><span class="line"><span class="comment"> * happen with IRQ disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">debug_work_activate(work);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if draining, only works from the same workqueue are allowed */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;</span><br><span class="line">    WARN_ON_ONCE(!is_chained_work(wq)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">// (1) 如果没有指定 cpu，则使用当前 cpu</span></span><br><span class="line"><span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pwq which will be used unless @work is executing elsewhere */</span></span><br><span class="line"><span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND))</span><br><span class="line"><span class="comment">// (2) 对于 normal wq，使用当前 cpu 对应的 normal worker_pool</span></span><br><span class="line">pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// (3) 对于 unbound wq，使用当前 cpu 对应 node 的 worker_pool</span></span><br><span class="line">pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果 work 在其他 worker 上正在被执行，把 work 压到对应的 worker 上去</span></span><br><span class="line"><span class="comment">// 避免 work 出现重入的问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @work was previously on a different pool, it might still be</span></span><br><span class="line"><span class="comment"> * running there, in which case the work needs to be queued on that</span></span><br><span class="line"><span class="comment"> * pool to guarantee non-reentrancy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">last_pool = get_work_pool(work);</span><br><span class="line"><span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">pwq = worker-&gt;current_pwq;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pwq is determined and locked.  For unbound pools, we could have</span></span><br><span class="line"><span class="comment"> * raced with pwq release and it could already be dead.  If its</span></span><br><span class="line"><span class="comment"> * refcnt is zero, repeat pwq selection.  Note that pwqs never die</span></span><br><span class="line"><span class="comment"> * without another pwq replacing it in the numa_pwq_tbl or while</span></span><br><span class="line"><span class="comment"> * work items are executing on it, so the retrying is guaranteed to</span></span><br><span class="line"><span class="comment"> * make forward-progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line"><span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">cpu_relax();</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* oops */</span></span><br><span class="line">WARN_ONCE(<span class="literal">true</span>, <span class="string">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt"</span>,</span><br><span class="line">  wq-&gt;name, cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pwq determined, queue */</span></span><br><span class="line">trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry))) &#123;</span><br><span class="line">spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) 如果还没有达到 max_active，将 work 挂载到 pool-&gt;worklist</span></span><br><span class="line"><span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">trace_workqueue_activate_work(work);</span><br><span class="line">pwq-&gt;nr_active++;</span><br><span class="line">worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line"><span class="comment">// 否则，将 work 挂载到临时队列 pwq-&gt;delayed_works</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 将 work 压入 worklist 当中</span></span><br><span class="line">insert_work(pwq, work, worklist, work_flags);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-flush-work"><a href="#1-5-2-flush-work" class="headerlink" title="1.5.2 flush_work()"></a>1.5.2 <code>flush_work()</code></h4><p>flush 某个 work，确保 work 执行完成。</p><p>怎么判断异步的 work 已经执行完成？这里面使用了一个技巧：在目标 work 的后面插入一个新的 work wq_barrier，如果 wq_barrier 执行完成，那么目标 work 肯定已经执行完成。</p><ul><li>kernel/workqueue.c:</li><li><code>queue_work()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flush_work - wait for a work to finish executing the last queueing instance</span></span><br><span class="line"><span class="comment"> * @work: the work to flush</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait until @work has finished execution.  @work is guaranteed to be idle</span></span><br><span class="line"><span class="comment"> * on return if it hasn't been requeued since flush started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * %true if flush_work() waited for the work to finish execution,</span></span><br><span class="line"><span class="comment"> * %false if it was already idle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">lock_map_acquire(&amp;work-&gt;lockdep_map);</span><br><span class="line">lock_map_release(&amp;work-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start_flush_work(work, &amp;barr)) &#123;</span><br><span class="line"><span class="comment">// 等待 barr work 执行完成的信号</span></span><br><span class="line">wait_for_completion(&amp;barr.done);</span><br><span class="line">destroy_work_on_stack(&amp;barr.work);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_flush_work</span><span class="params">(struct work_struct *work, struct wq_barrier *barr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 如果 work 所在 worker_pool 为 NULL，说明 work 已经执行完</span></span><br><span class="line">local_irq_disable();</span><br><span class="line">pool = get_work_pool(work);</span><br><span class="line"><span class="keyword">if</span> (!pool) &#123;</span><br><span class="line">local_irq_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;pool-&gt;lock);</span><br><span class="line"><span class="comment">/* see the comment in try_to_grab_pending() with the same code */</span></span><br><span class="line">pwq = get_work_pwq(work);</span><br><span class="line"><span class="keyword">if</span> (pwq) &#123;</span><br><span class="line"><span class="comment">// (2) 如果 work 所在 pwq 指向的 worker_pool 不等于上一步得到的 worker_pool，说明 work 已经执行完</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(pwq-&gt;pool != pool))</span><br><span class="line"><span class="keyword">goto</span> already_gone;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (3) 如果 work 所在 pwq 为 NULL，并且也没有在当前执行的 work 中，说明 work 已经执行完</span></span><br><span class="line">worker = find_worker_executing_work(pool, work);</span><br><span class="line"><span class="keyword">if</span> (!worker)</span><br><span class="line"><span class="keyword">goto</span> already_gone;</span><br><span class="line">pwq = worker-&gt;current_pwq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果 work 没有执行完，向 work 的后面插入 barr work</span></span><br><span class="line">insert_wq_barrier(pwq, barr, work, worker);</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @max_active is 1 or rescuer is in use, flushing another work</span></span><br><span class="line"><span class="comment"> * item on the same workqueue may lead to deadlock.  Make sure the</span></span><br><span class="line"><span class="comment"> * flusher is not running on the same workqueue by verifying write</span></span><br><span class="line"><span class="comment"> * access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pwq-&gt;wq-&gt;saved_max_active == <span class="number">1</span> || pwq-&gt;wq-&gt;rescuer)</span><br><span class="line">lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">already_gone:</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_wq_barrier</span><span class="params">(struct pool_workqueue *pwq,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct wq_barrier *barr,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct work_struct *target, struct worker *worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> linked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * debugobject calls are safe here even with pool-&gt;lock locked</span></span><br><span class="line"><span class="comment"> * as we know for sure that this will not trigger any of the</span></span><br><span class="line"><span class="comment"> * checks and call back into the fixup functions where we</span></span><br><span class="line"><span class="comment"> * might deadlock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.1) barr work 的执行函数 wq_barrier_func()</span></span><br><span class="line">INIT_WORK_ONSTACK(&amp;barr-&gt;work, wq_barrier_func);</span><br><span class="line">__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&amp;barr-&gt;work));</span><br><span class="line">init_completion(&amp;barr-&gt;done);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @target is currently being executed, schedule the</span></span><br><span class="line"><span class="comment"> * barrier to the worker; otherwise, put it after @target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.2) 如果 work 当前在 worker 中执行，则 barr work 插入 scheduled 队列</span></span><br><span class="line"><span class="keyword">if</span> (worker)</span><br><span class="line">head = worker-&gt;scheduled.next;</span><br><span class="line"><span class="comment">// 否则，则 barr work 插入正常的 worklist 队列中，插入位置在目标 work 后面</span></span><br><span class="line"><span class="comment">// 并且置上 WORK_STRUCT_LINKED 标志</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *bits = work_data_bits(target);</span><br><span class="line"></span><br><span class="line">head = target-&gt;entry.next;</span><br><span class="line"><span class="comment">/* there can already be other linked works, inherit and set */</span></span><br><span class="line">linked = *bits &amp; WORK_STRUCT_LINKED;</span><br><span class="line">__set_bit(WORK_STRUCT_LINKED_BIT, bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_work_activate(&amp;barr-&gt;work);</span><br><span class="line">insert_work(pwq, &amp;barr-&gt;work, head,</span><br><span class="line">    work_color_to_flags(WORK_NO_COLOR) | linked);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wq_barrier_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> *<span class="title">barr</span> = <span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">wq_barrier</span>, <span class="title">work</span>);</span></span><br><span class="line"><span class="comment">// (4.1.1) barr work 执行完成，发出 complete 信号。</span></span><br><span class="line">complete(&amp;barr-&gt;done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Workqueue-对外接口函数"><a href="#2-Workqueue-对外接口函数" class="headerlink" title="2.Workqueue 对外接口函数"></a>2.Workqueue 对外接口函数</h2><p>CMWQ 实现的 workqueue 机制，被包装成相应的对外接口函数。</p><h3 id="2-1-schedule-work"><a href="#2-1-schedule-work" class="headerlink" title="2.1 schedule_work()"></a>2.1 <code>schedule_work()</code></h3><p>把 work 压入系统默认 wq system_wq，WORK_CPU_UNBOUND 指定 worker 为当前 CPU 绑定的 normal worker_pool 创建的 worker。</p><ul><li>kernel/workqueue.c:</li><li><code>schedule_work()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-sschedule-work-on"><a href="#2-2-sschedule-work-on" class="headerlink" title="2.2 sschedule_work_on()"></a>2.2 <code>sschedule_work_on()</code></h3><p>在 <code>schedule_work()</code> 基础上，可以指定 work 运行的 CPU。</p><ul><li>kernel/workqueue.c:</li><li><code>schedule_work_on()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_work_on(cpu, system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-schedule-delayed-work"><a href="#2-3-schedule-delayed-work" class="headerlink" title="2.3 schedule_delayed_work()"></a>2.3 <code>schedule_delayed_work()</code></h3><p>启动一个 timer，在 timer 定时到了以后调用 <code>delayed_work_timer_fn()</code> 把 work 压入系统默认 wq system_wq。</p><ul><li>kernel/workqueue.c:</li><li><code>schedule_work_on()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_delayed_work(system_wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">   struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line"><span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* read the comment in __queue_work() */</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">__queue_delayed_work(cpu, wq, dwork, delay);</span><br><span class="line">ret = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_delayed_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">timer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||</span><br><span class="line">     timer-&gt;data != (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dwork);</span><br><span class="line">WARN_ON_ONCE(timer_pending(timer));</span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;work-&gt;entry));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @delay is 0, queue @dwork-&gt;work immediately.  This is for</span></span><br><span class="line"><span class="comment"> * both optimization and correctness.  The earliest @timer can</span></span><br><span class="line"><span class="comment"> * expire is on the closest next tick and delayed_work users depend</span></span><br><span class="line"><span class="comment"> * on that there's no such delay when @delay is 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!delay) &#123;</span><br><span class="line">__queue_work(cpu, wq, &amp;dwork-&gt;work);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);</span><br><span class="line"></span><br><span class="line">dwork-&gt;wq = wq;</span><br><span class="line">dwork-&gt;cpu = cpu;</span><br><span class="line">timer-&gt;expires = jiffies + delay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu != WORK_CPU_UNBOUND))</span><br><span class="line">add_timer_on(timer, cpu);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayed_work_timer_fn</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> __data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> = (<span class="title">struct</span> <span class="title">delayed_work</span> *)__<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* should have been called from irqsafe timer with irq already off */</span></span><br><span class="line">__queue_work(dwork-&gt;cpu, dwork-&gt;wq, &amp;dwork-&gt;work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://git.kernel.org/cgit/Linux/kernel/git/torvalds/Linux.git/tree/Documentation/workqueue.txt?id=refs/tags/v4.7-rc5" target="_blank" rel="noopener">Documentation/workqueue.txt</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 进程管理与通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Workqueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SELinux 安全策略解析 </title>
      <link href="/2016/08/12//linux-selinux-intro.html/"/>
      <url>/2016/08/12//linux-selinux-intro.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>SELinux 是 Security-Enhanced Linux 的简称，是美国国家安全局（NSA=The National Security Agency) 和 SCC（Secure Computing Corporation）开发的基于 Linux 的一个强制访问控制安全模块扩展。原先是在 Fluke 上开发的，2000 年以 GNU GPL 协议发布。对于目前可用的 Linux 安全模块来说，SELinux 是功能最全面 , 而且测试最充分的，它是在 20 年的 MAC 研究基础上建立的。SELinux 已足够成熟、稳定，因此应用非常广泛，现在 Android M 上已经默认开启 SELinux。</p><h2 id="2、自主访问控制"><a href="#2、自主访问控制" class="headerlink" title="2、自主访问控制"></a>2、自主访问控制</h2><p>标准 Linux 也不是没有一点安全性，对于用户对资源的访问也是有一定的限制的，这个限制由三个因素来决定：用户及其组 ID、资源所属的用户及其组 ID、访问模式。这里以文件访问为例，介绍一下标准 Linux 访问控制及其安全漏洞。</p><p>Linux 是一个多用户多任务的分时操作系统，如果要使用系统资源，就必须向系统管理员申请一个账户，然后通过这个账户进入系统。这个账户就是用户 ID。有时需要让多个用户具有相同的权限，为了简化管理，将具有相同特征用户组成一个逻辑集合，就叫用户组。而文件所属用户，一般为文件的创建者，谁创建了该文件 , 就天然的成为该文件的所有者，创建者所在组就是该文件的所属用户组。</p><p><code>ls -l</code> 显示文件的属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r‐-1 dengtaiping dengtaiping 4096 6 月 2 09:39 temp</span><br></pre></td></tr></table></figure><p>前面 10 个字符代表了标准 Linux 对 temp 这个文件的访问控制：</p><ul><li>第一个字符代表文件（-）、目录（d），链接（l）</li><li>其余字符每 3 个一组（rwx），读（r）、写（w）、执行（x）</li><li>第一组 rwx：文件所有者的权限是读、写和执行</li><li>第二组 rw-：与文件所有者同一组的用户的权限是读、写但不能执行</li><li>第三组 r—：不与文件所有者同组的其他用户的权限是读不能写和执行</li></ul><p>后面是文件的所有者、所有者所在的组及其它属性。在安全访问中，访问的发起者称为主体，被访问的资源成为客体。标准 Linux 世界里这种由客体的属主对自己的客体进行管理，由属主自己决定是否将自己的客体访问权或部分访问权授予其他主体的访问控制称为自主访问控制（Discretionary Access Control——DAC）。也就是说，在自主访问控制下，用户可以按自己的意愿，有选择地与其他用户共享他的文件。如在标准 Linux 里，可以通过 chmod、chgrp、chown 分别改变文件的权限、用户组及所有者。所以，DAC 最大的缺点是它不能区分用户和程序，即授权许可是给用户的，只要用户有授权，该用户的所有程序都自动获得授权，包括侵入该用户名下的恶意程序。如果恶意程序获得 root 用户权限，那在标准 Liunx 世界里，就无所不能了。</p><h2 id="3、强制访问控制"><a href="#3、强制访问控制" class="headerlink" title="3、强制访问控制"></a>3、强制访问控制</h2><p>强制访问控制（Mandatory Access Control——MAC），用于将系统中的客体分密级和类进行管理，以保证每个主体只能访问到那些被标明可以由它访问的一种访问约束机制。在 SELinux 的强制访问控制下，访问的主体不再是用户，而是进程。客体可以是文件、目录、共享内存、套接字、网络主机等。主体和客体都被标记了固定的安全属性（如安全等级、访问权限等），在每次访问发生时，系统检测安全属性以便确定一个主体是否有权访问该客体。因此在这里，决定访问权限的不再是主体和客体，而是访问控制策略。这就意味着在 SELinux 中没有默认的超级用户。SELinux 实现了一个灵活的 MAC 机制，引入了两套安全策略，分别是类型强制 (Type Enforcement) 和多层安全 (Multi-Level Security)。</p><h3 id="3-1、类型强制"><a href="#3-1、类型强制" class="headerlink" title="3.1、类型强制"></a>3.1、类型强制</h3><p>类型强制访问控制通过指定主体类型（即域）和客体类型使用 allow 规则授予访问权限，allow 规则由四部分组成：</p><ul><li>源类型（Source type(s)）：通常是尝试访问的进程的域类型</li><li>目标类型（Target type(s)）： 被进程访问的客体的类型</li><li>客体类别（Object class(es)）： 指定允许访问的客体的类型</li><li>许可（Permission(s)）： 象征目标类型允许源类型访问客体类型的访问种类</li></ul><p>下面以 Android 手机中一个例子说明 TE 是如何工作的。在手机的 console 环境中，运行 <code>ls -Z | grep proc</code>，可看到 proc 目录的安全上下文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr-xr-xr-x root     root              u:object_r:proc:s0 proc</span><br></pre></td></tr></table></figure><p>再运行 <code>ps -Z | grep adbd</code>，看看进程 adbd 的安全上下文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u:r:su:s0                      root      2935  1     &#x2F;sbin&#x2F;adbd</span><br></pre></td></tr></table></figure><p>可以看到，目录 proc 和进程 adbd 各自有自己的安全上下文，安全上下文实际上是附加在对象上的一个标签，由用户、角色、类型和安全级别四部分组成，由冒号隔开。安全级别下一节再介绍，在 SEAndroid 里，只定义了一个用户 u，所以文件和进程安全上下文中，所有的用户都为 u。文件的角色一般都为 object_r，而进程的角色固定为 r。用户和角色定义得这么随意，是因为对安全策略来说它们并不重要，在类型强制访问控制的安全上下文中，最重要的就是类型，它才是定义规则时需要的。假如要想通过 adb 读写 proc 目录下的文件节点，则需要定义如下一条规则来授权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow init proc:dir rw_dir_perms;</span><br></pre></td></tr></table></figure><h3 id="3-2、多级安全"><a href="#3-2、多级安全" class="headerlink" title="3.2、多级安全"></a>3.2、多级安全</h3><p>SELinux 引入的另外一个安全策略是多级安全 (Multi-Level Security)。多级安全是建立在 TE 的基础之上的，这个安全策略在 SELinux 中是可选的，但引入多级安全，不仅是对安全访问的增强，更是因为对于一组对象进行分类访问授权，使用多级安全是非常高效的。在前面所举例子中，proc 和 adbd 都有一个安全级别 s0。</p><p>在多级安全中，主体和客体都有一个关联的安全级别，多级安全的访问规则就是：安全级别较高的主体可以读取安全级别较低的客体；而安全级别较低的主体可以写入安全级别较高的客体。前者称为 “read down”，后者称为 “write up”。通过这种规则，可以允许数据从安全级别较低的客体流向安全级别较高的主体，而限制数据从安全级别较高的客体流向安全级别较低的主体，从而有效的保护了数据。对于安全级别相同的主体和客体，主体对客体的读写都是允许的。</p><p>基于多级安全策略的 MAC 数据流向，如下所示：</p><p><img src="images/posts/2016/08/SELinux_1.png" alt="MAC 数据流向 "></p><p>图中定义来两个安全级别，PUBLIC 和 SECRET，其中，SECRET 安全级别高于 PUBLIC。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>SELinux 原来是作为一个内核补丁实现的，现在已经将 Linux 安全模块（LSM）重新实现为一个安全模块。嵌入到标准 Linux 中的方式是 LSM 提供一套钩子函数 (hook)，MAC 安全策略检查在这些钩子函数中实现。钩子函数通常放在标准 Linux 检查后、内核调用访问真实资源前调用。系统调用进入内核后，会做常规的错误检查 ( 如参数有效性等 )，然后是标准 Linux 的 DAC 检查。MAC 在这些检查都通过之后才会生效。所以，在 SELinux 中，DAC 和 MAC 同时起作用，两者并行而不悖。LSM 具体实现机制及代码解读将在后续文章中介绍。最终 SELinux 的访问控制流程就如下图所示：</p><p><img src="images/posts/2016/08/SELinux_2.png" alt="SELinux 控制流程 "></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SELinux </tag>
            
            <tag> 类型强制 </tag>
            
            <tag> 多级安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS 调度器移植体验 </title>
      <link href="/2016/08/06//bfs-porting.html/"/>
      <url>/2016/08/06//bfs-porting.html/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>BFS 全称 Brain Fuck Scheduler. 至于为什么叫这个名字，可以参考 BFS-FAQ<sup><a href="#fn_FAQ" id="reffn_FAQ">FAQ</a></sup>．</p><p>作者 Con Kolivas 在介绍中表示，BFS 的设计的初衷是带来更好的桌面交互式体验，特别是对于大多数的低规格机器．</p><p>Android 也曾经评估过 BFS, 测试的结果对用户体验没有明显的改进，因此并没有最终导入．</p><p>通过一些第三方机构的测试数据来看，低配置的硬件平台使用 BFS 带来的体验提升会更加明显．比如笔者正在用的这台　thinkpad t61 ( 所以手上有比较老的笔记本 / PC 尽管来体验吧 )．</p><h3 id="Get-Prepared"><a href="#Get-Prepared" class="headerlink" title="Get Prepared"></a>Get Prepared</h3><ol><li><p>选择内核版本<br>从 <a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a> 选择下载需要的版本 , 比如 3.18.31.tx.gz</p></li><li><p>解压缩该版本到你想要路径 , 网络上有建议放在 /usr/src 下 , 看起来更合理 , 因为内核的源代码默认就存放在该路径 , 但我就遇到了编译时空间不够的问题 , 因为我给 ‘/‘ 分配的空间是 20GB, 能用的不到 8GB 了 . 所以建议放在空间够的分区 , 至少有 15GB, 例如 ~/projects/3.18.31-ck1-bfs/</p></li></ol><h3 id="Apply-BFS-Patch"><a href="#Apply-BFS-Patch" class="headerlink" title="Apply BFS Patch"></a>Apply BFS Patch</h3><ol><li>获取对应内核版本的 BFS patch, 从 BFS 作者 <a href="http://ck.kolivas.org/" target="_blank" rel="noopener">Con Kolivas 的个人站点 </a> 获得指定内核版本的 BFS patch, 例如 <code>http://ck.kolivas.org/patches/bfs/3.0/3.18/</code> 下面就有 3.18-sched-bfs-460.patch 等</li><li>进入到内核目录 ~/projects/3.18.31-ck1-bfs/, <code>patch -p1 &lt;xxxx.patch</code>, patch 不止一个 , 建议都打上 , 省的后期再 tunning 了</li></ol><h3 id="Build-Kernel-with-BFS-patch"><a href="#Build-Kernel-with-BFS-patch" class="headerlink" title="Build Kernel with BFS patch"></a>Build Kernel with BFS patch</h3><ol><li><p><code>$ make menuconfig</code><br>注意再 General Setup 确认 BFS 是不是已经勾选上了，OK 之后就保存 .config 文件</p></li><li><p><code>$ make bzImage -j4</code><br>这取决于机器的性能, 一般是 -jx 是 CPU core 的 2 倍 , 考虑到有些电脑太老了, 可以把源码的编译放在性能更好的机器上做 , 完事后 copy 过来就 OK 了</p></li><li><p><code>$ make modules -j4</code><br>同上 , 完成这一步之后 , 可以把整个源码包复制到你想要的电脑上</p></li><li><p><code>$ make modules_install</code></p></li><li><code>$ sudo mkinitramfs -o /boot/initrd.img-3.18.31-ck1-bfs</code></li></ol><h3 id="Configure-New-Kernel"><a href="#Configure-New-Kernel" class="headerlink" title="Configure New Kernel"></a>Configure New Kernel</h3><ol><li><p>Copy bzImage 到 /boot/<br><code>$ sudo cp arch/x86_64/boot/bzImage /boot/vmlinuz-3.18.31-ck1-bfs</code><br>具体取决于系统架构 , 也不一定是 x86_64 目录</p></li><li><p>Copy System.map 到 /boot/, 建立新的软链接<br><code>$ sudo cp System.map /boot/System.map-3.18.31-ck1-bfs</code><br><code>$ sudo ln -s /boot/System.map-3.18.31-ck1-bfs /boot/System.map</code></p></li><li><p>配置引导文件<br><code>$ sudo update-grub2</code></p></li></ol><p>至此 , 工作完成 , reboot 之后就可以体验啦</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote id="fn_FAQ"><sup>FAQ</sup>. <a href="http://ck.kolivas.org/patches/bfs/bfs-faq.txt" target="_blank" rel="noopener">http://ck.kolivas.org/patches/bfs/bfs-faq.txt</a><a href="#reffn_FAQ" title="Jump back to footnote [FAQ] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 调度器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> scheduler </tag>
            
            <tag> BFS </tag>
            
            <tag> 调度器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 死锁检测模块 Lockdep 简介</title>
      <link href="/2016/07/25//linux-dead-lock-detect-lockdep.html/"/>
      <url>/2016/07/25//linux-dead-lock-detect-lockdep.html/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h2><p>死锁是指多个进程（线程）因为长久等待已被其他进程占有的的资源而陷入阻塞的一种状态。当等待的资源一直得不到释放，死锁会一直持续下去。死锁一旦发生，程序本身是解决不了的，只能依靠外部力量使得程序恢复运行，例如重启，开门狗复位等。</p><p>Linux 提供了检测死锁的机制，主要分为 D 状态死锁和 R 状态死锁。</p><ul><li><p><strong>D 状态死锁</strong></p><p>进程等待 I/O 资源无法得到满足，长时间（系统默认配置 120 秒）处于 TASK_UNINTERRUPTIBLE 睡眠状态，这种状态下进程不响应异步信号（包括 kill -9）。如：进程与外设硬件的交互（如 read），通常使用这种状态来保证进程与设备的交互过程不被打断，否则设备可能处于不可控的状态。对于这种死锁的检测 Linux 提供的是 hung task 机制，MTK 也提供 hang detect 机制来检测 Android 系统 hang 机问题。触发该问题成因比较复杂多样，可能因为 synchronized_irq、mutex lock、内存不足等。D 状态死锁只是局部多进程间互锁，一般来说只是 hang 机、冻屏，机器某些功能没法使用，但不会导致没喂狗，而被狗咬死。</p></li><li><p><strong>R 状态死锁</strong></p><p>进程长时间（系统默认配置 60 秒）处于 TASK_RUNNING 状态垄断 CPU 而不发生切换，一般情况下是进程关抢占或关中断后长时候执行任务、死循环，此时往往会导致多 CPU 间互锁，整个系统无法正常调度，导致喂狗线程无法执行，无法喂狗而最终看门狗复位的重启。该问题多为原子操作，spinlock 等 CPU 间并发操作处理不当造成。本文所介绍的 Lockdep 死锁检测工具检测的死锁类型就是 R 状态死锁。</p></li></ul><p><strong>常见错误</strong></p><ul><li>AA: 重复上锁</li><li>ABBA: 曾经使用 AB 顺序上锁，又使用 BA 上锁</li><li>ABBCCA: 这种类型是 ABBA 的扩展。AB 顺序 , AB 顺序，CA 顺序。这种锁人工很难发现。</li><li>多次 unlock</li></ul><h2 id="AB-BA-死锁的形成"><a href="#AB-BA-死锁的形成" class="headerlink" title="AB-BA 死锁的形成"></a>AB-BA 死锁的形成</h2><p>假设有两处代码（比如不同线程的两个函数 thread_P 和 thread_Q）都要获取两个锁（分别为 lockA 和 lockB），如果 thread_P 持有 lockA 后再去获取 lockB，而此时恰好由 thread_Q 持有 lockB 且它也正在尝试获取 lockA，那么此时就是处于死锁的状态，这是一个最简单的死锁例子，也即所谓的 AB-BA 死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">thread_P()</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    spin_lock(&amp;lockA);</span><br><span class="line">    spin_lock(&amp;lockB);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;lockA);</span><br><span class="line">    spin_unlock(&amp;lockB);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_Q()</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    spin_lock(&amp;lockB);</span><br><span class="line">    spin_lock(&amp;lockA);</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;lockB);</span><br><span class="line">    spin_unlock(&amp;lockA);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面接合时间轴来观察死锁发生的时机：</p><p><img src="/images/posts/2016/07/lockdep-ABBA-1.png" alt="ABBA 死锁示意图 1"></p><p>X 轴表示进程 P 执行的时间轴，Y 轴表示进程 Q 执行的时间轴。</p><p>这幅图依据两个进程并发时间点不同而给出了 6 种执行线路：</p><ol><li>Q 获得 B，然后获得 A；然后释放 B，然后释放 A；此时 P 执行时，它可以获得全部资源</li><li>Q 获得 B，然后获得 A；此时 P 执行并阻塞在对 A 的请求上；Q 释放 B 和 A，当 P 恢复执行时，它可以获得全部资源</li><li>Q 获得 B，然后 P 执行获得 A；此时 Q 阻塞在对 A 的请求上；P 阻塞在对 B 的请求上，大家都在互相等待各自的资源而死锁</li><li>P 获得 A，然后 Q 执行获得 B；此时 P 阻塞在对 B 的请求上；Q 阻塞在对 A 的请求上，大家都在互相等待各自的资源而死锁</li><li>P 获得 A，然后获得 B；此时 Q 执行并阻塞在对 B 的请求上；P 释放 A 和 B，当 Q 恢复执行时，它可以获得全部资源</li><li>P 获得 A，然后获得 B；然后释放 A，然后释放 B；此时 Q 执行时，它可以获得全部资源</li></ol><p>下面这种情况是任何时间点都不会出现死锁的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Process P                  Process Q</span><br><span class="line">  •••                        •••</span><br><span class="line"> Get A                      Get B</span><br><span class="line">  •••                        •••</span><br><span class="line">Release A                   Get A</span><br><span class="line">  •••                        •••</span><br><span class="line"> Get B                     Release B</span><br><span class="line">  •••                        •••</span><br><span class="line">Release B                  Release A</span><br><span class="line">  •••                        •••</span><br></pre></td></tr></table></figure><p><img src="/images/posts/2016/07/lockdep-ABBA-2.png" alt="ABBA 死锁示意图 2"></p><h2 id="lockdep-死锁检测模块"><a href="#lockdep-死锁检测模块" class="headerlink" title="lockdep 死锁检测模块"></a>lockdep 死锁检测模块</h2><p>介绍了最简单的 ABBA 死锁的形成，回到正题，回到 kernel, 里面有千千万万锁，错综复杂，也不可能要求所有开发人员熟悉 spin_lock, spin_lock_irq, spin_lock_irqsave, spin_lock_nested 的区别。所以，在锁死发生前，还是要做好预防胜于治疗，防患于未然的工作，尽量提前发现并且提前在开发阶段发现和解决这其中潜在的死锁风险，而不是等到最后真正出现死锁时给用户带来糟糕的体验。应运而生的就是 lockdep 死锁检测模块，在 2006 年已经引入内核（<a href="https://lwn.net/Articles/185666/）。" target="_blank" rel="noopener">https://lwn.net/Articles/185666/）。</a></p><h3 id="1-相关内核配置选项"><a href="#1-相关内核配置选项" class="headerlink" title="1. 相关内核配置选项"></a>1. 相关内核配置选项</h3><ul><li><p><strong>CONFIG_PROVE_LOCKING</strong></p><p>This feature enables the kernel to report locking related deadlocks before they actually occur. For more details, see Documentation/locking/lockdep-design.txt.</p></li><li><p><strong>CONFIG_DEBUG_LOCK_ALLOC</strong></p><p>Detect incorrect freeing of live locks.</p></li><li><p><strong>CONFIG_DEBUG_LOCKDEP</strong></p><p>The lock dependency engine will do additional runtime checks to debug itself, at the price of more runtime overhead.</p></li><li><p><strong>CONFIG_LOCK_STAT</strong></p><p>Lock usage statistics. For more details, see Documentation/locking/lockstat.txt</p></li><li><p><strong>CONFIG_DEBUG_LOCKING_API_SELFTESTS</strong></p><p>The kernel to run a short self-test during bootup in <code>start_kernel()</code>. The self-test checks whether common types of locking bugs are detected by debugging mechanisms or not. For more details, see lib/locking-selftest.c</p></li></ul><h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2. 基本实现"></a>2. 基本实现</h3><p>lockdep 操作的基本单元并非单个的锁实例，而是锁类（lock-class），事实上，也没必要跟踪千千万万的锁，完全可以用同一方式对待同一类锁的行为。比如，struct inode 结构体中的自旋锁 i_lock 字段就代表了这一类锁，而具体每个 inode 节点的锁只是该类锁中的一个实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># define raw_spin_lock_init(lock)\</span><br><span class="line">do &#123;\</span><br><span class="line">static struct lock_class_key __key;\</span><br><span class="line">\</span><br><span class="line">__raw_spin_lock_init((lock), #lock, &amp;__key);\</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure><p>对于每个锁的初始化，这段代码创建了一个静态变量 (__key)，并使用它的地址作为识别锁的类型。因此，系统中的每个锁 ( 包括 rwlocks 和 mutexes ) 都被分配一个特定的 key 值，并且都是静态声明的，同一类的锁会对应同一个 key 值。这里用得是哈希表来存储。</p><p>Lockdep 为每个锁类维护了两个链表：</p><ul><li>before 链：锁类 L 前曾经获取的所有锁类，也就是锁类 L 前可能获取的锁类集合。</li><li>after 链：锁类 L 后曾经获取的所有锁类。</li></ul><p>Lockdep 逻辑：</p><p>当获取 L 时，检查 after 链中的锁类是否已经被获取，如果存在则报重复上锁。联合 L 的 after 链，和已经获取的锁的 before 链。递归检查是否某个已经获取的锁中包含 L after 锁。为了加速，lockdep 检查锁类顺序关系，计算出 64bit 的 hash key。当新的 lock 顺序出现则计算 hash key 并放入表中。当获取锁时，则直接扫描表，用于加速。</p><p>也由于上述的设计逻辑，不可避免会存在误报。例如，同一类（对应相同 key 值）的多个锁同时持有时，Lockdep 会误报“重复上锁”的警报。此时，你就需要使用 spin_lock_nested 这类 API 设置不同的子类来区分同类锁，消除警报。</p><p>随便找一个代码例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dentry_lock_for_move() @fs&#x2F;dcache.c</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">if (d_ancestor(dentry-&gt;d_parent, target-&gt;d_parent)) &#123;</span><br><span class="line">spin_lock(&amp;dentry-&gt;d_parent-&gt;d_lock);</span><br><span class="line">spin_lock_nested(&amp;target-&gt;d_parent-&gt;d_lock,</span><br><span class="line">DENTRY_D_LOCK_NESTED);  &#x2F;&#x2F;set sub-class</span><br><span class="line">&#125; else &#123;</span><br><span class="line">spin_lock(&amp;target-&gt;d_parent-&gt;d_lock);</span><br><span class="line">spin_lock_nested(&amp;dentry-&gt;d_parent-&gt;d_lock,</span><br><span class="line">DENTRY_D_LOCK_NESTED); &#x2F;&#x2F;set sub-class</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init()</span><br><span class="line">        ↓</span><br><span class="line">raw_spin_lock_init()</span><br><span class="line">        ↓</span><br><span class="line">__raw_spin_lock_init()</span><br><span class="line">        → debug_check_no_locks_freed()</span><br><span class="line">        → lockdep_init_map()</span><br><span class="line">        → 初始化 spin_lock 的值</span><br></pre></td></tr></table></figure><p>2）获取锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spin_lock()</span><br><span class="line">    ↓</span><br><span class="line">raw_spin_lock()</span><br><span class="line">    ↓</span><br><span class="line">_raw_spin_lock() @kernel&#x2F;spinlock.c</span><br><span class="line">    ↓</span><br><span class="line">__raw_spin_lock() @include&#x2F;linux&#x2F;spinlock_api_smp.h</span><br><span class="line">    → preempt_disable();</span><br><span class="line">    → spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">            ↓</span><br><span class="line">        lock_acquire() → __lock_acquire() → __lock_acquire()</span><br><span class="line">        __lock_acquire() 是 lockdep 死锁检测的核心，所有原理中描述的死锁错误都是在这里检测的。如果出错，最终会调用 print_xxx_bug() 函数。</span><br><span class="line">    → LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br></pre></td></tr></table></figure><h3 id="3-检查规则"><a href="#3-检查规则" class="headerlink" title="3. 检查规则"></a>3. 检查规则</h3><p><strong>1）概述</strong></p><p>Lockdep 操作的基本单元并非单个的锁实例，而是锁类（lock-class）。比如，struct inode 结构体中的自旋锁 i_lock 字段就代表了这一类锁，而具体每个 inode 节点的锁只是该类锁中的一个实例。</p><p>lockdep 跟踪每个锁类的自身状态，也跟踪各个锁类之间的依赖关系，通过一系列的验证规则，以确保锁类状态和锁类之间的依赖总是正确的。另外，锁类一旦在初次使用时被注册，那么后续就会一直存在，所有它的具体实例都会关联到它。</p><p><strong>2）状态</strong></p><p>锁类有 4n + 1 种不同的使用历史状态：</p><p>其中的 4 是指：</p><ul><li>‘ever held in STATE context’ –&gt; 该锁曾在 STATE 上下文被持有过</li><li>‘ever held as readlock in STATE context’ –&gt; 该锁曾在 STATE 上下文被以读锁形式持有过</li><li>‘ever held with STATE enabled’ –&gt; 该锁曾在启用 STATE 的情况下被持有过</li><li>‘ever held as readlock with STATE enabled’ –&gt; 该锁曾在启用 STATE 的情况下被以读锁形式持有过</li></ul><p>其中的 n 也就是 STATE 状态的个数：</p><ul><li>hardirq –&gt; 硬中断</li><li>softirq –&gt; 软中断</li><li>reclaim_fs –&gt; fs 回收</li></ul><p>其中的 1 是：</p><ul><li>ever used  [ == !unused ] –&gt; 不属于上面提到的任何特殊情况，仅仅只是表示该锁曾经被使用过</li></ul><p>当触发 lockdep 检测锁的安全规则时，会在 log 中提示对应的状态位信息</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe&#x2F;2287 is trying to acquire lock:</span><br><span class="line"> (&amp;sio_locks[i].lock)&#123;-.-...&#125;, at: [&lt;c02867fd&gt;] mutex_lock+0x21&#x2F;0x24</span><br><span class="line"></span><br><span class="line">but task is already holding lock:</span><br><span class="line"> (&amp;sio_locks[i].lock)&#123;-.-...&#125;, at: [&lt;c02867fd&gt;] mutex_lock+0x21&#x2F;0x24</span><br></pre></td></tr></table></figure><p>注意大括号内的符号，一共有 6 个字符，分别对应 STATE 和 STATE-read 这六种（因为目前每个 STATE 有 3 种不同含义）情况，各个字符代表的含义分别如下：</p><ul><li>‘.’  表示在在进程上下文，在 irq 关闭时获得一把锁</li><li>‘-‘  表示在中断上下文，获得一把锁</li><li>‘+’  表示在 irq 打开时获得一把锁</li><li>‘?’  表示在中断上下文，在 irq 打开时获得一把锁</li></ul><p><strong>3）单锁状态规则（Single-lock state rules）</strong></p><ul><li>一个软中断不安全 (softirq-unsafe) 的锁类也是硬中断不安全 (hardirq-unsafe) 的锁类。</li><li>对于任何一个锁类，它不可能同时是 hardirq-safe  和 hardirq-unsafe，也不可能同时是 softirq-safe 和 softirq-unsafe，即这两对对应状态是互斥的。</li></ul><p>上面这两条就是 lockdep 判断单锁是否会发生死锁的检测规则。</p><p>关于四个名称的概念如下 :</p><ul><li>ever held in hard interrupt context (hardirq-safe);</li><li>ever held in soft interrupt context (softirg-safe);</li><li>ever held in hard interrupt with interrupts enabled (hardirq-unsafe);</li><li>ever held with soft interrupts and hard interrupts enabled (softirq-unsafe);</li></ul><p><strong>4）多锁依赖规则（Multi-lock dependency rules）</strong></p><ul><li>同一个锁类不能被获取两次，否则会导致递归死锁（AA）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU0:    [ L1 ] -&gt; [ L1 ]</span><br></pre></td></tr></table></figure><ul><li>不能以不同的顺序获取两个锁类，即：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----                    ----</span><br><span class="line">[ L1 ]</span><br><span class="line">                        [ L2 ]</span><br><span class="line">                        [ L1 ]</span><br><span class="line">[ L2 ]</span><br><span class="line">*** DEADLOCK ***</span><br></pre></td></tr></table></figure><p>是不行的。因为这会非常容易的导致 AB-BA 死锁。当然，下面这样的情况也不行，即在中间插入了其它正常顺序的锁也能被 lockdep 检测出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----                    ----</span><br><span class="line">[ L1 ]</span><br><span class="line">[ L3 ]</span><br><span class="line">[ L4 ]</span><br><span class="line">                        [ L2 ]</span><br><span class="line">                        [ L3 ]</span><br><span class="line">                        [ L4 ]</span><br><span class="line">                        [ L1 ]</span><br><span class="line">[ L2 ]</span><br><span class="line">*** DEADLOCK ***</span><br></pre></td></tr></table></figure><ul><li>同一个锁实例在任何两个锁类之间，嵌套获取锁的状态前后需要保持一致，即：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hardirq-safe]   -&gt;  [hardirq-unsafe]</span><br><span class="line"></span><br><span class="line">[softirq-safe]   -&gt;  [softirq-unsafe]</span><br></pre></td></tr></table></figure><p>这意味着，如果同一个锁实例，在某些地方是 hardirq-safe（即采用 spin_lock_irqsave(…)），而在某些地方又是 hardirq-unsafe（即采用 spin_lock(…)），那么就存在死锁的风险。这应该容易理解，比如在进程上下文中持有锁 A，并且锁 A 是 hardirq-unsafe，如果此时触发硬中断，而硬中断处理函数又要去获取锁 A，那么就导致了死锁。后面会有例子分析。</p><p>在锁类状态发生变化时，进行如下几个规则检测，判断是否存在潜在死锁。比较简单，就是判断 hardirq-safe 和 hardirq-unsafe 以 及 softirq-safe 和 softirq-unsafe 是否发生了碰撞，直接引用英文，如下：</p><ul><li>if a new hardirq-safe lock is discovered, we check whether it took any hardirq-unsafe lock in the past.</li><li>if a new softirq-safe lock is discovered, we check whether it took any softirq-unsafe lock in the past.</li><li>if a new hardirq-unsafe lock is discovered, we check whether any hardirq-safe lock took it in the past.</li><li>if a new softirq-unsafe lock is discovered, we check whether any softirq-safe lock took it in the past.</li></ul><p>所以要注意嵌套获取锁前后的状态需要保持一致，避免死锁风险。</p><p><strong>5) 出错处理 </strong></p><p>当检测到死锁风险时，lockdep 会打印下面几种类型的风险提示，更完整的 LOG 会在下面例子中展示。</p><ul><li>[ INFO: possible circular locking dependency detected ] // 圆形锁，获取锁的顺序异常（ABBA）</li><li>[ INFO: %s-safe -&gt; %s-unsafe lock order detected ] // 获取从 safe 的锁类到 unsafe 的锁类的操作</li><li>[ INFO: possible recursive locking detected ] // 重复去获取同类锁（AA）</li><li>[ INFO: inconsistent lock state ]  // 锁的状态前后不一致</li><li>[ INFO: possible irq lock inversion dependency detected ]  // 嵌套获取锁的状态前后需要保持一致，即 [hardirq-safe]   -&gt;  [hardirq-unsafe]，[softirq-safe]   -&gt;  [softirq-unsafe] 会警报死锁风险</li><li>[ INFO: suspicious RCU usage. ] // 可疑的 RCU 用法</li></ul><h3 id="4-使用实例"><a href="#4-使用实例" class="headerlink" title="4. 使用实例"></a>4. 使用实例</h3><p>Lockdep 每次都只检测并 report 第一次出错的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@lib&#x2F;debug_locks.c</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * We want to turn all lock-debugging facilities on&#x2F;off at once,</span><br><span class="line"> * via a global flag. The reason is that once a single bug has been</span><br><span class="line"> * detected and reported, there might be cascade of followup bugs</span><br><span class="line"> * that would just muddy the log. So we report the first one and</span><br><span class="line"> * shut up after that.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int debug_locks &#x3D; 1;</span><br><span class="line">EXPORT_SYMBOL_GPL(debug_locks);</span><br></pre></td></tr></table></figure><p>只报一次死锁风险打印提示就不报了，因为第一个报出来的可能会引发其他的风险提示，就像编译错误一样。并且，这只是一个 warning info, 在实时运行的系统中，LOG 可能一下子就被冲掉了。本着魅族手机对用户体验极致的追求，不允许任何一个死锁风险在开发阶段侥幸存在，我们会把 lockdep warning 转化为 <code>BUG_ON()</code>，使机器在遇到死锁风险就主动重启来引起开发人员的关注，从而不放过每一个可能存在的漏洞。</p><p>下面是实际开发中遇到 lockdep 报的死锁风险 LOG：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">(0)[1132:system_server]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">(0)[1132:system_server][ INFO: HARDIRQ-safe -&gt; HARDIRQ-unsafe lock order detected ]</span><br><span class="line">(0)[1132:system_server]3.18.22-eng-01315-gea95810-cIb68b198-dirty #2 Tainted: G        W</span><br><span class="line">(0)[1132:system_server]------------------------------------------------------</span><br><span class="line">(0)[1132:system_server]system_server&#x2F;1132 [HC0[0]:SC0[0]:HE0:SE1] is trying to acquire:</span><br><span class="line">(0)[1132:system_server]lockdep: [ffffffc0013a6b18] (resume_reason_lock)&#123;+.+...&#125;</span><br><span class="line">(0)[1132:system_server]lockdep: , at:</span><br><span class="line">(0)[1132:system_server][&lt;ffffffc00011a2e0&gt;] log_wakeup_reason+0x40&#x2F;0x17c</span><br><span class="line">(0)[1132:system_server]</span><br><span class="line">and this task is already holding:</span><br><span class="line">(0)[1132:system_server]lockdep: [ffffffc001401440] (__spm_lock)&#123;-.....&#125;</span><br><span class="line">(0)[1132:system_server]lockdep: , at:</span><br><span class="line">(0)[1132:system_server][&lt;ffffffc000492164&gt;] spm_go_to_sleep+0x200&#x2F;0x948</span><br><span class="line">(0)[1132:system_server]which would create a new lock dependency:</span><br><span class="line">(0)[1132:system_server] (__spm_lock)&#123;-.....&#125; -&gt; (resume_reason_lock)&#123;+.+...&#125;</span><br><span class="line">(0)[1132:system_server]</span><br><span class="line">but this new dependency connects a HARDIRQ-irq-safe lock:</span><br><span class="line">(0)[1132:system_server] (__spm_lock)&#123;-.....&#125;</span><br><span class="line">... which became HARDIRQ-irq-safe at:</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00010b834&gt;] mark_lock+0x180&#x2F;0x770</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00010e868&gt;] __lock_acquire+0xaf8&#x2F;0x243c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000110b08&gt;] lock_acquire+0xe8&#x2F;0x1a8</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000c73eb4&gt;] _raw_spin_lock_irqsave+0x54&#x2F;0x84</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00048f880&gt;] spm_irq0_handler+0x2c&#x2F;0x12c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00011f948&gt;] handle_irq_event_percpu+0xc0&#x2F;0x338</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00011fc08&gt;] handle_irq_event+0x48&#x2F;0x78</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000122d68&gt;] handle_fasteoi_irq+0xe0&#x2F;0x1a4</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00011eee0&gt;] generic_handle_irq+0x30&#x2F;0x4c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00011effc&gt;] __handle_domain_irq+0x100&#x2F;0x2a4</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000081568&gt;] gic_handle_irq+0x54&#x2F;0xe0</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000085290&gt;] el0_irq_naked+0x14&#x2F;0x24</span><br><span class="line">(0)[1132:system_server]</span><br><span class="line">to a HARDIRQ-irq-unsafe lock:</span><br><span class="line">(0)[1132:system_server] (resume_reason_lock)&#123;+.+...&#125;</span><br><span class="line">... which became HARDIRQ-irq-unsafe at:</span><br><span class="line">(0)[1132:system_server]...  [&lt;ffffffc00010b834&gt;] mark_lock+0x180&#x2F;0x770</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00010e65c&gt;] __lock_acquire+0x8ec&#x2F;0x243c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000110b08&gt;] lock_acquire+0xe8&#x2F;0x1a8</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000c73e48&gt;] _raw_spin_lock+0x38&#x2F;0x50</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc00011a258&gt;] wakeup_reason_pm_event+0x54&#x2F;0x9c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0000c4d88&gt;] notifier_call_chain+0x84&#x2F;0x2d4</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0000c5400&gt;] __blocking_notifier_call_chain+0x40&#x2F;0x74</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0000c5444&gt;] blocking_notifier_call_chain+0x10&#x2F;0x1c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000115ed4&gt;] pm_notifier_call_chain+0x1c&#x2F;0x48</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000117b68&gt;] pm_suspend+0x36c&#x2F;0x70c</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000115e40&gt;] state_store+0xb0&#x2F;0xe0</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0003b1f28&gt;] kobj_attr_store+0x10&#x2F;0x24</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc000266f88&gt;] sysfs_kf_write+0x50&#x2F;0x64</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0002662c8&gt;] kernfs_fop_write+0x110&#x2F;0x180</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0001f6570&gt;] vfs_write+0x98&#x2F;0x1b8</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0001f678c&gt;] SyS_write+0x4c&#x2F;0xb0</span><br><span class="line">(0)[1132:system_server]  [&lt;ffffffc0000854ac&gt;] el0_svc_naked+0x20&#x2F;0x28</span><br><span class="line">(0)[1132:system_server]</span><br><span class="line">other info that might help us debug this:</span><br><span class="line"></span><br><span class="line">(0)[1132:system_server] Possible interrupt unsafe locking scenario:</span><br><span class="line"></span><br><span class="line">(0)[1132:system_server]       CPU0                    CPU1</span><br><span class="line">(0)[1132:system_server]       ----                    ----</span><br><span class="line">(0)[1132:system_server]  lock(resume_reason_lock);</span><br><span class="line">(0)[1132:system_server]                         local_irq_disable();</span><br><span class="line">(0)[1132:system_server]                         lock(__spm_lock);</span><br><span class="line">(0)[1132:system_server]                         lock(resume_reason_lock);</span><br><span class="line">(0)[1132:system_server]  &lt;Interrupt&gt;</span><br><span class="line">(0)[1132:system_server]  lock(__spm_lock);</span><br><span class="line">(0)[1132:system_server]  *** DEADLOCK ***</span><br></pre></td></tr></table></figure><p>从上面的 LOG 信息可以知道：system_server 已经合了一个 HARDIRQ-safe 的锁 __spm_lock， 此时再去拿一个 HARDIRQ-unsafe 的锁 resume_reason_lock，违反了嵌套获取锁前后的状态需要保持一致的规则。</p><p>记得上面说过一条规则吗？</p><blockquote><p>if a new hardirq-unsafe lock is discovered, we check whether any hardirq-safe lock took it in the past.（当要获取一个 hardirq-unsafe lock 时，lockdep 就会检查该进程是否在之前已经获取 hardirq-safe lock）</p></blockquote><p>HARDIRQ-safe 是不允许 irq 的锁，如：spin_lock_irqsave(&amp;lock, flags);</p><p>HARDIRQ-unsafe 是允许 irq 的锁，如：spin_lock(&amp;lock);</p><p>在之前已经使用 spin_lock_irqsave 的方式拿了 __spm_lock， 再以 spin_lock 的方式拿 resume_reason_lock。再来看看可能发生死锁的情景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(0)[1132:system_server] Possible interrupt unsafe locking scenario:</span><br><span class="line"></span><br><span class="line">(0)[1132:system_server]       CPU0                    CPU1</span><br><span class="line">(0)[1132:system_server]       ----                    ----</span><br><span class="line">(0)[1132:system_server]  lock(resume_reason_lock);</span><br><span class="line">(0)[1132:system_server]                         local_irq_disable();</span><br><span class="line">(0)[1132:system_server]                         lock(__spm_lock);</span><br><span class="line">(0)[1132:system_server]                         lock(resume_reason_lock);</span><br><span class="line">(0)[1132:system_server]  &lt;Interrupt&gt;</span><br><span class="line">(0)[1132:system_server]  lock(__spm_lock);</span><br><span class="line">(0)[1132:system_server]  *** DEADLOCK ***</span><br></pre></td></tr></table></figure><p>Lockdep 列出一个可能发生死锁的设想：</p><ul><li>CPU0 先获取了一个 HARDIRQ-unsafe 的锁 lock(resume_reason_lock)，CPU0 本地 irq 是开启的。</li><li>接着 CPU1 再获取了 HARDIRQ-safe 的锁 lock(__spm_lock)，此时 CPU1 本地 irq 是关闭的。</li><li>接着 CPU1 又去获取 lock(resume_reason_lock)，但此时该锁正在被 CPU0 锁持有，CPU1 唯有等待 lock(resume_reason_lock) 释放而无法继续执行。</li><li>假如此时 CPU0 来了一个中断，并且在中断里去获取 lock(__spm_lock)，CPU0 也会因为该锁被 CPU1 持有而未被释放而一直等待无法继续执行。</li><li>CPU0， CPU1 都因为互相等待对方释放锁而不能继续执行，导致 AB-BA 死锁。</li></ul><p>分析到这里，自然知道死锁风险点和正确使用锁的规则了，按照这个规则去修复代码，避免死锁就可以了。解决办法：</p><ol><li>分析 resume_reason_lock 是否在其他地方中断上下文有使用这把锁。</li><li>如果没有，直接把获取这把锁的地方 wakeup_reason_pm_event+0x54/0x9c 从 spin_lock 改成 spin_lock_irqsave 就可以了。保持嵌套获取锁前后的状态一致。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Operating%20Systems%20-%20Internals%20and%20Design%20Principles%207th.pdf" target="_blank" rel="noopener">《Operating systems : internals and design principles / William Stallings. — 7th ed.》</a></li><li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/locking/lockdep-design.txt" target="_blank" rel="noopener"> 内核文档 lockdep-design.txt</a></li><li><a href="http://www.lenky.info/archives/2013/04/2253" target="_blank" rel="noopener"> 死锁检测模块 lockdep 简介 </a></li><li><a href="http://www.freepatentsonline.com/8145903.html" target="_blank" rel="noopener">Method and system for a kernel lock validator</a></li><li><a href="https://lwn.net/Articles/185666/" target="_blank" rel="noopener">The kernel lock validator</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可靠性 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Tick 和 Tickless</title>
      <link href="/2016/07/20//linux-tick-and-tickless.html/"/>
      <url>/2016/07/20//linux-tick-and-tickless.html/</url>
      
        <content type="html"><![CDATA[<p>Tick，即周期性产生的 timer 中断事件，可用于系统时间管理、进程信息统计、低精度 timer 处理等等。这样就会有一个问题，那就是在系统空闲的时候也还是周期性的产生中断，系统会被周期性的唤醒导致功耗的增加，这对于追求低功耗的嵌入式设备来说是很难接受的。为此，内核开发者提出了动态时钟的概念，即在系统空闲阶段停掉周期性的时钟达到节省功耗的目的。内核可以通过配置项 CONFIG_NO_HZ 及 CONFIG_NO_HZ_IDLE 来打开该功能，这样在系统空闲的时候就可以停掉 tick 一段时间，但并不是完全没有 tick 了，当有除了 idle 进程之外的其它进程运行的时候会恢复 tick 。</p><h2 id="Tick-事件"><a href="#Tick-事件" class="headerlink" title="Tick 事件"></a>Tick 事件</h2><h3 id="clock-event-device"><a href="#clock-event-device" class="headerlink" title="clock_event_device"></a>clock_event_device</h3><p>clock_event_device，代表一个可以产生时钟事件的硬件时钟设备，这样的时钟设备就像单片机的定时器，可以对它编程设置要触发的定时时间，在定时时间到达的时候产生中断，它可以工作在周期模式或者单触发模式。周期模式就是周期性的产生 timer 中断事件，这和 tick 的定义很像。</p><p>clock_event_device 结构定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct clock_event_device &#123;</span><br><span class="line">&#x2F;* 回调函数指针，在硬件时钟设备的中断服务程序中调用 *&#x2F;</span><br><span class="line">void(*event_handler)(struct clock_event_device *);</span><br><span class="line">&#x2F;* 设置下一个定时时间，以 counter 的 cycle 数值为参数 *&#x2F;</span><br><span class="line">int(*set_next_event)(unsigned long evt,</span><br><span class="line">  struct clock_event_device *);</span><br><span class="line">&#x2F;* 设置下一个定时时间，要设置的定时时间是 ktime 格式，要配合 CLOCK_EVT_FEAT_KTIME 标记使用 *&#x2F;</span><br><span class="line">int(*set_next_ktime)(ktime_t expires,</span><br><span class="line">  struct clock_event_device *);</span><br><span class="line">ktime_tnext_event;</span><br><span class="line">u64max_delta_ns;</span><br><span class="line">u64min_delta_ns;</span><br><span class="line">u32mult;</span><br><span class="line">u32shift;</span><br><span class="line">enum clock_event_modemode;</span><br><span class="line">unsigned intfeatures;</span><br><span class="line">unsigned longretries;</span><br><span class="line">void(*broadcast)(const struct cpumask *mask);</span><br><span class="line">void(*set_mode)(enum clock_event_mode mode,</span><br><span class="line">    struct clock_event_device *);</span><br><span class="line">void(*suspend)(struct clock_event_device *);</span><br><span class="line">void(*resume)(struct clock_event_device *);</span><br><span class="line">unsigned longmin_delta_ticks;</span><br><span class="line">unsigned longmax_delta_ticks;</span><br><span class="line">const char*name;</span><br><span class="line">intrating;</span><br><span class="line">intirq;</span><br><span class="line">const struct cpumask*cpumask;</span><br><span class="line">struct list_headlist;</span><br><span class="line">struct module*owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SMP 系统，每个 CPU 都有一个只属于自己的 local timer 用于提供时钟事件服务，在 CPU 启动的时候通过调用 percpu_timer_setup 函数完成初始化工作。以三星 exynos7420 平台为例，percpu_timer_setup 函数最终调用 exynos4_local_timer_setup 函数来初始化每个 CPU 的 local timer ，配置和注册 clock_event_device。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t exynos4_mct_tick_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">struct mct_clock_event_device *mevt &#x3D; dev_id;</span><br><span class="line">struct clock_event_device *evt &#x3D; mevt-&gt;evt;</span><br><span class="line">exynos4_mct_tick_stop(mevt, 0);</span><br><span class="line">&#x2F;* 调用 clock_event_device 的 event_handler *&#x2F;</span><br><span class="line">evt-&gt;event_handler(evt);</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static DEFINE_PER_CPU(struct irqaction, percpu_mct_irq) &#x3D; &#123;</span><br><span class="line">.flags          &#x3D; IRQF_TIMER | IRQF_NOBALANCING,</span><br><span class="line">&#x2F;* 中断处理程序 *&#x2F;</span><br><span class="line">.handler        &#x3D; exynos4_mct_tick_isr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int exynos4_local_timer_setup(struct clock_event_device *evt)</span><br><span class="line">&#123;</span><br><span class="line">struct mct_clock_event_device *mevt;</span><br><span class="line">unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">mevt &#x3D; this_cpu_ptr(&amp;percpu_mct_tick);</span><br><span class="line">mevt-&gt;evt &#x3D; evt;</span><br><span class="line"></span><br><span class="line">mevt-&gt;base &#x3D; EXYNOS4_MCT_L_BASE(cpu);</span><br><span class="line">&#x2F;* 每个 CPU local timer 的名字分别为 mct_tick0, mct_tick1 ... mct_tick7 *&#x2F;</span><br><span class="line">snprintf(mevt-&gt;name, sizeof(mevt-&gt;name), &quot;mct_tick%d&quot;, cpu);</span><br><span class="line"></span><br><span class="line">evt-&gt;name &#x3D; mevt-&gt;name;</span><br><span class="line">evt-&gt;cpumask &#x3D; cpumask_of(cpu);  &#x2F;* 属于哪个 CPU *&#x2F;</span><br><span class="line">&#x2F;* 设置下次触发的时间，即把时间编程到定时器 *&#x2F;</span><br><span class="line">evt-&gt;set_next_event &#x3D; exynos4_tick_set_next_event;</span><br><span class="line">&#x2F;* 设置工作模式，例如周期模式，单触发模式等 *&#x2F;</span><br><span class="line">evt-&gt;set_mode &#x3D; exynos4_tick_set_mode;</span><br><span class="line">&#x2F;* 支持周期模式和单触发模式 *&#x2F;</span><br><span class="line">evt-&gt;features &#x3D; CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;</span><br><span class="line">evt-&gt;rating &#x3D; 450;</span><br><span class="line">tick_base_cnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (!soc_is_exynos5433()) &#123;</span><br><span class="line">tick_base_cnt &#x3D; 1;</span><br><span class="line">exynos4_mct_write(tick_base_cnt, mevt-&gt;base + MCT_L_TCNTB_OFFSET);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* exynos7420 每个 CPU 的 local timer 都是使用的 SPI 类型中断 *&#x2F;</span><br><span class="line">if (mct_int_type &#x3D;&#x3D; MCT_INT_SPI) &#123;</span><br><span class="line">struct irqaction *mct_irq &#x3D; this_cpu_ptr(&amp;percpu_mct_irq);</span><br><span class="line"></span><br><span class="line">mct_irq-&gt;dev_id &#x3D; mevt;</span><br><span class="line">evt-&gt;irq &#x3D; mct_irqs[MCT_L0_IRQ + cpu];</span><br><span class="line">irq_set_affinity(evt-&gt;irq, cpumask_of(cpu));</span><br><span class="line">enable_irq(evt-&gt;irq);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 配置和注册 clock_event_device *&#x2F;</span><br><span class="line">clockevents_config_and_register(evt, clk_rate &#x2F; (tick_base_cnt + 1),</span><br><span class="line">0xf, 0x7fffffff);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exynos7420 平台 local timer 使用的是 SPI 类型的中断，它可以直接唤醒 idle 状态的 CPU，这样就不需要使用 broadcast framework 了。MTK 平台 CPU 的 local timer 一般使用 PPI 中断，它不具有唤醒处于 idle 状态的 CPU 的能力，所以需要一个 global HW timer 作为 broadcast tick，由它来服务每个 CPU，例如将 tick 事件广播到 CPU，唤醒 CPU 等等。</p><h3 id="tick-device"><a href="#tick-device" class="headerlink" title="tick_device"></a>tick_device</h3><p>tick_device，tick 设备，是对 clock_event_device 及其工作模式的封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct tick_device &#123;</span><br><span class="line">struct clock_event_device *evtdev;</span><br><span class="line">enum tick_device_mode mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tick_device_mode 只有两种模式，TICKDEV_MODE_PERIODIC 和 TICKDEV_MODE_ONESHOT，即周期模式和单触发模式。在 clock_event_device 注册的时候，tick_device 通过 tick_check_new_device 和 tick_setup_device 函数绑定一个属于该 CPU 且精度最高的 clock_event_device。这样，tick_device 工作在 TICKDEV_MODE_PERIODIC 模式时可以产生周期性的时钟事件，传统意义上的 tick 就是这么来的。周期模式下，clock_event_device 的 event_handler 被设置为 tick_periodic ，每个 tick 事件到来时 tick_periodic 就会被调用，它会通过 update_process_times 函数进行系统时间的更新、到期 hrtimer 的处理、TIMER_SOFTIRQ 软中断处理、进程信息更新及负载均衡等等。</p><h2 id="模拟-tick-事件"><a href="#模拟-tick-事件" class="headerlink" title="模拟 tick 事件"></a>模拟 tick 事件</h2><h3 id="低分辨率定时器"><a href="#低分辨率定时器" class="headerlink" title="低分辨率定时器"></a>低分辨率定时器</h3><p>低分辨率定时器是基于 HZ 来实现的，精度为 1/HZ，内核 HZ 一般配置为 100，那么低分辨率定时器的精度就是 10ms。对定时器精度要求不高的内核模块还在大量使用低分辨率定时器，例如 CPU DVFS，CPU Hotplug 等。内核通过 time_list  结构体来描述低分辨率定时器。</p><h3 id="高精度定时器"><a href="#高精度定时器" class="headerlink" title="高精度定时器"></a>高精度定时器</h3><p>高精度定时器可以提供纳秒级别的定时精度，以满足对时间精度要求严格的内核模块，例如音频模块，内核通过 hrtimer 结构体来描述高精度定时器。在系统启动的开始阶段，高精度定时器只能工作在低精度周期模式，在条件满足之后的某个阶段就会切换到高精度单触发模式。上面所说的 tick_periodic 函数，最后会调用 hrtimer_run_pending 函数来判断是否可以切换到高精度模式。另外，动态时钟也是在这里判断和切换的。流程如下：</p><p>tick_periodic -&gt; update_process_times -&gt; run_local_timers -&gt; raise_softirq(TIMER_SOFTIRQ) == run_timer_softirq -&gt; hrtimer_run_pending</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer_run_pending(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 如果 hrtimer 已经是高精度模式则返回 *&#x2F;</span><br><span class="line">if (hrtimer_hres_active())</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">if (tick_check_oneshot_change(!hrtimer_is_hres_enabled()))</span><br><span class="line">hrtimer_switch_to_hres();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int tick_init_highres(void)</span><br><span class="line">&#123;</span><br><span class="line">return tick_switch_to_oneshot(hrtimer_interrupt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int hrtimer_switch_to_hres(void)</span><br><span class="line">&#123;</span><br><span class="line">int i, cpu &#x3D; smp_processor_id();</span><br><span class="line">struct hrtimer_cpu_base *base &#x3D; &amp;per_cpu(hrtimer_bases, cpu);</span><br><span class="line">unsigned long flags;</span><br><span class="line">&#x2F;* 如果已经是高精度模式了，则返回 *&#x2F;</span><br><span class="line">if (base-&gt;hres_active)</span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">if (tick_init_highres()) &#123;</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">printk(KERN_WARNING &quot;Could not switch to high resolution &quot;</span><br><span class="line">    &quot;mode on CPU %d\n&quot;, cpu);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 表示工作在高精度模式了 *&#x2F;</span><br><span class="line">base-&gt;hres_active &#x3D; 1;</span><br><span class="line">for (i &#x3D; 0; i &lt; HRTIMER_MAX_CLOCK_BASES; i++)</span><br><span class="line">base-&gt;clock_base[i].resolution &#x3D; KTIME_HIGH_RES;</span><br><span class="line">&#x2F;* 创建一个 hrtimer 来模拟 tick，初始化这个 hrtimer *&#x2F;</span><br><span class="line">tick_setup_sched_timer();</span><br><span class="line">&#x2F;* &quot;Retrigger&quot; the interrupt to get things going *&#x2F;</span><br><span class="line">retrigger_next_event(NULL);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，通过 hrtimer_switch_to_hres 完成低精度周期模式到高精度单触发模式的切换。tick_device 的工作模式变成了 TICKDEV_MODE_ONESHOT，其 clock_event_device 的 event_handler 被替换为 hrtimer_interrupt。至此，tick_device 不能再定期产生 tick 事件了，但是系统还离不开 tick 事件，所以内核通过一个 hrtimer 模拟了 tick，这个是在 tick_setup_sched_timer 函数中完成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void tick_setup_sched_timer(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts &#x3D; &amp;__get_cpu_var(tick_cpu_sched);</span><br><span class="line">ktime_t now &#x3D; ktime_get();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Emulate tick processing via per-CPU hrtimers:</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* 初始化用作模拟 tick 的 hrtimer *&#x2F;</span><br><span class="line">hrtimer_init(&amp;ts-&gt;sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);</span><br><span class="line">&#x2F;* 设置该 hrtimer 的回调函数 *&#x2F;</span><br><span class="line">ts-&gt;sched_timer.function &#x3D; tick_sched_timer;</span><br><span class="line"></span><br><span class="line">&#x2F;* Get the next period (per cpu) *&#x2F;</span><br><span class="line">hrtimer_set_expires(&amp;ts-&gt;sched_timer, tick_init_jiffy_update());</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">     &#x2F;* tick_period 就是一个 tick 周期，HZ 为 100 的话就是 10ms *&#x2F;</span><br><span class="line">hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line"></span><br><span class="line">&#x2F;* 启动 hrtimer，加入 hrtimer 红黑树，如果这个 hrtimer 的到期时间是最近的，*&#x2F;</span><br><span class="line">                &#x2F;* 还会把它编程到硬件时钟设备，即 clock_event_device *&#x2F;</span><br><span class="line">hrtimer_start_expires(&amp;ts-&gt;sched_timer,</span><br><span class="line">      HRTIMER_MODE_ABS_PINNED);</span><br><span class="line"></span><br><span class="line">&#x2F;* Check, if the timer was already in the past *&#x2F;</span><br><span class="line">if (hrtimer_active(&amp;ts-&gt;sched_timer))</span><br><span class="line">break;</span><br><span class="line">now &#x3D; ktime_get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_COMMON</span><br><span class="line">if (tick_nohz_enabled)</span><br><span class="line">&#x2F;* NO_HZ 的工作模式，表明是使用的 hrtimer 实现 NO_HZ *&#x2F;</span><br><span class="line">ts-&gt;nohz_mode &#x3D; NOHZ_MODE_HIGHRES;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，sched_timer 就是模拟 tick 使用的 hrtimer，在其回调函数 tick_sched_timer 中会设置下次触发时间为 tick_period，这样就可以定期产生 tick 事件了。另外，还会通过 tick_sched_handle 函数调用 update_process_times 函数，相信很多人对 u pdate_process_times 很眼熟，前面说的系统时间的更新、到期 hrtimer 的处理、TIMER_SOFTIRQ 软中断处理、进程信息更新及负载均衡等等就是由它完成的。所以说利用 hrtimer 很完美的模拟了 tick 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts &#x3D;</span><br><span class="line">container_of(timer, struct tick_sched, sched_timer);</span><br><span class="line">struct pt_regs *regs &#x3D; get_irq_regs();</span><br><span class="line">ktime_t now &#x3D; ktime_get();</span><br><span class="line"></span><br><span class="line">tick_sched_do_timer(now);   &#x2F;* 更新时间 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Do not call, when we are not in irq context and have</span><br><span class="line"> * no valid regs pointer</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (regs)</span><br><span class="line">&#x2F;* tick_sched_handle 会调用 update_process_times 函数 *&#x2F;</span><br><span class="line">tick_sched_handle(ts, regs);</span><br><span class="line">&#x2F;* 设置下次触发时间为 tick_period *&#x2F;</span><br><span class="line">hrtimer_forward(timer, now, tick_period);</span><br><span class="line"></span><br><span class="line">return HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tickless"><a href="#tickless" class="headerlink" title="tickless"></a>tickless</h2><p>tickless，即上面所说的动态时钟，之所以被称为 tickless，估计是为了更好的和 tick 联系起来。另外，并不是真的没有 tick 了，只是在系统空闲的时候停掉 tick 一段时间。使能了动态时钟之后，周期时钟的开关就由 idle 进程控制，当满足条件时就可以停掉 tick 若干时间，这个流程如下：</p><p>cpu_idle_loop -&gt; tick_nohz_idle_enter -&gt; __tick_nohz_idle_enter -&gt; tick_nohz_stop_sched_tick</p><p>最后，通过 tick_nohz_stop_sched_tick 停止掉若干 tick。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">&#x2F;* 开始进入 NO_HZ idle *&#x2F;</span><br><span class="line">tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">while (!need_resched()) &#123;</span><br><span class="line">check_pgt_cache();</span><br><span class="line">rmb();</span><br><span class="line"></span><br><span class="line">if (cpu_is_offline(smp_processor_id()))</span><br><span class="line">arch_cpu_idle_dead();</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line">arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">if (cpu_idle_force_poll || tick_check_broadcast_expired()) &#123;</span><br><span class="line">cpu_idle_poll();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (!current_clr_polling_and_test()) &#123;</span><br><span class="line">stop_critical_timings();</span><br><span class="line">rcu_idle_enter();</span><br><span class="line">arch_cpu_idle();</span><br><span class="line">WARN_ON_ONCE(irqs_disabled());</span><br><span class="line">rcu_idle_exit();</span><br><span class="line">start_critical_timings();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line">__current_set_polling();</span><br><span class="line">&#125;</span><br><span class="line">arch_cpu_idle_exit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 有其它进程运行，退出 NO_HZ，恢复之前的周期时钟 *&#x2F;</span><br><span class="line">tick_nohz_idle_exit();</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停掉 tick 若干时间，那么这个若干时间是怎么得来的呢？系统此时处于空闲状态只有 idle 进程在运行，还要处理可能产生的中断，但是无法获知除了定时器中断以外的其它中断何时产生，而定时器第一个即将到期的中断时间是可以得到的，在这个时间到期之前都可以停掉 tick，由此得到需要停掉的 tick 数。另外，停掉 tick 的时间不能超过 clock_event_device 的 max_delta_ns，不然可能会造成 clocksource 的溢出。</p><p>回顾一下 tick 事件产生时的工作流程。首先是中断处理函数 exynos4_mct_tick_isr 被运行，它会调用 clock_event_device 的 event_handler，即 hrtimer_interrupt，hrtimer_interrupt 会调用 __run_hrtimer 处理到期的 hrtimer， tick_sched_timer 这个 hrtimer 的回调函数 tick_sched_timer 被调用，tick_sched_timer 会把下次唤醒时间设置为 tick_period，相当于恢复了周期时钟。如果没有别的进程需要运行，恢复周期时钟的做法显然是不合理的，我们需要的是在第一个定时时间到来之前停止若干 tick。 通过前面的内容可以了解到 tick 产生时会触发 TIMER_SOFTIRQ 软中断，所以内核在软中断的 irq_exit 函数中做了些手脚，解决了刚才所说的周期时钟恢复的问题，流程如下：</p><p>irq_exit -&gt; tick_irq_exit -&gt; tick_nohz_irq_exit -&gt; __tick_nohz_idle_enter -&gt; tick_nohz_stop_sched_tick</p><p>看到了熟悉的身影 tick_nohz_stop_sched_tick，通过它又可以停掉若干的 tick。</p><p>tick_irq_exit  函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick_irq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_NO_HZ_COMMON</span><br><span class="line">int cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">&#x2F;* Make sure that timer wheel updates are propagated *&#x2F;</span><br><span class="line">if ((idle_cpu(cpu) &amp;&amp; !need_resched()) || tick_nohz_full_cpu(cpu)) &#123;</span><br><span class="line">if (!in_interrupt())</span><br><span class="line">tick_nohz_irq_exit();</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有别的进程需要运行，<code>need_resched()</code> 就会为 1，就不能进入 tick_nohz_irq_exit 函数，也就无法停掉若干 tick，下次唤醒的时间就还是一个 tick_period。</p><p>没有使能 tickless，tick 周期性产生，如下图所示：</p><p><img src="/images/posts/2016/07/tick.jpg" alt="Tick"></p><p>配置了 tickless，tick 会被停掉若干时间，变得没有规律，如下图所示：</p><p><img src="/images/posts/2016/07/tickless.jpg" alt="Tickless"></p>]]></content>
      
      
      <categories>
          
          <category> 时间管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Thermal 框架解析 </title>
      <link href="/2016/07/16//linux-thermal-framework-intro.html/"/>
      <url>/2016/07/16//linux-thermal-framework-intro.html/</url>
      
        <content type="html"><![CDATA[<p>Linux Thermal 是 Linux 系统下温度控制相关的模块，主要用来控制系统运行过程中芯片产生的热量，使芯片温度和设备外壳温度维持在一个安全、舒适的范围。</p><p>那下面我们就来一起看看对于温度控制这样一个需求，Linux 内核是怎么实现的。</p><h2 id="Thermal-的主要框架"><a href="#Thermal-的主要框架" class="headerlink" title="Thermal 的主要框架"></a>Thermal 的主要框架</h2><p>要实现一个温度控制的需求，试想一下我们是不是最少要有获取温度的设备和控制温度的设备这两个最基本的东西？当然附带的也会产生一些使用温度控制设备的策略。</p><p>那上面这些东西在 Linux Thermal 框架中怎么体现呢？通过阅读源码我们发现代码中对上面的东西进行了一些抽象。</p><ul><li>获取温度的设备：在 Thermal 框架中被抽象为 Thermal Zone Device;</li><li>控制温度的设备：在 Thermal 框架中被抽象为 Thermal Cooling Device;</li><li>控制温度策略：在 Thermal 框架中被抽象为 Thermal Governor;</li></ul><p><img src="/images/posts/2016/07/thermal.png" alt="Thermal 框架 "></p><h2 id="Thermal-Zone-Device"><a href="#Thermal-Zone-Device" class="headerlink" title="Thermal Zone Device"></a>Thermal Zone Device</h2><p>上面说到 Thermal Zone Device 是获取温度设备的抽象，怎么抽象的？终究我们还是要 RTFSC。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">struct thermal_zone_device &#123;</span><br><span class="line">        int id;</span><br><span class="line">        char type[THERMAL_NAME_LENGTH];</span><br><span class="line">        struct device device;</span><br><span class="line">        struct thermal_attr *trip_temp_attrs;</span><br><span class="line">        struct thermal_attr *trip_type_attrs;</span><br><span class="line">        struct thermal_attr *trip_hyst_attrs;</span><br><span class="line">        void *devdata;</span><br><span class="line">        int trips;</span><br><span class="line">&#x2F;* 轮询时间 *&#x2F;</span><br><span class="line">        int passive_delay;</span><br><span class="line">        int polling_delay;</span><br><span class="line">        int temperature;</span><br><span class="line">        int last_temperature;</span><br><span class="line">        int emul_temperature;</span><br><span class="line">        int passive;</span><br><span class="line">        unsigned int forced_passive;</span><br><span class="line">&#x2F;* 设备的操作函数 *&#x2F;</span><br><span class="line">        struct thermal_zone_device_ops *ops;</span><br><span class="line">        const struct thermal_zone_params *tzp;</span><br><span class="line">        struct thermal_governor *governor;</span><br><span class="line">        struct list_head thermal_instances;</span><br><span class="line">        struct idr idr;</span><br><span class="line">        struct mutex lock;</span><br><span class="line">        struct list_head node;</span><br><span class="line">&#x2F;* 用来循环处理的 delayed_work *&#x2F;</span><br><span class="line">        struct delayed_work poll_queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct thermal_zone_device_ops &#123;</span><br><span class="line">&#x2F;* 绑定函数 *&#x2F;</span><br><span class="line">        int (*bind) (struct thermal_zone_device *,</span><br><span class="line">                     struct thermal_cooling_device *);</span><br><span class="line">        int (*unbind) (struct thermal_zone_device *,</span><br><span class="line">                       struct thermal_cooling_device *);</span><br><span class="line">&#x2F;* 获取温度函数 *&#x2F;</span><br><span class="line">        int (*get_temp) (struct thermal_zone_device *, unsigned long *);</span><br><span class="line">        int (*get_mode) (struct thermal_zone_device *,</span><br><span class="line">                         enum thermal_device_mode *);</span><br><span class="line">        int (*set_mode) (struct thermal_zone_device *,</span><br><span class="line">                enum thermal_device_mode);</span><br><span class="line">        int (*get_trip_type) (struct thermal_zone_device *, int,</span><br><span class="line">                enum thermal_trip_type *);</span><br><span class="line">&#x2F;* 获取触发点温度 *&#x2F;</span><br><span class="line">        int (*get_trip_temp) (struct thermal_zone_device *, int,</span><br><span class="line">                              unsigned long *);</span><br><span class="line">        int (*set_trip_temp) (struct thermal_zone_device *, int,</span><br><span class="line">                              unsigned long);</span><br><span class="line">        int (*get_trip_hyst) (struct thermal_zone_device *, int,</span><br><span class="line">                              unsigned long *);</span><br><span class="line">        int (*set_trip_hyst) (struct thermal_zone_device *, int,</span><br><span class="line">                              unsigned long);</span><br><span class="line">        int (*get_crit_temp) (struct thermal_zone_device *, unsigned long *);</span><br><span class="line">        int (*set_emul_temp) (struct thermal_zone_device *, unsigned long);</span><br><span class="line">        int (*get_trend) (struct thermal_zone_device *, int,</span><br><span class="line">                          enum thermal_trend *);</span><br><span class="line">        int (*notify) (struct thermal_zone_device *, int,</span><br><span class="line">                       enum thermal_trip_type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过代码我们可以看到，一个能提供温度的设备操作函数主要有 : 绑定函数、获取温度函数、获取触发点温度函数。</p><p>绑定函数 : Thermal core 用来绑定用的 , 这个后面会讲 ;</p><p>获取温度函数 : 获取设备温度用的，这个也好理解 , 一般 SOC 内部会有温度传感器提供温度，有些热敏电阻通过 ADC 也算出温度，这个函数就是取这些温度值 ;</p><p>获取触发点温度函数 : 这个是什么用来做什么呢 ?　这个其实是 thermal 框架里面一个关键点，因为要控制温度，那么什么时候控制就需要有东西来描述，</p><p>描述什么时候控制的东西就是触发点，每个 thermal zone device 会定义很多触发点，那么每个触发点的温度就是通过该函数获得；</p><h2 id="Thermal-Cooling-Devices"><a href="#Thermal-Cooling-Devices" class="headerlink" title="Thermal Cooling Devices"></a>Thermal Cooling Devices</h2><p>Thermal Cooling Device 是可以降温设备的抽象，能降温的设备比如风扇，这些好理解，但是想 CPU,GPU 这些 Cooling devices 怎么理解呢？</p><p>其实降温可以从两方面来理解，一个是加快散热，另外一个就是降低产热量。风扇，散热片这些是用来加快散热，CPU,GPU 这些 Cooling devices 是通过降低产热来降温。</p><p>那代码是怎么将这两个方式统一起来呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct thermal_cooling_device &#123;</span><br><span class="line">int id;</span><br><span class="line">        char type[THERMAL_NAME_LENGTH];</span><br><span class="line">        struct device device;</span><br><span class="line">        struct device_node *np;</span><br><span class="line">        void *devdata;</span><br><span class="line">&#x2F;* cooling device 操作函数 *&#x2F;</span><br><span class="line">        const struct thermal_cooling_device_ops *ops;</span><br><span class="line">        bool updated; &#x2F;* true if the cooling device does not need update *&#x2F;</span><br><span class="line">        struct mutex lock; &#x2F;* protect thermal_instances list *&#x2F;</span><br><span class="line">        struct list_head thermal_instances;</span><br><span class="line">        struct list_head node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct thermal_cooling_device_ops &#123;</span><br><span class="line">        int (*get_max_state) (struct thermal_cooling_device *, unsigned long *);</span><br><span class="line">        int (*get_cur_state) (struct thermal_cooling_device *, unsigned long *);</span><br><span class="line">&#x2F;* 设定等级 *&#x2F;</span><br><span class="line">        int (*set_cur_state) (struct thermal_cooling_device *, unsigned long);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Thermal Cooling device 抽象的方式是，认为所有的能降温的设备有很多可以单独控制的状态。例如，风扇有不同的风速状态，</p><p>CPU/GPU Cooling device 有不同最大运行频率状态，这样当温度高了之后通过调整这些状态来降低温度；</p><h2 id="Thermal-Governor"><a href="#Thermal-Governor" class="headerlink" title="Thermal Governor"></a>Thermal Governor</h2><p>Thermal Governor 是降温策略的一个抽象 , 主要是根据温度来选择 thermal cooling devices 等级的方法，举个简单的例子，当前的温度升高速很快，选择风扇３档风，温度升高不快，选择１档风。这就是一个 Governor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct thermal_governor - structure that holds thermal governor information</span><br><span class="line"> * @name:       name of the governor</span><br><span class="line"> * @throttle:   callback called for every trip point even if temperature is</span><br><span class="line"> *              below the trip point temperature</span><br><span class="line"> * @governor_list:      node in thermal_governor_list (in thermal_core.c)</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct thermal_governor &#123;</span><br><span class="line">        char name[THERMAL_NAME_LENGTH];</span><br><span class="line">&#x2F;* 策略函数 *&#x2F;</span><br><span class="line">        int (*throttle)(struct thermal_zone_device *tz, int trip);</span><br><span class="line">        struct list_head        governor_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很简单，所有的策略都通过 throttle 这个函数实现，内核已经实现了一些策略，step_wise, user_space, power_allocator, bang_bang 等具体实现算法细节就不展开；</p><h2 id="Thermal-Core"><a href="#Thermal-Core" class="headerlink" title="Thermal Core"></a>Thermal Core</h2><p>有了获取温度的设备，有了温控控制的设备，有了控制方法，Thermal Core 就负责把这些整合在一起。下面看一下整合的简单流程。</p><p>１．注册函数 ,thermal Core 通过对外提供注册的接口，让 thermal zone device、thermal cooling device、thermal governor 注册进来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct thermal_zone_device *thermal_zone_device_register(const char *, int, int,</span><br><span class="line">                void *, struct thermal_zone_device_ops *,</span><br><span class="line">                const struct thermal_zone_params *, int, int);</span><br><span class="line"></span><br><span class="line">struct thermal_cooling_device *thermal_cooling_device_register(char *, void *,</span><br><span class="line">                const struct thermal_cooling_device_ops *);</span><br><span class="line"></span><br><span class="line">int thermal_register_governor(struct thermal_governor *);</span><br></pre></td></tr></table></figure><p>２．Thermal zone/cooling device 注册的过程中 thermal core 会调用绑定函数，绑定的过程最主要是一个 cooling device 绑定到一个 thremal_zone 的触发点上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int thermal_zone_bind_cooling_device(struct thermal_zone_device *tz)</span><br><span class="line">&#123;</span><br><span class="line">        struct thermal_instance *dev;</span><br><span class="line">        struct thermal_instance *pos;</span><br><span class="line">        struct thermal_zone_device *pos1;</span><br><span class="line">        struct thermal_cooling_device *pos2;</span><br><span class="line">        unsigned long max_state;</span><br><span class="line">        int result;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* thermal_instace 就是绑定之后的实例 *&#x2F;</span><br><span class="line">        dev &#x3D;</span><br><span class="line">            kzalloc(sizeof(struct thermal_instance), GFP_KERNEL);</span><br><span class="line">        if (!dev)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line">        dev-&gt;tz &#x3D; tz;</span><br><span class="line">        dev-&gt;cdev &#x3D; cdev;</span><br><span class="line">        dev-&gt;trip &#x3D; trip;</span><br><span class="line">    dev-&gt;upper &#x3D; upper;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            sysfs_create_link(&amp;tz-&gt;device.kobj, &amp;cdev-&gt;device.kobj, dev-&gt;name);</span><br><span class="line">        if (result)</span><br><span class="line">                goto release_idr;</span><br><span class="line"></span><br><span class="line">        sprintf(dev-&gt;attr_name, &quot;cdev%d_trip_point&quot;, dev-&gt;id);</span><br><span class="line">        sysfs_attr_init(&amp;dev-&gt;attr.attr);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        list_for_each_entry(pos, &amp;tz-&gt;thermal_instances, tz_node)</span><br><span class="line">            if (pos-&gt;tz &#x3D;&#x3D; tz &amp;&amp; pos-&gt;trip &#x3D;&#x3D; trip &amp;&amp; pos-&gt;cdev &#x3D;&#x3D; cdev) &#123;</span><br><span class="line">                result &#x3D; -EEXIST;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!result) &#123;</span><br><span class="line">&#x2F;* 绑定完了就添加到链表中 *&#x2F;</span><br><span class="line">                list_add_tail(&amp;dev-&gt;tz_node, &amp;tz-&gt;thermal_instances);</span><br><span class="line">                list_add_tail(&amp;dev-&gt;cdev_node, &amp;cdev-&gt;thermal_instances);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>３．Thermal core 使能 delayed_work 循环处理 , 使整个 thermal 控制流程运转起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void thermal_zone_device_check(struct work_struct *wrok)</span><br><span class="line">&#123;</span><br><span class="line">        struct thermal_zone_device *tz &#x3D; container_of(work, struct</span><br><span class="line">                                                      thermal_zone_device,</span><br><span class="line">                                                      poll_queue.work);</span><br><span class="line">&#x2F;* 处理函数 *&#x2F;</span><br><span class="line">        thermal_zone_device_update(tz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thermal_zone_device_update(struct thermal_zone_device *tz)</span><br><span class="line">&#123;</span><br><span class="line">        int count;</span><br><span class="line">        if (!tz-&gt;ops-&gt;get_temp)</span><br><span class="line">                return;</span><br><span class="line">&#x2F;* 更新温度 *&#x2F;</span><br><span class="line">        update_temperature(tz);-</span><br><span class="line">        for (count &#x3D; 0; count &lt; tz-&gt;trips; count++)</span><br><span class="line">&#x2F;* 处理触发点，这里面就会调到具体的 governor *&#x2F;</span><br><span class="line">                handle_thermal_trip(tz, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void thermal_zone_device_set_polling(struct thermal_zone_device *tz, int delay)</span><br><span class="line">&#123;</span><br><span class="line">        if (delay &gt; 1000)</span><br><span class="line">&#x2F;* 更改 delayed_work 下次唤醒时间完成轮询 *&#x2F;</span><br><span class="line">                mod_delayed_work(system_freezable_wq, &amp;tz-&gt;poll_queue,</span><br><span class="line">                                 round_jiffies(msecs_to_jiffies(delay)));</span><br><span class="line">        else if (delay)</span><br><span class="line">                mod_delayed_work(system_freezable_wq, &amp;tz-&gt;poll_queue,</span><br><span class="line">                                 msecs_to_jiffies(delay));</span><br><span class="line">        else</span><br><span class="line">                cancel_delayed_work(&amp;tz-&gt;poll_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/posts/2016/07/thermal_control_flow.png" alt="Thermal 控制流程 "></p><p>当温度升高超过温度触发点的话，就会使能对应的 cooling device 进行降温处理，至此 Linux Thermal 相关的一些基本框架就介绍完了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://lxr.free-electrons.com/source/drivers/thermal/" target="_blank" rel="noopener">Thermal 内核源码 </a></p>]]></content>
      
      
      <categories>
          
          <category> 性能与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thermal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程中 Stop, Park, Freeze</title>
      <link href="/2016/07/11//linux-process-stop.html/"/>
      <url>/2016/07/11//linux-process-stop.html/</url>
      
        <content type="html"><![CDATA[<p>在调试内核的时候，经常会碰到几个相近的概念：进程 stop、进程 park、进程 freeze。这几个名词看起来都是停止进程，那么他们之间的区别和应用场景在分别是什么呢？下面就来分析一番。</p><blockquote><p>本文的代码分析基于 Linux kernel 3.18.22，最好的学习方法还是 “RTFSC”</p></blockquote><h2 id="1-进程-stop"><a href="#1-进程-stop" class="headerlink" title="1. 进程 stop"></a>1. 进程 stop</h2><p>进程 stop 分成两种：用户进程 stop 和内核进程 stop。</p><p>用户进程 stop 可以通过给进程发送 STOP 信号来实现，可以参考“Linux Signal”这一篇的描述。但是对内核进程来说不会响应信号，如果碰到需要 stop 内核进程的场景怎么处理？比如：我们在设备打开的时候创建了内核处理进程，在设备关闭的时候需要 stop 内核进程。</p><p>Linux 实现了一套 <code>kthread_stop()</code> 的机制来实现内核进程 stop。</p><h3 id="1-1-内核进程的创建"><a href="#1-1-内核进程的创建" class="headerlink" title="1.1 内核进程的创建"></a>1.1 内核进程的创建</h3><p>内核进程创建过程，是理解本篇的基础。</p><p>可以看到 <code>kthread_create()</code> 并不是自己去创建内核进程，而是把创建任务推送给 <code>kthreadd()</code> 进程执行。</p><p><code>kthreadd()</code> -&gt; <code>create_kthread()</code> -&gt; <code>kernel_thread()</code> 创建的新进程也不是直接使用用户的函数 <code>threadfn()</code>，而是创建通用函数 <code>kthread()</code>，<code>kthread()</code> 再来调用 <code>threadfn()</code>。</p><ul><li>kernel/kthread.c:</li></ul><p><img src="/images/posts/2016/07/stop_kthread_create.png" alt="kthread_create"></p><h3 id="1-2-内核进程的-stop"><a href="#1-2-内核进程的-stop" class="headerlink" title="1.2 内核进程的 stop"></a>1.2 内核进程的 stop</h3><p>如果内核进程需要支持 <code>kthread_stop()</code>，需要根据以下框架来写代码。用户在主循环中调用 <code>kthread_should_stop()</code> 来判断当前 kthread 是否需要 stop，如果被 stop 则退出循环。</p><p>这种代码为什么不做到通用代码 <code>kthread()</code> 中？这应该是和 Linux 的设计思想相关的。Linux 运行内核态的策略比较灵活，而对用户态的策略更加严格统一。</p><p><img src="/images/posts/2016/07/stop_kthread_should_stop.png" alt="kthread_should_stop"></p><p><code>kthread_should_stop()</code> 和 <code>kthread_stop()</code> 的代码实现：</p><ul><li>kernel/kthread.c:</li><li><code>kthread_should_stop()</code>/<code>kthread_stop()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kthread_should_stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (1) 判断进程所在 kthread 结构中的 KTHREAD_SHOULD_STOP 是否被置位</span></span><br><span class="line"><span class="keyword">return</span> test_bit(KTHREAD_SHOULD_STOP, &amp;to_kthread(current)-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">trace_sched_kthread_stop(k);</span><br><span class="line"></span><br><span class="line">get_task_struct(k);</span><br><span class="line">kthread = to_live_kthread(k);</span><br><span class="line"><span class="keyword">if</span> (kthread) &#123;</span><br><span class="line"><span class="comment">// (2) 置位进程所在 kthread 结构中的 KTHREAD_SHOULD_STOP</span></span><br><span class="line">set_bit(KTHREAD_SHOULD_STOP, &amp;kthread-&gt;flags);</span><br><span class="line"><span class="comment">// (3) unpark &amp; wake_up 进程来响应 stop 信号</span></span><br><span class="line">__kthread_unpark(k, kthread);</span><br><span class="line">wake_up_process(k);</span><br><span class="line">wait_for_completion(&amp;kthread-&gt;exited);</span><br><span class="line">&#125;</span><br><span class="line">ret = k-&gt;exit_code;</span><br><span class="line">put_task_struct(k);</span><br><span class="line"></span><br><span class="line">trace_sched_kthread_stop_ret(ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-进程-park"><a href="#2-进程-park" class="headerlink" title="2. 进程 park"></a>2. 进程 park</h2><p><code>smpboot_register_percpu_thread()</code> 用来创建 per_cpu 内核进程，所谓的 per_cpu 进程是指需要在每个 online cpu 上创建线程。比如执行 <code>stop_machine()</code> 中 cpu 同步操作的 migration 进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shell@:&#x2F; $ ps | grep migration</span><br><span class="line">root      10    2     0      0     smpboot_th 0000000000 S migration&#x2F;0</span><br><span class="line">root      11    2     0      0     smpboot_th 0000000000 S migration&#x2F;1</span><br><span class="line">root      15    2     0      0     __kthread_ 0000000000 R migration&#x2F;2</span><br><span class="line">root      19    2     0      0     __kthread_ 0000000000 R migration&#x2F;3</span><br><span class="line">root      207   2     0      0     __kthread_ 0000000000 R migration&#x2F;8</span><br><span class="line">root      247   2     0      0     __kthread_ 0000000000 R migration&#x2F;4</span><br><span class="line">root      251   2     0      0     __kthread_ 0000000000 R migration&#x2F;5</span><br><span class="line">root      265   2     0      0     __kthread_ 0000000000 R migration&#x2F;6</span><br><span class="line">root      356   2     0      0     __kthread_ 0000000000 R migration&#x2F;7</span><br><span class="line">root      2165  2     0      0     __kthread_ 0000000000 R migration&#x2F;9</span><br></pre></td></tr></table></figure><p>问题来了，既然 per_cpu 进程是和 cpu 绑定的，那么在 cpu hotplug 的时候，进程需要相应的 disable 和 enable。实现的方法可以有多种：</p><ul><li>动态的销毁和创建线程。缺点是开销比较大。</li><li>设置进程的 cpu 亲和力 <code>set_cpus_allowed_ptr()</code>。缺点是进程绑定的 cpu 如果被 down 掉，进程会迁移到其他 cpu 继续执行。</li></ul><p>为了克服上述方案的缺点，适配 per_cpu 进程的 cpu hotplug 操作，设计了 <code>kthread_park()</code>/<code>kthread_unpark()</code> 机制。</p><h3 id="2-1-smpboot-register-percpu-thread"><a href="#2-1-smpboot-register-percpu-thread" class="headerlink" title="2.1 smpboot_register_percpu_thread()"></a>2.1 <code>smpboot_register_percpu_thread()</code></h3><p>per_cpu 进程从代码上看，实际也是调用 <code>kthread_create()</code> 来创建的。</p><ul><li>kernel/smpboot.c:</li><li>kernel/kthread.c:</li></ul><p><img src="/images/posts/2016/07/stop_smpboot_register.png" alt="smpboot_register_percpu_thread"></p><p>我们可以看到 smpboot_register 又增加了一层封装：<code>kthread()</code> -&gt; <code>smpboot_thread_fn()</code> -&gt; <code>ht-&gt;thread_fn()</code>，这种封装的使用可以参考 cpu_stop_threads。</p><ul><li>kernel/stop_machine.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">cpu_stop_threads</span> = &#123;</span></span><br><span class="line">.store= &amp;cpu_stopper_task,</span><br><span class="line">.thread_should_run= cpu_stop_should_run,</span><br><span class="line">.thread_fn= cpu_stopper_thread,</span><br><span class="line">.thread_comm= <span class="string">"migration/%u"</span>,</span><br><span class="line">.create= cpu_stop_create,</span><br><span class="line">.setup= cpu_stop_unpark,</span><br><span class="line">.park= cpu_stop_park,</span><br><span class="line">.pre_unpark= cpu_stop_unpark,</span><br><span class="line">.selfparking= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">cpu_stop_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_stopper</span> *<span class="title">stopper</span> = &amp;<span class="title">per_cpu</span>(<span class="title">cpu_stopper</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;stopper-&gt;lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;stopper-&gt;works);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUG_ON(smpboot_register_percpu_thread(&amp;cpu_stop_threads));</span><br><span class="line">stop_machine_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>smpboot_thread_fn()</code> 循环中实现了对 park 的支持，具体实现 <code>kthread_should_park()</code>、<code>kthread_parkme()</code>、<code>kthread_park()</code>、<code>kthread_unpark()</code> 的代码分析：</p><ul><li>kernel/kthread.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kthread_should_park</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (1) 判断进程所在 kthread 结构中的 KTHREAD_SHOULD_PARK 是否被置位</span></span><br><span class="line"><span class="keyword">return</span> test_bit(KTHREAD_SHOULD_PARK, &amp;to_kthread(current)-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kthread_parkme</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__kthread_parkme(to_kthread(current));</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kthread_parkme(struct kthread *self)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (2) 如果当前进程的 KTHREAD_SHOULD_PARK 标志被置位 ,</span></span><br><span class="line"><span class="comment">// 将当前进程进入 TASK_PARKED 的阻塞状态。</span></span><br><span class="line"><span class="comment">// 如果 KTHREAD_SHOULD_PARK 不清除，</span></span><br><span class="line"><span class="comment">// 就算被 wake_up 唤醒还是会循环进入 TASK_PARKED 的阻塞状态。</span></span><br><span class="line">__set_current_state(TASK_PARKED);</span><br><span class="line"><span class="keyword">while</span> (test_bit(KTHREAD_SHOULD_PARK, &amp;self-&gt;flags)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(KTHREAD_IS_PARKED, &amp;self-&gt;flags))</span><br><span class="line">complete(&amp;self-&gt;parked);</span><br><span class="line">schedule();</span><br><span class="line">__set_current_state(TASK_PARKED);</span><br><span class="line">&#125;</span><br><span class="line">clear_bit(KTHREAD_IS_PARKED, &amp;self-&gt;flags);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_park</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span> = <span class="title">to_live_kthread</span>(<span class="title">k</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kthread) &#123;</span><br><span class="line"><span class="comment">// (3) 设置 KTHREAD_IS_PARKED 标志位，并且唤醒进程进入 park 状态</span></span><br><span class="line"><span class="keyword">if</span> (!test_bit(KTHREAD_IS_PARKED, &amp;kthread-&gt;flags)) &#123;</span><br><span class="line">set_bit(KTHREAD_SHOULD_PARK, &amp;kthread-&gt;flags);</span><br><span class="line"><span class="keyword">if</span> (k != current) &#123;</span><br><span class="line">wake_up_process(k);</span><br><span class="line">wait_for_completion(&amp;kthread-&gt;parked);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kthread_unpark</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span> = <span class="title">to_live_kthread</span>(<span class="title">k</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kthread)</span><br><span class="line">__kthread_unpark(k, kthread);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kthread_unpark(struct task_struct *k, struct kthread *kthread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (4) 清除 KTHREAD_IS_PARKED 标志位</span></span><br><span class="line">clear_bit(KTHREAD_SHOULD_PARK, &amp;kthread-&gt;flags);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We clear the IS_PARKED bit here as we don't wait</span></span><br><span class="line"><span class="comment"> * until the task has left the park code. So if we'd</span></span><br><span class="line"><span class="comment"> * park before that happens we'd see the IS_PARKED bit</span></span><br><span class="line"><span class="comment"> * which might be about to be cleared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果进程已经被 park，并且 wake_up 唤醒进程</span></span><br><span class="line"><span class="keyword">if</span> (test_and_clear_bit(KTHREAD_IS_PARKED, &amp;kthread-&gt;flags)) &#123;</span><br><span class="line"><span class="comment">// 如果是 per_cpu 进程，重新绑定进程 cpu</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(KTHREAD_IS_PER_CPU, &amp;kthread-&gt;flags))</span><br><span class="line">__kthread_bind(k, kthread-&gt;cpu, TASK_PARKED);</span><br><span class="line">wake_up_state(k, TASK_PARKED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-cpu-hotplug-支持"><a href="#2-2-cpu-hotplug-支持" class="headerlink" title="2.2 cpu hotplug 支持"></a>2.2 cpu hotplug 支持</h3><p>我们前面说到 park 机制的主要目的是为了 per_cpu 进程支持 cpu hotplug，具体怎么响应热插拔事件呢？</p><ul><li>kernel/smpboot.c:</li></ul><p><img src="/images/posts/2016/07/stop_park_hotplug.png" alt="park_hotplug"></p><h2 id="3-进程-freeze"><a href="#3-进程-freeze" class="headerlink" title="3. 进程 freeze"></a>3. 进程 freeze</h2><p>在系统进入 suspend 的时候，会尝试冻住一些进程，以避免一些进程无关操作影响系统的 suspend 状态。主要的流程如下：</p><ul><li>kernel/power/suspend.c:</li></ul><p><img src="/images/posts/2016/07/stop_pm_suspend.png" alt="suspend_freeze_processes"></p><p>这 suspend_freeze 里面判断当前在那个阶段，有 3 个重要的变量：</p><ul><li>system_freezing_cnt - &gt;0 表示系统全局的 freeze 开始；</li><li>pm_freezing - =true 表示用户进程 freeze 开始；</li><li>pm_nosig_freezing - =true 表示内核进程 freeze 开始；</li></ul><p>具体代码分析如下：</p><ul><li>kernel/power/process.c:</li><li>kernel/freezer.c:</li><li><code>suspend_freeze_processes()</code> -&gt; <code>freeze_processes()</code> -&gt; <code>try_to_freeze_tasks()</code> -&gt; <code>freeze_task()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeze_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">int</span> oom_kills_saved;</span><br><span class="line"></span><br><span class="line">error = __usermodehelper_disable(UMH_FREEZING);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 置位 PF_SUSPEND_TASK，确保当前进程不会被 freeze</span></span><br><span class="line"><span class="comment">/* Make sure this task doesn't get frozen */</span></span><br><span class="line">current-&gt;flags |= PF_SUSPEND_TASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 使用全局 freeze 标志 system_freezing_cnt</span></span><br><span class="line"><span class="keyword">if</span> (!pm_freezing)</span><br><span class="line">atomic_inc(&amp;system_freezing_cnt);</span><br><span class="line"></span><br><span class="line">pm_wakeup_clear();</span><br><span class="line">printk(<span class="string">"Freezing user space processes ... "</span>);</span><br><span class="line"><span class="comment">// (3) 使用用户进程 freeze 标志 pm_freezing</span></span><br><span class="line">pm_freezing = <span class="literal">true</span>;</span><br><span class="line">oom_kills_saved = oom_kills_count();</span><br><span class="line"><span class="comment">// (4) freeze user_only 进程</span></span><br><span class="line"><span class="comment">// 判断进程是否可以被 freeze，唤醒进程 freeze 自己</span></span><br><span class="line">error = try_to_freeze_tasks(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">__usermodehelper_set_disable_depth(UMH_DISABLED);</span><br><span class="line">oom_killer_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There might have been an OOM kill while we were</span></span><br><span class="line"><span class="comment"> * freezing tasks and the killed task might be still</span></span><br><span class="line"><span class="comment"> * on the way out so we have to double check for race.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (oom_kills_count() != oom_kills_saved &amp;&amp;</span><br><span class="line">    !check_frozen_processes()) &#123;</span><br><span class="line">__usermodehelper_set_disable_depth(UMH_ENABLED);</span><br><span class="line">printk(<span class="string">"OOM in progress."</span>);</span><br><span class="line">error = -EBUSY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">"done."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line">BUG_ON(in_atomic());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">thaw_processes();</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_freeze_tasks</span><span class="params">(<span class="keyword">bool</span> user_only)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_time;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> todo;</span><br><span class="line"><span class="keyword">bool</span> wq_busy = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">u64 elapsed_msecs64;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> elapsed_msecs;</span><br><span class="line"><span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> sleep_usecs = USEC_PER_MSEC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line"><span class="keyword">char</span> suspend_abort[MAX_SUSPEND_ABORT_LEN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">do_gettimeofday(&amp;start);</span><br><span class="line"></span><br><span class="line">end_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.1) 如果是 kernel freeze，</span></span><br><span class="line"><span class="comment">// 停工有 WQ_FREEZABLE 标志的 workqueue</span></span><br><span class="line"><span class="comment">// 将 wq 的 pwq-&gt;max_active 设置成 0，新的 work 不能被执行</span></span><br><span class="line"><span class="keyword">if</span> (!user_only)</span><br><span class="line">freeze_workqueues_begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">todo = <span class="number">0</span>;</span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line"><span class="comment">// (4.2) 对每个进程执行 freeze_task()</span></span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p == current || !freeze_task(p))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!freezer_should_skip(p))</span><br><span class="line">todo++;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.3) 如果是 kernel freeze，</span></span><br><span class="line"><span class="comment">// 判断停工的 workqueue 中残留的 work 有没有执行完</span></span><br><span class="line"><span class="keyword">if</span> (!user_only) &#123;</span><br><span class="line">wq_busy = freeze_workqueues_busy();</span><br><span class="line">todo += wq_busy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!todo || time_after(jiffies, end_time))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pm_wakeup_pending()) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">pm_get_active_wakeup_sources(suspend_abort,</span><br><span class="line">MAX_SUSPEND_ABORT_LEN);</span><br><span class="line">log_suspend_abort_reason(suspend_abort);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">wakeup = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to retry, but first give the freezing tasks some</span></span><br><span class="line"><span class="comment"> * time to enter the refrigerator.  Start with an initial</span></span><br><span class="line"><span class="comment"> * 1 ms sleep followed by exponential backoff until 8 ms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">usleep_range(sleep_usecs / <span class="number">2</span>, sleep_usecs);</span><br><span class="line"><span class="keyword">if</span> (sleep_usecs &lt; <span class="number">8</span> * USEC_PER_MSEC)</span><br><span class="line">sleep_usecs *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_gettimeofday(&amp;end);</span><br><span class="line">elapsed_msecs64 = timeval_to_ns(&amp;end) - timeval_to_ns(&amp;start);</span><br><span class="line">do_div(elapsed_msecs64, NSEC_PER_MSEC);</span><br><span class="line">elapsed_msecs = elapsed_msecs64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wakeup) &#123;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line">printk(KERN_ERR <span class="string">"Freezing of tasks aborted after %d.%03d seconds"</span>,</span><br><span class="line">       elapsed_msecs / <span class="number">1000</span>, elapsed_msecs % <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (todo) &#123;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line">printk(KERN_ERR <span class="string">"Freezing of tasks failed after %d.%03d seconds"</span></span><br><span class="line">       <span class="string">" (%d tasks refusing to freeze, wq_busy=%d):\n"</span>,</span><br><span class="line">       elapsed_msecs / <span class="number">1000</span>, elapsed_msecs % <span class="number">1000</span>,</span><br><span class="line">       todo - wq_busy, wq_busy);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p != current &amp;&amp; !freezer_should_skip(p)</span><br><span class="line">    &amp;&amp; freezing(p) &amp;&amp; !frozen(p))</span><br><span class="line">sched_show_task(p);</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">"(elapsed %d.%03d seconds) "</span>, elapsed_msecs / <span class="number">1000</span>,</span><br><span class="line">elapsed_msecs % <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> todo ? -EBUSY : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freeze_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This check can race with freezer_do_not_count, but worst case that</span></span><br><span class="line"><span class="comment"> * will result in an extra wakeup being sent to the task.  It does not</span></span><br><span class="line"><span class="comment"> * race with freezer_count(), the barriers in freezer_count() and</span></span><br><span class="line"><span class="comment"> * freezer_should_skip() ensure that either freezer_count() sees</span></span><br><span class="line"><span class="comment"> * freezing == true in try_to_freeze() and freezes, or</span></span><br><span class="line"><span class="comment"> * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task</span></span><br><span class="line"><span class="comment"> * normally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (freezer_should_skip(p))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;freezer_lock, flags);</span><br><span class="line"><span class="comment">// (4.2.1) 检查当前进程是否可以被 freeze，</span></span><br><span class="line"><span class="comment">// 或者是否已经被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (!freezing(p) || frozen(p)) &#123;</span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.2.2) 如果是用户进程，伪造一个 signal 发送给进程</span></span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">fake_signal_wake_up(p);</span><br><span class="line"><span class="comment">// (4.2.3) 如果是内核进程，wake_up 内核进程</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">wake_up_state(p, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">freezing</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; 具体代码分析如下：</span><br><span class="line"></span><br><span class="line">- kernel/power/process.c:</span><br><span class="line">- kernel/freezer.c:</span><br><span class="line"><span class="comment">// 如果 system_freezing_cnt 为 0，说明全局 freeze 还没有开始</span></span><br><span class="line"><span class="keyword">if</span> (likely(!atomic_read(&amp;system_freezing_cnt)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> freezing_slow_path(p);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freezing_slow_path</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (PF_NOFREEZE | PF_SUSPEND_TASK) 当前进程不能被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; (PF_NOFREEZE | PF_SUSPEND_TASK))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_thread_flag(TIF_MEMDIE))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 pm_nosig_freezing 为 true，内核进程 freeze 已经开始，</span></span><br><span class="line"><span class="comment">// 当前进程可以被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (pm_nosig_freezing || cgroup_freezing(p))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 pm_freezing 为 true，且当前进程为用户进程</span></span><br><span class="line"><span class="comment">// 当前进程可以被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (pm_freezing &amp;&amp; !(p-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-用户进程-freeze"><a href="#3-1-用户进程-freeze" class="headerlink" title="3.1 用户进程 freeze"></a>3.1 用户进程 freeze</h3><p>freeze 用户态的进程利用了 signal 机制，系统 suspend 使能了 suspend 以后，调用 <code>fake_signal_wake_up()</code> 伪造一个信号唤醒进程，进程在 <code>ret_to_user()</code> -&gt; <code>do_notify_resume()</code> -&gt; <code>do_signal()</code> -&gt; <code>get_signal()</code> -&gt; <code>try_to_freeze()</code> 中 freeze 自己。</p><p>具体代码分析如下：</p><ul><li>kernel/freezer.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_NOFREEZE))</span><br><span class="line">debug_check_no_locks_held();</span><br><span class="line"><span class="keyword">return</span> try_to_freeze_unsafe();</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze_unsafe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"><span class="comment">// 当前进程是否可以被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (likely(!freezing(current)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 调用 __refrigerator() freeze 当前进程</span></span><br><span class="line"><span class="keyword">return</span> __refrigerator(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">bool</span> __refrigerator(<span class="keyword">bool</span> check_kthr_stop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Hmm, should we be allowed to suspend when there are realtime</span></span><br><span class="line"><span class="comment">   processes around? */</span></span><br><span class="line"><span class="keyword">bool</span> was_frozen = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">long</span> save = current-&gt;state;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s entered refrigerator\n"</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// (1) 设置当前进程进入 TASK_UNINTERRUPTIBLE 阻塞状态</span></span><br><span class="line">set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;freezer_lock);</span><br><span class="line"><span class="comment">// (2) 设置已经 freeze 标志 PF_FROZEN</span></span><br><span class="line">current-&gt;flags |= PF_FROZEN;</span><br><span class="line"><span class="comment">// (3) 如果当前进程已经不是 freeze 状态，</span></span><br><span class="line"><span class="comment">// 退出 freeze</span></span><br><span class="line"><span class="keyword">if</span> (!freezing(current) ||</span><br><span class="line">    (check_kthr_stop &amp;&amp; kthread_should_stop()))</span><br><span class="line">current-&gt;flags &amp;= ~PF_FROZEN;</span><br><span class="line">spin_unlock_irq(&amp;freezer_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_FROZEN))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">was_frozen = <span class="literal">true</span>;</span><br><span class="line">schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s left refrigerator\n"</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Restore saved task state before returning.  The mb'd version</span></span><br><span class="line"><span class="comment"> * needs to be used; otherwise, it might silently break</span></span><br><span class="line"><span class="comment"> * synchronization which depends on ordered task state change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_current_state(save);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> was_frozen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-内核进程-freeze"><a href="#3-2-内核进程-freeze" class="headerlink" title="3.2 内核进程 freeze"></a>3.2 内核进程 freeze</h3><p>内核进程对 freeze 的响应，有两个问题：</p><ul><li>wake_up_state(p, TASK_INTERRUPTIBLE) 能唤醒哪些内核进程。</li><li>内核进程怎么样来响应 freeze 状态，怎么样来 freeze 自己。</li></ul><p>如果进程阻塞在信号量、mutex 等内核同步机制上，wake_up_state 并不能解除阻塞。因为这些机制都有 while(1) 循环来判断条件，是否成立，不成立只是简单的唤醒随即又会进入阻塞睡眠状态。</p><ul><li>kernel/locking/mutex.c:</li><li><code>mutex_lock()</code> -&gt; <code>__mutex_lock_common()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__mutex_lock_common(struct mutex *lock, <span class="keyword">long</span> state, <span class="keyword">unsigned</span> <span class="keyword">int</span> subclass,</span><br><span class="line">    struct lockdep_map *nest_lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip,</span><br><span class="line">    struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> <span class="keyword">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lets try to take the lock again - this is needed even if</span></span><br><span class="line"><span class="comment"> * we get here for the first time (shortly after failing to</span></span><br><span class="line"><span class="comment"> * acquire the lock), to make sure that we get a wakeup once</span></span><br><span class="line"><span class="comment"> * it's unlocked. Later on, if we sleep, this is the</span></span><br><span class="line"><span class="comment"> * operation that gives us the lock. We xchg it to -1, so</span></span><br><span class="line"><span class="comment"> * that when we release the lock, we properly wake up the</span></span><br><span class="line"><span class="comment"> * other waiters. We only attempt the xchg if the count is</span></span><br><span class="line"><span class="comment"> * non-negative in order to avoid unnecessary xchg operations:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1) 如果 mutex_lock 条件成立，才退出</span></span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;lock-&gt;count) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    (atomic_xchg(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 如果如果有信号阻塞，也退出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * got a signal? (This code gets eliminated in the</span></span><br><span class="line"><span class="comment"> * TASK_UNINTERRUPTIBLE case.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx-&gt;acquired &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = __mutex_lock_check_stamp(lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 否则继续进入阻塞休眠状态</span></span><br><span class="line">__set_task_state(task, state);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* didn't get the lock, go to sleep: */</span></span><br><span class="line">spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line">spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>wake_up_state()</code> 只能唤醒这种简单阻塞的内核进程，而对于阻塞在内核同步机制上是无能无力的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">schedule();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核进程响应 freeze 操作，也必须显式的调用 <code>try_to_freeze()</code> 或者 <code>kthread_freezable_should_stop()</code> 来 freeze 自己：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!kthread_should_stop()) &#123;</span><br><span class="line"></span><br><span class="line">try_to_freeze();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以从代码逻辑上看内核进程 freeze，并不会 freeze 所有内核进程，只 freeze 了 2 部分：一部分是设置了 WQ_FREEZABLE 标志的 workqueue，另一部分是内核进程主动调用 <code>try_to_freeze()</code> 并且在架构上设计的可以响应 freeze。</p>]]></content>
      
      
      <categories>
          
          <category> 进程管理与通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kthread_stop </tag>
            
            <tag> kthread_park </tag>
            
            <tag> freeze_processes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Signal</title>
      <link href="/2016/07/04//linux-signal.html/"/>
      <url>/2016/07/04//linux-signal.html/</url>
      
        <content type="html"><![CDATA[<p>信号的基本使用场景：使用 <code>ctrl+c</code> 中止一个程序，或者使用 <code>kill pid</code> 命令杀掉一个进程。Linux 信号机制基本上每个同学都用过，但是信号的具体实现机制还是有很多人不清楚的。在很多人的概念中信号是一种异步机制，像中断一样。但是除了硬中断，信号也是由中断实现的吗？如果不是中断，系统又怎么样来利用软件机制模拟类似如异步中断的动作？</p><blockquote><p>本文的代码分析基于 Linux Kernel 3.18.22，最好的学习方法还是 “read the fucking source code”</p></blockquote><h2 id="1-信号的响应时机"><a href="#1-信号的响应时机" class="headerlink" title="1.信号的响应时机"></a>1.信号的响应时机</h2><p>理解信号异步机制的关键是信号的响应时机，我们对一个进程发送一个信号以后，其实并没有硬中断发生，只是简单把信号挂载到目标进程的信号 pending 队列上去，信号真正得到执行的时机是进程执行完异常/中断返回到用户态的时刻。</p><p>让信号看起来是一个异步中断的关键就是，正常的用户进程是会频繁的在用户态和内核态之间切换的（这种切换包括：系统调用、缺页异常、系统中断…），所以信号能很快的能得到执行。但这也带来了一点问题，内核进程是不响应信号的，除非它刻意的去查询。所以通常情况下我们无法通过kill命令去杀死一个内核进程。</p><p><img src="/images/posts/2016/07/signal_ret_to_user.png" alt="信号响应时机"></p><ul><li>arch/arm64/kernel/entry.s:</li><li>el0_sync()/el0_irq() -&gt; ret_to_user() -&gt; work_pending() -&gt; do_notify_resume()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) 在arm64架构中，kernel运行在el1，用户态运行在el0。</span></span><br><span class="line"><span class="comment">// el0_sync是用户态发生异常的入口，el0_irq是用户态发生中断的的入口。</span></span><br><span class="line"><span class="comment">// 异常包括几种：系统调用el0_svc、数据异常el0_da、指令异常el0_ia等等几种。</span></span><br><span class="line">.align<span class="number">11</span></span><br><span class="line">ENTRY(vectors)</span><br><span class="line">ventryel0_sync<span class="comment">// Synchronous 64-bit EL0</span></span><br><span class="line">ventryel0_irq<span class="comment">// IRQ 64-bit EL0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 用户态异常el0_sync</span></span><br><span class="line">.align<span class="number">6</span></span><br><span class="line">el0_sync:</span><br><span class="line">kernel_entry <span class="number">0</span></span><br><span class="line">mrsx25, esr_el1<span class="comment">// read the syndrome register</span></span><br><span class="line">lsrx24, x25, #ESR_EL1_EC_SHIFT<span class="comment">// exception class</span></span><br><span class="line">cmpx24, #ESR_EL1_EC_SVC64<span class="comment">// SVC in 64-bit state</span></span><br><span class="line">b.eqel0_svc</span><br><span class="line">cmpx24, #ESR_EL1_EC_DABT_EL0<span class="comment">// data abort in EL0</span></span><br><span class="line">b.eqel0_da</span><br><span class="line">cmpx24, #ESR_EL1_EC_IABT_EL0<span class="comment">// instruction abort in EL0</span></span><br><span class="line">b.eqel0_ia</span><br><span class="line">cmpx24, #ESR_EL1_EC_FP_ASIMD<span class="comment">// FP/ASIMD access</span></span><br><span class="line">b.eqel0_fpsimd_acc</span><br><span class="line">cmpx24, #ESR_EL1_EC_FP_EXC64<span class="comment">// FP/ASIMD exception</span></span><br><span class="line">b.eqel0_fpsimd_exc</span><br><span class="line">cmpx24, #ESR_EL1_EC_SYS64<span class="comment">// configurable trap</span></span><br><span class="line">b.eqel0_undef</span><br><span class="line">cmpx24, #ESR_EL1_EC_SP_ALIGN<span class="comment">// stack alignment exception</span></span><br><span class="line">b.eqel0_sp_pc</span><br><span class="line">cmpx24, #ESR_EL1_EC_PC_ALIGN<span class="comment">// pc alignment exception</span></span><br><span class="line">b.eqel0_sp_pc</span><br><span class="line">cmpx24, #ESR_EL1_EC_UNKNOWN<span class="comment">// unknown exception in EL0</span></span><br><span class="line">b.eqel0_undef</span><br><span class="line">cmpx24, #ESR_EL1_EC_BREAKPT_EL0<span class="comment">// debug exception in EL0</span></span><br><span class="line">b.geel0_dbg</span><br><span class="line">bel0_inv</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.1) 用户态数据访问el0_da</span></span><br><span class="line">el0_da:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Data abort handling</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mrsx26, far_el1</span><br><span class="line"><span class="comment">// enable interrupts before calling the main handler</span></span><br><span class="line">enable_dbg_and_irq</span><br><span class="line">ct_user_exit</span><br><span class="line">bicx0, x26, #(<span class="number">0xff</span> &lt;&lt; <span class="number">56</span>)</span><br><span class="line">movx1, x25</span><br><span class="line">movx2, sp</span><br><span class="line">bldo_mem_abort</span><br><span class="line">bret_to_user</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 用户态中断el0_irq</span></span><br><span class="line">.align<span class="number">6</span></span><br><span class="line">el0_irq:</span><br><span class="line">kernel_entry <span class="number">0</span></span><br><span class="line">el0_irq_naked:</span><br><span class="line">enable_dbg</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_off</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ct_user_exit</span><br><span class="line">irq_handler</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_on</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">bret_to_user</span><br><span class="line">ENDPROC(el0_irq)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 返回用户态的处理函数ret_to_user</span></span><br><span class="line"><span class="comment">// 判断thread_info-&gt;flags与#_TIF_WORK_MASK，是否有置位，有则跳转到work_pending执行。</span></span><br><span class="line"><span class="comment">// _TIF_SIGPENDING置位即代表了进程有信号需要处理</span></span><br><span class="line"><span class="comment">// #define _TIF_WORK_MASK(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \</span></span><br><span class="line"><span class="comment">// _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE)</span></span><br><span class="line">ret_to_user:</span><br><span class="line">disable_irq<span class="comment">// disable interrupts</span></span><br><span class="line">ldrx1, [tsk, #TI_FLAGS]</span><br><span class="line"><span class="keyword">and</span>x2, x1, #_TIF_WORK_MASK</span><br><span class="line">cbnzx2, work_pending</span><br><span class="line">enable_step_tsk x1, x2</span><br><span class="line">no_work_pending:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_COMPAT</span></span><br><span class="line">kernel_exit_compat ret = <span class="number">0</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">kernel_exit <span class="number">0</span>, ret = <span class="number">0</span></span><br><span class="line">#endif</span><br><span class="line">ENDPROC(ret_to_user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) work_pending</span></span><br><span class="line">fast_work_pending:</span><br><span class="line">strx0, [sp, #S_X0]<span class="comment">// returned x0</span></span><br><span class="line">work_pending:</span><br><span class="line">tbnzx1, #TIF_NEED_RESCHED, work_resched</span><br><span class="line"><span class="comment">/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */</span></span><br><span class="line">ldrx2, [sp, #S_PSTATE]</span><br><span class="line">movx0, sp<span class="comment">// 'regs'</span></span><br><span class="line">Markdown</span><br><span class="line">Toggle Zen Mode</span><br><span class="line">Preview</span><br><span class="line"></span><br><span class="line">tstx2, #PSR_MODE_MASK<span class="comment">// user mode regs?</span></span><br><span class="line">b.neno_work_pending<span class="comment">// returning to kernel</span></span><br><span class="line">enable_irq<span class="comment">// enable interrupts for do_notify_resume()</span></span><br><span class="line">bldo_notify_resume</span><br><span class="line">bret_to_user</span><br><span class="line">work_resched:</span><br><span class="line">blschedule</span><br></pre></td></tr></table></figure><ul><li>arch/arm64/kernel/signal.c:</li><li>-&gt; do_notify_resume() -&gt; do_signal() -&gt; get_signal()/handle_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_notify_resume</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">unsigned</span> <span class="keyword">int</span> thread_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (5.1)具体的信号处理过程</span></span><br><span class="line"><span class="keyword">if</span> (thread_flags &amp; _TIF_SIGPENDING)</span><br><span class="line">do_signal(regs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread_flags &amp; _TIF_NOTIFY_RESUME) &#123;</span><br><span class="line">clear_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">tracehook_notify_resume(regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread_flags &amp; _TIF_FOREIGN_FPSTATE)</span><br><span class="line">fpsimd_restore_current_state();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-INTERRUPTIBLE-UNINTERRUPTIBLE-进程对信号的响应"><a href="#1-1-INTERRUPTIBLE-UNINTERRUPTIBLE-进程对信号的响应" class="headerlink" title="1.1 INTERRUPTIBLE/UNINTERRUPTIBLE 进程对信号的响应"></a>1.1 INTERRUPTIBLE/UNINTERRUPTIBLE 进程对信号的响应</h3><p>上节主要描述运行状态（TASK_RUNNING）进程对信号的响应时机：信号发送后挂到目标进程的信号队列，进程返回用户态的时候在 <code>do_notify_resume()</code> 中处理信号。</p><p>那么对于阻塞状态的进程又怎么样来响应信号呢？</p><p>让一个进程进入阻塞状态，我们可以选择让其进入可中断（TASK_INTERRUPTIBLE）或者不可中断（TASK_UNINTERRUPTIBLE）状态，比如 mutex 操作分为 <code>mutex_lock()</code> 和 <code>mutex_lock_interruptible()</code>。所谓的可中断和不可中断就是说是否可以被中断信号打断：如果进程处于可中断（TASK_INTERRUPTIBLE）状态，信号发送函数会直接唤醒进程，让进程处理完内核态操作去返回用户态，让进程迅速去执行信号处理函数；如果进程处于不可中断（TASK_UNINTERRUPTIBLE）状态俗称为 D 进程，信号只会挂到信号队列，但是没有机会去立即执行。</p><ul><li>kernel/signal.c:</li><li>__send_signal() -&gt; complete_signal() -&gt; signal_wake_up() -&gt; signal_wake_up_state()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_wake_up_state</span><span class="params">(struct task_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TASK_WAKEKILL also means wake it up in the stopped/traced/killable</span></span><br><span class="line"><span class="comment"> * case. We don't check t-&gt;state here because there is a race with it</span></span><br><span class="line"><span class="comment"> * executing another processor and just now entering stopped state.</span></span><br><span class="line"><span class="comment"> * By using wake_up_state, we ensure the process will wake up and</span></span><br><span class="line"><span class="comment"> * handle its death signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1)在发送完信号后，会唤醒状态为TASK_INTERRUPTIBLE的进程。</span></span><br><span class="line"><span class="keyword">if</span> (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2内核进程响应信号"><a href="#1-2内核进程响应信号" class="headerlink" title="1.2内核进程响应信号"></a>1.2内核进程响应信号</h3><p>上面说到内核进程普通情况下是不会响应信号的，如果需要内核进程响应信号，可以在内核进程中加入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义信号处理函数</span></span><br><span class="line">&#125;</span><br><span class="line">flush_signals(current);</span><br></pre></td></tr></table></figure><h2 id="2-信号简介"><a href="#2-信号简介" class="headerlink" title="2.信号简介"></a>2.信号简介</h2><p>在给大家引出重点的信号响应时机以后，还是简单介绍以下信号的背景知识。信号也是一种进程间通讯的机制，它传递的信息很短，只有一个编号。</p><h3 id="2-1-常规信号和实时信号"><a href="#2-1-常规信号和实时信号" class="headerlink" title="2.1 常规信号和实时信号"></a>2.1 常规信号和实时信号</h3><p>Linux 传统的信号 1~31 为常规信号（regular signal），POSIX 还引入了一种新的信号实时信号（real-time signal）编号为 32~64。它们的不同在于：常规信号同一个编号在 pending 队列中只存在一份，如果有重复的则直接丢弃；实时信号的多个相同信号不能丢弃，需要保证每个信号都能送达。</p><p>Linux 常用的是常规信号，以下是具体的定义<sup><a href="#fn_ULK" id="reffn_ULK">ULK</a></sup>：</p><div class="table-container"><table><thead><tr><th>编号</th><th style="text-align:center">信号名称</th><th style="text-align:center">缺省操作</th><th style="text-align:center">解释</th><th style="text-align:center">POSIX</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">SIGHUP</td><td style="text-align:center">Terminate</td><td style="text-align:center">Hang up controlling terminal or process</td><td style="text-align:center">Yes</td></tr><tr><td>2</td><td style="text-align:center">SIGINT</td><td style="text-align:center">Terminate</td><td style="text-align:center">Interrupt from keyboard</td><td style="text-align:center">Yes</td></tr><tr><td>3</td><td style="text-align:center">SIGQUIT</td><td style="text-align:center">Dump</td><td style="text-align:center">Quit from keyboard</td><td style="text-align:center">Yes</td></tr><tr><td>4</td><td style="text-align:center">SIGILL</td><td style="text-align:center">Dump</td><td style="text-align:center">Illegal instruction</td><td style="text-align:center">Yes</td></tr><tr><td>5</td><td style="text-align:center">SIGTRAP</td><td style="text-align:center">Dump</td><td style="text-align:center">Breakpoint for debugging</td><td style="text-align:center">No</td></tr><tr><td>6</td><td style="text-align:center">SIGABRT</td><td style="text-align:center">Dump</td><td style="text-align:center">Abnormal termination</td><td style="text-align:center">Yes</td></tr><tr><td>6</td><td style="text-align:center">SIGIOT</td><td style="text-align:center">Dump</td><td style="text-align:center">Equivalent to SIGABRT</td><td style="text-align:center">No</td></tr><tr><td>7</td><td style="text-align:center">SIGBUS</td><td style="text-align:center">Dump</td><td style="text-align:center">Bus error</td><td style="text-align:center">No</td></tr><tr><td>8</td><td style="text-align:center">SIGFPE</td><td style="text-align:center">Dump</td><td style="text-align:center">Floating-point exception</td><td style="text-align:center">Yes</td></tr><tr><td>9</td><td style="text-align:center">SIGKILL</td><td style="text-align:center">Terminate</td><td style="text-align:center">Forced-process termination</td><td style="text-align:center">Yes</td></tr><tr><td>10</td><td style="text-align:center">SIGUSR1</td><td style="text-align:center">Terminate</td><td style="text-align:center">Available to processes</td><td style="text-align:center">Yes</td></tr><tr><td>11</td><td style="text-align:center">SIGSEGV</td><td style="text-align:center">Dump</td><td style="text-align:center">Invalid memory reference</td><td style="text-align:center">Yes</td></tr><tr><td>12</td><td style="text-align:center">SIGUSR2</td><td style="text-align:center">Terminate</td><td style="text-align:center">Available to processes</td><td style="text-align:center">Yes</td></tr><tr><td>13</td><td style="text-align:center">SIGPIPE</td><td style="text-align:center">Terminate</td><td style="text-align:center">Write to pipe with no readers</td><td style="text-align:center">Yes</td></tr><tr><td>14</td><td style="text-align:center">SIGALRM</td><td style="text-align:center">Terminate</td><td style="text-align:center">Real-timerclock</td><td style="text-align:center">Yes</td></tr><tr><td>15</td><td style="text-align:center">SIGTERM</td><td style="text-align:center">Terminate</td><td style="text-align:center">Process termination</td><td style="text-align:center">Yes</td></tr><tr><td>16</td><td style="text-align:center">SIGSTKFLT</td><td style="text-align:center">Terminate</td><td style="text-align:center">Coprocessor stack error</td><td style="text-align:center">No</td></tr><tr><td>17</td><td style="text-align:center">SIGCHLD</td><td style="text-align:center">Ignore</td><td style="text-align:center">Child process stopped or terminated, or got signal if traced</td><td style="text-align:center">Yes</td></tr><tr><td>18</td><td style="text-align:center">SIGCONT</td><td style="text-align:center">Continue</td><td style="text-align:center">Resume execution, if stopped</td><td style="text-align:center">Yes</td></tr><tr><td>19</td><td style="text-align:center">SIGSTOP</td><td style="text-align:center">Stop</td><td style="text-align:center">Stop process execution</td><td style="text-align:center">Yes</td></tr><tr><td>20</td><td style="text-align:center">SIGTSTP</td><td style="text-align:center">Stop</td><td style="text-align:center">Stop process issued from tty</td><td style="text-align:center">Yes</td></tr><tr><td>21</td><td style="text-align:center">SIGTTIN</td><td style="text-align:center">Stop</td><td style="text-align:center">Background process requires input</td><td style="text-align:center">Yes</td></tr><tr><td>22</td><td style="text-align:center">SIGTTOU</td><td style="text-align:center">Stop</td><td style="text-align:center">Background process requires output</td><td style="text-align:center">Yes</td></tr><tr><td>23</td><td style="text-align:center">SIGURG</td><td style="text-align:center">Ignore</td><td style="text-align:center">Urgent condition on socket</td><td style="text-align:center">No</td></tr><tr><td>24</td><td style="text-align:center">SIGXCPU</td><td style="text-align:center">Dump</td><td style="text-align:center">CPU time limit exceeded</td><td style="text-align:center">No</td></tr><tr><td>25</td><td style="text-align:center">SIGXFSZ</td><td style="text-align:center">Dump</td><td style="text-align:center">File size limit exceeded</td><td style="text-align:center">No</td></tr><tr><td>26</td><td style="text-align:center">SIGVTALRM</td><td style="text-align:center">Terminate</td><td style="text-align:center">Virtual timer clock</td><td style="text-align:center">No</td></tr><tr><td>27</td><td style="text-align:center">SIGPROF</td><td style="text-align:center">Terminate</td><td style="text-align:center">Profile timer clock</td><td style="text-align:center">No</td></tr><tr><td>28</td><td style="text-align:center">SIGWINCH</td><td style="text-align:center">Ignore</td><td style="text-align:center">Window resizing</td><td style="text-align:center">No</td></tr><tr><td>29</td><td style="text-align:center">SIGIO</td><td style="text-align:center">Terminate</td><td style="text-align:center">I/O now possible</td><td style="text-align:center">No</td></tr><tr><td>29</td><td style="text-align:center">SIGPOLL</td><td style="text-align:center">Terminate</td><td style="text-align:center">Equivalent to SIGIO</td><td style="text-align:center">No</td></tr><tr><td>30</td><td style="text-align:center">SIGPWR</td><td style="text-align:center">Terminate</td><td style="text-align:center">Power supply failure</td><td style="text-align:center">No</td></tr><tr><td>31</td><td style="text-align:center">SIGSYS</td><td style="text-align:center">Dump</td><td style="text-align:center">Bad system call</td><td style="text-align:center">No</td></tr><tr><td>31</td><td style="text-align:center">SIGUNUSED</td><td style="text-align:center">Dump</td><td style="text-align:center">Equivalent to SIGSYS</td><td style="text-align:center">No</td></tr></tbody></table></div><p>所谓的缺省操作：是在用户没有注册用户态的信号处理函数的情况下，默认的信号内核处理方法。在第4节中会详细的讲解。</p><h2 id="3-信号的发送"><a href="#3-信号的发送" class="headerlink" title="3.信号的发送"></a>3.信号的发送</h2><p>信号的发送者可以是 user 也可以是 kernel，我们经常是通过用户态来调用 kill()、tkill() 等函数来发送信号的，我们通过分析这些系统调用来理解信号的具体发送过程。</p><ul><li>与信号相关的系统调用主要有以下函数：</li></ul><div class="table-container"><table><thead><tr><th>系统调用</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>kill</td><td style="text-align:center">向线程组发送信号</td></tr><tr><td>tkill</td><td style="text-align:center">向进程发送信号</td></tr><tr><td>tgkill</td><td style="text-align:center">向指定线程组中的进程发送信号</td></tr><tr><td>signal</td><td style="text-align:center">注册信号的用户态处理函数</td></tr><tr><td>sigprocmask</td><td style="text-align:center">block/unblock信号</td></tr></tbody></table></div><h3 id="3-1-kill"><a href="#3-1-kill" class="headerlink" title="3.1 kill()"></a>3.1 kill()</h3><p><code>kill()</code> 系统调用的功能是发送一个信号给线程组，只需要线程组挑出一个线程来响应处理信号。但是对于致命信号，线程组内所有进程都会被杀死，而不仅仅是处理信号的线程。</p><p><img src="/images/posts/2016/07/signal_kill.png" alt="kill 调用"></p><ul><li>kernel/signal.c:</li><li>kill() -&gt; kill_something_info() -&gt; kill_pid_info() -&gt; group_send_sig_info() -&gt; do_send_sig_info() -&gt; send_signal() -&gt; __send_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_USER;</span><br><span class="line">info.si_pid = task_tgid_vnr(current);</span><br><span class="line">info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">// (1)pid&gt;0, 发送信号给pid进程所在的线程组</span></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line"><span class="comment">// (2)(pid &lt;= 0) &amp;&amp; (pid != -1), 发送信号给pid进程所在进程组中的每一个线程组</span></span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">ret = __kill_pgrp_info(sig, info,</span><br><span class="line">pid ? find_vpid(-pid) : task_pgrp(current));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (3)pid = -1, 发送信号给所有进程的进程组，除了pid=1和当前进程自己</span></span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(p) &#123;</span><br><span class="line"><span class="keyword">if</span> (task_pid_vnr(p) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">!same_thread_group(p, current)) &#123;</span><br><span class="line"><span class="keyword">int</span> err = group_send_sig_info(sig, info, p);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">if</span> (err != -EPERM)</span><br><span class="line">retval = err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = count ? retval : -ESRCH;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = check_kill_permission(sig, info, p);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line"><span class="comment">// (1.1)参数group=ture，信号发送给线程组</span></span><br><span class="line">ret = do_send_sig_info(sig, info, p, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/posts/2016/07/signal_pending_queue.png" alt="信号队列"></p><p>接下来来到了发送信号的核心函数 <code>__send_signal()</code>，函数的主要目的是把信号挂到信号的 pending 队列中去。pending 队列有两种：一种是进程组共享的 <code>task_struct-&gt;signal-&gt;shared_pending</code>，发送给线程组的信号会挂载到该队列；另一种是进程私有队列 <code>task_struct-&gt;pending</code>，发送给进程的信号会挂载到该队列。</p><p>从下面的代码中，我们可以看到在创建线程时，线程组贡献信号队列 <code>task_struct-&gt;signal-&gt;shared_pending</code> 是怎么实现的。</p><ul><li>kernel/fork.c:</li><li>do_fork() -&gt; copy_process() -&gt; copy_signal()/copy_sighand()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// (1)复制父进程current的task_struct结构体到新进程p；</span></span><br><span class="line"><span class="comment">// 这里已经包含做了signal的复制动作:p-&gt;signal=current-&gt;signal</span></span><br><span class="line">p = dup_task_struct(current);</span><br><span class="line">...</span><br><span class="line">retval = copy_sighand(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line"><span class="comment">// (2)如果是创建线程(CLONE_THREAD被置位)，那么新进程和父进程共享tsk-&gt;signal结构，</span></span><br><span class="line"><span class="comment">// 不会分配新的tsk-&gt;signal结构空间</span></span><br><span class="line">retval = copy_signal(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_signal</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.1)如果是创建线程(CLONE_THREAD被置位)，不分配新的tsk-&gt;signal空间直接返回</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);</span><br><span class="line">tsk-&gt;signal = sig;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_sighand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.2)同样，也可以用CLONE_SIGHAND标志来控制是否共享tsk-&gt;sighand</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">atomic_inc(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);</span><br><span class="line">rcu_assign_pointer(tsk-&gt;sighand, sig);</span><br><span class="line"><span class="keyword">if</span> (!sig)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">atomic_set(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="keyword">sizeof</span>(sig-&gt;action));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续来看 <code>__send_signal()</code> 的具体实现：</p><ul><li>kernel/signal.c:</li><li>-&gt; <code>__send_signal()</code> -&gt; <code>prepare_signal()</code>/<code>complete_signal()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span><br><span class="line"><span class="keyword">int</span> group, <span class="keyword">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="keyword">int</span> override_rlimit;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">result = TRACE_SIGNAL_IGNORED;</span><br><span class="line"><span class="comment">// (1)判断是否可以忽略信号</span></span><br><span class="line"><span class="keyword">if</span> (!prepare_signal(sig, t,</span><br><span class="line">from_ancestor_ns || (info == SEND_SIG_FORCED)))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)选择信号pending队列</span></span><br><span class="line"><span class="comment">// 线程组共享队列(t-&gt;signal-&gt;shared_pending) or 进程私有队列(t-&gt;pending)</span></span><br><span class="line">pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment"> * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment"> * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line"><span class="comment">// (3)如果信号是常规信号(regular signal)，且已经在pending队列中，则忽略重复信号；</span></span><br><span class="line"><span class="comment">// 另外一方面也说明了，如果是实时信号，尽管信号重复，但还是要加入pending队列；</span></span><br><span class="line"><span class="comment">// 实时信号的多个信号都需要能被接收到。</span></span><br><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fast-pathed signals for kernel-internal things like SIGSTOP</span></span><br><span class="line"><span class="comment"> * or SIGKILL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4)如果是强制信号(SEND_SIG_FORCED)，不走挂载pending队列的流程，直接快速路径优先处理。</span></span><br><span class="line"><span class="keyword">if</span> (info == SEND_SIG_FORCED)</span><br><span class="line"><span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment"> * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment"> * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment"> * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment"> * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment"> * make sure at least one signal gets delivered and don't</span></span><br><span class="line"><span class="comment"> * pass on the info struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (5)符合条件的特殊信号可以突破siganl pending队列的大小限制(rlimit)</span></span><br><span class="line"><span class="comment">// 否则在队列满的情况下，丢弃信号</span></span><br><span class="line"><span class="comment">// signal pending队列大小rlimit的值可以通过命令"ulimit -i"查看</span></span><br><span class="line"><span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6)没有ignore的信号，加入到pending队列中。</span></span><br><span class="line">q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,</span><br><span class="line">override_rlimit);</span><br><span class="line"><span class="keyword">if</span> (q) &#123;</span><br><span class="line">list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_USER;</span><br><span class="line">q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">task_active_pid_ns(t));</span><br><span class="line">q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line"><span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userns_fixup_signal_uid(&amp;q-&gt;info, t);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info)) &#123;</span><br><span class="line"><span class="keyword">if</span> (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment"> * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment"> * other than kill().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_OVERFLOW_FAIL;</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment"> * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_LOSE_INFO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">signalfd_notify(t, sig);</span><br><span class="line"><span class="comment">// (7)更新pending-&gt;signal信号集合中对应的bit</span></span><br><span class="line">sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line"><span class="comment">// (8)选择合适的进程来响应信号，如果需要并唤醒对应的进程</span></span><br><span class="line">complete_signal(sig, t, group);</span><br><span class="line">ret:</span><br><span class="line">trace_signal_generate(sig, info, t, group, result);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">prepare_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">p</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> flush;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) &#123;</span><br><span class="line"><span class="comment">// (1.1)如果进程正在处于SIGNAL_GROUP_COREDUMP，则当前信号被忽略</span></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_GROUP_COREDUMP) &#123;</span><br><span class="line">pr_debug(<span class="string">"[%d:%s] is in the middle of doing coredump so skip sig %d\n"</span>, p-&gt;pid, p-&gt;comm, sig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The process is in the middle of dying, nothing to do.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sig_kernel_stop(sig)) &#123;</span><br><span class="line"><span class="comment">// (1.2)如果当前是stop信号，则移除线程组所有线程pending队列中的SIGCONT信号</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a stop signal.  Remove SIGCONT from all queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">siginitset(&amp;flush, sigmask(SIGCONT));</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;signal-&gt;shared_pending);</span><br><span class="line">for_each_thread(p, t)</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;t-&gt;pending);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGCONT) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> why;</span><br><span class="line"><span class="comment">// (1.3)如果当前是SIGCONT信号，则移除线程组所有线程pending队列中的stop信号，并唤醒stop进程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove all stop signals from all queues, wake all threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">siginitset(&amp;flush, SIG_KERNEL_STOP_MASK);</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;signal-&gt;shared_pending);</span><br><span class="line">for_each_thread(p, t) &#123;</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;t-&gt;pending);</span><br><span class="line">task_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);</span><br><span class="line"><span class="keyword">if</span> (likely(!(t-&gt;ptrace &amp; PT_SEIZED)))</span><br><span class="line">wake_up_state(t, __TASK_STOPPED);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ptrace_trap_notify(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notify the parent with CLD_CONTINUED if we were stopped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If we were in the middle of a group stop, we pretend it</span></span><br><span class="line"><span class="comment"> * was already finished, and then continued. Since SIGCHLD</span></span><br><span class="line"><span class="comment"> * doesn't queue we report only CLD_STOPPED, as if the next</span></span><br><span class="line"><span class="comment"> * CLD_CONTINUED was dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">why = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_STOP_STOPPED)</span><br><span class="line">why |= SIGNAL_CLD_CONTINUED;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (signal-&gt;group_stop_count)</span><br><span class="line">why |= SIGNAL_CLD_STOPPED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (why) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The first thread which returns from do_signal_stop()</span></span><br><span class="line"><span class="comment"> * will take -&gt;siglock, notice SIGNAL_CLD_MASK, and</span></span><br><span class="line"><span class="comment"> * notify its parent. See get_signal_to_deliver().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">signal-&gt;flags = why | SIGNAL_STOP_CONTINUED;</span><br><span class="line">signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">signal-&gt;group_exit_code = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4)进一步判断信号是否会被忽略</span></span><br><span class="line"><span class="keyword">return</span> !sig_ignored(p, sig, force);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sig_ignored</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> sig, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Blocked signals are never ignored, since the</span></span><br><span class="line"><span class="comment"> * signal handler may change by the time it is</span></span><br><span class="line"><span class="comment"> * unblocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1.4.1)如果信号被blocked，不会被忽略</span></span><br><span class="line"><span class="keyword">if</span> (sigismember(&amp;t-&gt;blocked, sig) || sigismember(&amp;t-&gt;real_blocked, sig))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2)进一步判断信号的忽略条件</span></span><br><span class="line"><span class="keyword">if</span> (!sig_task_ignored(t, sig, force))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tracers may want to know about even ignored signals.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1.4.3)信号符合忽略条件，且没有被trace，则信号被忽略</span></span><br><span class="line"><span class="keyword">return</span> !t-&gt;ptrace;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sig_task_ignored</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> sig, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2.1)提取信号的操作函数</span></span><br><span class="line">handler = sig_handler(t, sig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2.2)如果符合条件，信号被忽略</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">handler == SIG_DFL &amp;&amp; !force)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2.3)</span></span><br><span class="line"><span class="keyword">return</span> sig_handler_ignored(handler, sig);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sig_handler_ignored</span><span class="params">(<span class="keyword">void</span> __user *handler, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Is it explicitly or implicitly ignored? */</span></span><br><span class="line"><span class="comment">// (1.4.2.3.1)如果信号操作函数是忽略SIG_IGN，或者操作函数是默认SIG_DFL但是默认动作是忽略</span></span><br><span class="line"><span class="comment">// 默认动作是忽略的信号包括：</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_IGNORE_MASK (\</span></span><br><span class="line"><span class="comment">//    rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \</span></span><br><span class="line"><span class="comment">//    rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )</span></span><br><span class="line"><span class="comment">// 忽略这一类信号</span></span><br><span class="line"><span class="keyword">return</span> handler == SIG_IGN ||</span><br><span class="line">(handler == SIG_DFL &amp;&amp; sig_kernel_ignore(sig));</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">p</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now find a thread we can wake up to take the signal off the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the main thread wants the signal, it gets first crack.</span></span><br><span class="line"><span class="comment"> * Probably the least surprising to the average bear.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.1)判断当前线程是否符合响应信号的条件</span></span><br><span class="line"><span class="keyword">if</span> (wants_signal(sig, p))</span><br><span class="line">t = p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!group || thread_group_empty(p))</span><br><span class="line"><span class="comment">// (8.2)如果信号是发给单线程的，直接返回</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There is just one thread and it does not need to be woken.</span></span><br><span class="line"><span class="comment"> * It will dequeue unblocked signals before it runs again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Otherwise try to find a suitable thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.3)在当前线程组中挑出一个符合响应信号条件的线程</span></span><br><span class="line"><span class="comment">// 从signal-&gt;curr_target线程开始查找</span></span><br><span class="line">t = signal-&gt;curr_target;</span><br><span class="line"><span class="keyword">while</span> (!wants_signal(sig, t)) &#123;</span><br><span class="line">t = next_thread(t);</span><br><span class="line"><span class="keyword">if</span> (t == signal-&gt;curr_target)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No thread needs to be woken.</span></span><br><span class="line"><span class="comment"> * Any eligible threads will see</span></span><br><span class="line"><span class="comment"> * the signal in the queue soon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">signal-&gt;curr_target = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Found a killable thread.  If the signal will be fatal,</span></span><br><span class="line"><span class="comment"> * then start taking the whole group down immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig_fatal(p, sig) &amp;&amp;</span><br><span class="line">    !(signal-&gt;flags &amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;&amp;</span><br><span class="line">    !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;</span><br><span class="line">    (sig == SIGKILL || !t-&gt;ptrace)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This signal will be fatal to the whole group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!sig_kernel_coredump(sig)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start a group exit and wake everybody up.</span></span><br><span class="line"><span class="comment"> * This way we don't have other threads</span></span><br><span class="line"><span class="comment"> * running and doing things after a slower</span></span><br><span class="line"><span class="comment"> * thread has the fatal signal pending.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">signal-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">signal-&gt;group_exit_code = sig;</span><br><span class="line">signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">t = p;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);</span><br><span class="line">sigaddset(&amp;t-&gt;pending.signal, SIGKILL);</span><br><span class="line">signal_wake_up(t, <span class="number">1</span>);</span><br><span class="line">&#125; while_each_thread(p, t);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The signal is already in the shared-pending queue.</span></span><br><span class="line"><span class="comment"> * Tell the chosen thread to wake up and dequeue it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.4)唤醒挑选出的响应信号的线程</span></span><br><span class="line">signal_wake_up(t, sig == SIGKILL);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ptrace_signal_wake_up</span><span class="params">(struct task_struct *t, <span class="keyword">bool</span> resume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal_wake_up_state(t, resume ? __TASK_TRACED : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_wake_up_state</span><span class="params">(struct task_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (8.4.1)设置thread_info-&gt;flags中的TIF_SIGPENDING标志</span></span><br><span class="line"><span class="comment">// ret_to_user()时会根据此标志来调用do_notify_resume()</span></span><br><span class="line">set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TASK_WAKEKILL also means wake it up in the stopped/traced/killable</span></span><br><span class="line"><span class="comment"> * case. We don't check t-&gt;state here because there is a race with it</span></span><br><span class="line"><span class="comment"> * executing another processor and just now entering stopped state.</span></span><br><span class="line"><span class="comment"> * By using wake_up_state, we ensure the process will wake up and</span></span><br><span class="line"><span class="comment"> * handle its death signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.4.2)唤醒阻塞状态为TASK_INTERRUPTIBLE的信号响应线程</span></span><br><span class="line"><span class="keyword">if</span> (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-tkill"><a href="#3-2-tkill" class="headerlink" title="3.2 tkill()"></a>3.2 <code>tkill()</code></h3><p><code>kill()</code> 是向进程组发一个信号，而 <code>tkill()</code> 是向某一个进程发送信号。</p><p><img src="/images/posts/2016/07/signal_tkill.png" alt="tkill 调用"></p><ul><li>kernel/signal.c:</li><li>tkill() -&gt; do_tkill() -&gt; do_send_specific() -&gt; send_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(tkill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is only valid for single tasks */</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_tkill(<span class="number">0</span>, pid, sig);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_tkill</span><span class="params">(<span class="keyword">pid_t</span> tgid, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span> = &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_TKILL;</span><br><span class="line">info.si_pid = task_tgid_vnr(current);</span><br><span class="line">info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_send_specific(tgid, pid, sig, &amp;info);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">do_send_specific(<span class="keyword">pid_t</span> tgid, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, struct siginfo *info)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> error = -ESRCH;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">p = find_task_by_vpid(pid);</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; (tgid &lt;= <span class="number">0</span> || task_tgid_vnr(p) == tgid)) &#123;</span><br><span class="line"><span class="comment">// (1)tkill()符合条件1：tgid=0</span></span><br><span class="line"><span class="comment">// tgkill()需要符合条件2：tgid指定的线程组 == p所在的线程组</span></span><br><span class="line">error = check_kill_permission(sig, info, p);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The null signal is a permissions and process existence</span></span><br><span class="line"><span class="comment"> * probe.  No signal is actually delivered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; sig) &#123;</span><br><span class="line"><span class="comment">// (2)参数group=false，信号发送给单个进程组</span></span><br><span class="line">error = do_send_sig_info(sig, info, p, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If lock_task_sighand() failed we pretend the task</span></span><br><span class="line"><span class="comment"> * dies after receiving the signal. The window is tiny,</span></span><br><span class="line"><span class="comment"> * and the signal is private anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(error == -ESRCH))</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-tgkill"><a href="#3-3-tgkill" class="headerlink" title="3.3 tgkill()"></a>3.3 <code>tgkill()</code></h3><p><code>tgkill()</code> 是向特定线程组中的进程发送信号。</p><p><img src="/images/posts/2016/07/signal_tgkill.png" alt="tgkill 调用"></p><ul><li>kernel/signal.c:</li><li>tkill() -&gt; do_tkill() -&gt; do_send_specific() -&gt; send_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(tgkill, <span class="keyword">pid_t</span>, tgid, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is only valid for single tasks */</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span> || tgid &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_tkill(tgid, pid, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-signal"><a href="#3-4-signal" class="headerlink" title="3.4 signal()"></a>3.4 signal()</h3><p><code>signal()</code>/<code>sigaction()</code> 注册用户自定义的信号处理函数。</p><ul><li>kernel/signal.c:</li><li>signal() -&gt; do_sigaction()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(signal, <span class="keyword">int</span>, sig, <span class="keyword">__sighandler_t</span>, handler)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">new_sa</span>, <span class="title">old_sa</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">new_sa.sa.sa_handler = handler;</span><br><span class="line">new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;</span><br><span class="line">sigemptyset(&amp;new_sa.sa.sa_mask);</span><br><span class="line"></span><br><span class="line">ret = do_sigaction(sig, &amp;new_sa, &amp;old_sa);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret ? ret : (<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_sa.sa.sa_handler;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sigaction</span><span class="params">(<span class="keyword">int</span> sig, struct k_sigaction *act, struct k_sigaction *oact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> = <span class="title">current</span>, *<span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">k</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!valid_signal(sig) || sig &lt; <span class="number">1</span> || (act &amp;&amp; sig_kernel_only(sig)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">k = &amp;p-&gt;sighand-&gt;action[sig<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock);</span><br><span class="line"><span class="keyword">if</span> (oact)</span><br><span class="line">*oact = *k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (act) &#123;</span><br><span class="line">sigdelsetmask(&amp;act-&gt;sa.sa_mask,</span><br><span class="line">      sigmask(SIGKILL) | sigmask(SIGSTOP));</span><br><span class="line"><span class="comment">// (1)将信号处理函数sighand-&gt;action[sig-1]替换成用户函数</span></span><br><span class="line">*k = *act;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * POSIX 3.3.1.3:</span></span><br><span class="line"><span class="comment"> *  "Setting a signal action to SIG_IGN for a signal that is</span></span><br><span class="line"><span class="comment"> *   pending shall cause the pending signal to be discarded,</span></span><br><span class="line"><span class="comment"> *   whether or not it is blocked."</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  "Setting a signal action to SIG_DFL for a signal that is</span></span><br><span class="line"><span class="comment"> *   pending and whose default action is to ignore the signal</span></span><br><span class="line"><span class="comment"> *   (for example, SIGCHLD), shall cause the pending signal to</span></span><br><span class="line"><span class="comment"> *   be discarded, whether or not it is blocked"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig_handler_ignored(sig_handler(p, sig), sig)) &#123;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, sig);</span><br><span class="line">flush_sigqueue_mask(&amp;mask, &amp;p-&gt;signal-&gt;shared_pending);</span><br><span class="line">for_each_thread(p, t)</span><br><span class="line">flush_sigqueue_mask(&amp;mask, &amp;t-&gt;pending);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-sigprocmask"><a href="#3-5-sigprocmask" class="headerlink" title="3.5 sigprocmask()"></a>3.5 <code>sigprocmask()</code></h3><p><code>sigprocmask()</code> 用来设置进程对信号是否阻塞。阻塞以后，信号继续挂载到信号 pending 队列，但是信号处理时不响应信号。<code>SIG_BLOCK</code> 命令阻塞信号，<code>SIG_UNBLOCK</code> 命令解除阻塞信号。</p><ul><li>kernel/signal.c:</li><li>sigprocmask() -&gt; set_current_blocked()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(sigprocmask, <span class="keyword">int</span>, how, <span class="keyword">old_sigset_t</span> __user *, nset,</span><br><span class="line"><span class="keyword">old_sigset_t</span> __user *, oset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">old_sigset_t</span> old_set, new_set;</span><br><span class="line"><span class="keyword">sigset_t</span> new_blocked;</span><br><span class="line"></span><br><span class="line">old_set = current-&gt;blocked.sig[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nset) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;new_set, nset, <span class="keyword">sizeof</span>(*nset)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">new_blocked = current-&gt;blocked;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (how) &#123;</span><br><span class="line"><span class="keyword">case</span> SIG_BLOCK:</span><br><span class="line">sigaddsetmask(&amp;new_blocked, new_set);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SIG_UNBLOCK:</span><br><span class="line">sigdelsetmask(&amp;new_blocked, new_set);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SIG_SETMASK:</span><br><span class="line">new_blocked.sig[<span class="number">0</span>] = new_set;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1)根据SIG_BLOCK/SIG_UNBLOCK命令来重新设计阻塞信号set current-&gt;blocked。</span></span><br><span class="line">set_current_blocked(&amp;new_blocked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oset) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(oset, &amp;old_set, <span class="keyword">sizeof</span>(*oset)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于信号阻塞 <code>current-&gt;blocked</code> 的使用在信号处理函数 <code>get_signal()</code> 中使用。</p><ul><li>arch/arm64/kernel/signal.c:</li><li>do_signal() -&gt; get_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue_signal</span><span class="params">(struct task_struct *tsk, <span class="keyword">sigset_t</span> *mask, <span class="keyword">siginfo_t</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> signr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We only dequeue private signals from ourselves, we don't let</span></span><br><span class="line"><span class="comment"> * signalfd steal them</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">signr = __dequeue_signal(&amp;tsk-&gt;pending, mask, info);</span><br><span class="line"><span class="keyword">if</span> (!signr) &#123;</span><br><span class="line">signr = __dequeue_signal(&amp;tsk-&gt;signal-&gt;shared_pending,</span><br><span class="line"> mask, info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dequeue_signal(struct sigpending *pending, <span class="keyword">sigset_t</span> *mask,</span><br><span class="line"><span class="keyword">siginfo_t</span> *info)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (1)对于pending被设置的阻塞信号，信号处理时不予响应。</span></span><br><span class="line"><span class="keyword">int</span> sig = next_signal(pending, mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sig) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;notifier) &#123;</span><br><span class="line"><span class="keyword">if</span> (sigismember(current-&gt;notifier_mask, sig)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;notifier)(current-&gt;notifier_data)) &#123;</span><br><span class="line">clear_thread_flag(TIF_SIGPENDING);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collect_signal(sig, pending, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-信号的处理"><a href="#4-信号的处理" class="headerlink" title="4.信号的处理"></a>4.信号的处理</h2><ul><li>系统对信号的处理有三种方式：</li></ul><div class="table-container"><table><thead><tr><th>信号响应</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>忽略</td><td style="text-align:center">ignore</td></tr><tr><td>调用用户态注册的处理函数</td><td style="text-align:center">如果用户有注册信号处理函数，调用 sighand-&gt;action[signr-1] 中对应的注册函数</td></tr><tr><td>调用默认的内核态处理函数</td><td style="text-align:center">如果用户没有注册对应的处理函数，调用默认的内核处理</td></tr></tbody></table></div><ul><li>默认的内核态处理，进一步可以细分为几种：</li></ul><div class="table-container"><table><thead><tr><th>信号默认内核处理类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Terminate</td><td style="text-align:center">进程被中止(杀死)。</td></tr><tr><td>Dump</td><td style="text-align:center">进程被中止(杀死)，并且输出 dump 文件。</td></tr><tr><td>Ignore</td><td style="text-align:center">信号被忽略。</td></tr><tr><td>Stop</td><td style="text-align:center">进程被停止，把进程设置为 TASK_STOPPED 状态。</td></tr><tr><td>Continue</td><td style="text-align:center">如果进程被停止（TASK_STOPPED），把它设置成 TASK_RUNNING 状态。</td></tr></tbody></table></div><h3 id="4-1-do-signal"><a href="#4-1-do-signal" class="headerlink" title="4.1 do_signal()"></a>4.1 <code>do_signal()</code></h3><p>信号处理的核心函数就是 <code>do_signal()</code>，下面我们来详细分析一下具体实现。</p><ul><li>arch/arm64/kernel/signal.c:</li><li>-&gt; ret_to_user() -&gt; do_notify_resume() -&gt; do_signal() -&gt; get_signal()/handle_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> continue_addr = <span class="number">0</span>, restart_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> syscall = (<span class="keyword">int</span>)regs-&gt;syscallno;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we were from a system call, check for system call restarting...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1)如果是 system call 被信号中断，判断是否需要重启 system call</span></span><br><span class="line"><span class="keyword">if</span> (syscall &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">continue_addr = regs-&gt;pc;</span><br><span class="line">restart_addr = continue_addr - (compat_thumb_mode(regs) ? <span class="number">2</span> : <span class="number">4</span>);</span><br><span class="line">retval = regs-&gt;regs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Avoid additional syscall restarting via ret_to_user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">regs-&gt;syscallno = ~<span class="number">0U</span>L;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prepare for system call restart. We do this here so that a</span></span><br><span class="line"><span class="comment"> * debugger will see the already changed PC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (retval) &#123;</span><br><span class="line"><span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line"><span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line"><span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line"><span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">regs-&gt;regs[<span class="number">0</span>] = regs-&gt;orig_x0;</span><br><span class="line">regs-&gt;pc = restart_addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the signal to deliver. When running under ptrace, at this point</span></span><br><span class="line"><span class="comment"> * the debugger may change all of our registers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2) 从线程的信号 pending 队列中取出信号，</span></span><br><span class="line"><span class="comment">// 如果没有对应的用户自定义处理函数，则执行默认的内核态处理函数</span></span><br><span class="line"><span class="keyword">if</span> (get_signal(&amp;ksig)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Depending on the signal settings, we may need to revert the</span></span><br><span class="line"><span class="comment"> * decision to restart the system call, but skip this if a</span></span><br><span class="line"><span class="comment"> * debugger has chosen to restart at a different PC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (regs-&gt;pc == restart_addr &amp;&amp;</span><br><span class="line">    (retval == -ERESTARTNOHAND ||</span><br><span class="line">     retval == -ERESTART_RESTARTBLOCK ||</span><br><span class="line">     (retval == -ERESTARTSYS &amp;&amp;</span><br><span class="line">      !(ksig.ka.sa.sa_flags &amp; SA_RESTART)))) &#123;</span><br><span class="line">regs-&gt;regs[<span class="number">0</span>] = -EINTR;</span><br><span class="line">regs-&gt;pc = continue_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3)如果有对应的用户自定义处理函数，则执行用户态处理函数</span></span><br><span class="line">handle_signal(&amp;ksig, regs);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle restarting a different system call. As above, if a debugger</span></span><br><span class="line"><span class="comment"> * has chosen to restart at a different PC, ignore the restart.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4)重启被中断的system call</span></span><br><span class="line"><span class="keyword">if</span> (syscall &gt;= <span class="number">0</span> &amp;&amp; regs-&gt;pc == restart_addr) &#123;</span><br><span class="line"><span class="keyword">if</span> (retval == -ERESTART_RESTARTBLOCK)</span><br><span class="line">setup_restart_syscall(regs);</span><br><span class="line">user_rewind_single_step(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restore_saved_sigmask();</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> = <span class="title">current</span>-&gt;<span class="title">sighand</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">current</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line"><span class="keyword">int</span> signr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.1)执行task work机制中的work</span></span><br><span class="line"><span class="comment">// 这是和信号无关的机制，属于搭便车在ret_to_user时刻去执行的机制</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">task_work_run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(uprobe_deny_signal()))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do this once, we can't return to user-mode if freezing() == T.</span></span><br><span class="line"><span class="comment"> * do_signal_stop() and ptrace_stop() do freezable_schedule() and</span></span><br><span class="line"><span class="comment"> * thus do not need another check after return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.2)第二个搭便车的机制freeze，</span></span><br><span class="line"><span class="comment">// 系统在suspend时会调用suspend_freeze_processes()来freeze线程</span></span><br><span class="line"><span class="comment">// 实际上也是唤醒线程，让线程在ret_to_user时刻去freeze自己</span></span><br><span class="line">try_to_freeze();</span><br><span class="line"></span><br><span class="line">relock:</span><br><span class="line">spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every stopped thread goes here after wakeup. Check to see if</span></span><br><span class="line"><span class="comment"> * we should notify the parent, prepare_signal(SIGCONT) encodes</span></span><br><span class="line"><span class="comment"> * the CLD_ si_code into SIGNAL_CLD_MASK bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.3)在子进程状态变化的情况下，发送SIGCHLD信号通知父进程</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line"><span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">why = CLD_CONTINUED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notify the parent that we're continuing.  This event is</span></span><br><span class="line"><span class="comment"> * always per-process and doesn't make whole lot of sense</span></span><br><span class="line"><span class="comment"> * for ptracers, who shouldn't consume the state via</span></span><br><span class="line"><span class="comment"> * wait(2) either, but, for backward compatibility, notify</span></span><br><span class="line"><span class="comment"> * the ptracer of the group leader too unless it's gonna be</span></span><br><span class="line"><span class="comment"> * a duplicate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line"><span class="literal">true</span>, why);</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_STOP_PENDING) &amp;&amp;</span><br><span class="line">    do_signal_stop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_TRAP_MASK)) &#123;</span><br><span class="line">do_jobctl_trap();</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.4)从信号pending队列中，取出优先级最好的信号</span></span><br><span class="line">signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;ptrace) &amp;&amp; signr != SIGKILL) &#123;</span><br><span class="line">signr = ptrace_signal(signr, &amp;ksig-&gt;info);</span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5)从信号处理数组sighand中，取出信号对应的处理函数</span></span><br><span class="line">ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trace actually delivered signals. */</span></span><br><span class="line">trace_signal_deliver(signr, &amp;ksig-&gt;info, ka);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.1)信号处理的第1种方法：忽略</span></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// (2.6.2)信号处理的第2种方法：调用用户态注册的处理函数</span></span><br><span class="line"><span class="comment">// 获取到用户态的处理函数指针，返回调用handle_signal()来执行</span></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line"><span class="comment">/* Run the handler.  */</span></span><br><span class="line">ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.3)信号处理的第3种方法：调用默认的内核态处理函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now we are doing the default action for this signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.6.3.1)SIG_KERNEL_IGNORE_MASK信号的默认处理方法Ignore：忽略</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_IGNORE_MASK (\</span></span><br><span class="line"><span class="comment">//        rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Global init gets no signals it doesn't want.</span></span><br><span class="line"><span class="comment"> * Container-init gets no signals it doesn't want from same</span></span><br><span class="line"><span class="comment"> * container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if global/container-init sees a sig_kernel_only()</span></span><br><span class="line"><span class="comment"> * signal here, the signal must have been generated internally</span></span><br><span class="line"><span class="comment"> * or must have come from an ancestor namespace. In either</span></span><br><span class="line"><span class="comment"> * case, the signal cannot be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">!sig_kernel_only(signr))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.3.2)SIG_KERNEL_STOP_MASK信号的默认处理方法Stop：do_signal_stop()</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_STOP_MASK (\</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_stop(signr)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The default action is to stop all threads in</span></span><br><span class="line"><span class="comment"> * the thread group.  The job control signals</span></span><br><span class="line"><span class="comment"> * do nothing in an orphaned pgrp, but SIGSTOP</span></span><br><span class="line"><span class="comment"> * always works.  Note that siglock needs to be</span></span><br><span class="line"><span class="comment"> * dropped during the call to is_orphaned_pgrp()</span></span><br><span class="line"><span class="comment"> * because of lock ordering with tasklist_lock.</span></span><br><span class="line"><span class="comment"> * This allows an intervening SIGCONT to be posted.</span></span><br><span class="line"><span class="comment"> * We need to check for that and bail out if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (signr != SIGSTOP) &#123;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signals can be posted during this window */</span></span><br><span class="line"><span class="comment">// 不是SIGSTOP信号，且是孤儿进程组</span></span><br><span class="line"><span class="keyword">if</span> (is_current_pgrp_orphaned())</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123;</span><br><span class="line"><span class="comment">/* It released the siglock.  */</span></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We didn't actually stop, due to a race</span></span><br><span class="line"><span class="comment"> * with SIGCONT or something like that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Anything else is fatal, maybe with a core dump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">current-&gt;flags |= PF_SIGNALED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.3.3)SIG_KERNEL_COREDUMP_MASK信号的默认处理方法Dump：do_coredump() &amp; do_group_exit()</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_COREDUMP_MASK (\</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \</span></span><br><span class="line"><span class="comment">// SIGEMT_MASK       )</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">proc_coredump_connector(current);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it was able to dump core, this kills all</span></span><br><span class="line"><span class="comment"> * other threads in the group and synchronizes with</span></span><br><span class="line"><span class="comment"> * their demise.  If we lost the race with another</span></span><br><span class="line"><span class="comment"> * thread getting here, it set group_exit_code</span></span><br><span class="line"><span class="comment"> * first and our do_group_exit call below will use</span></span><br><span class="line"><span class="comment"> * that value and ignore the one we pass it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Death signals, no core dump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.6.3.4)Death signals信号的默认处理方法Terminate：do_group_exit()</span></span><br><span class="line">do_group_exit(ksig-&gt;info.si_signo);</span><br><span class="line"><span class="comment">/* NOTREACHED */</span></span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">ksig-&gt;sig = signr;</span><br><span class="line"><span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户没有注册信号处理函数，默认的内核处理函数在 <code>get_signal()</code> 函数中执行完了。对于用户有注册处理函数的信号，但是因为这些处理函数都是用户态的，所以内核使用了一个技巧：先构造堆栈，返回用户态去执行自定义信号处理函数，再返回内核态继续被信号打断的返回用户态的动作。</p><p><img src="/images/posts/2016/07/signal_handle_signal.png" alt="信号处理"></p><p>我们来看 <code>handle_signal()</code> 函数中的具体实现。</p><ul><li>arch/arm64/kernel/signal.c:</li><li>-&gt; ret_to_user() -&gt; do_notify_resume() -&gt; do_signal() -&gt; handle_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(struct ksignal *ksig, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">thread</span> = <span class="title">current_thread_info</span>();</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> *oldset = sigmask_to_save();</span><br><span class="line"><span class="keyword">int</span> usig = ksig-&gt;sig;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * translate the signal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (usig &lt; <span class="number">32</span> &amp;&amp; thread-&gt;exec_domain &amp;&amp; thread-&gt;exec_domain-&gt;signal_invmap)</span><br><span class="line">usig = thread-&gt;exec_domain-&gt;signal_invmap[usig];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the stack frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1)构造返回堆栈，将用户态返回地址替换成用户注册的信号处理函数&amp;ksig-&gt;ka</span></span><br><span class="line"><span class="keyword">if</span> (is_compat_task()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO)</span><br><span class="line">ret = compat_setup_rt_frame(usig, ksig, oldset, regs);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = compat_setup_frame(usig, ksig, oldset, regs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = setup_rt_frame(usig, ksig, oldset, regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that the resulting registers are actually sane.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret |= !valid_user_regs(&amp;regs-&gt;user_regs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fast forward the stepping logic so we step into the signal</span></span><br><span class="line"><span class="comment"> * handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">user_fastforward_single_step(tsk);</span><br><span class="line"></span><br><span class="line">signal_setup_done(ret, ksig, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_ULK"><sup>ULK</sup>. <a href="http://shop.oreilly.com/product/9780596000028.do" target="_blank" rel="noopener">Understanding the Linux Kernel</a><a href="#reffn_ULK" title="Jump back to footnote [ULK] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 进程管理与通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signal </tag>
            
            <tag> Linux 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析 Android M 锁屏密码存储方式</title>
      <link href="/2016/06/26//lockcreen-password.html/"/>
      <url>/2016/06/26//lockcreen-password.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-M-之前锁屏密码的存储"><a href="#Android-M-之前锁屏密码的存储" class="headerlink" title="Android M 之前锁屏密码的存储"></a>Android M 之前锁屏密码的存储</h2><p>在 Android M 之前，锁屏密码的存储格式很简单，其使用了 64 位随机数作为 salt 值，此 salt 值被存储在 SQLite 数据库 <code>/data/system/locksettings.db</code> 中。密码在存储的时候，会将输入的密码加上此随机数组成新的字符串。然后对新的字符串分别进行 SHA-1 和 MD5 加密，将加密后的密文通过 MD5 + SHA-1 的方式进行字符串拼接，组成新的密文存储在 <code>/data/system/password.key</code> 中，共有 72 位。其加密后的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;data&#x2F;system # cat password.key</span><br><span class="line">B40C2F6FE4E89F3386D4E689B135304410D64951914FB35770FDAC58B694177B29297A80</span><br></pre></td></tr></table></figure><p>而密码的详细信息，存储在 <code>/data/system/device_policies.xml</code> 中，内容类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;data&#x2F;system # cat device_policies.xml</span><br><span class="line">&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39; standalone&#x3D;&#39;yes&#39; ?&gt;</span><br><span class="line">&lt;policies setup-complete&#x3D;&quot;true&quot;&gt;</span><br><span class="line">&lt;active-password quality&#x3D;&quot;196608&quot; length&#x3D;&quot;4&quot; uppercase&#x3D;&quot;0&quot; lowercase&#x3D;&quot;0&quot; letters&#x3D;&quot;0&quot; numeric&#x3D;&quot;4&quot; symbols&#x3D;&quot;0&quot; nonletter&#x3D;&quot;4&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;policies&gt;</span><br></pre></td></tr></table></figure><p>其中主要用到的两个字段 quality 是密码的类型，简单密码和复杂密码的值不同，length 是密码的长度，其他字段存储密码中各种字符的数量。</p><h2 id="Android-M-中锁屏密码的存储"><a href="#Android-M-中锁屏密码的存储" class="headerlink" title="Android M 中锁屏密码的存储"></a>Android M 中锁屏密码的存储</h2><p>在 Android M 中，锁屏密码的存储格式发生了变化，其默认的存储格式在 <code>/system/gatekeeper/include/gatekeeper/password_handle.h</code> 中描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef uint64_t secure_id_t;</span><br><span class="line">typedef uint64_t salt_t;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * structure for easy serialization</span><br><span class="line"> * and deserialization of password handles.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static const uint8_t HANDLE_VERSION &#x3D; 2;</span><br><span class="line">struct __attribute__ ((__packed__)) password_handle_t &#123;</span><br><span class="line">    &#x2F;&#x2F; fields included in signature</span><br><span class="line">    uint8_t version;</span><br><span class="line">    secure_id_t user_id;</span><br><span class="line">    uint64_t flags;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fields not included in signature</span><br><span class="line">    salt_t salt;</span><br><span class="line">    uint8_t signature[32];</span><br><span class="line"></span><br><span class="line">    bool hardware_backed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 version 默认是 2，user_id 是 Android 用户 id ，signature 存储的便是密文，hardware_backed 存储的是加密方式，0 表示密文是软件加密，而 1 表示密文是通过 TEE 环境进行加密得到的。</p><p>密码加密后默认以 <code>password_handle_t</code> 格式存储在 <code>/data/system/gatekeeper.password.key</code> 中。密码的生成和校验，在 HAL 层是通过 <code>system/core/gatekeeperd/gatekeeperd.cpp</code> 中的函数实现的。其在系统启动时被注册为 gatekeeperd 服务，服务在启动的时候会调用 <code>GateKeeperProxy()</code> 对象，此类的构造函数会去查找 TEE module，如果找到，则通过 TEE 设备进行加解密，如果没有找到，则通过一个软件设备进行加解密。</p><p>这里主要分析下通过软甲设备解密的逻辑。解密时，会调用到 <code>system/core/gatekeeperd/gatekeeperd.cpp</code> 中的以下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int verify(uint32_t uid, const uint8_t *enrolled_password_handle,</span><br><span class="line">            uint32_t enrolled_password_handle_length,</span><br><span class="line">            const uint8_t *provided_password, uint32_t provided_password_length,</span><br><span class="line">            bool *request_reenroll)</span><br></pre></td></tr></table></figure><p>在此函数中，由于没有使用 TEE，所以会调用到软件设备验证 <code>system/core/gatekeeperd/SoftGateKeeperDevice.cpp</code> 中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int SoftGateKeeperDevice::verify(uint32_t uid,</span><br><span class="line">uint64_t challenge, const uint8_t *enrolled_password_handle,</span><br><span class="line">uint32_t enrolled_password_handle_length, const uint8_t *provided_password,</span><br><span class="line">uint32_t provided_password_length, uint8_t **auth_token, uint32_t *auth_token_length,</span><br><span class="line">bool *request_reenroll)</span><br></pre></td></tr></table></figure><p>函数进行校验，此函数对传进来的信息进行处理后交到 <code>system/gatekeeper/gatekeeper.cpp</code> 中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void GateKeeper::Verify(const VerifyRequest &amp;request, VerifyResponse *response)</span><br></pre></td></tr></table></figure><p>进行处理，在这里对参数进行一系列处理和重新组织后再交给</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool GateKeeper::DoVerify(const password_handle_t *expected_handle, const SizedBuffer &amp;password)</span><br></pre></td></tr></table></figure><p>进行校验，在此函数中，再调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool GateKeeper::CreatePasswordHandle(SizedBuffer *password_handle_buffer, salt_t salt,</span><br><span class="line">secure_id_t user_id, uint64_t flags, uint8_t handle_version, const uint8_t *password,</span><br><span class="line">uint32_t password_length)</span><br></pre></td></tr></table></figure><p>将上面提到的 <code>/data/system/gatekeeper.password.key</code> 文件中存储的信息进行解析，然后调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ComputePasswordSignature(password_handle-&gt;signature, sizeof(password_handle-&gt;signature),</span><br><span class="line">            password_key, password_key_length, to_sign, sizeof(to_sign), salt);</span><br></pre></td></tr></table></figure><p>函数将输入的密码进行加密，从这里可以看到，输入的密码要加密成密文只需要用到存储的密码中的 salt 值，此函数在 <code>system/core/gatekeeperd/SoftGateKeeper.h</code> 中，其调用 crypto 库中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crypto_scrypt(password, password_length, reinterpret_cast&lt;uint8_t *&gt;(&amp;salt),</span><br><span class="line">sizeof(salt), N, r, p, signature, signature_length);</span><br></pre></td></tr></table></figure><p>将输入的密码存储在 signature 中并返回。此函数最终会通过 SHA256 进行加密，参数中的 N, r, p 默认为如下值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static const uint64_t N &#x3D; 16384;</span><br><span class="line">static const uint32_t r &#x3D; 8;</span><br><span class="line">static const uint32_t p &#x3D; 1;</span><br></pre></td></tr></table></figure><p>通过以上处理后对输入的密码加密后得到的密文与手机中存储的密文进行比较后返回校验结果，从而判断输入的密码的正确与否。</p><p>在 Android M 中，改变了之前直接在 Java 层进行密码校验的方式，将密码的校验通过 HAL 层的服务进行处理，同时加入对 TEE 的支持，使得锁屏密码的安全性大大提升，同时也可以方便的支持其他的安全特性，提升了整个系统的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> lockcreen </tag>
            
            <tag> 锁屏 </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球面拟合算法</title>
      <link href="/2016/06/19//nonlinear-regression.html/"/>
      <url>/2016/06/19//nonlinear-regression.html/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在传感器数据融合以及工业测量中，常常需要对已知的数据或者是已知的结构的特征参数进行检测，来评估数据的信噪比或者结构的质量是否符合产品的需求。一般的，可以通过记录大量数据或者通过结构的离散点，来反解出它的特征参数。<br>以球面为例，这些特征参数可以是球的半径，或者是球心等。对于球体拟合算法，通常有代数拟合和几何拟合。在本例中，以一般的代数拟合方法为主进行介绍。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>以下图的数据为例，我们可以明显看出这些数据“可能”是一个球体，那么我们应该如何来得到这个球体的半径以及球心？</p><p><img src="/images/posts/2016/06/pic1.png" alt="拟合前示意图"></p><p>从如此多的数据中很明显可以看到，最后的执行方程组肯定是超定方程组。正常来看，超定方程组是没有解的，但在数值计算领域我们可以以最优解的形式来获得我们想要的参数。正所谓，有总比没有好，迟到总比不到好，是吧。</p><p>话不多说，原始数据经过剔除异常点以及滤波之后，我们假设这些离散点为</p><p>Pi = (Xi,Yi,Zi), i = 1，2，…，n</p><p>假如球的球心m为 (a,b,c)，球的半径为 r，则球的标准方程为</p><p>(x-a)^2 + (y-b)^2 + (z-c)^2 = r^2</p><p>以 Di 表示离散点 Pi 到 m 的距离，即</p><p>Di^2 = (Xi-a)^2 + (Yi-b)^2 + (Zi-c)^2, i = 1，2，…，n。</p><p>令残差平方和 S = <img src="/images/posts/2016/06/chart.png" alt=""><br>其中 i = 1，2，…，n。</p><p>为了选取最合适的让该等式”尽量成立”，只需要让 S 为最小值即可。也就是说，b` = argmin(S)。而且很明显，S 肯定存在大于或等于 0 的极小值。由逼近算法可以罗列出超定方程组，在这里，我们将球的标准方程展开然后代入 S 中，将 S 对其中的未知数求偏导，令偏导为 0，得到极值点，比较之后即可得到最小值。由于解方程是比较基础的内容，本例中就不罗列出来了。</p><p>这个时候，就可以将 b` 中的数据直接代入球的标准方程，看看是否得到了我们想要的球面。一般的，可以直接得到比较好的球面了。</p><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>这个时候还没有结束，我们还需要对我们所得到的球面进行评定，看看是否误差在允许的范围之内，这个范围取决于个人或者组织对产品的定义。我们可以将所得到的最优解 b` 以及离散点Pi的均方误差作为评定的参考，假如均方误差不在允许范围之内，可以再次进行剔除异常值还有滤波，一直迭代，直到数据满足要求。</p><h2 id="原理扩展"><a href="#原理扩展" class="headerlink" title="原理扩展"></a>原理扩展</h2><p>从上述例子中，我们可以知道，该算法不仅可以从大量已知数据得出最优解，也可以从四个不共面的点来确定一球面，甚至可以通过结构的球冠来得到最匹配的球面。</p><p>下图是经过剔除异常值并且滤波之后，由上述逼近算法拟合得到的最优解。</p><p><img src="/images/posts/2016/06/pic2.png" alt="最优解拟合图"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个案例还比较容易，因为仅有 4 个未知量，而且也不需要考虑三维空间旋转。如果大伙搞懂了这个，下次再来给大伙讲讲二次曲面/椭球拟合算法（结合三维空间旋转，大概 10 个未知数）或者扩展卡尔曼滤波结合四元数进行姿态解算。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《概率论与数理统计》（第 4 版）盛骤</p>]]></content>
      
      
      <categories>
          
          <category> 传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> sensors </tag>
            
            <tag> 球面拟合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机系统综述 —— ISP</title>
      <link href="/2016/06/05//camera-isp-intro.html/"/>
      <url>/2016/06/05//camera-isp-intro.html/</url>
      
        <content type="html"><![CDATA[<p>ISP(Image Signal Processor)，即图像信号处理器，用于处理图像信号传感器输出的图像信号。它在相机系统中占有核心主导的地位，是构成相机的重要设备。</p><h2 id="主要内部构成"><a href="#主要内部构成" class="headerlink" title="主要内部构成"></a>主要内部构成</h2><p>如下图所示，ISP 内部包含 CPU、SUP IP、IF 等设备，事实上，可以认为 ISP 是一个 SOC，可以运行各种算法程序，实时处理图像信号。<br><img src="/images/posts/2016/06/isp_archi.PNG" alt="ISP 架构"></p><ul><li><p>CPU</p><p>CPU 即中央处理器，可以运行 AF、LSC 等各种图像处理算法，控制外围设备。现代的 ISP 内部的 CPU 一般都是 ARM Cortex-A 系列的，例如 Cortex-A5、Cortex-A7。</p></li><li><p>SUB IP</p><p>SUB IP 是各种功能模块的通称，对图像进行各自专业的处理。常见的 SUB IP 如 DIS、CSC、VRA 等。</p></li><li><p>图像传输接口</p><p>图像传输接口主要分两种，并口 ITU 和串口 CSI。CSI 是 MIPI CSI 的简称，鉴于 MIPI CSI 的诸多优点，在手机相机领域，已经广泛使用 MIPI-CSI 接口传输图像数据和各种自定义数据。外置 ISP 一般包含 MIPI-CSIS 和 MIPI-CSIM 两个接口。内置 ISP 一般只需要 MIPI-CSIS 接口。</p></li><li><p>通用外围设备</p><p>通用外围设备指 I2C、SPI、PWM、UART、WATCHDOG 等。ISP 中包含 I2C 控制器，用于读取 OTP 信息，控制 VCM 等。对于外置 ISP，ISP 本身还是 I2C 从设备。AP 可以通过 I2C 控制 ISP 的工作模式，获取其工作状态等。</p></li></ul><h2 id="主要功能特性"><a href="#主要功能特性" class="headerlink" title="主要功能特性"></a>主要功能特性</h2><p>ISP 作为图像处理的核心器件，拥有十分重要的功能，下图展示了 ISP 处理图像数据的基本流程。</p><p><img src="/images/posts/2016/06/isp_process.jpg" alt="ISP 处理流程"></p><p>下面针对 ISP 的主要功能特性进行下介绍。</p><ul><li><p>DEMOSAIC</p><p>DEMOSAIC 是 ISP 的主要功能之一。SENSOR 的像素点上覆盖着 CFA，光线通过 CFA 后照射到像素上。CFA 由 R、G、B 三种颜色的遮光罩组成，每种遮光罩只允许一种颜色通过，因此每个像素输出的信号只包含 R、G、B 三者中的一种颜色信息。SENSOR 输出的这种数据就是 BAYER 数据，即通常所说的 RAW 数据。显而易见，RAW 数据所反映的颜色信息不是真实的颜色信息。DEMOSAIC 就是通过插值算法将将每个像素所代表的真实颜色计算出来。</p></li><li><p>FOCUS</p><p>根据光学知识，景物在传感器上成像最清晰时处于合焦平面上。通过更改 LENS 的位置，使得景物在传感器上清晰的成像，是 ISP FOCUS 功能所需要完成的任务。FOCUS 分为手动和自动两种模式。ISP 可以运行 CONTRAST AF、PDAF、LASER AF 等算法实现自动对焦。</p></li><li><p>EXPOSURE</p><p>曝光。EXPOSURE 主要影响图像的明暗程度。ISP 需要实现 AE 功能，通过控制曝光程度，使得图像亮度适宜。</p></li><li><p>WB</p><p>白平衡。白平衡与色温相关，用于衡量图像的色彩真实性和准确性。ISP需要实现 AWB 功能，力求在各种复杂场景下都能精确的还原物体本来的颜色。</p></li><li><p>LSC</p><p>用于消除图像周边和图片中心的不一致性，包含亮度和色度两方面。ISP 需要借助 OTP 中的校准数据完成 LSC 功能。</p></li><li><p>GAMMA CORRECTION</p><p>伽玛校正。传感器对光线的响应和人眼对光线的响应是不同的。伽玛校正就是使得图像看起来符合人眼的特性。</p></li><li><p>CROP/RESIZE</p><p>图像剪裁，即改变图像的尺寸。可用于输出不同分辨率的图像。</p></li><li><p>VRA</p><p>视觉识别。用于识别特定的景物，例如人脸识别，车牌识别。ISP 通过各种 VRA 算法，准确的识别特定的景物。</p></li><li><p>DRC</p><p>动态范围校正。动态范围即图像的明暗区间。DRC 可以使得暗处的景物不至于欠曝，而亮处的景物不至于过曝。ISP 需要支持 DRC 功能。</p></li><li><p>CSC</p><p>颜色空间转换。例如，ISP 会将 RGB 信号转化为 YUV 信号输出。</p></li><li><p>IS</p><p>图像稳定。IS 的主要作用是使得图像不要因为手持时轻微的抖动而模糊不清。IS 有很多种，例如 OIS、DIS、EIS。ISP 可以实现 DIS 和 EIS。</p></li></ul><p>事实上，ISP 除了上面提到的主要功能外，还需要支持 DENOISE、CONTRAST、SATURATION、SHARPNESS 等调整功能。</p><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><p>这里所说的控制方式是 AP 对 ISP 的操控方式。</p><ul><li><p>I2C/SPI</p><p>这一般是外置 ISP 的做法。SPI 一般用于下载固件、I2C 一般用于寄存器控制。在内核的 ISP 驱动中，外置 ISP 一般是实现为 I2C 设备，然后封装成 V4L2-SUBDEV。</p></li><li><p>MEM MAP</p><p>这一般是内置 ISP 的做法。将 ISP 内部的寄存器地址空间映射到内核地址空间，</p></li><li><p>MEM SHARE</p><p>这也是内置 ISP 的做法。AP 这边分配内存，然后将内存地址传给 ISP，二者实际上共享同一块内存。因此 AP 对这段共享内存的操作会实时反馈到 ISP 端。</p></li></ul><h2 id="ISP-架构方案"><a href="#ISP-架构方案" class="headerlink" title="ISP 架构方案"></a>ISP 架构方案</h2><p>上文多次提到外置 ISP 和内置 ISP，这实际上是 ISP 的架构方案。</p><h3 id="外置-ISP-架构"><a href="#外置-ISP-架构" class="headerlink" title="外置 ISP 架构"></a>外置 ISP 架构</h3><p>外置 ISP 架构是指在 AP 外部单独布置 ISP 芯片用于图像信号处理。外置 ISP 的架构图一般如下所示：</p><p><img src="/images/posts/2016/06/isp_ext.PNG" alt="外置 ISP 架构图"></p><p>外置 ISP 架构的优点主要有：</p><ul><li><p>能够提供更优秀的图像质量</p><p>在激烈的市场竞争下，能够存活到现在的外置 ISP 生产厂商在此领域一般都有很深的造诣，积累了丰富的影像质量调试经验，能够提供比内置 ISP 更优秀的性能和效果。因此，选用优质的外置 ISP 能提供专业而且优秀的图像质量。</p></li><li><p>能够支援更丰富的设计规划</p><p>外置 ISP 的选型基本不受 AP 的影响，因此魅族可以从各个优秀 ISP 芯片供应商的众多产品中甄选最合适的器件，从而设计出更多优秀的产品。</p></li><li><p>能够实现产品的差异化</p><p>内置 ISP 是封装在 AP 内部的，是和 AP 紧密的联系在一起，如果 AP 相同，那么 ISP 也就是一样的。因此基于同样 AP 生产出来的手机，其 ISP 的性能也是一样的，可供调教的条件也是固定的，这样就不利于实现产品的差异化。而如果选择外置 ISP，那么同一颗 AP，可以搭配不同型号的 ISP，这样可以实现产品的差异化，为给用户提供更丰富和优质的产品。</p></li></ul><p>外置 ISP 架构的缺点主要有：</p><ul><li><p>成本价格高</p><p>外置 ISP 需要单独购买，其售价往往不菲，而且某些特殊功能还需要额外支付费用。使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件。</p></li><li><p>开发周期长</p><p>外置 ISP 驱动的设计需要多费精力和时间。使用外置 ISP 时，AP 供应商提供的 ISP 驱动就无法使用，需要额外设计编写外置 ISP 驱动。另外，为了和 AP 进行完美的搭配，将效果最大化，也往往需要付出更多的调试精力。上文也提到，使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件，这也是需要花费时间进行处理的。</p></li></ul><h3 id="内置-ISP-架构"><a href="#内置-ISP-架构" class="headerlink" title="内置 ISP 架构"></a>内置 ISP 架构</h3><p>内置 ISP 架构是指在 AP 内部嵌入了 ISP IP，直接使用 AP 内部的 ISP 进行图像信号处理。<br>内置 ISP 的架构图一般如下所示：</p><p><img src="/images/posts/2016/06/isp_int.PNG" alt="内置 ISP 架构图"></p><p>内置 ISP 架构的优点主要有：</p><ul><li><p>能降低成本价格</p><p>内置 ISP 内嵌在 AP 内部，因此无需像外置 ISP 一样需要额外购买，且不占 PCB 空间，无需单独为其设计外围电路，这样就能节省 BOM，降低成本。鉴于大多数用户在选购手机时会将价格因素放在重要的位置，因此降低成本能有效的降低终端成品价格，有利于占领市场。</p></li><li><p>能提高产品的上市速度</p><p>内置 ISP 和 AP 紧密结合，无需进行原理图设计和 LAYOUT 设计，因此可以减小开发周期，加快产品上市的速度。</p></li><li><p>能降低开发难度</p><p>如果使用内置 ISP，那么 AP 供应商能在前期提供相关资料，驱动开发人员可以有充足的时间熟悉相关资料，而且不会存在软件版本适配问题，也不存在平台架构兼容性问题。但是，如果使用外置 ISP，那么 ISP 供应商往往都不能提供针对某个平台的代码/资料，而且一般都存在软件版本兼容问题，这就需要驱动开发人员付出额的经历和时间。</p></li></ul><p>使用内置 ISP 当然也有相应的不足之处，具体见上文的分析，这里就不赘述了。</p><p>事实上，鉴于 ISP 的重要性，为了推广其 AP，提高其 AP 竞争力，现在 AP 内置的 ISP 也越来越强大，其性能足以满足手机市场的需求。再加上其一系列优点，现在使用内置 ISP 方案的手机越来越多。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ISP 是相机系统中重要的组成部分，要了解相机系统，就不能不熟悉 ISP。本文从 ISP 内部构成、功能特性、操控方式等角度介绍了 ISP 的各方面知识。另外，本文还详细的分析了两种架构的 ISP 方案的优缺点，希望能有所裨益。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://source.android.com/devices/camera/index.html" target="_blank" rel="noopener">Google Camera</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPUIDLE 之低功耗定时器</title>
      <link href="/2016/05/28//cpuidle.html/"/>
      <url>/2016/05/28//cpuidle.html/</url>
      
        <content type="html"><![CDATA[<p>在 Linux 操作系统中，Idle 进程（又叫 Swapper 进程）的 pid 号是 0，是所有进程的祖先，它是在 Linux 初始化阶段从无到有创建的一个内核线程。<code>stark_kernel()</code> 函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程 1 的内核线程（init 进程）。新创建内核线程的 PID 为 1，并与进程 0 共享进程所有的内核数据结构。创建 init 进程后，进程 0 执行无限循环， <code>cpu_idle_loop()</code> 函数，只有当没有其它进程处于 TASK_RUNNING 状态时，调度器才会选择进程 0，也就是执行 Idle 线程，让 CPU 进入 Idle 模式。</p><p>当 CPU 进入比较深层次的 Idle 模式时，为了达到最大程度的节省功耗，CPU 会把系统时钟给关闭掉。那么怎么保证 CPU 从 Idle 模式重新进入工作模式，从而保证系统正常运行呢？本文主要探讨低功耗定时器在该情况下扮演什么样的角色。</p><h2 id="Idle的执行流程"><a href="#Idle的执行流程" class="headerlink" title="Idle的执行流程"></a>Idle的执行流程</h2><p>这里先大概的列出 Idle 进程的执行流程，怎么执行到让 CPU 进入各级 Idle 模式。详细的分析会在以后的文章中补上。</p><h3 id="Idle-进程创建"><a href="#Idle-进程创建" class="headerlink" title="Idle 进程创建"></a>Idle 进程创建</h3><p>Linux Kernel 会在系统启动完成后，在 Idle 进程中，处理 CPUIdle 相关的事情。在多核系统中，CPU 启动的过程是，先启动主 CPU，启动过程和传统的单核系统类似。其函数调用关系如下：</p><p>stext —&gt; start_kernel —&gt; rest_init —&gt; cpu_startup_entry</p><p>而启动其它 CPU，可以有多种方式，例如 CPU hotplug 等，启动过程：</p><p>secondary_startup —&gt; __secondary_switched —&gt; secondary_start_kernel —&gt; cpu_startup_entry</p><p>无论是上述的哪种启动，最终都会运行至 cpu_startup_entry 函数，在这个函数中，最终程序会掉进无限循环里 cpu_idle_loop。到此，Idle 进程创建完成，以下是 Idle 进程的代码实现（参考的是 linux-3.18 版本）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">__current_set_polling();</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭周期 tick，CONFIG_NO_HZ_IDLE 必须打开 *&#x2F;</span><br><span class="line">tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">&#x2F;* 如果系统当前不需要调度，执行后续的动作 *&#x2F;</span><br><span class="line">while (!need_resched()) &#123;</span><br><span class="line">check_pgt_cache();</span><br><span class="line">rmb();</span><br><span class="line"></span><br><span class="line">if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line">tick_set_cpu_plugoff_flag(1);</span><br><span class="line">arch_cpu_idle_dead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭 irq 中断 *&#x2F;</span><br><span class="line">local_irq_disable();</span><br><span class="line"></span><br><span class="line">&#x2F;* arch 相关的 cpuidle enter, 主要执行注册到 idle 的 notify callback *&#x2F;</span><br><span class="line">arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line"></span><br><span class="line">&#x2F;* idle poll，这时先不分析 *&#x2F;</span><br><span class="line">cpu_idle_poll();</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">&#x2F;* 进入 CPU 的 Idle 模式，进行省电 *&#x2F;</span><br><span class="line">cpuidle_idle_call();</span><br><span class="line"></span><br><span class="line">&#x2F;* Idle 退出, 主要执行注册到 idle 的 notify callback *&#x2F;</span><br><span class="line">arch_cpu_idle_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 如果系统当前需要调度，则退出 Idle 进程 *&#x2F;</span><br><span class="line">preempt_set_need_resched();</span><br><span class="line"></span><br><span class="line">&#x2F;* 打开周期 tick *&#x2F;</span><br><span class="line">tick_nohz_idle_exit();</span><br><span class="line">__current_clr_polling();</span><br><span class="line"></span><br><span class="line">smp_mb__after_atomic();</span><br><span class="line"></span><br><span class="line">sched_ttwu_pending();</span><br><span class="line"></span><br><span class="line">&#x2F;* 让出 cpu，使调度器调度其它优化级更高的进程 *&#x2F;</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tickless-和-CPUIdle-的关系"><a href="#Tickless-和-CPUIdle-的关系" class="headerlink" title="Tickless 和 CPUIdle 的关系"></a>Tickless 和 CPUIdle 的关系</h2><p>Tickless 是指动态时钟，即系统的周期 Tick 可动态地关闭和打开。这个功能可通过内核配置项 CONFIG_NO_HZ 打开，而 Idle 正是使用了这项技术，使系统尽量长时间处于空闲状态，从而尽可能地节省功耗.</p><p>打开内核配置项 CONFIG_NO_HZ_IDLE，即可让系统在 Idle 前关闭周期 Tick，退出 Idle 时重新打开周期 Tick。</p><p>那么在关闭了周期 Tick 之后，系统何时被唤醒呢？</p><p>在关闭周期 Tick 时，同时会根据时钟子系统计算下一个时钟中断到来的时间，以这个时间为基准来设置一个 hrtimer 用于唤醒系统（高精度时钟框架），而这个时间的计算方法也很简单，即在所有注册到时钟框架的定时器中找到离此时最近的那一个的时间点作为这个时间。当然，用什么定时器来唤醒系统还要根据 CPU Idle 的深度来决定，后面会介绍。</p><h2 id="不同层级的-CPU-Idle-对唤醒时钟源的处理"><a href="#不同层级的-CPU-Idle-对唤醒时钟源的处理" class="headerlink" title="不同层级的 CPU Idle 对唤醒时钟源的处理"></a>不同层级的 CPU Idle 对唤醒时钟源的处理</h2><p>前面提到了，系统关闭周期 Tick 的同时，会计算出下一个时钟中断到来的时间，以这个时间为基准来设置一个 hrtimer 用于唤醒系统。那么，如果有些 CPU 进入的层级比较深，关闭了 CPU 中的 hrtimer，系统将无法再次被唤醒。针对这种情况，则需要低功耗 Timer 去唤醒系统，这里先以 MTK 平台为例，在 CPU 进入 dpidle 和 soidle （两种 Idle 模式）时都会关闭 hrtimer ，另外起用一个 GPT Timer，而这个 GPT Timer 的超时时间直接从被关闭的 hrtimer 中的寄存器获取。这样就保证时间的延续性。因为 GPT Timer 是以 32K 晶振作为时钟源，所以在 CPU 进入 dpidle 时可以把 26M 的主时钟源给关闭，从而达到最大程度的省电。</p><p>以下我们通过源码探讨一下 MTK 的 CPU Idle 的实现，到底哪里设置 GPT Timer。其实很多平台为了实现 CPU 达到最省电的效果，都是使用这种做法。</p><p>MTK 的 CPU 一般有以下几种 Idle 模式</p><ul><li>rgidle，浅度 Idle 模式，即 WFI</li><li>soidle，亮屏 Idle 模式</li><li>dpidle，灭屏 Idle 模式</li></ul><p>先以 dpidle 模式为例子分析 CPU 如何在关闭所有系统时钟的情况下保证 Idle 和系统正常运行。</p><p>CPU 进入 dpidle 的实现接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int dpidle_enter(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; IDLE_TYPE_DP;</span><br><span class="line"></span><br><span class="line">&#x2F;* 记录 dpidle 的开始时间 *&#x2F;</span><br><span class="line">idle_ratio_calc_start(IDLE_TYPE_DP, cpu);</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭一些与平台相关的定时器，hps，thermal *&#x2F;</span><br><span class="line">dpidle_pre_handler();</span><br><span class="line"></span><br><span class="line">&#x2F;* 进入 dpidle *&#x2F;</span><br><span class="line">spm_go_to_dpidle(slp_spm_deepidle_flags, (u32)cpu, dpidle_dump_log);</span><br><span class="line"></span><br><span class="line">&#x2F;* 打开一些与平台相关的定时器，hps，thermal *&#x2F;</span><br><span class="line">dpidle_post_handler();</span><br><span class="line"></span><br><span class="line">&#x2F;* 记录 dpidle 的退出时间，从而计算出 CPU 进入 dpidle 的总时间 *&#x2F;</span><br><span class="line">idle_ratio_calc_stop(IDLE_TYPE_DP, cpu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">idle_warn_log(&quot;DP:timer_left&#x3D;%d, timer_left2&#x3D;%d, delta&#x3D;%d\n&quot;,</span><br><span class="line">dpidle_timer_left, dpidle_timer_left2, dpidle_timer_left-dpidle_timer_left2);</span><br><span class="line"></span><br><span class="line">&#x2F;* For test *&#x2F;</span><br><span class="line">if (dpidle_run_once)</span><br><span class="line">idle_switch[IDLE_TYPE_DP] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正进入 dpidle 的实现在 spm_go_to_dpidle 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">wake_reason_t spm_go_to_dpidle(u32 spm_flags, u32 spm_data, u32 dump_log)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 更新 spm 的标志 *&#x2F;</span><br><span class="line">update_pwrctrl_pcm_flags(&amp;spm_flags);</span><br><span class="line">&#x2F;* 设置 spm 标志位 *&#x2F;</span><br><span class="line">set_pwrctrl_pcm_flags(pwrctrl, spm_flags);</span><br><span class="line"></span><br><span class="line">&#x2F;* 设置 GPT4 定时器，超时时间为下一个 Timer 的唤醒时间，并开启 GPT4 定时器 *&#x2F;</span><br><span class="line">spm_dpidle_before_wfi(cpu);</span><br><span class="line"></span><br><span class="line">lockdep_off();</span><br><span class="line">spin_lock_irqsave(&amp;__spm_lock, flags);</span><br><span class="line">&#x2F;* 屏蔽 GIC 控制器中的所有中断 *&#x2F;</span><br><span class="line">mt_irq_mask_all(&amp;mask);</span><br><span class="line">&#x2F;* 打开 GIC 中 SPM_IRQ0_ID 号中断，用于唤醒 *&#x2F;</span><br><span class="line">mt_irq_unmask_for_sleep(SPM_IRQ0_ID);</span><br><span class="line"></span><br><span class="line">if (request_uart_to_sleep()) &#123;</span><br><span class="line">wr &#x3D; WR_UART_BUSY;</span><br><span class="line">goto RESTORE_IRQ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭系统时钟 *&#x2F;</span><br><span class="line">spm_dpidle_pre_process();</span><br><span class="line">&#x2F;* 进入 Idle *&#x2F;</span><br><span class="line">spm_trigger_wfi_for_dpidle(pwrctrl);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">RESTORE_IRQ:</span><br><span class="line">mt_irq_mask_restore(&amp;mask);</span><br><span class="line">spin_unlock_irqrestore(&amp;__spm_lock, flags);</span><br><span class="line">lockdep_on();</span><br><span class="line">spm_dpidle_after_wfi(cpu, wakesta.debug_flag);</span><br><span class="line"></span><br><span class="line">return wr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 spm_dpidle_before_wfi 函数中会去设置 GPT Timer 的定时时间，并且开启这个 Timer，设置完毕后关闭 GIC 的所有中断，只打开 GPT Timer IRQ，保证 CPU 在定时时间到期时被 GPT Timer 唤醒。最后调用 spm_dpidle_pre_process 和 spm_trigger_wfi_for_dpidle 函数关闭系统时钟并进入 dpidle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void spm_dpidle_before_wfi(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">bus_dcm_enable();</span><br><span class="line">faudintbus_pll2sq();</span><br><span class="line"></span><br><span class="line">&#x2F;* 从 localtimer 中获取定时器计数 *&#x2F;</span><br><span class="line">dpidle_timer_left2 &#x3D; localtimer_get_counter();</span><br><span class="line"></span><br><span class="line">if ((int)dpidle_timer_left2 &lt;&#x3D; 0)</span><br><span class="line">&#x2F;* Trigger GPT4 Timeout imediately *&#x2F;</span><br><span class="line">gpt_set_cmp(idle_gpt, 1);</span><br><span class="line">else</span><br><span class="line">&#x2F;* 把从 localtimer 中获取到的定时器计数设置到 GPT Timer 中 *&#x2F;</span><br><span class="line">gpt_set_cmp(idle_gpt, dpidle_timer_left2);</span><br><span class="line"></span><br><span class="line">&#x2F;* 启动 GPT Timer *&#x2F;</span><br><span class="line">start_gpt(idle_gpt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>localtimer_get_counter 函数中其实就是读取 hrtimer 的定时器里的剩下计数 count，然后把 count 设置到 GPT Timer 中，这种做法非常简便和巧妙。这样就能保障系统的正常运行又能达到最省电的效果了。</p>]]></content>
      
      
      <categories>
          
          <category> 电源管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> cpuidle </tag>
            
            <tag> hrtimer </tag>
            
            <tag> tickless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zram 简介</title>
      <link href="/2016/05/21//zram-introduction.html/"/>
      <url>/2016/05/21//zram-introduction.html/</url>
      
        <content type="html"><![CDATA[<h2 id="zram-技术的由来"><a href="#zram-技术的由来" class="headerlink" title="zram 技术的由来"></a>zram 技术的由来</h2><p>zram<sup><a href="#fn_zram_tech" id="reffn_zram_tech">zram_tech</a></sup>（也称为 zRAM，先前称为 compcache）是 Linux 内核的一项功能，可提供虚拟内存压缩。zram 通过在 RAM 内的压缩块设备上分页，直到必须使用硬盘上的交换空间，以避免在磁盘上进行分页，从而提高性能。由于 zram 可以用内存替代硬盘为系统提供交换空间的功能，zram 可以在需要交换 / 分页时让 Linux 更好利用 RAM ，在物理内存较少的旧电脑上尤其如此。</p><p>即使 RAM 的价格相对较低，zram 仍有利于嵌入式设备、上网本和其它相似的低端硬件设备。这些设备通常使用固态存储，它们由于其固有性质而寿命有限，因而避免以其提供交换空间可防止其迅速磨损。此外，使用 zRAM 还可显著降低 Linux 系统用于交换的 I/O 。</p><p>zram 在 2009 年的时候就进了 kernel 的 staging 目录，并于 2014 年 3 月 30 日发布的 3.14 版本正式合并入 Linux 内核主线。在 2014 年 6 月 8 日发布的 3.15 版本的 Linux 内核中，zram 已可支持 LZ4 压缩算法，而 LZO 仍然作为默认的压缩后端。内核 3.15 中的修改还改进了性能，以及经由 sysfs 切换压缩算法的能力。</p><p>Lubuntu 于 13.10 开始使用 zram 。截至 2012 年 12 月，Ubuntu 考虑为小内存的计算机默认启用 zram 。 Google 在 Chrome OS 中使用 zram，它也成为了 Android 4.4 及以后版本设备的一个选项。</p><p>本文主要介绍在 Android 设备上使用的 zram swap，它可以让小内存的设备在多任务的情况下切换自如，提高用户体验。</p><p>zram swap 主要原理就是从内存分配一块区域出来用作 swap 分区，每次如果内存空间不够了，不是把应用程序杀掉，而是把应用程序所占用的内存数据复制到 swap 分区，等切换回来的时候就可以直接把这部分数据恢复到内存当中，节省重新开启所需的时间。而被放到 swap 分区的应用程序，所占用的内存都是被压缩过的，比如，微信在普通内存中占用 50 MB 的空间，如果压缩率为 0.4，则放到 swap 分区里面的数据只需要 20 MB 的空间，这样 swap 分区里面就可以存放更多后台临时不用的应用程序，变相扩展了内存的大小。</p><h2 id="zram-配置步骤"><a href="#zram-配置步骤" class="headerlink" title="zram 配置步骤"></a>zram 配置步骤</h2><h3 id="1-内核配置zram-doc"><a href="#1-内核配置zram-doc" class="headerlink" title="1. 内核配置zram_doc"></a>1. 内核配置<sup><a href="#fn_zram_doc" id="reffn_zram_doc">zram_doc</a></sup></h3><ul><li><p>3.15 之前版本的 kernel</p><p>Device Drivers -&gt; Staging drivers (STAGING [=y])</p></li><li><p>3.15 及之后版本的 kernel</p><p>Device Drivers -&gt; [*] Block devices -&gt; <M> Compressed RAM block device support</p></li><li><p>具体的配置项如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_RESOURCE_COUNTERS&#x3D;y</span><br><span class="line">CONFIG_MEMCG&#x3D;y</span><br><span class="line">CONFIG_MEMCG_SWAP&#x3D;y</span><br><span class="line">CONFIG_MEMCG_SWAP_ENABLED&#x3D;y</span><br><span class="line">CONFIG_MEMCG_KMEM&#x3D;y</span><br><span class="line">CONFIG_ZRAM&#x3D;y</span><br><span class="line">CONFIG_TOI_ZRAM_SUPPORT&#x3D;y</span><br><span class="line">CONFIG_ZRAM_DEBUG&#x3D;y</span><br></pre></td></tr></table></figure><h3 id="2-zram-块设备个数设定"><a href="#2-zram-块设备个数设定" class="headerlink" title="2. zram 块设备个数设定:"></a>2. zram 块设备个数设定:</h3><ul><li>如果是将 zram 编译成模块，则可以使用下面命令动态加载，这个命令会创建 4 个设备 /dev/zram{0,1,2,3}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe zram num_devices&#x3D;4</span><br></pre></td></tr></table></figure><ul><li>如果是直接将 zram 编译到内核，那只能在代码里面直接修改 num_devices，3.15 之前的版本代码路径是 drivers/staging/zram/zram_drv.c，3.15 及之后的版本代码路径是  ./drivers/block/zram/zram_drv.c ，默认 zram 设备个数是一个。</li></ul><h3 id="3-压缩流的最大个数设定"><a href="#3-压缩流的最大个数设定" class="headerlink" title="3. 压缩流的最大个数设定"></a>3. 压缩流的最大个数设定</h3><p>这个是 3.15 版本及以后的 kernel 新加入的功能，3.15 版本之前的 zram 压缩都是使用一个压缩流（缓存 buffer 和算法私有部分）实现，每个写（压缩）操作都会独享压缩流，但是单压缩流如果出现数据奔溃或者卡住的现象，所有的写（压缩）操作将一直处于等待状态，这样效率非常低；而多压缩流的架构会让写（压缩）操作可以并行去执行，大大提高了压缩的效率和稳定性。</p><ul><li>查看压缩流的最大个数，默认是 1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;max_comp_streams</span><br></pre></td></tr></table></figure><ul><li>设定压缩流的最大个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 3 &gt; &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;max_comp_streams</span><br></pre></td></tr></table></figure><h3 id="4-压缩算法选择"><a href="#4-压缩算法选择" class="headerlink" title="4. 压缩算法选择"></a>4. 压缩算法选择</h3><ul><li>查看目前支持的压缩算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;comp_algorithm</span><br><span class="line">lzo [lz4]</span><br></pre></td></tr></table></figure><ul><li>修改压缩算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo lzo &gt; &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;comp_algorithm</span><br></pre></td></tr></table></figure><h3 id="5-zram-内存大小设定"><a href="#5-zram-内存大小设定" class="headerlink" title="5. zram 内存大小设定"></a>5. zram 内存大小设定</h3><p>分配部分内存作为 zram ，大小建议为总内存的 10%-25% 。</p><ul><li>可以使用数值直接设置内存大小，单位是 bytes</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $((512*1024*1024)) &gt; &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;disksize</span><br></pre></td></tr></table></figure><ul><li>也可以使用带内存单位作为后缀的方式设置内存大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 256K &gt; &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;disksize</span><br><span class="line">echo 512M &gt; &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;disksize</span><br><span class="line">echo 1G &gt; &#x2F;sys&#x2F;block&#x2F;zram0&#x2F;disksize</span><br></pre></td></tr></table></figure><h3 id="6-启用-zram-设备为-swap"><a href="#6-启用-zram-设备为-swap" class="headerlink" title="6. 启用 zram 设备为 swap"></a>6. 启用 zram 设备为 swap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap &#x2F;dev&#x2F;zram0</span><br><span class="line">swapon &#x2F;dev&#x2F;zram0</span><br></pre></td></tr></table></figure><h3 id="7-具体的-zram-相关对外接口说明"><a href="#7-具体的-zram-相关对外接口说明" class="headerlink" title="7. 具体的 zram 相关对外接口说明"></a>7. 具体的 zram 相关对外接口说明</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:center">Access</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">disksize</td><td style="text-align:center">RW</td><td style="text-align:left">显示和设置该块设备的内存大小</td></tr><tr><td style="text-align:left">initstate</td><td style="text-align:center">RO</td><td style="text-align:left">显示设备的初始化状态</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:center">WO</td><td style="text-align:left">重置设备</td></tr><tr><td style="text-align:left">num_reads</td><td style="text-align:center">RO</td><td style="text-align:left">读数据的个数</td></tr><tr><td style="text-align:left">failed_reads</td><td style="text-align:center">RO</td><td style="text-align:left">读数据失败的个数</td></tr><tr><td style="text-align:left">num_write</td><td style="text-align:center">RO</td><td style="text-align:left">写数据的个数</td></tr><tr><td style="text-align:left">failed_writes</td><td style="text-align:center">RO</td><td style="text-align:left">写数据失败的个数</td></tr><tr><td style="text-align:left">invalid_io</td><td style="text-align:center">RO</td><td style="text-align:left">非页面大小对齐的I/O请求的个数</td></tr><tr><td style="text-align:left">max_comp_streams</td><td style="text-align:center">RW</td><td style="text-align:left">最大可能同时执行压缩操作的个数</td></tr><tr><td style="text-align:left">comp_algorithm</td><td style="text-align:center">RW</td><td style="text-align:left">显示和设置压缩算法</td></tr><tr><td style="text-align:left">notify_free</td><td style="text-align:center">RO</td><td style="text-align:left">空闲内存的通知个数</td></tr><tr><td style="text-align:left">zero_pages</td><td style="text-align:center">RO</td><td style="text-align:left">写入该块设备的全为的页面的个数</td></tr><tr><td style="text-align:left">orig_data_size</td><td style="text-align:center">RO</td><td style="text-align:left">保存在该块设备中没有被压缩的数据的大小</td></tr><tr><td style="text-align:left">compr_data_size</td><td style="text-align:center">RO</td><td style="text-align:left">保存在该块设备中已被压缩的数据的大小</td></tr><tr><td style="text-align:left">mem_used_total</td><td style="text-align:center">RO</td><td style="text-align:left">分配给该块设备的总内存大小</td></tr><tr><td style="text-align:left">mem_used_max</td><td style="text-align:center">RW</td><td style="text-align:left">该块设备已用的内存大小，可以写 1 重置这个计数参数到当前真实的统计值</td></tr><tr><td style="text-align:left">mem_limit</td><td style="text-align:center">RW</td><td style="text-align:left">zram 可以用来保存压缩数据的最大内存</td></tr><tr><td style="text-align:left">pages_compacted</td><td style="text-align:center">RO</td><td style="text-align:left">在压缩过程中可用的空闲页面的个数</td></tr><tr><td style="text-align:left">compact</td><td style="text-align:center">WO</td><td style="text-align:left">触发内存压缩</td></tr></tbody></table></div><h3 id="8-系统运行之后的内存统计情况"><a href="#8-系统运行之后的内存统计情况" class="headerlink" title="8. 系统运行之后的内存统计情况"></a>8. 系统运行之后的内存统计情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br><span class="line">1  MemTotal:        1958596 kB</span><br><span class="line">2  MemFree:           40364 kB</span><br><span class="line">3  Buffers:            3472 kB</span><br><span class="line">4  Cached:           328080 kB</span><br><span class="line">5  SwapCached:         1908 kB</span><br><span class="line">6  Active:           906752 kB</span><br><span class="line">7  Inactive:         426648 kB</span><br><span class="line">8  Active(anon):     752824 kB</span><br><span class="line">9  Inactive(anon):   252756 kB</span><br><span class="line">10 Active(file):     153928 kB</span><br><span class="line">11 Inactive(file):   173892 kB</span><br><span class="line">12 Unevictable:        2516 kB</span><br><span class="line">13 Mlocked:               0 kB</span><br><span class="line">14 SwapTotal:        524284 kB</span><br><span class="line">15 SwapFree:         378320 kB</span><br><span class="line">16 Dirty:               480 kB</span><br><span class="line">17 Writeback:             0 kB</span><br><span class="line">18 AnonPages:       1003452 kB</span><br><span class="line">19 Mapped:           167052 kB</span><br><span class="line">20 Shmem:              1184 kB</span><br><span class="line">21 Slab:              83104 kB</span><br><span class="line">22 SReclaimable:      24368 kB</span><br><span class="line">23 SUnreclaim:        58736 kB</span><br><span class="line">24 KernelStack:       48736 kB</span><br><span class="line">25 PageTables:        41908 kB</span><br><span class="line">26 NFS_Unstable:          0 kB</span><br><span class="line">27 Bounce:                0 kB</span><br><span class="line">28 WritebackTmp:          0 kB</span><br><span class="line">29 CommitLimit:     1503580 kB</span><br><span class="line">30 Committed_AS:   94718220 kB</span><br><span class="line">31 VmallocTotal:  251658176 kB</span><br><span class="line">32 VmallocUsed:      181352 kB</span><br><span class="line">33 VmallocChunk:  251373156 kB</span><br></pre></td></tr></table></figure><p>从 Line 14,15 可以看到 swap 相关的统计信息，SwapTotal 的大小就是 zram 设备的大小，当系统开启了一段时间之后，就会将后台的一些优先级低的应用数据（匿名页面）压缩存放到 swap 区，然后再重新打开这些应用的时候，再从 swap 区将它们的数据解压出来。在 Android KitKat 版本之前，Android 设备因为没有 zram，所以查看 /proc/meinfo 看到的 swap 分区的大小和统计数据都会是零。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 Total RAM: 1958596 kB (status normal)</span><br><span class="line">2  Free RAM: 724527 kB (504283 cached pss + 183244 cached kernel + 37000 free)</span><br><span class="line">3  Used RAM: 1014008 kB (656204 used pss + 357804 kernel)</span><br><span class="line">4  Lost RAM: 220061 kB</span><br><span class="line">5      ZRAM: 27296 kB physical used for 145952 kB in swap (524284 kB total swap)</span><br><span class="line">6    Tuning: 256 (large 512), oom 286720 kB, restore limit 95573 kB (high-end-gfx)</span><br></pre></td></tr></table></figure><p>Line 5 也可以看到 swap 相关的统计信息，如果需要查看具体某个进程使用了多少 swap 空间，可以通过 <code>dumpsys meminfo pid</code>（该进程的 id 号）查看。</p><h2 id="zram-具体原理分析"><a href="#zram-具体原理分析" class="headerlink" title="zram 具体原理分析"></a>zram 具体原理分析</h2><p>zram 本质是就是一个块设备，所以下面先简单介绍一下块设备的一些基础知识。</p><h3 id="1-块设备基础概念"><a href="#1-块设备基础概念" class="headerlink" title="1. 块设备基础概念"></a>1. 块设备基础概念</h3><ul><li><p>块设备（block device）</p><p>块设备是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。</p></li><li><p>扇区 (Sectors)</p><p>块设备中最小的可寻址单元，大小一般都是 2 的整数倍，最常见的是 512 字节。</p></li><li><p>块 (Blocks)</p><p>块是文件系统的一种抽象，只能基于块来访问文件系统，块必须是扇区大小的 2 的整数倍，并且要小于页面的大小，所以通常块的大小是 512 字节、1 KB 或 4 KB 。</p></li><li><p>段 (Segments)</p><p>由若干个相邻的块组成，是 Linux 内存管理机制中一个内存页或者内存页的一部分。</p></li><li><p>页面 (Page)</p><p>物理页是 Linux 内存管理的基本单位，一般一个页面是 4KB 或者 64 KB。</p><p><img src="/images/posts/2016/05/Sectors_block_segment.gif" alt="Sectors Block Segment"></p></li></ul><h3 id="2-块设备驱动整体框架block-device"><a href="#2-块设备驱动整体框架block-device" class="headerlink" title="2. 块设备驱动整体框架block_device"></a>2. 块设备驱动整体框架<sup><a href="#fn_block_device" id="reffn_block_device">block_device</a></sup></h3><p>  <img src="/images/posts/2016/05/block_device_arch.gif" alt="Block Device ARCH"></p><h3 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3. 相关数据结构"></a>3. 相关数据结构</h3><ul><li><p>block_device</p><p>描述一个分区或整个磁盘对内核的一个块设备实例。</p></li><li><p>gendisk</p><p>描述一个通用硬盘（generic hard disk）对象。</p></li><li><p>hd_struct</p><p>描述分区应有的分区信息。</p></li><li><p>bio</p><p>描述块数据传送时怎样完成填充或读取块给 driver，既描述了磁盘的位置，又描述了内存的位置。</p></li><li><p>bio_vec</p><p>描述 bio 中的每个段。</p></li><li><p>request</p><p>描述向内核请求一个列表准备做队列处理。</p></li><li><p>request_queue</p><p>描述内核申请 request 资源建立请求链表并填写 bio 形成队列。</p></li></ul><h3 id="4-zram-架构"><a href="#4-zram-架构" class="headerlink" title="4. zram 架构"></a>4. zram 架构</h3><p>zram 从架构上可以分为三部分：</p><ul><li><p>驱动部分</p><p>该部分创建了一个块设备，然后提供了处理 IO 请求的接口；</p></li><li><p>数据流操作部分</p><p>该部分主要提供串行或者并行的压缩和解压操作；</p></li><li><p>解压缩算法部分</p><p>该部分主要是一个个压缩和解压算法，每个算法都提供统一的压缩和解压接口给数据流操作部分调用。</p></li></ul><h3 id="5-zram-驱动部分代码分析"><a href="#5-zram-驱动部分代码分析" class="headerlink" title="5. zram 驱动部分代码分析"></a>5. zram 驱动部分代码分析</h3><ul><li><p>zram_init</p><p>首先调用 register_blkdev 注册块设备驱动到内核中，然后再根据 num_devices 调用 create_device 来创建相应个数的块设备，<br>这里默认是创建一个块设备。</p></li><li><p>create_device</p><p>对于 flash、 RAM 等完全随机访问的非机械设备，并不需要进行复杂的 I/O 调度，所以这里直接调用 blk_alloc_queue 分配一个 “请求队列”，然后使用 blk_queue_make_request 函数绑定分配好的 “请求队列” 和 “请求处理”函数 zram_make_request。接着初始化块设备的操作函数集 zram_devops 及设备容量、名字、队列等其他属性，最后调用 add_disk 将该块设备真正添加到内核中。</p></li><li><p>disksize_store</p><p>zram 使用了 Zsmalloc 分配器来管理它的内存空间，Zsmalloc 分配器尝试将多个相同大小的对象存放在组合页（称为 zspage）中，这个组合页不要求物理连续，从而提高内存的使用率。</p><p>首先会根据 zram 的内存中页面的个数，创建相应个数的 zram table，每个 zram table 都对应一个页面；然后会调用 zs_create_pool 创建一个 zsmalloc 的内存池，以后所有的页面申请和释放都是通过 zs_malloc 和 zs_free 来分配和释放相对应的对象。</p></li><li><p>zram_make_request</p><p>在整个块设备的 I/O 操作中，贯穿于始终的就是“请求”，块设备的 I/O 操作会排队和整合。块设备驱动的任务就是处理请求，对请求的排队和整合则是由 I/O 调度算法解决，因此，zram 块设备驱动的核心这个请求处理函数，所有的 zram I/O 请求都是通过这个请求处理函数来处理的。</p><p>首先它判断这个 I/O 请求是否是有效的，即检测请求是否在 zram 逻辑块的范围以内，且是否对齐。然后调用 __zram_make_request 遍历 bio 中的每个段 bio_vec，根据 bio 的传输方向选择执行写 (zram_bvec_write) 或者读 (zram_bvec_read) 操作。</p></li><li><p>zram_bvec_write</p><p>在写数据之前，首先使用 GFP_NOIO 标志创建一个不允许任何 I/O 初始化的页面，然后将 zram_data 对应的数据先解压出来放到该创建的页面中。接着去调用 zcomp_strm_find 找到一个压缩操作流，如果是单压缩流，则实际调用的是 zcomp_strm_single_find，如果是多压缩流，则实际调用的是 zcomp_strm_multi_find。</p><p>然后，将段 bio_vec 中的页面临时映射到高端地址，并将高端地址空间页面的内容复制到已保存好 zram_data 压缩后的数据的页面。调用 zs_malloc 申请一个 zram table，使 zcomp_compress 压缩内容并将压缩后的内容存放到新申请的 zram table。最后调用 zram_free_page 删除旧内容所占用的 zram table。</p><p>zcomp_decompress 会根据 struct zcomp_backend 初始化时设定的压缩算法来调用相应的解压接口，lzo 压缩算法的解压接口是 lzo_compress ，而 lz4 压缩算法的解压接口是 zcomp_lz4_compress ，该接口还调用了压缩操作流，以此执行串行或者并行写操作。</p></li><li><p>zram_bvec_read</p><p>读操作首先将段 bio_vec 中的页面临时映射到高端地址，然后再调用 zram_decompress_page 将 zram_meta 所对应的数据解压到这块映射的高端内存空间，解压的接口是 zcomp_decompress，它会根据 struct zcomp_backend 初始化时设定的压缩算法来调用相应的解压接口，lzo 压缩算法的解压接口是 lzo_decompress ，而 lz4 压缩算法的解压接口是 zcomp_lz4_decompress 。</p></li></ul><h3 id="6-数据流操作部分代码分析"><a href="#6-数据流操作部分代码分析" class="headerlink" title="6. 数据流操作部分代码分析"></a>6. 数据流操作部分代码分析</h3><ul><li><p>zcomp_create</p><p>若最大可能同时执行压缩操作的个数来调用为一，则调用 zcomp_strm_single_create 来创建一个压缩流，而若最大可能同时执行压缩操作的个数来调用大于一，则调用 zcomp_strm_multi_create 先创建一个压缩流，然后创建一个压缩流链表，并将创建好的压缩流加到压缩流链表中，后面再根据需求来动态创建更多的压缩流。</p></li><li><p>zcomp_strm_multi_find</p><p>单压缩流非常简单，如果前一个压缩操作已经持有 strm_lock 锁，那么下一个压缩操作必须等待前一个压缩操作调用 zcomp_strm_single_release 释放该锁才可以接着执行。</p></li><li><p>zcomp_strm_multi_find</p><p>多压缩流就相对复杂一点，只要压缩流的个数没有达到最大的个数，那么压缩操作都可以分配到一个压缩流，并会加到压缩流链表中，当压缩流的个数达到最大限制之后，那么下一个压缩操作只能睡眠等待链表中有空闲的压缩流出现。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_zram_tech"><sup>zram_tech</sup>. <a href="https://lwn.net/Articles/545244/" target="_blank" rel="noopener">In-kernel memory compression</a><a href="#reffn_zram_tech" title="Jump back to footnote [zram_tech] in the text."> &#8617;</a></blockquote><blockquote id="fn_zram_doc"><sup>zram_doc</sup>. <a href="https://www.kernel.org/doc/Documentation/blockdev/zram.txt" target="_blank" rel="noopener">内核zram说明文档</a><a href="#reffn_zram_doc" title="Jump back to footnote [zram_doc] in the text."> &#8617;</a></blockquote><blockquote id="fn_block_device"><sup>block_device</sup>. <a href="http://blog.csdn.net/jianchi88/article/details/7212370" target="_blank" rel="noopener">inux设备驱动—块设备（一）之概念和框架</a><a href="#reffn_block_device" title="Jump back to footnote [block_device] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zram </tag>
            
            <tag> compcache </tag>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Sensor Framework 概览</title>
      <link href="/2016/05/18//android-sensor-framework.html/"/>
      <url>/2016/05/18//android-sensor-framework.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>Android Sensor Framework 的整体架构如图 1 所示:</p><p><img src="/images/posts/2016/05/android_sensor_framework_1.png" alt="图片 1"></p><p>Android Sensor Framework 可以分为 3 大部分，各个部分的主要功能如下：</p><p><strong>SDK</strong><br>    这一部分主要功能是为 Application 提供 Java API 接口，以便 Application 可以开启所需的 Sensor 并获取数据。</p><p><strong>Framework</strong><br>    这一部分主要有 Sensor Service 构成，主要实现了 Sensor 数据流和控制流。</p><p><strong>Libraries</strong><br>    这一部分是 Sensor 的硬件抽象层（HAL），它实现了 Sensor 的具体操作和数据获取功能。同时，它还进行虚拟 Sensor，电子罗盘等相关的算法处理过程。此模块通常以一个动态链接库的形式提供。</p><h2 id="2-Android-Sensor-Framework-类图"><a href="#2-Android-Sensor-Framework-类图" class="headerlink" title="2. Android Sensor Framework 类图"></a>2. Android Sensor Framework 类图</h2><p><img src="/images/posts/2016/05/android_sensor_framework_2.png" alt="图片 2"></p><h2 id="3-Android-Sensor-SDK"><a href="#3-Android-Sensor-SDK" class="headerlink" title="3. Android Sensor SDK"></a>3. Android Sensor SDK</h2><p>图片 2 中的 Client 部分内容即为 Android Sensor SDK 的主要构成。主要类的主要功能如下：</p><p><strong>SensorManager</strong><br>该类主要封装了 Sensor 相关的 API ，提供给 Application 使用。<br>文件路径：frameworks/base/core/java/android/hardware/SensorManager.java</p><p><strong>SystemSensorManager</strong><br>该类主要实现 SensorManager 控制和数据获取的逻辑。<br>文件路径：frameworks/base/core/java/android/hardware/SystemSensorManager.java</p><p><strong>android_hardware_SensorManager.cpp</strong><br>该文件负责 jave 层和 native 层通信的 JNI 实现，上层的 Java 代码通过 JNI 调用 Native 层提供的服务。<br>文件路径：frameworks/base/core/jni/android_hardware_SensorManager.cpp</p><p><strong>SensorManager.cpp</strong><br>Sensor 在 Native 层的客户端，负责与服务端 SensorService.cpp 的通信<br>文件路径：frameworks/native/libs/gui/SensorManager.cpp</p><h2 id="4-Android-Sensor-Native-Framework"><a href="#4-Android-Sensor-Native-Framework" class="headerlink" title="4. Android Sensor Native Framework"></a>4. Android Sensor Native Framework</h2><p>图片 2 中的 Server 部分内容即为 Android Sensor Native Framwork 的主要构成。主要类的主要功能如下：</p><p><strong>SensorService.cpp</strong><br>SensorService 是 Android Sensor Framework 最核心的模块，它实现了主要的 Sensor控制流和数据流逻辑，完成 Sensor 参数配置，数据分发，Client 请求处理等功能。<br>文件路径：frameworks/native/services/sensorservice/SensorService.cpp</p><p><strong>BinderService</strong><br>BinderService 是 Android Service 框架的主要类，它提供了 Service 的生命周期管理、进程间通信、请求响应处理等功能。Android 中的绝大部分 Service 都会继承此类。<br>文件路径：frameworks/native/include/binder/BinderService.h</p><p><strong>BnSensorServer</strong><br>该类提供类 Sensor 信息获取以及 SensorEventConnection 创建的功能。<br>文件路径：frameworks/native/include/gui/ISensorServer.h</p><p><strong>SensorEventConnection</strong><br>SensorEventConnection 是 Sensor 数据的传输通道，当 Client 开始监听某一个 Sensor 是，一个对应的 SensorEventConnection 将会被创建，Server 端在接收到 Sensor 数据后，通过写入到 SensorEventConnection 传递给 Client 端。<br>文件路径：frameworks/native/libs/gui/ISensorEventConnection.cpp</p><p><strong>Bittube</strong><br>该类为单向字节管道，提供进程间单向数据通信功能。SensorEventConnection 是基于 Bittube 实现的。<br>文件路径：frameworks/native/libs/gui/BitTube.cpp</p><p><strong>SensorDevice</strong><br>该类负责管理和维护系统中的所有 Sensor，封装了 Sensor 的使能、配置、数据读取等功能。<br>文件路径：frameworks/native/services/sensorservice/SensorDevice.cpp</p><h2 id="5-Android-Sensor-HAL"><a href="#5-Android-Sensor-HAL" class="headerlink" title="5. Android Sensor HAL"></a>5. Android Sensor HAL</h2><p>Android 定义了一系列 Sensor HAL 接口，实际的 Sensor HAL 库需要实现这些接口，主要的接口如下:</p><h3 id="5-1-SensorList"><a href="#5-1-SensorList" class="headerlink" title="5.1. SensorList"></a>5.1. SensorList</h3><p>SensorList 定义了 HAL 层提供的 Sensor，提供 Sensor 类型、供应商、功耗等信息。同时，HAL 层需要实现获取 SensorList 的回调接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sensor_t</span> <span class="title">SensorList</span>[] = &#123;</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name                   = <span class="string">"LTR559 Ambient Light Sensor"</span>,</span><br><span class="line">                .vendor                 = <span class="string">"LITE-ON TECHNOLOGY CORP."</span>,</span><br><span class="line">                .version                = <span class="number">0</span>,</span><br><span class="line">                .handle                 = SENSOR_HANDLE_LIGHT,</span><br><span class="line">                .type                   = SENSOR_TYPE_LIGHT,</span><br><span class="line">                .maxRange               = <span class="number">32767</span>,</span><br><span class="line">                .resolution             = <span class="number">1</span>,</span><br><span class="line">                .power                  = <span class="number">0.1f</span>, <span class="comment">/* 100 uA */</span></span><br><span class="line">                .minDelay               = <span class="number">0</span>,</span><br><span class="line">                .fifoReservedEventCount = <span class="number">0</span>,</span><br><span class="line">                .fifoMaxEventCount      = <span class="number">0</span>,</span><br><span class="line">                .stringType             = SENSOR_STRING_TYPE_LIGHT,</span><br><span class="line">                .requiredPermission     = <span class="string">""</span>,</span><br><span class="line">                .maxDelay               = <span class="number">500</span>,</span><br><span class="line">                .flags                  = SENSOR_FLAG_ON_CHANGE_MODE,</span><br><span class="line">                .reserved[<span class="number">0</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">                .reserved[<span class="number">1</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name                   = <span class="string">"LTR559 Proximity Sensor"</span>,</span><br><span class="line">                .vendor                 = <span class="string">"LITE-ON TECHNOLOGY CORP."</span>,</span><br><span class="line">                .version                = <span class="number">0</span>,</span><br><span class="line">                .handle                 = SENSOR_HANDLE_PROXIMITY,</span><br><span class="line">                .type                   = SENSOR_TYPE_PROXIMITY,</span><br><span class="line">                .maxRange               = <span class="number">4</span>,</span><br><span class="line">                .resolution             = <span class="number">4</span>,</span><br><span class="line">                .power                  = <span class="number">0.15f</span>, <span class="comment">/* 150 uA */</span></span><br><span class="line">                .minDelay               = <span class="number">0</span>,</span><br><span class="line">                .fifoReservedEventCount = <span class="number">0</span>,</span><br><span class="line">                .fifoMaxEventCount      = <span class="number">0</span>,</span><br><span class="line">                .stringType             = SENSOR_STRING_TYPE_PROXIMITY,</span><br><span class="line">                .requiredPermission     = <span class="string">""</span>,</span><br><span class="line">                .maxDelay               = <span class="number">100</span>,</span><br><span class="line">                .flags                  = SENSOR_FLAG_ON_CHANGE_MODE,</span><br><span class="line">                .reserved[<span class="number">0</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">                .reserved[<span class="number">1</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name                   = <span class="string">"LTR559 Proximity Sensor [Wake Up]"</span>,</span><br><span class="line">                .vendor                 = <span class="string">"LITE-ON TECHNOLOGY CORP."</span>,</span><br><span class="line">                .version                = <span class="number">0</span>,</span><br><span class="line">                .handle                 = SENSOR_HANDLE_PROXIMITY_WAKE_UP,</span><br><span class="line">                .type                   = SENSOR_TYPE_PROXIMITY,</span><br><span class="line">                .maxRange               = <span class="number">4</span>,</span><br><span class="line">                .resolution             = <span class="number">4</span>,</span><br><span class="line">                .power                  = <span class="number">0.15f</span>, <span class="comment">/* 150 uA */</span></span><br><span class="line">                .minDelay               = <span class="number">0</span>,</span><br><span class="line">                .fifoReservedEventCount = <span class="number">0</span>,</span><br><span class="line">                .fifoMaxEventCount      = <span class="number">0</span>,</span><br><span class="line">                .stringType             = SENSOR_STRING_TYPE_PROXIMITY,</span><br><span class="line">                .requiredPermission     = <span class="string">""</span>,</span><br><span class="line">                .maxDelay               = <span class="number">100</span>,</span><br><span class="line">                .flags                  = SENSOR_FLAG_ON_CHANGE_MODE | SENSOR_FLAG_WAKE_UP,</span><br><span class="line">                .reserved[<span class="number">0</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">                .reserved[<span class="number">1</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sensor_hal_get_sensors_list</span><span class="params">(struct <span class="keyword">sensors_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     struct <span class="keyword">sensor_t</span> <span class="keyword">const</span>** <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        *<span class="built_in">list</span> = SensorList;</span><br><span class="line">        <span class="keyword">return</span> ARRAY_SIZE(SensorList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-sensors-module-t"><a href="#5-2-sensors-module-t" class="headerlink" title="5.2. sensors_module_t"></a>5.2. sensors_module_t</h3><p>HAL 层需要定义一个 sensors_module_t，供系统在启动时加载 Sensor HAL 动态库。sensors_module_t 向上层注册获取 SensorList 和获取 Sensor 控制接口的相关回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_sensors</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* hw_module, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">hw_device_t</span>** hw_device_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">        <span class="keyword">sensors_poll_context_t</span> *dev = <span class="keyword">new</span> <span class="keyword">sensors_poll_context_t</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;dev-&gt;device, <span class="number">0</span>, <span class="keyword">sizeof</span>(sensors_poll_device_1));</span><br><span class="line"></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version = SENSORS_DEVICE_API_VERSION_1_3;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(hw_module);</span><br><span class="line">        dev-&gt;device.common.<span class="built_in">close</span> = device__close;</span><br><span class="line">        dev-&gt;device.activate = device__activate;</span><br><span class="line">        dev-&gt;device.setDelay = device__setDelay;</span><br><span class="line">        dev-&gt;device.poll = device__poll;</span><br><span class="line">        dev-&gt;device.batch = device__batch;</span><br><span class="line">        dev-&gt;device.<span class="built_in">flush</span> = device__flush;</span><br><span class="line"></span><br><span class="line">        *hw_device_out = &amp;dev-&gt;device.common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">sensors_module_methods</span> = &#123;</span></span><br><span class="line">        .<span class="built_in">open</span> = open_sensors</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensors_module_t</span> <span class="title">HAL_MODULE_INFO_SYM</span> = &#123;</span></span><br><span class="line">        .common = &#123;</span><br><span class="line">                .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">                .module_api_version = <span class="number">1</span>,</span><br><span class="line">                .hal_api_version = <span class="number">0</span>,</span><br><span class="line">                .id = SENSORS_HARDWARE_MODULE_ID,</span><br><span class="line">                .name = <span class="string">"ALS PS Sensor module"</span>,</span><br><span class="line">                .author = <span class="string">"Meizu Telecom Equipment Co., Ltd."</span>,</span><br><span class="line">                .methods = &amp;sensors_module_methods,</span><br><span class="line">        &#125;,</span><br><span class="line">        .get_sensors_list = sensor_hal_get_sensors_list,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-Sensor-控制和数据获取接口"><a href="#5-3-Sensor-控制和数据获取接口" class="headerlink" title="5.3. Sensor 控制和数据获取接口"></a>5.3. Sensor 控制和数据获取接口</h3><p>HAL 层还需要提供实际控制和获取 Sensor 数据的接口，SensorService 中对 Sensor 的控制和数据的获取最终会调用到这些接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extends a sensors_poll_device_1 by including all the sub-module's devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensors_poll_context_t</span> &#123;</span></span><br><span class="line">    sensors_poll_device_1 device; <span class="comment">// must be first</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">activate</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">int</span> enabled)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setDelay</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">int64_t</span> ns)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">sensors_event_t</span>* data, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">batch</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">int</span> flags, <span class="keyword">int64_t</span> period_ns, <span class="keyword">int64_t</span> timeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">int</span> handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__close</span><span class="params">(struct <span class="keyword">hw_device_t</span> *dev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">if</span> (ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval = ctx-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">delete</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__activate</span><span class="params">(struct <span class="keyword">sensors_poll_device_t</span> *dev, <span class="keyword">int</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;activate(handle, enabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__setDelay</span><span class="params">(struct <span class="keyword">sensors_poll_device_t</span> *dev, <span class="keyword">int</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int64_t</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;setDelay(handle, ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__poll</span><span class="params">(struct <span class="keyword">sensors_poll_device_t</span> *dev, <span class="keyword">sensors_event_t</span>* data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;poll(data, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__batch</span><span class="params">(struct sensors_poll_device_1 *dev, <span class="keyword">int</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, <span class="keyword">int64_t</span> period_ns, <span class="keyword">int64_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;batch(handle, flags, period_ns, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__flush</span><span class="params">(struct sensors_poll_device_1 *dev, <span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;<span class="built_in">flush</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Android-Sensor-Framework的初始化流程"><a href="#6-Android-Sensor-Framework的初始化流程" class="headerlink" title="6. Android Sensor Framework的初始化流程"></a>6. Android Sensor Framework的初始化流程</h2><h3 id="6-1-Android-Sensor-Service-初始化"><a href="#6-1-Android-Sensor-Service-初始化" class="headerlink" title="6.1. Android Sensor Service 初始化"></a>6.1. Android Sensor Service 初始化</h3><p><img src="/images/posts/2016/05/android_sensor_framework_3.png" alt="图片 3"></p><p>Kernel 在启动完成后，会执行 init 程序，该程序接着解析 init.rc 文件，启动 zygote，最终会执行 Zyoteinit.java 中的 main 函数。</p><p>在 Zygoteinit 的main 函数执行过程中，会调用 startSystemServer 接口，该接口最终会调用 native 层的 nativeforkSystemServer 接口，进而启动 SystemServer ，调用其 main 函数。</p><p>在 SystemServer 的 main 函数中，会调用对应的 nativeInit 接口。在 nativeInit 中，会创建第一个 SensorService 实例。当 SensorService 第一个实例创建时，其 onFirstRef 接口将会被调用。</p><p><img src="/images/posts/2016/05/android_sensor_framework_4.png" alt="图片 4"></p><p>在 SensorService 的 onFirstRef 接口中，会创建 SensorDevice 的实例。在 SensorDevice 的构造函数中，会调用 hw_get_module 接口加载 Sensor HAL 的动态库，接着调用 Sensor HAL 提供的 open 接口，执行 Sensor HAL 的初始化。<br>接着 SensorService 通过 SensorDevice，调用 Sensor HAL 提供的 get_sensors_list 接口，获取所支持的 Sensor 信息。<br>而后，SensorService 会创建一个 Looper 和 SensorEventAckReceiver。其中 Looper 用于 enable sensor 后，进行数据的接收；而 SensorEventAckReceiver 则用于在 dispatch wake up sensor event 给上层后，接收上层返回的确认 ACK。<br>至此，SensorService 初始化完毕。</p><h3 id="6-2-Android-Sensor-HAL-加载"><a href="#6-2-Android-Sensor-HAL-加载" class="headerlink" title="6.2. Android Sensor HAL 加载"></a>6.2. Android Sensor HAL 加载</h3><p>在 SensorService 创建 SensorDevice 时，会调用 hw_get_module 接口加载 SensorHAL 的动态库文件。<br>在64位的系统中，hw_get_module 接口会在 /vendor/lib64/hw 和 /system/lib64/hw 目录下搜索 SensorHAL 动态库文件，前者的优先级高。<br>hw_get_module 会获取依次获取 “ro.hardware.sensors”，”ro.hardware”，”ro.product.board”，”ro.board.platform”，”ro.arch” property 的值作为 subname，并以 sensors.subname.so 作为 SensorHAL 动态库的文件名，在上述两个目录中搜索文件是否存在，如果都没有搜索到，那么最后会用 sensors.default.so 作为文件名，进行搜索。<br>当搜索到 SensorHAL 的动态库文件后，就会调用 load 接口进行加载操作。<br>具体的流程可以查看下面的源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hw_module_exists</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">size_t</span> path_len, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span> *subname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH2, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH1, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> prop_name[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst)</span><br><span class="line">        <span class="built_in">snprintf</span>(name, PATH_MAX, <span class="string">"%s.%s"</span>, class_id, inst);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        strlcpy(name, class_id, PATH_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Here we rely on the fact that calling dlopen multiple times on</span></span><br><span class="line"><span class="comment">     * the same .so will simply increment a refcount (and not load</span></span><br><span class="line"><span class="comment">     * a new copy of the library).</span></span><br><span class="line"><span class="comment">     * We also assume that dlopen() is thread-safe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try a property specific to the class and possibly instance */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(prop_name, <span class="keyword">sizeof</span>(prop_name), <span class="string">"ro.hardware.%s"</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (property_get(prop_name, prop, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing found, try the default */</span></span><br><span class="line">    <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, <span class="string">"default"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">/* load the module, if this fails, we're doomed, and we should not try</span></span><br><span class="line"><span class="comment">     * to load a different variant. */</span></span><br><span class="line">    <span class="keyword">return</span> load(class_id, path, <span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, <span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENSORS_HARDWARE_MODULE_ID <span class="meta-string">"sensors"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SensorDevice::SensorDevice()</span><br><span class="line">    :  mSensorDevice(<span class="number">0</span>),</span><br><span class="line">       mSensorModule(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = hw_get_module(SENSORS_HARDWARE_MODULE_ID,</span><br><span class="line">            (<span class="keyword">hw_module_t</span> <span class="keyword">const</span>**)&amp;mSensorModule);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Android-Sensor-Manager-初始化"><a href="#6-3-Android-Sensor-Manager-初始化" class="headerlink" title="6.3. Android Sensor Manager 初始化"></a>6.3. Android Sensor Manager 初始化</h3><p><img src="/images/posts/2016/05/android_sensor_framework_5.png" alt="图片 5"></p><p>APP 在获取 Sensor 数据前，需要获取一个 SensorManager 对象。而在其构造函数中，会先调用 nativeClassInit 和 nativeGetNextSensor 获取系统支持的所有 Sensor 的参数（注，nativeClassInit 只会调用一次），包括名称、类型等参数。后续的相关接口，会用到这些参数。</p><h2 id="7-Android-Sensor-Framework的数据流程分析"><a href="#7-Android-Sensor-Framework的数据流程分析" class="headerlink" title="7. Android Sensor Framework的数据流程分析"></a>7. Android Sensor Framework的数据流程分析</h2><p><img src="/images/posts/2016/05/android_sensor_framework_6.png" alt="图片 6"></p><p>当上层调用 registerListener 接口时，相应的 sensor 就会被 enable。SensorService 在调用 HAL 提供的 enable 接口前，会先调用 batch 接口，对 sensor 的采样率、数据上报频率等进行配置。另外，如果 sensor 已经被 enable 了，那么 SensorService 就只调用 batch 和 flush 接口。<br>SensorService 在 onFirstRef 时创建了一个 Looper，该 Looper 的执行线程会调用 poll 接口，并阻塞在 sensor 的数据管道，当 sensor 有数据返回时，SensorService 会通过 SensorEventQueue 发送到上层，并最终分发到各个 listener。</p>]]></content>
      
      
      <categories>
          
          <category> 传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAB 分配器和 kmalloc</title>
      <link href="/2016/05/09//slab-allocator-and-kmalloc.html/"/>
      <url>/2016/05/09//slab-allocator-and-kmalloc.html/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要有-SLAB"><a href="#为什么要有-SLAB" class="headerlink" title="为什么要有 SLAB"></a>为什么要有 SLAB</h2><p>一般来说，一个新东西的产生总是为了解决某一个现有的问题的。那么，slab 是为了解决什么问题呢？我们知道，在 Linux 内核中的内存管理是使用伙伴系统 (Buddy System)，但是这个系统有一个问题就是，它的最小单位是页，即 PAGE_SIZE ，在 x86 架构中这个常数一般是 4k 。但是很多情况下我们要分配的单元大小是远远小于 4k 的，如果使用伙伴系统的话，必定是会产生很大的浪费的。所以，一个粒度更加小的分配器呼之欲出，SLAB 就是为了解决这个小粒度内存分配的问题的。</p><h2 id="如何解决以及结构组织"><a href="#如何解决以及结构组织" class="headerlink" title="如何解决以及结构组织"></a>如何解决以及结构组织</h2><p>既然 SLAB 分配器已经定下了这样的一个目标，那么它的策略是什么呢？ 答曰，SLAB 分配器是基于所谓“面向对象”的思想，当然，这里的“面向对象”跟 C++ 和 Java 等的“面向对象”是不一样的。这里的“面向对象”更加确切的说法是“面向对象类型”，不同的类型使用不同的 SLAB ，一个 SLAB 只分配一种类型。而且，SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是：每次释放掉某个对象之后，不是立即将其返回给伙伴系统（SLAB 分配器是建立在伙伴系统之上的），而是存放在一个叫 array_cache 的结构中，下次要分配的时候就可以直接从这里分配，从而加快了速度。</p><p>这里必须明确几个概念，说明如下：</p><ul><li><p>缓存(cache) : 这里的缓存只是一个叫法而已，其实就是一个管理结构头，它控制了每个 SLAB 的布局，具体的结构体是 struct kmem_cache 。（注意，虽然现在几乎所有的书或者博客都将这一个结构称为“缓存”，不过我觉得在这里称为“管理结构头”是更为合适的，所以下文中统一将“缓存（cache）”称为“管理结构头”。）</p></li><li><p>SLAB: 从伙伴系统分配的 2^order 个物理页就组成了一个 SLAB ，而后续的操作就是在这个 SLAB 上在进行细分的，具体的结构体是 struct slab 。</p></li><li><p>对象(object) : 上面说到，每一个 SLAB 都只针对一个数据类型，这个数据类型就被称为该 SLAB 的“对象”，将该对象进行对齐之后的大小就是该“对象”的大小，依照该大小将上面的 SLAB 进行切分，从而实现了我们想要的细粒度内存分配。</p></li><li><p>per-CPU 缓存：这个就是上面提到的 array_cache ，这个是为了加快分配，预先从 SLAB 中分配部分对象内存以加快速度。具体的结构体是 struct array_cache，包含在　struct kmem_cache　中。</p></li></ul><p>还有，我们在用户态编程的时候，需要分配内存的时候，一般都是使用 malloc() 函数来实现。那么在内核态编程中，如果我们要分配内存，而且又没有必要使用上面的基于某个特定对象的，内核给我们提供了一个类似 malloc() 的接口—— kmalloc() 。值得注意的是，其实 kmalloc() 也是基于 SLAB 分配器的，只不过它所需要的管理结构头已经按照 2^n 的大小排列事先准备好了而已，这个管理结构体数组是 struct cache_sizes malloc_sizes[] 。</p><p>还有，每个“对象”的缓存被组织成一个链表——cache_chain，然后每个缓存的 SLAB 被组织了三个不同的链表——slab_full，slab_partial 和 slab_free，这三个链表有何不同应该可以见名知意，就不赘述了。</p><p>然后，你可能就会发现了，在<strong>对象</strong>那一点，很可能出现一种情况，那就是 SLAB 的大小跟 object 的大小不整除，也就是说有不足于一个 object 的大小的空间剩余，怎么办，浪费掉吗？肯定不是！内核很好地利用了这些剩余的空间，提出了“缓存染色(cache coloring)”的概念。当然，这里的<strong>染色</strong>不是真的去染成红绿蓝等颜色，这只是一种说法而已。具体地将，就是让每个缓存的 SLAB 在页的起始位置有不同的偏移，以缓解<strong>缓存过热</strong>的问题。注意，这里提到的“缓存过热”中的“缓存”是真的 CPU 的物理缓存。具体的我后面会详细说明，这里只是综述一下。</p><h2 id="初始化——-kmem-cache-init"><a href="#初始化——-kmem-cache-init" class="headerlink" title="初始化—— kmem_cache_init()"></a>初始化—— kmem_cache_init()</h2><p>想要让 SLAB 分配器工作起来，必须进行一系列的初始化。不过这里存在一个“鸡生蛋蛋生鸡”的问题。我们前面说过，每个缓存需要一个管理结构头，而建立缓存的实质就是分配一个管理结构头 struct kmem_cache 来描述 SLAB 的布局，以指导后续的分配行为，这个建立缓存的过程是用函数 kmem_cache_create() 来实现的，这里只是点一下，下面会详细说明。很明显这个管理结构头的大小小于一页，那么是十分适合使用 SLAB 分配器进行分配的，但是问题是此时 SLAB 分配器还没有初始化完成，怎么办？内核的做法是直接静态分配一个 struct kmem_cache 类型的变量——cache_cache（不得不说，这个变量名起得真好！），然后呢，整个初始化的过程分为六步：</p><ol><li><p>初始化 struct kmem_cache 变量 cache_cache 。该变量之所以重要，是因为<strong>它是以后所有的对象的管理结构头的管理结构头，专业一点的话可以称作是“元管理结构头”</strong>，然后上面提到的 array_cache 和三个链表 kmem_list3 都是这个结构体里面的成员，初始化也都是静态分配的，对应的静态变量分别是 initarray_cache 和 initkmem_list3 。</p></li><li><p>建立 kmalloc() 的 struct array_cache 对应大小的管理结构头。为什么要进行这一步呢，因为下面的步骤是要完整地建立其 kmalloc() 支持的所有 2^n 大小的管理结构头，完成这一步就相当于 kmalloc() 完全可用了。但是每个管理结构头都必须要 struct array_cache 和 struct kmem_list3 这两个辅助管理结构头，就必须要建立这两个对应大小的 kmalloc() 的管理结构头以便能够使用 kmalloc() <strong>动态分配</strong>！这里之所以要提到<strong>动态分配</strong>是因为在给 struct array_cache 对应大小建立 kmalloc() 的管理结构头的时候，其自己的 struct array_cache 和 struct kmem_list3 也是静态分配的，所以后续将会把它们使用动态分配的空间替换掉。</p></li><li><p>建立 kmalloc() 的 struct kmem_list3 对应大小的管理结构头以及剩下的 2^n 对应大小的管理结构头。第二点已经说明过了，就不重复了。</p></li><li><p>（其实包括第五步）此时 kmalloc() 已经可用了，所以如上面所说要使用 kmalloc() 分配的动态内存去替代前面所有的静态内存，需要替换的对象有：cache_cache 的 struct array_cache ，struct array_cache 对应大小的 kmalloc() 的管理结构头的 struct array_cache 和 struct kmem_list3，以及 struct kmem_list3 对应大小的 kmalloc() 的管理结构头的 struct kmem_list3 。</p></li><li><p>重新调整各个管理结构体的 struct array_cache 中的 entry[] 的数目。</p></li></ol><p>然后这里有一个问题就是，内核是如何知道当前是属于哪一个阶段呢？为了解决这个问题，内核使用了一个枚举变量 g_cpucache_up ，其接受的变量范围有：NULL , PARTIAL_AC , PARTIAL_L3，PEARLY , FULL 。当第二步完成的时候，标记为 PARTIAL_AC ，此时意味着以后的 struct array_cache 都可以使用 kmalloc() 分配了；当第三步完成的时候，标记为 PARTIAL_L3 ，此时意味着以后的 struct kmem_l3 都可以使用；当第四和第五步完成的时候，标记为 PARTIAL_EARLY ，此时意味着 kmalloc() 已经支持所有其支持的 2^n 大小的内存分配了。</p><p>然后有一个很重要的点就是，如果你读过 mm/slab.c 的源代码，你就会发现，在建立 struct array_cache 的管理结构头和为 kmalloc() 各个管理结构头的 struct array_cache 的时候，<strong>内核使用的是 struct arraycache_init 而不是 struct array_cache </strong>，这究竟是怎么一回事？其实这是很有讲究的，且听我慢慢到来。</p><p>其实 struct initarray_cache 的完整结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct arraycache_init &#123;</span><br><span class="line">struct array_cache cache;</span><br><span class="line">void *entry[BOOT_CPUCACHE_ENTRIES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的结构可以看出，struct arraycache_init 就只是比 struct array_cache 多了一个 void * 的数组而已，这个究竟有什么区别呢？诶，别着急，我们再来看一下 struct array_cache 的结构就清楚了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct array_cache &#123;</span><br><span class="line">unsigned int avail;</span><br><span class="line">unsighed int limit;</span><br><span class="line">unsigned int batchcount;</span><br><span class="line">unsigned int touched;</span><br><span class="line">spinlock_t lock;</span><br><span class="line">void *entry[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>联系上文我提到 Per-CPU 的时候说过，为了加快速度将 SLAB 的一部分内存分配到 array_cache ，而事实上就上面我们看到的 struct array_cache 的结构，只是有一个 void * 的数组而已，而且是个伪数组，并没有数组项。其实细想这是一种十分优美的实现方法。因为各个管理结构头所需要的“一部分内存”是不一样的，这样就保证了一个通用性，每次要访问 array_cache 里面的内存的时候，只需要进行 array_cache-&gt;entry[下标] 就可以了。然后我们再来解决上面提到的 struct arraycache_init 的问题。内核静态分配了这样的一个 struct arraycache_init 的静态变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static struct arraycache_init initarray_cache __initdata &#x3D;</span><br><span class="line">&#123; &#123;0, BOOT_CPUCACHE_ENTRIES, 1, 0&#125; &#125;;</span><br></pre></td></tr></table></figure><p>对照结构体的成员我们发现，struct array_cache 的 batchcount 被被赋值为 BOOT_CPUCACHE_ENTRIES ，这个 batchcount 是什么来头呢？这个变量就是控制着我们上面提到的“一部分内存”的具体量了。更重要的是，我们可以看到，struct arraycache_init 多出来的那个 void <em> 数组的个数，就是 BOOT_CPUCACHE_ENTRIES 。也就是说，<em>*struct array_cache 的管理结构头的 struct array_cache 里面的 entry 的真正空间就在这里了。</em></em></p><p>提到这里的话，那么初始化的第六步就可以彻底地理解了：为每个 kmalloc() 的管理结构头的 array_cache 重新调整 entry 的个数，具体的函数调用是 enable_cpucache()-&gt;do_tune_cpucache()-&gt;alloc_arraycache() 。</p><h2 id="创建管理结构头——-kmem-cache-create"><a href="#创建管理结构头——-kmem-cache-create" class="headerlink" title="创建管理结构头—— kmem_cache_create()"></a>创建管理结构头—— kmem_cache_create()</h2><p>因为在初始化的过程中已经静态分配了管理结构头的管理结构头—— cache_cache，所以可以直接使用 kmem_cache_alloc() 给提供的对象建立其自己的管理结构头 struct kmem_cache ，而这个函数的作用也是如此。除了如此外，这个函数还有一个十分重要的功能就是创建 SLAB 的布局，即—— 应该占用页帧的阶数，SLAB 管理头应该在页内还是页外，剩余空间是多少，染色的个数，染色的大小（这两个说法在这里可能有点奇怪，不过等我们提到“染色”的时候就清楚了）等，具体的函数调用是 calculate_slab_order()-&gt;cache_estimate() ，过程比较简单，就不提了。</p><p>最后调用 enable_cpu_cache() 配置 struct array_cache 和 struct kmem_list3 ，这一步类似于我们在初始化那一节提到的第六步，也就不在重复了。</p><p>最后建立的管理结构头加入到 cache_chain 这个链表。</p><h2 id="分配内存——-kmem-cache-alloc"><a href="#分配内存——-kmem-cache-alloc" class="headerlink" title="分配内存—— kmem_cache_alloc()"></a>分配内存—— kmem_cache_alloc()</h2><p>kmem_cache_alloc() 这个函数进过多层的封装，最终调用的是 ____cache_alloc() ，kmalloc() 也是如此。我们先来看一下这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static inline void * ____cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span><br><span class="line">&#123;</span><br><span class="line">void *objp;</span><br><span class="line">struct array_cache *ac;</span><br><span class="line"></span><br><span class="line">check_irq_off();</span><br><span class="line"></span><br><span class="line">ac &#x3D; cpu_cache_get(cachep);</span><br><span class="line">if (likely(ac-&gt;avail)) &#123;</span><br><span class="line">STATS_INC_ALLOCHIT(cachep);</span><br><span class="line">ac-&gt;touched &#x3D; 1;</span><br><span class="line">objp &#x3D; ac-&gt;entry[--ac-&gt;avail];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">STATS_INC_ALLOCMISS(cachep);</span><br><span class="line">objp &#x3D; cache_alloc_refill(cachep, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kmemleak_erase(&amp;ac-&gt;entry[ac-&gt;avail]);</span><br><span class="line">return objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先涉及到我当初一直困惑的一个点：在使用 kmem_cache_create() 建立相关的管理结构之后，究竟有没有分配真正的内存空间呢？在通读了相关的代码之后，我得到了答案：<strong>没有，也没必要。因为存在这么一种情况：如果使用 kmem_cache_create() 之后还分配了真正的内存空间之后，如果该 SLAB 一直不使用，那么岂不是浪费了很多宝贵的内存了吗？</strong></p><p>解决上面的这一个疑惑之后，我们就可以知道在上面的代码中，第一次我们是走 else 那个分支了，也就是调用了 cache_alloc_refill() 来分配空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line">while (batchcount &gt; 0) &#123;</span><br><span class="line">struct list_head *entry;</span><br><span class="line">struct slab　*slabp;</span><br><span class="line"></span><br><span class="line">entry &#x3D; l3-&gt;slabs_partial.next;</span><br><span class="line">if (entry &#x3D;&#x3D; &amp;l3-&gt;slabs_partial) &#123;</span><br><span class="line">l3-&gt;free_touched &#x3D; 1;</span><br><span class="line">entry &#x3D; l3-&gt;slabs_free.next;</span><br><span class="line">if (entry &#x3D;&#x3D; &amp;l3-&gt;slabs_free)</span><br><span class="line">goto must_grow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我再插一句：在 Linux 内核中的链表的实现是十分简洁优美的，它只有两个指针，并不存在数据域。这么做是为了通用性，即任何结构都可以组织自己的链表，然后在结构体中嵌入 struct list_head 即可。然后可能有人会问了，如果我有一个 struct list_head ，那么如何才能访问到该链表的起始结构呢？内核十分贴心的给我们准备了一个宏：<strong>container_of</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(ptr, type, member) (&#123; \</span><br><span class="line">const typeof((type *)0-&gt;member)*__mptr &#x3D; (ptr);  \</span><br><span class="line">(type *)((char *)__mptr - offsetof(type, member)) \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单来说，这个宏的作用就是：<strong>我有一个类型为 (type *)-&gt;member 的变量，想要得到包含该变量的 type 类型变量的地址。</strong></p><p>所以在这里，如前面所说，这里 l3 的三个链表都是连接 struct SLAB 类型的，而这个类型就是内存空间的真正所在，也就是我们前面所说的 2^order 个物理页组成的 SLAB。</p><p>在 kmem_cache_create() 的过程中，在分配 struct kmem_list3 的时候调用了 kmem_list3_init() (line 3844) 将 l3 的三个链表全都置为首尾相连的空链表，所以上面的函数在初次运行的时候最终将跳转到 must_grow 这个标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">must_grow:</span><br><span class="line">l3-&gt;free_objects -&#x3D; ac-&gt;avail;</span><br><span class="line">alloc_done:</span><br><span class="line">spin_unlock(&amp;l3-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">if (unlikely(!ac-&gt;avail)) &#123;</span><br><span class="line">int x;</span><br><span class="line">x &#x3D; cache_grow(cachep, flag | THISNODE, node, NULL);</span><br><span class="line"></span><br><span class="line">ac &#x3D; cpu_cache_get(cachep);</span><br><span class="line">if (!x &amp;&amp; ac-&gt;avail)</span><br><span class="line">return NULL;</span><br><span class="line"></span><br><span class="line">if (!ac-&gt;avail)</span><br><span class="line">goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，函数将调用 cache_grow() 来进行真正的内存分配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int cache_grow(struct kmem_cache *cachep,</span><br><span class="line">gfp_t flags, int nodeid, void *objp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">offset &#x3D; l3-&gt;colour_next;</span><br><span class="line">l3-&gt;colour_next++;</span><br><span class="line">if (l3-&gt;colour_next &gt;&#x3D; cachep-&gt;colour)</span><br><span class="line">l3-&gt;colour &#x3D; 0;</span><br><span class="line"></span><br><span class="line">offset *&#x3D; cachep-&gt;colur_off;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，到这里，总算可以说到前面铺垫了很久的所谓的“缓存着色”了，不过我觉得我得先简单地提一下 CPU cache 的工作原理才行：</p><p>CPU cache 就是我们常看到的一级缓存，二级缓存，三级缓存啊，引入这些缓存是因为内存 RAM 的速度相较于 CPU 的速度而言，是在是太慢了，所以为了提高速度， CPU 制造商提供了速度接近于 CPU 的小容量缓存，以便加速 CPU 与 RAM 的数据交换。具体的策略是：</p><p>每块 cache 会被分为更小的 cache line ，每个 cache line 的容量是一样的，然后 CPU 将虚拟地址分成三部分—— data, index, tag　，其中 data 长度是 cache line 的长度，index 的长度是 cache 的长度减去 data 的长度，最后 tag 的长度是虚拟地址的长度减去 data+index 的长度。举个例子，在 x86 的机器中，虚拟地址的地址空间是 32bit=2^32 ，假设我们的一级缓存有 4MB=2^22，cache line 的长度是 64bit=2^6 ，所以，data 就是 6 位，index 就是 (22-6) = 12 位，tag 就是 32-22=10 位。然后得到这些位之后，CPU 的每一个虚拟地址，将其分成上面的三部分之后，将按照 index 作为索引存入到 cache 中，然后在看需要的内容是否在 cache 中，这回比较需要的虚拟地址的 tag 与 cache 对应索引 index 的 tag 是否一致，如果一致说明 cache hit ，否则说明 cache miss 。</p><p>有点啰嗦，不过这些知识准备是必须的，然后我们就可以来具体阐述了。</p><p>我们在前面提到，SLAB 利用剩余的不足一个 object 的空间来进行缓存染色。具体说来，就是以平台的 cache line 的长度（存储在 cachep-&gt;colour_off）为偏移值（<strong>这一点非常重要！</strong>），计算出剩余的空间有多少个偏移值 cachep-&gt;colour ，然后就从 0 到 cachep-&gt;colour - 1（这个值是 l3-&gt;colour_next），每次就偏移 colour_next * colour_off 。这样，根据我们上面的叙述，每个 SLAB 将最终被放到不同的 cache line ，从而缓解了缓存过热的问题。</p><p>不过，如果你细心一点的话，你也可以发现，其实这个方法并不是特别的有效，因为它的有效范围只有 colour 个，也就是说，colour 个之后，还是会发生覆盖的问题，所以我在上面才用了<strong>缓解</strong>一词。</p><p>总之，上面的代码就计算了下一个偏移值 offset ，那么真正的偏移在那里呢？请看后面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!objp)</span><br><span class="line">objp &#x3D; kmem_getpages(cachep, local_flags, nodeid);</span><br><span class="line">if (!objp)</span><br><span class="line">goto failed;</span><br><span class="line"></span><br><span class="line">slabp &#x3D; alloc_slabmgmt(cachep, objp, offset,</span><br><span class="line">local_flags &amp; ~GFP_CONSTRAINT_MASK, nodeid);</span><br></pre></td></tr></table></figure><p>真正的页分配就在这里了—— kmem_getpages() ，而真正的偏移就在 alloc_slabmgmt() 这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static struct slab *alloc_slabmgmt(struct kmem_cache *cachep, void *objp,</span><br><span class="line">int colour_off, gfp_t local_flags,</span><br><span class="line">int nodeid)</span><br><span class="line">&#123;</span><br><span class="line">struct slab *slabp;</span><br><span class="line"></span><br><span class="line">if (OFF_SLAB(cachep)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">slabp &#x3D; objp + colour_off;</span><br><span class="line">colour_off +&#x3D; cachep-&gt;slab_size;</span><br><span class="line">&#125;</span><br><span class="line">slabp-&gt;inuse &#x3D; 0;</span><br><span class="line">slabp-&gt;colouroff &#x3D; colour_off;</span><br><span class="line">slabp-&gt;s_mem &#x3D; objp + colour_off;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，这里就可以很明显的看出来了整个 SLAB 的布局了：在连续页 objp 的起始，先是 colour_off 的偏移，然后是 SLAB 的一些管理头（管理头的大小是 cachep-&gt;slab_size），最后就是 object 的起始地址 slab-&gt;s_mem 了。</p><p>接下来的具体工作就是设置 SLAB 的 bufctl 控制数组，这里简单地提一下：slab 控制头有一个成员是 slabp-&gt;free ，意义是当前可用的 object 的索引，而 bufctl 控制的则是当前可用的下一个 object 的索引。</p><p>然后，新建立的 SLAB 加入到 l3 的 slabs_free 链表（这很重要！）。然后 cache_grow() 函数结束，返回 cache_alloc_refill() ，注意，此时我们只是分配了一个新的 SLAB ，还没有分配出去。具体就是在 goto retry 重新回到 cache_alloc_refill() 那里重新分配，因为此时我们的 slabs_free 已经不是空的了，所以函数接下来将 batchcount 个 object 移到 array_cache 中，然后修改 SLAB 的 bufctl 数组。最后，看 SLAB 是否所有 object 都分配完了，如果是，则移到 l3-&gt;slabs_full，否则则移到 l3-&gt;slabs_partial 。</p><p>然后，在后续的操作中，如果 array_cache 中有空间，则从其直接分配，否则就看 slabs_partial　或者是 slabs_free 是否有足够的 object ，在不然，就再次重复上面分配 SLAB 的操作了。</p><h2 id="释放内存——-kmem-cache-free"><a href="#释放内存——-kmem-cache-free" class="headerlink" title="释放内存—— kmem_cache_free()"></a>释放内存—— kmem_cache_free()</h2><p>有了上面已经十分详细的阐述之后，释放内存和后面的销毁就显得简单许多了，就是从 array_cache 移回 SLAB 并且修改 bufctl 控制数组而已。就不赘述了。</p><h2 id="销毁内存——-kmem-cache-destroy"><a href="#销毁内存——-kmem-cache-destroy" class="headerlink" title="销毁内存—— kmem_cache_destroy()"></a>销毁内存—— kmem_cache_destroy()</h2><p>同样不赘述了。</p><p>好了，整个 SLAB 分配器我大概就简单地说到这里。下面我说一下我自己的看法。我们可以发现，SLAB 为了加快分配速度，使用了很多的管理结构，其中花销最大的就是那个 bufctl 数组，所以如果是分配小的 object 的话，那么这个 bufctl 数组占用的空间还是相当可观的。这也是它的一个主要的缺点。而后来的 SLUB，就是针对这个缺点进行了有效的改进，而这，我在后面的博客中，将会详细讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SLAB </tag>
            
            <tag> SLUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 5.1 上的 MTK GPS</title>
      <link href="/2016/05/02//gps-introduction.html/"/>
      <url>/2016/05/02//gps-introduction.html/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍手机上几种常见的定位技术，以及 Android 5.1 上的 MTK GPS。</p><h2 id="几种常见的定位技术介绍"><a href="#几种常见的定位技术介绍" class="headerlink" title="几种常见的定位技术介绍"></a>几种常见的定位技术介绍</h2><h3 id="纯-GPS-定位"><a href="#纯-GPS-定位" class="headerlink" title="纯 GPS 定位"></a>纯 GPS 定位</h3><p>数据直接来源于卫星，即搜星，然后下载卫星数据。通过卫星的位置（从卫星上接收），卫星到接收机的距离来测算接收机的位置</p><p>在无辅助信息的条件下用 GPS 定位，需捕获到至少四颗卫星（因为卫星和接收机都有时间差，4 个未知数需 4 个方程才能解）</p><h3 id="蜂窝基站-WIFI定位"><a href="#蜂窝基站-WIFI定位" class="headerlink" title="蜂窝基站 / WIFI定位"></a>蜂窝基站 / WIFI定位</h3><p>蜂窝基站定位原理：根据 CellID (基站 ID )，去对应的数据库搜索已经标识好了的经纬度，然后根据经纬度去地图供应商查询对应的地图和地址描述</p><p>WIFI 定位原理：扫描周围所有的 AP，获取 AP 的 MAC Address (说明下，不是 IP Address 哦)，在连网前提下，就可以去地图服务器（比如 Baidu 地图服务器，有这些 MAC Address 的经纬度）查询这些 MAC Address 的座标，并结合每个 AP 的信号强弱，计算出手机的大致地理位置并返回给用户（ Baidu 地图），从而完成定位</p><h3 id="AGPS定位"><a href="#AGPS定位" class="headerlink" title="AGPS定位"></a>AGPS定位</h3><p>AGPS 是标准的在线辅助手段，简单点说就是 GPS + 辅助数据，需要额外的辅助服务器支持。</p><p>原理：通过网络连接到 AGPS SERVER，从 AGPS SERVER 获取辅助数据（包括参考时间，参考位置，星历和历书），从而缩小 TTFF （Time To First Fix，首次定位时间）</p><p>如图： <img src="/images/posts/2016/05/agps.png" alt="AGPS"></p><h3 id="离线辅助定位"><a href="#离线辅助定位" class="headerlink" title="离线辅助定位"></a>离线辅助定位</h3><p>通过预测技术，将未来 N 天所有 GPS 卫星的 ephemeris （星历数据）放到 XX 服务器，然后手机端可以从该 XX 服务器下载，这样，在没有 A-GPS 去 supl 服务器下载卫星星历数据的情况下，也可以实现快速定位。<br>其存在目的就是缩小TTFF，提高定位速度。</p><p>比如 MTK EPO 原理：通过预测技术，将未来 30 天所有 GPS 卫星的 ephemeris 放到 mtk 服务器（epo.mediatek.com），当打开 GPS 和网络时，就会去下载预测的未来 30 天内所有卫星星历，15 天后只要在打开 GPS 和网络前提下就会自动去同步一下。</p><p>如图：<img src="/images/posts/2016/05/epo.png" alt="epo"></p><h2 id="Android5-1-上的-MTK-GPSandroid-book"><a href="#Android5-1-上的-MTK-GPSandroid-book" class="headerlink" title="Android5.1 上的 MTK GPSandroid_book"></a>Android5.1 上的 MTK GPS<sup><a href="#fn_android_book" id="reffn_android_book">android_book</a></sup></h2><p>下图是 Android 5.1 上 GPS 代码框架图：</p><p><img src="/images/posts/2016/05/gps_introduction.png" alt="Android5.1 上的 MTK GPS"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_android_book"><sup>android_book</sup>. 《深入理解 Android：Wi-Fi，NFC 和 GPS》第九章 深入理解 GPS<a href="#reffn_android_book" title="Jump back to footnote [android_book] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无线通讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gps </tag>
            
            <tag> 定位技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WrapFS 简介</title>
      <link href="/2016/04/15//intro-wrapfs.html/"/>
      <url>/2016/04/15//intro-wrapfs.html/</url>
      
        <content type="html"><![CDATA[<h2 id="初识-WrapFS"><a href="#初识-WrapFS" class="headerlink" title="初识 WrapFS"></a>初识 WrapFS</h2><p>WrapFS 是一种堆栈式文件系统，堆栈式文件系统的一个基本功能就是把操作和参数转换成底层文件系统的操作和参数。这就意味着我们会在 WrapFS 层上创建一个文件对象后会在底层文件对应着创建一个对象，要说明的是，WrapFS 层的这个文件对象只保存在内存里面，断电后会消失，真正文件里面的数据保存在底层文件系统里面。</p><p><img src="/images/posts/2016/04/wrapfs.gif" alt="wrapfs"></p><h2 id="WrapFS-的意义"><a href="#WrapFS-的意义" class="headerlink" title="WrapFS 的意义"></a>WrapFS 的意义</h2><p>从 WrapFS 的发明者有这样的回答：</p><ul><li>WrapFS 是一种理想的小模板，可以修改，逐步改造出新的文件系统功能。</li><li>WrapFS 可以当作一种方法，用于测试 Linux VFS 超强的堆叠能力。</li><li>WrapFS 可以当作学习 VFS，或学习如何写新的 Linux 文件系统的一个好工具。</li><li>在 Android 里面，采用的是 FUSE 文件系统，FUSE 文件系统的最终实现是在用户空间，这样导致一个文件操作会两次跨越用户空间和内核空间，导致效率降低，但是 WrapFS 不会有这个问题，其性能接近底层文件系统的实际性能.</li></ul><p><img src="/images/posts/2016/04/wrapfs-layer.gif" alt="wrapfs-layer"></p><h2 id="继承角度看-WrapFS"><a href="#继承角度看-WrapFS" class="headerlink" title="继承角度看 WrapFS"></a>继承角度看 WrapFS</h2><p>从面向对象的角度来看，WrapFS 继承自底层文件系统，并且新增加了一下类成员，重写了一些 VFS 层的方法。</p><h2 id="文件系统-mount"><a href="#文件系统-mount" class="headerlink" title="文件系统 mount"></a>文件系统 mount</h2><p>WrapFS 的 mount 方法为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t wrapfs &#x2F;some&#x2F;lower&#x2F;path &#x2F;mnt&#x2F;wrapfs</span><br></pre></td></tr></table></figure><p>这里 <code>/some/lower/path</code> 就是底层的文件系统的路径, <code>/mnt/wrapfs</code> 是挂载点的路径，在内核里面可以通过 <code>kern_path()</code> 获取路径所对应的 <code>sturct path</code> 结构，<code>path</code> 结构里面包含了文件系统 mount 时的 vfsmount 信息和挂载点路径的 dentry 信息，<code>struct path</code> 定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct path &#123;</span><br><span class="line">struct vfsmount *mnt;</span><br><span class="line">struct dentry *dentry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>struct vfsmount</code> 里面包含了底层文件系统的挂载点的 dentry 和 super block。通过 super block 和 dentry 结构，我们能获得操作底层文件系统的方法。这里来关注下填充 <code>struct super_block</code> 的方法，只列出了主要的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static int wrapfs_read_super(struct super_block *sb, void *raw_data, int silent)</span><br><span class="line">&#123;</span><br><span class="line">int err &#x3D; 0;</span><br><span class="line">struct super_block *lower_sb;</span><br><span class="line">struct path lower_path;</span><br><span class="line"></span><br><span class="line">&#x2F;* raw_data 就是挂载点的路径 *&#x2F;</span><br><span class="line">char *dev_name &#x3D; (char *) raw_data;</span><br><span class="line">struct inode *inode;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 通过kern_path获取挂载点的 path 结构 *&#x2F;</span><br><span class="line">err &#x3D; kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY,</span><br><span class="line">&amp;lower_path);</span><br><span class="line"></span><br><span class="line">&#x2F;* 获取底层文件系统的超级块，并绑定到 wrapfs 的超级块里面 *&#x2F;</span><br><span class="line">lower_sb &#x3D; lower_path.dentry-&gt;d_sb;</span><br><span class="line">wrapfs_set_lower_super(sb, lower_sb);</span><br><span class="line"></span><br><span class="line">&#x2F;* 设置超级块的方法 *&#x2F;</span><br><span class="line">sb-&gt;s_op &#x3D; &amp;wrapfs_sops;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 获取根 inode 和 dentry，并绑定对应底层目录的 inode ，后面会详细介绍 *&#x2F;</span><br><span class="line">inode &#x3D; wrapfs_iget(sb, lower_path.dentry-&gt;d_inode);</span><br><span class="line">if (IS_ERR(inode)) &#123;</span><br><span class="line">err &#x3D; PTR_ERR(inode);</span><br><span class="line">goto out_sput;</span><br><span class="line">&#125;</span><br><span class="line">sb-&gt;s_root &#x3D; d_alloc_root(inode);</span><br><span class="line">if (!sb-&gt;s_root) &#123;</span><br><span class="line">err &#x3D; -ENOMEM;</span><br><span class="line">goto out_iput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WrapFS-VFS-操作的一般方法"><a href="#WrapFS-VFS-操作的一般方法" class="headerlink" title="WrapFS VFS 操作的一般方法"></a>WrapFS VFS 操作的一般方法</h2><p>堆栈操作有两种类型：创建新 VFS 对象和不创建新 VFS 对象。</p><ul><li>下面是不创建 VFS 的方法.</li></ul><p>不创建 VFS 文件对象的方法仅仅传递 VFS 对象到底层，并返回可能的错误信息给 VFS ,比如 link 和 ulink 方法，下面是不创建新对象的代码，这个代码比较简单，就是调用 <code>get_lower_dentry()</code> 获取底层目录的 inode 对象，然后调用底层目录的 inode 对象的 unlink 方法解除 link。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int wrapfs_unlink(struct inode *dir, struct dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">struct inode *lower_dir;</span><br><span class="line">struct dentry *lower_dentry;</span><br><span class="line">lower_dir &#x3D; get_lower_inode(dir);</span><br><span class="line">lower_dentry &#x3D; get_lower_dentry(dentry);</span><br><span class="line">err &#x3D; lower_dir-&gt;i_op-&gt;unlink(lower_dir, lower_dentry);</span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面代码展现的是重新创建新 VFS 对象的方法 create。</li></ul><p>主要流程就是先调用 <code>vfs_create</code> 创建底层文件系统对象，再调用 <code>wrapfs_interpose()</code> 创建自已的文件系统对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int wrapfs_create(struct inode *dir, struct dentry *dentry, int mode)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">struct dentry *lower_dentry;</span><br><span class="line">struct inode *lower_dir;</span><br><span class="line">lower_dir &#x3D; wrapfs_lower_inode(dir);</span><br><span class="line">lower_dentry &#x3D; wrapfs_lower_dentry(dentry);</span><br><span class="line">err &#x3D; vfs_create(lower_dir, lower_dentry, mode);</span><br><span class="line">if (!err)</span><br><span class="line">err &#x3D; wrapfs_interpose(dentry, dir-&gt;i_sb);</span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数调用 <code>wrapfs_lower_inode()</code> 来获取底层 dir 的 inode，下面是该函数的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline struct inode *wrapfs_lower_inode(const struct inode *i)</span><br><span class="line">&#123;</span><br><span class="line">return wrapfs_I(i)-&gt;lower_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wrapfs_I(i)</code> 是一个宏，定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline struct wrapfs_inode_info *wrapfs_I(const struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">return container_of(inode, struct wrapfs_inode_info, vfs_inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 <code>struct wrapfs_inode_info</code> 的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct wrapfs_inode_info &#123;</span><br><span class="line">struct inode *lower_inode;</span><br><span class="line">struct inode vfs_inode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lower_inode</code> 是 WrapFS 层文件对应的底层文件的 inode，vfs_inode 是 WrapFS 层的 inode。那 lower_inode 是什么时候设置的?在后面会看到 WrapFS 在创建文件的时候会设置文件对应的 lower_inode。那么 WrapFS 的根目录的 lower_inode 是在什么时候设置的呢？前面有提到过 mount 的时候会获取 mount 点的 dentry 方法，其实根目录的 lower_inode 也是在 mount 时设定的。获取到底层文件系统的 inode 结构后，我们就可以在底层文件系统上创建文件了。这个时候底层的文件时创建好了，但是 WrapFS 层的文件还没有创建好，<code>wrapfs_interpose()</code> 就是做这个事情的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int wrapfs_interpose(struct dentry *dentry, struct super_block *sb,</span><br><span class="line">struct path *lower_path)</span><br><span class="line">&#123;</span><br><span class="line">int err &#x3D; 0;</span><br><span class="line">struct inode *inode;</span><br><span class="line">struct inode *lower_inode;</span><br><span class="line">struct super_block *lower_sb;</span><br><span class="line"></span><br><span class="line">lower_inode &#x3D; lower_path-&gt;dentry-&gt;d_inode;</span><br><span class="line">lower_sb &#x3D; wrapfs_lower_super(sb);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 这个函数创建 WrapFS 的 inode *&#x2F;</span><br><span class="line">inode &#x3D; wrapfs_iget(sb, lower_inode);</span><br><span class="line">if (IS_ERR(inode)) &#123;</span><br><span class="line">err &#x3D; PTR_ERR(inode);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 把 inode 和 dentry 绑定 *&#x2F;</span><br><span class="line">d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wrapfs_iget()</code> 创建 WrapFS 层的 inode，并绑定对应的底层文件的 inode;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct inode *wrapfs_iget(struct super_block *sb, struct inode*lower_inode)</span><br><span class="line">&#123;</span><br><span class="line">struct wrapfs_inode_info *info;</span><br><span class="line">struct inode *inode; &#x2F;* the new inode to return *&#x2F;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 创建 WrapFS 的 inode，该函数会调用 super_ops 的 alloc_inode 方法即</span><br><span class="line"> * wrapfs_alloc_in() 生成 struct wrapfs_inode_info 结构。</span><br><span class="line"> *&#x2F;</span><br><span class="line">inode &#x3D; iget5_locked(sb, &#x2F;* our superblock *&#x2F;</span><br><span class="line">lower_inode-&gt;i_ino, &#x2F;* hashval *&#x2F;</span><br><span class="line">wrapfs_inode_test, &#x2F;* inode comparison function *&#x2F;</span><br><span class="line">wrapfs_inode_set, &#x2F;* inode init function *&#x2F;</span><br><span class="line">lower_inode); &#x2F;* data passed to test+set fxns *&#x2F;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;* 设定底层文件的 inode 到 struct WrapFS_inode_info 结构 *&#x2F;</span><br><span class="line">wrapfs_set_lower_inode(inode, lower_inode);</span><br><span class="line"></span><br><span class="line">inode-&gt;i_version++;</span><br><span class="line"></span><br><span class="line">&#x2F;* 根据不同的文件类型设定不同的 inode 方法和 file_operation *&#x2F;</span><br><span class="line">if (S_ISDIR(lower_inode-&gt;i_mode))</span><br><span class="line">inode-&gt;i_op &#x3D; &amp;wrapfs_dir_iops;</span><br><span class="line">else if (S_ISLNK(lower_inode-&gt;i_mode))</span><br><span class="line">inode-&gt;i_op &#x3D; &amp;wrapfs_symlink_iops;</span><br><span class="line">else</span><br><span class="line">inode-&gt;i_op &#x3D; &amp;wrapfs_main_iops;</span><br><span class="line"></span><br><span class="line">&#x2F;* use different set of file ops for directories *&#x2F;</span><br><span class="line">if (S_ISDIR(lower_inode-&gt;i_mode))</span><br><span class="line">inode-&gt;i_fop &#x3D; &amp;wrapfs_dir_fops;</span><br><span class="line">else</span><br><span class="line">inode-&gt;i_fop &#x3D; &amp;wrapfs_main_fops;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_mapping-&gt;a_ops &#x3D; &amp;wrapfs_aops;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 初始化特殊的文件，比如 fifo，块设备文件，字符设备文件，socket 文件等，</span><br><span class="line"> * 这些文件对应子模块有相关接口，所以直接调用内核提高的接口初始化就好了</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (S_ISBLK(lower_inode-&gt;i_mode) || S_ISCHR(lower_inode-&gt;i_mode) ||</span><br><span class="line">S_ISFIFO(lower_inode-&gt;i_mode) || S_ISSOCK(lower_inode-&gt;i_mode))</span><br><span class="line">init_special_inode(inode, lower_inode-&gt;i_mode,</span><br><span class="line">lower_inode-&gt;i_rdev);</span><br><span class="line"></span><br><span class="line">&#x2F;* 拷贝底层文件的属性到 WrapFS 层文件，主要是创建时间，访问时间，文件大小等 *&#x2F;</span><br><span class="line">fsstack_copy_attr_all(inode, lower_inode);</span><br><span class="line">fsstack_copy_inode_size(inode, lower_inode);</span><br><span class="line"></span><br><span class="line">unlock_new_inode(inode);</span><br><span class="line">return inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WrapFS 创建文件的过程就是分别在底层文件系统和本层创建一个文件，然后重新设置一下本层文件的 inode 属性以及 inode 的方法和 <code>file_operation</code> 等方法，其它文件操作的方法和上面介绍的两种方法类似，就不一一介绍了。</p><h2 id="WrapFS-和链接的区别"><a href="#WrapFS-和链接的区别" class="headerlink" title="WrapFS 和链接的区别"></a>WrapFS 和链接的区别</h2><p>WrapFS 和链接是有很大区别的，WrapFS 是一种文件系统，有自己的 VFS 数据结构，他的数据结构保存在底层文件系统的某个路径，他把底层的文件系统改造一番后提供给用户，把用户创建的文件改造一番后写到底层文件系统上面。而硬链接是两个文件对于着同一个 inode 以及数据 block；软链接则只是一个文件，有着自己的数据块和 inode，文件数据里面存放着被链接文件的路径。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://wrapfs.filesystems.org" target="_blank" rel="noopener">WrapFS 官方网站</a></li><li><a href="http://blog.csdn.net/fybon/article/details/22789295" target="_blank" rel="noopener">WrapFS: a stackable file system（一种堆栈式文件系统）</a></li><li><a href="http://www.ithao123.cn/content-565293.html" target="_blank" rel="noopener">Android SDCard 存储方案（基于 FUSE 文件系统）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> WrapFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于调度器的 CPU 调频机制</title>
      <link href="/2016/04/08//cpufreq-sched.html/"/>
      <url>/2016/04/08//cpufreq-sched.html/</url>
      
        <content type="html"><![CDATA[<p>最近由于 Linaro 和 ARM 主导的 EAS(Energy Aware Scheduler) 日渐完善，属于 EAS 一部分的基于调度器的调频技术也获得了很多关注。本文主要介绍基于调度器的 CPU 调频策略的原理，以及当前上游社区在这一方面最新的进展。</p><h2 id="传统-CPU-调频策略"><a href="#传统-CPU-调频策略" class="headerlink" title="传统 CPU 调频策略"></a>传统 CPU 调频策略</h2><p>传统 CPU 调频模块主要分为 3 块：CPUFreq 核心模块、CPUFreq 驱动和 CPUFreq Governor。核心模块主要是一些公共的逻辑和 API，CPUFreq 驱动是处理和平台相关的逻辑，比如设置 CPU 的频率和电压。而 Governor 就是我们今天要讲的主角，CPU 调频的策略。CPU 在什么样负载，什么样的场景下应该跑多少频率，都是通过 CPUFreq Governor 采取一定策略来决定的，然后调用 <code>cpufreq_driver-&gt;target()</code> 来设置要调整的频率。</p><p>那么传统 CPUFreq Governor 是如何选择当前 CPU 的频率的呢？performance 和 powersave 这两个 governor 就不说了，一个是让 CPU 一直跑在最高频率，另外一个是让 CPU 跑在最低频率，所有的动作都在初始化的时候做了，本身也没有什么策略。userspace 只是实现了 scaling_setspeed 节点，主要策略在用户态，也没什么可讲的。而 ondemand 和 conservation 两个 governor 则是开启一个 timer，定期去计算各个 CPU 的负载。当 CPU 负载超过 80% 时，ondemand 就会把 CPU 频率调到最高，其他情况则会根据当前负载按比例计算频率。而对于 conservation 而言，CPU 负载超过 80% 时，默认会以 5% 的步伐递增；当 CPU 负载少于 20% 的时候，默认会以 5% 的步伐递减<sup><a href="#fn_cpufreq_source" id="reffn_cpufreq_source">cpufreq_source</a></sup>。</p><p>Interactive governor 并没有合入到 mainline，它是在 Android 中引入的。现在几乎所有的 Android 手机用的都在用这个 governor。所不同的是，它在每一个 CPU 上都注册了一个 idle notifier。当 CPU 退出 idle 状态时，interactive 就会缩减采样频率，从而可以快速响应负载变化。其他情况下，会根据当前 CPU 负载调整频率，这一点和 ondemand 类似<sup><a href="#fn_interactive" id="reffn_interactive">interactive</a></sup>。</p><p>总结起来，对于像 ondemand，conservation，interactive 含有调频逻辑的 governor，都包含一个共同的部分 - 负载采样，需要每隔一定时间就计算一次 CPU 负载。而这个共同点，就是今天这篇文章的关键。有些人认为，对于 CPU 的负载，没有谁比调度器还清楚的了。所以 cpufreq governor 完全没必要自己去做负载采样，应该从内核调度器那里获取。而基于调度器的 cpufreq governor 就是这样引出来的。</p><h2 id="基于调度器的-CPU-调频策略"><a href="#基于调度器的-CPU-调频策略" class="headerlink" title="基于调度器的 CPU 调频策略"></a>基于调度器的 CPU 调频策略</h2><p>内核调度器中的 CFS 调度类是通过 PELT(per entity load tracking) 来统计各个 Task 的负载（capacity），并映射到 0 ~ 1024（最大值可在编译时指定）。内核当中的负载均衡就是通过这些统计值来平衡各个 CPU 之间的任务。而基于调度器的 cpufreq governor 的主要原理就是把各个 CPU 的 capacity 映射到 CPU 频率，来完成调频动作，capacity 越高，当前 CPU 负载越高，所以频率也调的很高。</p><p>而当前内核社区中，已经有两个成形的方案。一个是 ARM 和 Linaro 主导的项目 - cpufreq_sched，属于 EAS 的一部分。而另外一个 Intel 主导的项目 - schedutil。</p><h3 id="cpufreq-sched"><a href="#cpufreq-sched" class="headerlink" title="cpufreq_sched"></a>cpufreq_sched</h3><p>cpufreq_sched<sup><a href="#fn_sched_freq" id="reffn_sched_freq">sched_freq</a></sup> 本身逻辑比较简单，当 cfs, rt, deadline 3 个调度类中的 capacity 出现变化的时候，就调用 <code>update_cpu_capacity_request()</code> 来更新当前 policy 下 CPU 的频率。cpufreq 中的 policy 有可能包含多个 CPU，所以这里要选择其中最大的 capacity 来代表整个 policy 的负载。capacity 到 CPU 频率，是通过如下代码按比例转换的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freq_new &#x3D; capacity * policy-&gt;max &gt;&gt; SCHED_CAPACITY_SHIFT</span><br></pre></td></tr></table></figure><p><code>SCHED_CAPACITY_SHIFT</code> 一般是 10，即 capacity 的最大值 1024。假定当前 policy 允许的最大 CPU 频率是 1.2GHz，capacity 为 500，那么对应的频率是 586Mhz。如果我们直接把 CPU 设置在这个频率上，会导致一些性能上的下降。所以 cpufreq_sched 会在最终的 capacity 基础上，乘上 1.25，相当于在当前 capacity 的基础上增加 20%。</p><p>从 cpufreq_sched 的实现，我们可以看到整个调频动作，都是从调度器中直接设置下来的，cpufreq_sched 自身并没有去统计各个 CPU 的负载。而这种做法也让 CPU 的频率可以快速的响应负载变化，理论上讲，当前平台的 cpufreq 驱动最小调频间隔是多少，那么 cpufreq_sched 就可以做到多少。相比于 interactive 20ms 的调频间隔，cpufreq_sched 不到 1ms 的调频间隔简直是天壤之别。下图分别是 interactive 和 sched 在不同负载下 CPU 频率图：</p><ul><li>Interactive: <img src="/images/posts/2016/04/interactive.png" alt="Interactive"></li><li>Cpufreq_sched: <img src="/images/posts/2016/04/sched.png" alt="Sched"></li></ul><p>响应速度快，调频间隔短，固然是 cpufreq_sched 的优势，但是把整个调频动作都放到调度器里做，无疑会增加调度器的负担。调度器代码路径变长，也会增加调度器的延时。如果某个平台的 cpufreq 驱动在设置 CPU 频率的时候会导致系统睡眠，那么 cpufreq_sched 还需要在每一个 CPU 上额外开启一个线程，防止对调度器造成影响。</p><h3 id="schedutil"><a href="#schedutil" class="headerlink" title="schedutil"></a>schedutil</h3><p>在介绍 schedutil 之前，我们首先得介绍一个内核社区最近出现的新机制 - utilization update callback<sup><a href="#fn_capacity_callback" id="reffn_capacity_callback">capacity_callback</a></sup>。其实就是一个各个 CPU 使用率变化时的一种回调机制。通过 <code>cpufreq_set_update_util_data()</code> 来注册回调函数，当 cfs, rt, deadline 3 个调度类的 capacity 出现变化时，调用 <code>cpufreq_update_util()</code> 来触发 hook，实现类似 notifier 的效果。</p><p>而 schedutil<sup><a href="#fn_schedutil" id="reffn_schedutil">schedutil</a></sup> 就是利用这个负载变化回调机制，通过 <code>cpufreq_add_update_util_hook()</code> 注册回调函数，当 CPU 负载出现变化的时候，就会触发 schedutil <code>sugov_update</code> 进行调频动作。而剩下的调频实现，其实跟 cpufreq_sched 大同小异。</p><p>目前来看，cpufreq_sched 好像已经被放弃，而 schedutil 有望在 Linux kenrel 4.7 版本中合入，到时候，内核 Cpufreq Governor 又要新添一名成员了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_cpufreq_source"><sup>cpufreq_source</sup>. <a href="http://lxr.free-electrons.com/source/drivers/cpufreq/" target="_blank" rel="noopener">Cpufreq Governor 内核源码</a><a href="#reffn_cpufreq_source" title="Jump back to footnote [cpufreq_source] in the text."> &#8617;</a></blockquote><blockquote id="fn_interactive"><sup>interactive</sup>. <a href="https://lwn.net/Articles/662209/" target="_blank" rel="noopener">New ‘interactive’ governor</a><a href="#reffn_interactive" title="Jump back to footnote [interactive] in the text."> &#8617;</a></blockquote><blockquote id="fn_sched_freq"><sup>sched_freq</sup>. <a href="https://lkml.org/lkml/2016/2/22/1037" target="_blank" rel="noopener">Cpufreq_sched 补丁</a><a href="#reffn_sched_freq" title="Jump back to footnote [sched_freq] in the text."> &#8617;</a></blockquote><blockquote id="fn_capacity_callback"><sup>capacity_callback</sup>. <a href="https://lkml.org/lkml/2016/2/15/734" target="_blank" rel="noopener">utilization update callback</a><a href="#reffn_capacity_callback" title="Jump back to footnote [capacity_callback] in the text."> &#8617;</a></blockquote><blockquote id="fn_schedutil"><sup>schedutil</sup>. <a href="https://lkml.org/lkml/2016/3/29/1041" target="_blank" rel="noopener">Schedutil 补丁</a><a href="#reffn_schedutil" title="Jump back to footnote [schedutil] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 调度器 </category>
          
          <category> 电源管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpufreq </tag>
            
            <tag> schedutil </tag>
            
            <tag> EAS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
