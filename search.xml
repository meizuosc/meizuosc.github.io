<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>硬核内核技术：irq_work通用硬中断回调机制首版特性分析</title>
      <link href="/2025/01/06/%E7%A1%AC%E6%A0%B8%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%EF%BC%9Airq_work%E9%80%9A%E7%94%A8%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E9%A6%96%E7%89%88%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2025/01/06/%E7%A1%AC%E6%A0%B8%E5%86%85%E6%A0%B8%E6%8A%80%E6%9C%AF%EF%BC%9Airq_work%E9%80%9A%E7%94%A8%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E9%A6%96%E7%89%88%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>irq_work 在实际工程应用的例子是，在手机出现卡屏卡死状态时，可以使用组合按键触发 irq_work 来 dump 系统信息，而避免使用进程调度，因为此时系统可能资源匮乏、锁竞争让执行 dump 系统信息的进程处于 D 状态无法正常调度工作，导致操作失效，失去分析现场的机会。</p><p><img src="1.webp" alt="图片"></p><hr><p>本文是对 Linux 邮件列表中 ”[PATCH -tip -v6] irq_work: generic hard-irq context callbacks”主题的分析总结。2010 年 Peter Zijlstra 提交了 irq work 首版内核特性，从 perf event 中提取出通用的 irq work 机制。这个 patch 涉及到了多种 CPU 架构，本文主要以 X86 和 Arm 架构进行详细描述。</p><h2 id="About-The-Author"><a href="#About-The-Author" class="headerlink" title="About The Author"></a>About The Author</h2><p><img src="2.webp" alt="图片"></p><p>Peter Zijlstra 是 Linux 内核开发领域内一位杰出的内核开发者和维护者，以其在 CPU 调度领域的创新而闻名。他设计并提出了一种新型 CPU 调度器——Earliest Eligible Virtual Deadline First（EEVDF），这是一种先进的基于虚拟运行时间的调度策略，专门针对提升任务响应性和吞吐量而设计，尤其适用于对延迟敏感的任务处理场景。此外，Zijlstra 在组调度领域也颇有建树，这一特性使得 Linux 内核调度器能够更有效地管理相关任务的分组，以优化整体调度性能。在实时调度领域，Zijlstra 的工作不仅推动了实时调度算法的改进，还显著提升了系统性能。他对 Linux 内核的内存管理机制也进行了深入的优化和改进，极大地提高了系统的稳定性和效率。值得一提的是，Zijlstra 提供了一种创新机制，允许代码在 IRQ（中断请求）上下文中执行，这对于需要与系统其他部分交互的 NMI（非屏蔽中断）处理至关重要，为 Linux 内核的中断处理带来了新的可能。总的来说，Peter Zijlstra 的贡献对 Linux 内核的发展有着深远的影响。</p><h2 id="Patch-Archives"><a href="#Patch-Archives" class="headerlink" title="Patch Archives"></a>Patch Archives</h2><table>    <colgroup>        <col width="30%">        <col width="90%">    </colgroup>    <tr>        <th>档案项</th>        <th>说明</th>    </tr>    <tr>        <td>Subject</td>        <td>irq_work: generic hard-irq context callbacks</td>    </tr>    <tr>        <td>Author</td>        <td>Peter Zijlstra a.p.zijlstra@chello.nl</td>    </tr>    <tr>        <td>合入内核版本</td>        <td>v2.6.37-rc1</td>    </tr>    <tr>        <td>合入时间</td>        <td>Thu Oct 14 14:01:34 2010</td>    </tr></table><h2 id="邮件主题"><a href="#邮件主题" class="headerlink" title="邮件主题"></a>邮件主题</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[PATCH -tip -v6] irq_work: generic hard-irq context callbacks</span><br><span class="line"><span class="keyword">From</span>: Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;</span><br><span class="line">Provide a mechanism that allows running code <span class="keyword">in</span><span class="built_in"> IRQ </span>context. </span><br><span class="line">It is most useful <span class="keyword">for</span> NMI code that needs <span class="keyword">to</span> interact with</span><br><span class="line">the rest of the<span class="built_in"> system </span>-- like wakeup a task <span class="keyword">to</span> drain buffers.</span><br><span class="line">Perf currently has such a mechanism, so extract that <span class="keyword">and</span> provide</span><br><span class="line">it as a generic feature, independent of perf so that others may </span><br><span class="line">also benefit.</span><br><span class="line">The<span class="built_in"> IRQ </span>context callback is generated through self-IPIs where possible, </span><br><span class="line"><span class="keyword">or</span> on architectures like powerpc the decrementer (the built-in timer </span><br><span class="line">facility) is <span class="builtin-name">set</span> <span class="keyword">to</span> generate an interrupt immediately.</span><br><span class="line">Architectures that don<span class="string">'t have anything like this get to do with a </span></span><br><span class="line"><span class="string">callback from the timer tick. These architectures can call irq_work_run()</span></span><br><span class="line"><span class="string">at the tail of any IRQ handlers that might enqueue such work (like the </span></span><br><span class="line"><span class="string">perf IRQ handler) to avoid undue latencies in processing the work.</span></span><br><span class="line"><span class="string">Huang Ying: some fixes</span></span><br><span class="line"><span class="string">This patch is only tested on x86 platform.</span></span><br></pre></td></tr></table></figure><p>irq_work 提供了一种机制，允许在中断（IRQ）上下文中运行代码。这对于需要与系统其余部分交互的 NMI（非屏蔽中断）代码非常有用——比如唤醒一个任务来清空缓冲区。性能监控（Perf）目前就有这样一个机制，因此提取出来并作为一个通用特性提供，独立于性能监控，以便其他人也可以受益。在可能的情况下，通过自 IPIs（自我处理器间中断）生成中断上下文回调，或者在像 powerpc 这样的架构上，设置递减器（内置的定时器设施）立即生成一个中断。没有类似机制的架构可以通过定时器（timer tick）进行回调。这些架构可以在 IRQ 处理程序的尾部调用 irq_work_run()来处理已经入队的 work，以避免在处理工作中产生不必要的延迟。这个补丁仅在 x86 平台上进行了测试。</p><blockquote><p>注：irq_work 设计的初衷就是将一些实时性比较高的工作放到中断上下文执行，在中断上下文实现像工作队列 work 一样执行。irq_work 执行的内容相对比较简单，它会将耗时任务通过工作队列推迟执行。</p></blockquote><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> arch/alpha/Kconfig                   |    <span class="number">1</span></span><br><span class="line"> arch/alpha/<span class="keyword">include</span>/<span class="keyword">asm</span>/perf_event.h  |    <span class="number">5</span> -</span><br><span class="line"> arch/alpha/kernel/time.c             |   <span class="number">30</span> +++---</span><br><span class="line"> arch/arm/Kconfig                     |    <span class="number">1</span></span><br><span class="line"> arch/arm/<span class="keyword">include</span>/<span class="keyword">asm</span>/perf_event.h    |   <span class="number">12</span> --</span><br><span class="line"> arch/arm/kernel/perf_event.c         |    <span class="number">8</span> -</span><br><span class="line"> arch/frv/Kconfig                     |    <span class="number">1</span></span><br><span class="line"> arch/frv/<span class="class"><span class="keyword">lib</span>/<span class="title">Makefile</span>                |    2</span></span><br><span class="line"> arch/frv/<span class="class"><span class="keyword">lib</span>/<span class="title">perf_event</span>.<span class="title">c</span>            |   19 ----</span></span><br><span class="line"> arch/parisc/Kconfig                  |    <span class="number">1</span></span><br><span class="line"> arch/parisc/<span class="keyword">include</span>/<span class="keyword">asm</span>/perf_event.h |    <span class="number">3</span></span><br><span class="line"> arch/powerpc/Kconfig                 |    <span class="number">1</span></span><br><span class="line"> arch/powerpc/<span class="keyword">include</span>/<span class="keyword">asm</span>/paca.h      |    <span class="number">2</span></span><br><span class="line"> arch/powerpc/kernel/time.c           |   <span class="number">42</span> ++++----</span><br><span class="line"> arch/s390/Kconfig                    |    <span class="number">1</span></span><br><span class="line"> arch/s390/<span class="keyword">include</span>/<span class="keyword">asm</span>/perf_event.h   |    <span class="number">3</span></span><br><span class="line"> arch/sh/Kconfig                      |    <span class="number">1</span></span><br><span class="line"> arch/sh/<span class="keyword">include</span>/<span class="keyword">asm</span>/perf_event.h     |    <span class="number">7</span> -</span><br><span class="line"> arch/sparc/Kconfig                   |    <span class="number">2</span></span><br><span class="line"> arch/sparc/<span class="keyword">include</span>/<span class="keyword">asm</span>/perf_event.h  |    <span class="number">4</span></span><br><span class="line"> arch/sparc/kernel/pcr.c              |    <span class="number">8</span> -</span><br><span class="line"> arch/x86/Kconfig                     |    <span class="number">1</span></span><br><span class="line"> arch/x86/<span class="keyword">include</span>/<span class="keyword">asm</span>/entry_arch.h    |    <span class="number">4</span></span><br><span class="line"> arch/x86/<span class="keyword">include</span>/<span class="keyword">asm</span>/hardirq.h       |    <span class="number">2</span></span><br><span class="line"> arch/x86/<span class="keyword">include</span>/<span class="keyword">asm</span>/hw_irq.h        |    <span class="number">2</span></span><br><span class="line"> arch/x86/<span class="keyword">include</span>/<span class="keyword">asm</span>/irq_vectors.h   |    <span class="number">4</span></span><br><span class="line"> arch/x86/kernel/Makefile             |    <span class="number">1</span></span><br><span class="line"> arch/x86/kernel/cpu/perf_event.c     |   <span class="number">19</span> ----</span><br><span class="line"> arch/x86/kernel/entry_64.S           |    <span class="number">6</span> -</span><br><span class="line"> arch/x86/kernel/irq.c                |    <span class="number">8</span> -</span><br><span class="line"> arch/x86/kernel/irq_work.c           |   <span class="number">30</span> ++++++</span><br><span class="line"> arch/x86/kernel/irqinit.c            |    <span class="number">6</span> -</span><br><span class="line"> <span class="keyword">include</span>/linux/irq_work.h             |   <span class="number">20</span> ++++</span><br><span class="line"> <span class="keyword">include</span>/linux/perf_event.h           |   <span class="number">11</span> --</span><br><span class="line"> init/Kconfig                         |    <span class="number">8</span> +</span><br><span class="line"> kernel/Makefile                      |    <span class="number">2</span></span><br><span class="line"> kernel/irq_work.c                    |  <span class="number">164</span> +++++++++++++++++++++++++++++++++++</span><br><span class="line"> kernel/perf_event.c                  |  <span class="number">104</span> +---------------------</span><br><span class="line"> kernel/timer.c                       |    <span class="number">7</span> +</span><br><span class="line"> <span class="number">39</span> files changed, <span class="number">311</span> insertions(+), <span class="number">242</span> deletions(-)</span><br><span class="line"> delete mode <span class="number">100644</span> arch/frv/<span class="class"><span class="keyword">lib</span>/<span class="title">perf_event</span>.<span class="title">c</span></span></span><br><span class="line"> create mode <span class="number">100644</span> arch/x86/kernel/irq_work.c</span><br><span class="line"> create mode <span class="number">100644</span> <span class="keyword">include</span>/linux/irq_work.h</span><br><span class="line"> create mode <span class="number">100644</span> kernel/irq_work.c</span><br></pre></td></tr></table></figure><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p><img src="3.webp" alt="图片"></p><ul><li>irq_work</li></ul><p>定义在 include/linux/irq_work.h 文件，irq_work 结构体是 Linux 内核中用于在中断上下文中执行回调函数的机制。irq_work_list 是一个 per cpu 链表，连接了当前 CPU 所有的 irq_work。irq_work 的 next 成员指向下一个 irq_work，它的最低两位被用来标记当前 irq_work 的状态（free/claimed/pending/busy）</p><ul><li>perf_event</li></ul><p>在 include/linux/perf_event.h 中定义，perf_event 是 Linux 性能计数框架的基础，它使得用户空间能够灵活地创建和管理性能监控事件，以收集系统和应用程序的性能数据。通过操作这个结构体，用户空间可以获取关于 CPU 周期、指令缓存命中、分支预测错误等性能相关的统计信息。perf_event 与 irq_work 的关联主要体现在性能事件（perf_event）的溢出处理和工作队列的调度上。如：当一个性能事件（perf_event）发生溢出时，内核需要执行相应的处理逻辑。这通常涉及到唤醒等待这些事件的应用，以便它可以处理这些数据。在内核中，perf_event 结构体中有一个 pending_irq 成员，它是一个 irq_work 结构体，用于处理性能事件的溢出工作。</p><h2 id="基本接口"><a href="#基本接口" class="headerlink" title="基本接口"></a>基本接口</h2><table>  <tr>    <th>接口名称</th>    <th>含义</th>  </tr>  <tr>    <td>bool irq_work_queue(struct irq_work *entry)</td>    <td>将 irq_work 实例 entry 入队，成功返回 true，如果 entry 已经被入队则失败，当 callback 回调仍在处理过程中，也可以入队</td>  </tr>  <tr>    <td>void irq_work_run(void)</td>    <td>运行当前 CPU 链表的 irq_work 项，要求在硬件中断上下文运行，且保持 local irq 关闭，以避免中断嵌套</td>  </tr>  <tr>    <td>void irq_work_sync(struct irq_work *entry)</td>    <td>同步对 irq_work 结构体实例 entry 的访问，确保该实例当前不被使用</td>  </tr></table><h2 id="irq-work-初始化"><a href="#irq-work-初始化" class="headerlink" title="irq_work 初始化"></a>irq_work 初始化</h2><p>声明了一个 irq_work 链表，它是一个 PER CPU 结构，irq_work 入队后，将链接到此链表</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+static <span class="constructor">DEFINE_PER_CPU(<span class="params">struct</span> <span class="params">irq_work</span> <span class="operator">*</span>, <span class="params">irq_work_list</span>)</span>;</span><br></pre></td></tr></table></figure><p>初始化一个 irq_work 需要指定它的回调 func，且将其next指针赋值为NULL</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">static</span> <span class="keyword">inline</span> void init_irq_work(struct irq_work *entry, void <span class="comment">(*func)(struct irq_work *)</span>)</span><br><span class="line">+<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">+       entry-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">+       entry-&gt;func = func;</span></span><br><span class="line"><span class="comment">+&#125;</span></span><br></pre></td></tr></table></figure><p>本 patch 中初始化一个 irq_work 的例子是 perf_event_alloc，它通过 init_irq_work 初始化一个 irq_work，这个 irq_work的回调perf_pending_event将唤醒等待 perf event 的进程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span></span> *</span><br><span class="line">perf_event_alloc(<span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span></span> *attr, int cpu,</span><br><span class="line">                 <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span> *task,</span><br><span class="line">                 <span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span></span> *group_leader,</span><br><span class="line">                 <span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span></span> *parent_event,</span><br><span class="line">                 perf_overflow_handler_t overflow_handler)</span><br><span class="line">|—— <span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span></span> *event;</span><br><span class="line">|—— event = kzalloc(sizeof(*event), GFP_KERNEL);</span><br><span class="line">|__ +init_irq_work(&amp;event-&gt;pending, perf_pending_event);</span><br></pre></td></tr></table></figure><h2 id="irq-work-的工作状态"><a href="#irq-work-的工作状态" class="headerlink" title="irq_work 的工作状态"></a>irq_work 的工作状态</h2><p><img src="4.webp" alt="图片"></p><p>irq_work 主要有如下几种工作状态：</p><table>  <tr>    <th>工作状态</th>    <th>说明</th>  </tr>  <tr>    <td>free</td>    <td>空闲状态，next 指针为 NULL，最低两位为 0，可转向 claimed 状态</td>  </tr>  <tr>    <td>claimed</td>    <td>声明状态，next 指针为 NULL，最低两位为 3，可转向 pending 状态</td>  </tr>  <tr>    <td>pending</td>    <td>待处理状态，next 指针不为 NULL，最低两位为 3，可转向 busy 状态</td>  </tr>  <tr>    <td>busy</td>    <td>忙状态，next 指针不为 NULL，最低两位为 2，可转向 free/claimed 状态</td>  </tr></table><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+/* kernel/irq_work.c */</span></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * An entry can be in one of four states:</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * free      NULL, 0 -&gt; &#123;claimed&#125;       : free to be used</span></span><br><span class="line"><span class="addition">+ * claimed   NULL, 3 -&gt; &#123;pending&#125;       : claimed to be enqueued</span></span><br><span class="line"><span class="addition">+ * pending   next, 3 -&gt; &#123;busy&#125;          : queued, pending callback</span></span><br><span class="line"><span class="addition">+ * busy      NULL, 2 -&gt; &#123;free, claimed&#125; : callback in progress, can be claimed</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * We use the lower two bits of the next pointer to keep PENDING and BUSY</span></span><br><span class="line"><span class="addition">+ * flags.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+#define IRQ_WORK_PENDING        1UL</span></span><br><span class="line"><span class="addition">+#define IRQ_WORK_BUSY           2UL</span></span><br><span class="line"><span class="addition">+#define IRQ_WORK_FLAGS          3UL</span></span><br></pre></td></tr></table></figure><blockquote><p>irq_work 在清空 claimed 标记后，可以重新 claimed，入队；irq_work 处理完毕后，会重置为 free 状态</p></blockquote><h2 id="irq-work-claim"><a href="#irq-work-claim" class="headerlink" title="irq_work claim"></a>irq_work claim</h2><p>irq_work claim 是指将 irq_work 标记为正在使用，以确保一次只有一个处理器或线程可以访问，防止并发修改。</p><p>claimed 通常用在并发编程的上下文中，特别是在多线程或多处理器环境中处理共享资源时。此处对 irq_work 执行 claim 指的是标记一个资源当前正在被特定线程或处理器使用。这样可以阻止其他线程或处理器同时访问。通过执行 irq_work_claim，线程或处理器可获得对该 irq_work 的独占访问。</p><p>(1) 如果 irq_work 实例 entry 已经被标记了 IRQ_WORK_PENDING，表示已经被 claimed；</p><p>(2) 对 irq_work 实例的 next 指针低两位赋值为 IRQ_WORK_FLAGS，表示转向 claimed 状态；</p><p>(3) 通过 while 循环中 cmpxchg 判断来验证对 irq_work 实例 entry 操作期间是否有发生并发修改访问，保证原子操作</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+static bool irq_work_claim(struct irq_work *entry)</span><br><span class="line"><span class="params">|—— +struct irq_work *<span class="keyword">next</span>, *nflags;</span></span><br><span class="line"><span class="params">|</span>—— +<span class="keyword">do</span> &#123;</span><br><span class="line"><span class="params">|   +      <span class="keyword">next</span> = entry-&gt;<span class="keyword">next</span>;</span></span><br><span class="line"><span class="params">|</span>   +      <span class="keyword">if</span> ((unsigned long)<span class="keyword">next</span> &amp; IRQ_WORK_PENDING)--(<span class="number">1</span>)</span><br><span class="line"><span class="params">|   +             <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="params">|</span>   +      nflags = next_flags(<span class="keyword">next</span>, IRQ_WORK_FLAGS);---(<span class="number">2</span>)</span><br><span class="line"><span class="params">|   +&#125; <span class="keyword">while</span> (cmpxchg(&amp;entry-&gt;<span class="keyword">next</span>, <span class="keyword">next</span>, nflags) != <span class="keyword">next</span>)；---(3)</span></span><br><span class="line"><span class="params">|</span>_<span class="number">_</span> +<span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="irq-work-入队"><a href="#irq-work-入队" class="headerlink" title="irq_work 入队"></a>irq_work 入队</h2><p>将 irq_work 入队到 irq_work_list 链表，等待处理：</p><p>(1) 判断 irq_work 实例 entry 是否已经入队，如果已经入队则返回 false;</p><p>(2) 将 irq_work 实例 entry 入队，成功返回 true</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="built_in">bool</span> irq<span class="constructor">_work_queue(<span class="params">struct</span> <span class="params">irq_work</span> <span class="operator">*</span><span class="params">entry</span>)</span></span><br><span class="line"><span class="pattern-match">|—— +<span class="keyword">if</span> (!irq<span class="constructor">_work_claim(<span class="params">entry</span>)</span>)-----------(1)</span></span><br><span class="line"><span class="pattern-match">|   +     return <span class="literal">false</span>;</span></span><br><span class="line"><span class="pattern-match">|—— +<span class="constructor">__irq_work_queue(<span class="params">entry</span>)</span>;--------------(2)</span></span><br><span class="line"><span class="pattern-match">|<span class="constructor">__</span> +return <span class="literal">true</span>;</span></span><br></pre></td></tr></table></figure><p>__irq_work_queue 具体实现 irq_work 的入队操作：</p><p>(1) irq_work_list 是一个 per-cpu 变量，是当前 cpu 上 irq_work 的链表头；</p><p>(2) 将 irq_work 实例 entry 入队到这个 wirq_work_list。next_flags 用于设置 irq_work 的状态，这里将 next 指针的低两位与 IRQ_WORK_FLAGS（0b11）执行了或操作，根据前面 irq_work 工作状态一节的分析，next 非 NULL, 且 bit10=0b11，则表示执行了入队操作，entry 实例转换为 peding 状态，这里通过使用 cmpxchg 函数原子地更新 head。如果更新成功（即返回值等于 next），则退出循环。</p><blockquote><p>cmpxchg 操作本身是原子的，它会检查 head 的当前值是否与 next 相等。如果不相等，cmpxchg 操作会失败，并返回 head 的当前值，这表明在执行 cmpxchg 期间 head 已经被其他线程或处理器修改，说明有其它线程或处理器执行了 irq_work 入队操作，需要重新入队。</p></blockquote><p>(3) irq_work_next 函数用于检查 entry 项是否是队列中的第一个元素。如果是，这意味着在加入 entry 之前队列是空的，因此需要触发一个自中断（self-interrupt）来开始处理队列中的工作项。arch_irq_work_raise 函数是一个架构相关的函数，用于触发自中断，它会通知当前 CPU 开始处理 irq_work 队列。</p><blockquote><p>为什么要在队列为空时触发自中断？因为如果没有工作项在队列中，当前 CPU 可能不会主动去检查和处理 irq_work 队列。通过触发自中断，可以确保即使在队列刚刚从空变为非空时，CPU 也能立即响应并开始处理队列中的工作项。</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+static void <span class="constructor">__irq_work_queue(<span class="params">struct</span> <span class="params">irq_work</span> <span class="operator">*</span><span class="params">entry</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+        <span class="keyword">struct</span> irq_work **head, *next;</span><br><span class="line">+</span><br><span class="line">+        head = &amp;get<span class="constructor">_cpu_var(<span class="params">irq_work_list</span>)</span>;--------------------(<span class="number">1</span>)</span><br><span class="line">+</span><br><span class="line">+        <span class="keyword">do</span> &#123;</span><br><span class="line">+                next = *head;</span><br><span class="line">+                <span class="comment">/* Can assign non-atomic because we keep the flags set. */</span></span><br><span class="line">+                entry-&gt;next = next<span class="constructor">_flags(<span class="params">next</span>, IRQ_WORK_FLAGS)</span>;</span><br><span class="line">+        &#125; <span class="keyword">while</span> (cmpxchg(head, next, entry) != next);----------(<span class="number">2</span>)</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">/* The list was empty, raise self-interrupt to start processing. */</span></span><br><span class="line">+        <span class="keyword">if</span> (!irq<span class="constructor">_work_next(<span class="params">entry</span>)</span>)-----------------------------(<span class="number">3</span>)</span><br><span class="line">+                arch<span class="constructor">_irq_work_raise()</span>;</span><br><span class="line">+</span><br><span class="line">+        put<span class="constructor">_cpu_var(<span class="params">irq_work_list</span>)</span>;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><p>当前 patch 中，irq_work 入队的发生时机位于 PMU 中断中，如果处于 NMI 中断上下文，则会通过 irq_work_queue 将一些操作通过 irq_work 执行；这样可以避免 NMI 中处理一些复杂操作。</p><blockquote><p>PMU 是一个硬件组件，用于监控、跟踪、计数系统内部的一些底层硬件事件，包括与 CPU 有关的事件（如执行指令数、捕获异常数、时钟周期数等），与 cache 有关的事件（数据/指令/L1/L2 cache 访问次数，cache miss 次数等）以及与 TLB 有关的事件等。对于 x86 架构，PMU（Performance Monitoring Unit）中断被配置为 NMI（Non-Maskable Interrupt）来处理。这种配置确保了性能监控事件的高优先级处理，即使在其他中断被禁用的情况下也能及时响应。在 arch/x86/events/core.c::perf_events_lapic_init()函数中，PMI（Performance Monitoring Interrupt）被配置为通过 NMI 向操作系统发送通知。这种配置允许操作系统在性能计数器溢出时，通过调用 perf_event_overflow 函数来处理数据采样和事件通知，而这个函数中的 nmi 参数用于指示性能事件是否是在 NMI 上下文中触发的。</p></blockquote><p>NMI 中断不能做太复杂的操作，因为 NMI 处理程序需要快速执行以避免影响系统的稳定性。NMI 处理程序需要快速返回以避免影响系统的实时性。通过将一些可以延迟处理的任务放入 irq_work_queue，NMI 处理程序可以快速返回，而将复杂的处理逻辑推迟到后续执行，这样可以保证系统的响应性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> x86<span class="constructor">_pmu_handle_irq(<span class="params">struct</span> <span class="params">pt_regs</span> <span class="operator">*</span><span class="params">regs</span>)</span></span><br><span class="line"><span class="pattern-match">|—— perf<span class="constructor">_event_overflow(<span class="params">event</span>, 1, &amp;<span class="params">data</span>, <span class="params">regs</span>)</span></span></span><br><span class="line"><span class="pattern-match">|    |<span class="constructor">__</span> <span class="constructor">__perf_event_overflow(<span class="params">event</span>, <span class="params">nmi</span>, 1, <span class="params">data</span>, <span class="params">regs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">|        |—— event-&gt;pending<span class="constructor">_disable</span> = 1;</span></span><br><span class="line"><span class="pattern-match">|        |<span class="constructor">__</span> +irq<span class="constructor">_work_queue(&amp;<span class="params">event</span>-&gt;<span class="params">pending</span>)</span></span></span><br><span class="line"><span class="pattern-match">|<span class="constructor">__</span> return handled;</span></span><br></pre></td></tr></table></figure><h2 id="irq-work-运行"><a href="#irq-work-运行" class="headerlink" title="irq_work 运行"></a>irq_work 运行</h2><p>irq_work_run 用于执行当前 CPU 链表的 irq_work 项，它会遍历当前 cpu 的 irq_work 链表，执行所有 irq_work 的 func 回调。这里需要注意的是 irq_work_run 属于硬件上下文，需要将 local irq 关掉，以避免发生中断嵌套</p><p>(1) irq_work_list 是一个 per-cpu 变量，是当前 cpu 上 irq_work 的链表头；</p><p>(2) 用于原子判断链表是否空；</p><p>(3) 如果链表不为空，则会循环遍历每个 irq_work 项，执行其 func 回调函数。这里 next_flags 用于设置 irq_work 的状态为 busy，回调函数执行完毕后，irq_work 切换为 free 状态</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+void irq_work_run(void)</span><br><span class="line">|—— +struct irq_work *<span class="keyword">list</span>, **head;</span><br><span class="line">|—— +head = &amp;__get_cpu_var(irq_work_list);----------------(<span class="number">1</span>)</span><br><span class="line">|—— +<span class="keyword">list</span> = xchg(head, <span class="keyword">NULL</span>);-----------------------------(<span class="number">2</span>)</span><br><span class="line">|__ +<span class="keyword">while</span> (<span class="keyword">list</span> != <span class="keyword">NULL</span>)---------------------------------(<span class="number">3</span>)</span><br><span class="line">        +struct irq_work *entry = <span class="keyword">list</span>;</span><br><span class="line">        +<span class="keyword">list</span> = irq_work_next(<span class="keyword">list</span>);</span><br><span class="line">        +entry-&gt;next = next_flags(<span class="keyword">NULL</span>, IRQ_WORK_BUSY);</span><br><span class="line">        +entry-&gt;func(entry);</span><br><span class="line">        +cmpxchg(&amp;entry-&gt;next, next_flags(<span class="keyword">NULL</span>,</span><br><span class="line">        +            RQ_WORK_BUSY), <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>在当前 patch 中 irq_work 运行时机，主要包含两个：pmu 中断中（如 ARM 处理器）；定时器中断中</p><ul><li>pmu 中断中</li></ul><p>对于 ARM 处理器（如 ARMV7）的 PMU 组件有 1 个 cycle 计数器和多个其它事件计数器，通过配置可以指定时间计数器的阈值，当事件累积次数达到阈值时，计数器就会溢出触发中断。对于 ARMV7，对应的 PMU 硬件中断处理程序为 armv7pmu_handle_irq，它会通过 irq_work_run 执行 irq_work 队列中的 irq_work，而这个 irq_work 的回调就是用来处理 pending 的的 perf events 事件的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arch/arm/kernel/perf_event.c</span></span><br><span class="line">static irqreturn_t armv7pmu<span class="constructor">_handle_irq(<span class="params">int</span> <span class="params">irq_num</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line"><span class="pattern-match">|—— +irq<span class="constructor">_work_run()</span>；</span></span><br><span class="line"><span class="pattern-match">|<span class="constructor">__</span> return <span class="constructor">IRQ_HANDLED</span>;</span></span><br></pre></td></tr></table></figure><ul><li>定时器中断中</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void update_process_times(<span class="keyword">int</span> user_tick)</span><br><span class="line">|_<span class="number">_</span> +<span class="keyword">if</span> (in_ir<span class="string">q()</span>)</span><br><span class="line">    +    irq_work_run();</span><br></pre></td></tr></table></figure><h2 id="irq-work-同步"><a href="#irq-work-同步" class="headerlink" title="irq_work 同步"></a>irq_work 同步</h2><p>irq_work同步对 irq_work 结构的访问，确保在执行某个操作时 irq_work 不会被其他执行路径同时使用。通过检查和等待 irq_work 的状态来实现。irq_work_sync 函数通常需要确保 irq_work 不会被中断或其他执行路径同时使用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">++ * Synchronize against the irq_work @entry, ensures the entry is not</span></span><br><span class="line"><span class="comment">+ * currently in use.</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+void irq<span class="constructor">_work_sync(<span class="params">struct</span> <span class="params">irq_work</span> <span class="operator">*</span><span class="params">entry</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+        <span class="constructor">WARN_ON_ONCE(<span class="params">irqs_disabled</span>()</span>);</span><br><span class="line">+</span><br><span class="line">+        <span class="keyword">while</span> (irq<span class="constructor">_work_is_set(<span class="params">entry</span>, IRQ_WORK_BUSY)</span>)</span><br><span class="line">+                cpu<span class="constructor">_relax()</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+<span class="constructor">EXPORT_SYMBOL_GPL(<span class="params">irq_work_sync</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用 irq_work_sync 的一个时机是 perf_event 释放时：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void free<span class="constructor">_event(<span class="params">struct</span> <span class="params">perf_event</span> <span class="operator">*</span><span class="params">event</span>)</span></span><br><span class="line"><span class="pattern-match">|—— +irq<span class="constructor">_work_sync(&amp;<span class="params">event</span>-&gt;<span class="params">pending</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">|—— <span class="keyword">if</span> (!event-&gt;parent) &#123;</span></span><br><span class="line"><span class="pattern-match">|             atomic<span class="constructor">_dec(&amp;<span class="params">nr_events</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">|<span class="constructor">__</span> call<span class="constructor">_rcu(&amp;<span class="params">event</span>-&gt;<span class="params">rcu_head</span>, <span class="params">free_event_rcu</span>)</span>;</span></span><br></pre></td></tr></table></figure><h2 id="irq-work-与工作队列-work-的比较"><a href="#irq-work-与工作队列-work-的比较" class="headerlink" title="irq_work 与工作队列 work 的比较"></a>irq_work 与工作队列 work 的比较</h2><div class="table-container"><table><thead><tr><th>比较项</th><th>irq_work</th><th>工作队列 work</th></tr></thead><tbody><tr><td>执行上下文</td><td>中断上下文</td><td>进程上下文</td></tr><tr><td>同步机制</td><td>通过 irq_work_sync 函数，确保在执行 irq_work 时不会被其他中断或执行路径同时使用，从而避免数据竞争和同步问题</td><td>通常使用互斥锁（mutexes）或其他同步机制来保护共享数据</td></tr><tr><td>延迟和调度</td><td>一旦触发，通常会尽快在中断上下文执行，延迟相对较低，通常只会执行简单操作，复杂操作推迟到软中断上下文或通过工作队列推迟到进程上下文</td><td>可以通过 schedule_delayed_work 或 queue_delayed_work 来实现延迟执行，提供了更灵活的调度选项</td></tr><tr><td>使用场景</td><td>适合实时性要求高的场景</td><td>适合处理不需要立即完成的任务</td></tr></tbody></table></div><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>[1]<a href="https://lore.kernel.org/lkml/1287036094.7768.291.camel@yhuang-dev/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/1287036094.7768.291.camel@yhuang-dev/</a> </p><p>[2]<a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en" target="_blank" rel="noopener">https://developer.arm.com/documentation/ddi0406/cd/?lang=en</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>物格而后知至：WALT调度器之RTG</title>
      <link href="/2024/12/25/%E7%89%A9%E6%A0%BC%E8%80%8C%E5%90%8E%E7%9F%A5%E8%87%B3-WALT%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8BRTG/"/>
      <url>/2024/12/25/%E7%89%A9%E6%A0%BC%E8%80%8C%E5%90%8E%E7%9F%A5%E8%87%B3-WALT%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8BRTG/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a><strong>1. 引言</strong></h1><p><img src="1.webp" alt=""></p><p>我们在《浅析高通 mvp 进程优先调度》一文中有提到 RTG 任务是 mvp 进程优先调度的其中一种任务类型，然而 RTG 的的影响范围不仅仅是进程优先调度。下面再带大家物格而后知至：再研读高通 WALT 调度器中的RTG。</p><p>RTG（Related Thread Group）是高通引入的一个特性，目的是将关联的进程加入到同一个group组中，用于提升性能。比如显示相关的主线程和render线程就可以加入到相同的RTG组中，根据实际需求，对其进行一些特殊处理。可以<br>将其调度到同一个CPU簇上，使得它们可以共享相同的cache资源，减少cache miss；也可以聚合RTG组里的任务负载，提升CPU的频率，达到性能提升的目的。RTG对于选核也会产生一定的影响。除此之外，在RTG的基础上引申出来很&gt;多其它的特性，如优先调度等。本文在分析时难免出现错误和遗漏，欢迎批评指正。</p><h1 id="2-RTG总体说明"><a href="#2-RTG总体说明" class="headerlink" title="2. RTG总体说明"></a><strong>2. RTG总体说明</strong></h1><p><img src="2.webp" alt=""></p><p>RTG在内核中定义了一个独立的结构体，但是它在内核中并非以一个独立的模块存在，而是散落在WALT的各处代码中：</p><ol><li>用户空间可以通过/proc文件节点将某个任务设置到RTG的不同组中</li><li>在将任务加到cgroup中时，会同时将任务添加到RTG中，默认”top-app” cgroup中的任务设置到默认RTG 组，其它任务通过sysctl设置到其它RTG组</li><li>在WALT FREQ GOV调频的过程中会参考CPU当前是否运行RTG任务，做出调频决策，如果是则会影响其调频行为；在某些场景下，CPU也会累加RTG任务的负载，起到聚合调频的作用</li><li>在WALT CFS和RT任务选核的过程中会参考CPU当前是否运行RTG任务，或要选核的任务是否位于RTG，做出选核决策，如果是则会影响其选核行为</li></ol><h1 id="3-RTG相关数据结构"><a href="#3-RTG相关数据结构" class="headerlink" title="3. RTG相关数据结构"></a><strong>3. RTG相关数据结构</strong></h1><p><img src="3.webp" alt=""></p><ol><li>walt_related_thread_group<br>用于管理RTG任务，位于同一个RTG组的任务一般被调度到同一个CPU（cluste）运行，共享cache，提升性能。它维护了一个taks链表，RTG组内所有的任务将链接到此链表；RTG的skip_min显示他倾向的选核策略，如果为true，则选<br>择大核或超大核运行，略过小核;</li><li>walt_cpu_load<br>用于管理CPU负载，其中rtgb_active将影响CPU Busy的延迟时间（如进入lpm的时间），如果rtgb_active为true则会延长CPU某一个状态的时间，避免频繁进出状态引发抖动；rtgb_active也会影响调频，当rtgb_active为true时，  则会优先满足RTG组任务的util，从而影响了调频频率;</li><li>waltgov_cpu<br>用于管理CPU的WALT调频，它的walt_load中的rtgb_active会影响CPU的调频和CPU状态延迟时间;</li><li>waltgov_tunables<br>作为walt gov的旋钮，它确定了不同算力CPU的boost频率，记录在rtg_boost_freq里，rtg_boost_freq主要作为CPU调频时的参考，如对于RTG任务调频时，将参考这个值, 相当于会对频率做一些抬升;</li><li>waltgov_policy<br>用于管理cluster的walt调频，它的rtg_boost_util是参考waltgov_tunables的rtg_boost_freq得到的boot util，在调频时也会参考这个值;</li><li>walt_sched_stats<br>walt运行队列的统计数据，它的nr_rtg_high_prio_tasks代表队列中高优先级任务的个数。它对CPU状态延迟时间和选核都有影响，如果walt_nr_rtg_high_prio大于一定的阈值，则任务选核时将略过这个CPU，避免与RTG任务产生竞<br>争</li></ol><h1 id="4-RTG初始化"><a href="#4-RTG初始化" class="headerlink" title="4. RTG初始化"></a><strong>4. RTG初始化</strong></h1><p>RTG相关的初始化是在WALT的初始化过程中完成的，主要通过walt_init和waltgov_init：</p><h2 id="WALT初始化"><a href="#WALT初始化" class="headerlink" title="WALT初始化"></a>WALT初始化</h2><p>WALT初始化主要调用walt_init，与RTG相关的初始化工作主要包含：<br>(1) walt_init会遍历所有的walt_task_group，对其进行初始化，其中对colocate的初始化会影响到RTG，可以看到只有”top-app” task_group的colocate置为true，colocate会影响cgroup任务的RTG分组;<br>(2) 注册了cpu cgroup attach的vendor hook回调。这个回调的主要功能是在任务加入到cgroup时，将任务也加入到RTG组中<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.c</span><br><span class="line">static void walt_init(struct work_struct *work)</span><br><span class="line">    |- walt_init_tg_pointers();--------------------------（1）</span><br><span class="line">    |   |_ css_for_each_child(css, top_css)</span><br><span class="line">    |         walt_update_tg_pointer(css);</span><br><span class="line">    |_register_walt_hooks()-----------------------------（2）</span><br><span class="line">        |_ register_trace_android_rvh_cpu_cgroup_attach(android_rvh_cpu_cgroup_attach, NULL);</span><br></pre></td></tr></table></figure></p><h2 id="WALT-governor初始化"><a href="#WALT-governor初始化" class="headerlink" title="WALT governor初始化"></a>WALT governor初始化</h2><p>WALT governor初始化主要通过waltgov_init对walt调频器进行初始化，这里仅列出与RTG相关的部分，它会根据CPU的类型，设定RTG boost频率；这个RTG boost频率将来对RTG任务的调频会产生影响，参考 RTG影响调频 一节。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/cpufreq_walt.c</span><br><span class="line">static int waltgov_init(struct cpufreq_policy *policy)</span><br><span class="line">    |- struct waltgov_tunables *tunables;</span><br><span class="line">    |- tunables = kzalloc(sizeof(*tunables), GFP_KERNEL);</span><br><span class="line">                                                                                                                                                                                            |  ......</span><br><span class="line">    |_ if (is_min_possible_cluster_cpu(policy-&gt;cpu))</span><br><span class="line">            tunables-&gt;rtg_boost_freq = DEFAULT_SILVER_RTG_BOOST_FREQ;</span><br><span class="line">      else if (is_max_possible_cluster_cpu(policy-&gt;cpu))</span><br><span class="line">            tunables-&gt;rtg_boost_freq = DEFAULT_PRIME_RTG_BOOST_FREQ;</span><br><span class="line">      else</span><br><span class="line">            tunables-&gt;rtg_boost_freq = DEFAULT_GOLD_RTG_BOOST_FREQ;</span><br></pre></td></tr></table></figure><br>对于不同类型的CPU簇，定义了不同的RTG boost频率阈值如下，可以看到不同算力的cluster，它的boost频率定义也不一样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/cpufreq_walt.c</span><br><span class="line">#define DEFAULT_SILVER_RTG_BOOST_FREQ 1000000</span><br><span class="line">#define DEFAULT_GOLD_RTG_BOOST_FREQ 768000</span><br><span class="line">#define DEFAULT_PRIME_RTG_BOOST_FREQ 0</span><br></pre></td></tr></table></figure></p><h1 id="5-将任务加入RTG组"><a href="#5-将任务加入RTG组" class="headerlink" title="5. 将任务加入RTG组"></a><strong>5. 将任务加入RTG组</strong></h1><p>有两种方法可以将任务设置到RTG组：通过sysctl进行设置；通过cgroup进行设置。</p><h2 id="通过sysctl设置进程到RTG组"><a href="#通过sysctl设置进程到RTG组" class="headerlink" title="通过sysctl设置进程到RTG组"></a>通过sysctl设置进程到RTG组</h2><p>通过sysctl可以将一个WALT任务添加到RTG组中，操作方法举例如下，其中pidxx为任务的pid：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo pidxx &gt; /proc/sys/walt/sched_task_read_pid</span><br><span class="line"># echo pidxx group_idxx &gt; /proc/sys/walt/sched_group_id</span><br></pre></td></tr></table></figure></p><h2 id="通过cgroup设置进程到RTG组"><a href="#通过cgroup设置进程到RTG组" class="headerlink" title="通过cgroup设置进程到RTG组"></a>通过cgroup设置进程到RTG组</h2><p>前面介绍WAL初始化时，提到会注册cpu cgroup attach的vendor hook回调，任务在加入到某个cgroup中时，会触发执行android_rvh_cpu_cgroup_attach，它会遍历cgroup task group里的任务，将其加入到RTG组中。如walt_task_group的colocate为真则加入到RTG 默认组（ID为DEFAULT_CGROUP_COLOC_ID）；否则不允许加入到RTG组。在前面walt_init中可以看到只有”top-app” task group中的任务才可以加入到默认RTG默认组，这也预示着默认情况下，只&gt;有“top-app” task group组的任务享有RTG的的”待遇“，如调频/选核等。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.c</span><br><span class="line">static void android_rvh_cpu_cgroup_attach(void *unused,</span><br><span class="line">    |        struct cgroup_taskset *tset)</span><br><span class="line">    |- struct task_group *tg;</span><br><span class="line">    |- cgroup_taskset_first(tset, &amp;css);</span><br><span class="line">    |- tg = container_of(css, struct task_group, css);</span><br><span class="line">    |- wtg = (struct walt_task_group *) tg-&gt;android_vendor_data1;</span><br><span class="line">    |_ cgroup_taskset_for_each(task, css, tset)</span><br><span class="line">           grp_id = wtg-&gt;colocate ? DEFAULT_CGROUP_COLOC_ID : 0;</span><br><span class="line">           __sched_set_group_id(task, grp_id);</span><br></pre></td></tr></table></figure></p><h1 id="6-RTG-的-CFS-选核"><a href="#6-RTG-的-CFS-选核" class="headerlink" title="6. RTG 的 CFS 选核"></a><strong>6. RTG 的 CFS 选核</strong></h1><p>RTG影响选核主要发生在唤醒一个进程时。选核的主要原则是：如果被唤醒的是RTG组的任务，则它会倾向于选择算力充足的cluster；如果被唤醒的是其它任务，则它倾向于与RTG组的任务分开，不运行在同一个CPU上。<br>(1) 通过set_preferred_cluster来选择一个倾向的cluster，这个过程会受RTG组任务的影响；<br>(2) 通过walt_select_task_rq_fair选择一个 cpu来运行<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/core.c</span><br><span class="line">static int</span><br><span class="line">try_to_wake_up(struct task_struct *p, unsigned int state, </span><br><span class="line">    |              int wake_flags)</span><br><span class="line">    |    |_ android_rvh_try_to_wake_up(unused, p)</span><br><span class="line">    |        |_ if (update_preferred_cluster(grp, p, old_load, false))</span><br><span class="line">    |             set_preferred_cluster(grp);---------------------(1)</span><br><span class="line">    |                |_ _set_preferred_cluster(grp)</span><br><span class="line">    |- cpu = select_task_rq(p, p-&gt;wake_cpu, wake_flags | WF_TTWU)</span><br><span class="line">    |    |_ select_task_rq_fair(p, cpu, wake_flags)</span><br><span class="line">    |        |_ walt_select_task_rq_fair(void *unused, </span><br><span class="line">    |            p, prev_cpu, sd_flag, wake_flags, target_cpu)----(2)</span><br><span class="line">    |_ ttwu_queue(p, cpu, wake_flags)</span><br></pre></td></tr></table></figure></p><h2 id="set-preferred-cluster"><a href="#set-preferred-cluster" class="headerlink" title="set_preferred_cluster"></a>set_preferred_cluster</h2><p>对于RTG任务，在选核时会选取满足RTG算力的最佳的cluster，保存在walt_related_thread_group的preferred_cluster:<br>(1) 循环遍历RTG组里所有的任务，如果任务p的boost  policy为SCHED_BOOST_ON_BIG，表示需要至少在大核上面运行，为后续选核遍历做index指导；否则累加RTG组所有任务的负载，以此作为选核的依据，将来也会用来做聚合调频&gt;；如果运行时间太短，则任务是一个新任务，退出不做选核操作；<br>(2) update_best_cluster根据combined_demand来更新cluster，主要是更新walt_related_thread_group的skip_min, 它决定了更倾向于哪个cluster，如果为true则倾向于大核<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.c</span><br><span class="line">static void _set_preferred_cluster(struct walt_related_thread_group *grp)</span><br><span class="line">    |- u64 combined_demand = 0;</span><br><span class="line">    |  bool group_boost = false</span><br><span class="line">    |- list_for_each_entry(wts, &amp;grp-&gt;tasks, grp_list)---------------(1)</span><br><span class="line">    |    p = wts_to_ts(wts);</span><br><span class="line">    |    if (task_boost_policy(p) == SCHED_BOOST_ON_BIG)</span><br><span class="line">    |            group_boost = true;</span><br><span class="line">    |            break;</span><br><span class="line">    |</span><br><span class="line">    |    if (wts-&gt;mark_start <span class="tag">&lt; <span class="attr">wallclock</span> <span class="attr">-</span></span></span><br><span class="line"><span class="tag">    |        (<span class="attr">sched_ravg_window</span> * <span class="attr">RAVG_HIST_SIZE</span>))</span></span><br><span class="line"><span class="tag">    |            <span class="attr">continue</span>;</span></span><br><span class="line"><span class="tag">    |</span></span><br><span class="line"><span class="tag">    |    <span class="attr">combined_demand</span> += <span class="string">wts-</span>&gt;</span>coloc_demand;</span><br><span class="line">    |    if (!trace_sched_set_preferred_cluster_enabled())</span><br><span class="line">    |            if (combined_demand &gt; sched_group_upmigrate)</span><br><span class="line">    |                    break;</span><br><span class="line">    |- grp-&gt;last_update = wallclock;</span><br><span class="line">    |_ update_best_cluster(grp, combined_demand, group_boost);-------(2)</span><br></pre></td></tr></table></figure></p><h2 id="walt-select-task-rq-fair"><a href="#walt-select-task-rq-fair" class="headerlink" title="walt_select_task_rq_fair"></a>walt_select_task_rq_fair</h2><p>walt_select_task_rq_fair为任务选取一个合适的运行队列，这里特别说明下sync标志，在Linux内核调度器中，WF_SYNC标志用于表示同步唤醒（sync wakeup）。同步唤醒是指在唤醒操作后，唤醒者（waker）即将进入睡眠状态的&gt;场景。具体来说，当一个任务（waker）唤醒另一个任务（wakee）后，如果WF_SYNC标志被设置，这意味着waker很快会进入阻塞状态，因此调度器会倾向于将wakee放置在waker当前运行的CPU上，以减少上下文切换和提高效率，因此<br>处于性能考虑，如果当前任务和唤醒的任务都是RTG任务，则避免将其调度到同个CPU上：</p><p>(1) walt_get_indicies会确定一个选核的范围，对于RTG任务，选核会从cluster1开始，而非从cluster0开始；<br>(2) 如果任务p和当前运行的是都是RTG任务，那么尽量避免将任务p调度到与当前任务相同的CPU上；<br>(3) walt_find_best_target选择最佳的cpu，在选择CPU时，尽量分散高优先级的RTG任务，以避免它们相互抢占，同时优先选择剩余容量最大的CPU。这是一种优化策略，旨在提高系统的性能和响应速度。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt_cfs.c</span><br><span class="line">walt_select_task_rq_fair(void *unused, p, prev_cpu, sd_flag, wake_flags, target_cpu)</span><br><span class="line">    |- int sync;</span><br><span class="line">    |  sync = (wake_flags &amp; WF_SYNC) &amp;&amp; !(current-&gt;flags &amp; PF_EXITING);</span><br><span class="line">    |_ *target_cpu=walt_find_energy_efficient_cpu(p, prev_cpu, sync, sibling_count_hint)</span><br><span class="line">        |- walt_get_indicies(p, &amp;order_index, &amp;end_index, task_boost, uclamp_boost,</span><br><span class="line">        |                          &amp;energy_eval_needed);------------------------(1)</span><br><span class="line">        |      |_ walt_task_skip_min_cpu(p)</span><br><span class="line">        |- is_rtg = task_in_related_thread_group(p);</span><br><span class="line">        |- curr_is_rtg = task_in_related_thread_group(cpu_rq(cpu)-&gt;curr)</span><br><span class="line">        |- if (sync &amp;&amp; (need_idle || (is_rtg &amp;&amp; curr_is_rtg)))</span><br><span class="line">        |    sync = 0;-----------------------------------------------------------(2)</span><br><span class="line">        |_ walt_find_best_target(NULL, candidates, p, &amp;fbt_env)-----------------（3）</span><br></pre></td></tr></table></figure><br>walt_find_best_target的实现如下，在选择CPU时，尽量分散高优先级的RTG任务，以避免它们相互抢占，同时优先选择剩余容量最大的CPU。这是一种优化策略，旨在提高系统的性能和响应速度。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt_cfs.c</span><br><span class="line">static void walt_find_best_target(struct sched_domain *sd,</span><br><span class="line">                                        cpumask_t *candidates,</span><br><span class="line">                                        struct task_struct *p,</span><br><span class="line">                                        struct find_best_target_env *fbt_env)</span><br><span class="line">    |- unsigned int target_nr_rtg_high_prio = UINT_MAX;</span><br><span class="line">    |  bool rtg_high_prio_task = task_rtg_high_prio(p);</span><br><span class="line">    |_ for_each_cpu(i, &amp;visit_cpus)</span><br><span class="line">            if (rtg_high_prio_task) &#123;</span><br><span class="line">                    if (walt_nr_rtg_high_prio(i) &gt; target_nr_rtg_high_prio)</span><br><span class="line">                            continue;</span><br><span class="line">                    /* Favor CPUs with maximum spare capacity */</span><br><span class="line">                    if (walt_nr_rtg_high_prio(i) == target_nr_rtg_high_prio &amp;&amp;</span><br><span class="line">                                    spare_cap <span class="tag">&lt; <span class="attr">target_max_spare_cap</span>)</span></span><br><span class="line"><span class="tag">                            <span class="attr">continue</span>;</span></span><br><span class="line"><span class="tag">            &#125; <span class="attr">else</span> &#123;</span></span><br><span class="line"><span class="tag">                    /* <span class="attr">Favor</span> <span class="attr">CPUs</span> <span class="attr">with</span> <span class="attr">maximum</span> <span class="attr">spare</span> <span class="attr">capacity</span> */</span></span><br><span class="line">                    if (spare_cap &lt; target_max_spare_cap)</span><br><span class="line">                            continue;</span><br><span class="line">            &#125;</span><br><span class="line">            target_max_spare_cap = spare_cap;</span><br><span class="line">            target_nr_rtg_high_prio = walt_nr_rtg_high_prio(i);</span><br><span class="line">            target_cpu_cluster = i;</span><br></pre></td></tr></table></figure></p><h1 id="7-RTG-的-RT-选核"><a href="#7-RTG-的-RT-选核" class="headerlink" title="7. RTG 的 RT 选核"></a><strong>7. RTG 的 RT 选核</strong></h1><p>walt_select_task_rq_rt在为rt任务选核过程中，会对当前CPU的状态进行判断，如果CPU当前运行的任务属于低延迟任务（如RTG任务）或RTG高优先级任务（RT任务且位于RTG）数不为0，则不会将RT任务调度到此cpu core上, 以避&gt;免与RTG任务争夺资源。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt_rt.c</span><br><span class="line">static void walt_select_task_rq_rt(void *unused, struct task_struct *task, int cpu,</span><br><span class="line">                                        int sd_flag, int wake_flags, int *new_cpu)</span><br><span class="line">    |_ walt_rt_energy_aware_wake_cpu(task, &amp;lowest_mask_reduced, ret, &amp;target)</span><br><span class="line">        |_ for (cluster = 0; cluster <span class="tag">&lt; <span class="attr">num_sched_clusters</span>; <span class="attr">cluster</span>++)</span></span><br><span class="line"><span class="tag">                <span class="attr">for_each_cpu_and</span>(<span class="attr">cpu</span>, <span class="attr">lowest_mask</span>, &amp;<span class="attr">cpu_array</span>[<span class="attr">order_index</span>][<span class="attr">cluster</span>])</span></span><br><span class="line"><span class="tag">                    |<span class="attr">-</span> <span class="attr">lt</span> = <span class="string">(walt_low_latency_task(cpu_rq(cpu)-</span>&gt;</span>curr) ||</span><br><span class="line">                    |                    walt_nr_rtg_high_prio(cpu));</span><br><span class="line">                    |_ if (lt &amp;&amp; !best_cpu_lt)</span><br><span class="line">                            continue;</span><br></pre></td></tr></table></figure></p><h1 id="8-RTG-的负载均衡选核"><a href="#8-RTG-的负载均衡选核" class="headerlink" title="8. RTG 的负载均衡选核"></a><strong>8. RTG 的负载均衡选核</strong></h1><p>负载均衡指的是让CPU获得与其算力匹配的负载，广义的负载均衡包含：负载均衡（load balance）、任务放置（task placement）、主动均衡（active upmigration）。前面简要介绍过RTG对任务放置的影响，下面主要介绍RTG对负<br>载均衡（load balance）的影响，这里仅考虑CFS任务。</p><p>那么触发负载均衡（load balance）的时机有哪些呢？概括的讲，主要包含有两种情况：<br>(1)当系统tick事件发生时会通过软中断触发负载均衡（load balance）<br>periodic balance，找到调度域中负载最重的调度组，将其上的runnable任务拉到本CPU以便让该调度域上各个调度组的负载处于均衡的状态，让 busy cpu 之间负载均衡。<br>nohz idle load banlance，本CPU任务太重，其他任务处于 idle，需要通过ipi将idle的cpu唤醒来进行负载均衡。<br>(2)当scheduler选取下一个任务时，如果rq没有可运行的任务，此时只能执行idle线程，就会通过newidle_balance来触发new idle load balance。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/fair.c</span><br><span class="line">static int load_balance(int this_cpu, struct rq *this_rq,------------------------（1）</span><br><span class="line">                        struct sched_domain *sd, enum cpu_idle_type idle,</span><br><span class="line">                        int *continue_balancing)</span><br><span class="line">    |_ detach_tasks(&amp;env)</span><br><span class="line">        |_ can_migrate_task(p, env)</span><br><span class="line">            |_ trace_android_rvh_can_migrate_task(p, env-&gt;dst_cpu, &amp;can_migrate)</span><br><span class="line">                |_ walt_can_migrate_task(void *unused, p, env-&gt;dst_cpu, can_migrate)</span><br><span class="line">                    |_ _walt_can_migrate_task(p, dst_cpu, to_lower, to_higher, true)</span><br></pre></td></tr></table></figure><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/core.c</span><br><span class="line">static void __sched notrace __schedule(unsigned int sched_mode)-----------------（2）</span><br><span class="line">    |_ pick_next_task(rq, prev, &amp;rf)</span><br><span class="line">        |_ put_prev_task_balance(rq, prev, rf)</span><br><span class="line">            |_ for_class_range(class, prev-&gt;sched_class, &amp;idle_sched_class)</span><br><span class="line">                    class-&gt;balance(rq, prev, rf)</span><br><span class="line">                    balance_fair(rq, struct prev, rf)</span><br><span class="line">                        |_ newidle_balance(rq, rf)</span><br><span class="line">                            |_ trace_android_rvh_sched_newidle_balance(this_rq, rf, &amp;pulled_task, &amp;done);</span><br><span class="line">                                 |_ walt_newidle_balance(this_rq, rf, pulled_task, done, false)</span><br><span class="line">                                    |_ walt_lb_pull_tasks(this_cpu, busy_cpu, pulled_task_struct);</span><br><span class="line">                                        |_ list_for_each_entry_reverse(p, &amp;src_rq-&gt;cfs_tasks, se.group_node)</span><br><span class="line">                                              if (!_walt_can_migrate_task(p, dst_cpu, to_lower, to_higher, false))</span><br><span class="line">                                                     continue;</span><br></pre></td></tr></table></figure><br>如上两种触发负载均衡（load balance)的场景都会调用_walt_can_migrate_task，它是用来判断任务p是否可以迁移的函数，walt_get_rtg_status返回的就是任务p所在RTG的skip_min状态，这里仅列出与RTG相关的内容：<br>如果没有强制要求迁移到某个核的前提下，对于RTG组的任务会做一些判断，如果任务要求运行在大核上（walt_related_thread_group的skip_min为true），则任务不能迁移到算力比当前CPU低的CPU上。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt_lb.c</span><br><span class="line">static inline bool _walt_can_migrate_task(struct task_struct *p, int dst_cpu,</span><br><span class="line">                                          bool to_lower, bool to_higher, bool force)</span><br><span class="line">    |- struct walt_rq *wrq = &amp;per_cpu(walt_rq, task_cpu(p));</span><br><span class="line">    |  struct walt_task_struct *wts = (struct walt_task_struct *) p-&gt;android_vendor_data1;</span><br><span class="line">    |_ if (to_lower)</span><br><span class="line">            if (!force &amp;&amp; walt_get_rtg_status(p))</span><br><span class="line">                    return false;</span><br></pre></td></tr></table></figure></p><h1 id="9-RTG-的调频策略"><a href="#9-RTG-的调频策略" class="headerlink" title="9.  RTG 的调频策略"></a>9. <strong> RTG 的调频策略</strong></h1><p>walt负载跟踪中，对RTG组任务的util是单独统计的，RTG组的util可以影响到CPU的调频，主要表现在：<br>(1) 某些场景下(如点击或滑动)，RTG组任务的util会累加到当前CPU的util上，起到聚合调频的作用，从而拉高了频率;<br>(2) RTG任务自身运行时，影响调频。初始化时waltgov_init会根据CPU簇的算力，设定CPU簇的boost频率，这个boost频率又可以根据CPU算力转换为util，这个util是比实际util大的，如果此时有RTG任务在运行时，util就就会<br>   影响到cpu的调频，保证cpu不低于某个频率。这里影响到的RTG任务主要是”top-app” cgroup任务，因为其它的task group任务不会自动加入到RTG组中，除非手动加入。</p><p>具体分析如下：<br>(1) waltgov_get_util获取cpu的util，这个util将用于估算所需要的频率。freq_policy_load在某些场景（如滑动或点击）会将CPU当前的util和RTG组任务的util进行累加，作为后续选频的依据，这也就是所谓的”RTG聚合调频”;__cpu_util_freq_walt也会初始化walt_load-&gt;rtgb_active，它来源于rtgb_active，rtgb_active在walt_irq_work设置，后面可以看到walt_load-&gt;rtgb_active会最终影响到util的计算，如果为true会在wg_policy-&gt;rtg_boost_uti与计算的util之间选取最大值;<br>(2) 以wg_policy-&gt;tunables-&gt;rtg_boost_freq为目标频率，得到rtg_boost_util，保存在wg_policy-&gt;rtg_boost_util，rtg_boost_freq是在waltgov_init时根据不同的簇进行初始化；<br>(3) walt_load-&gt;rtgb_active如果为true则会选取当前util和wg_policy-&gt;rtg_boost_util的最大值作为util；<br>(4) 根据util值得到下一个候选频率<br>(5) 执行调频<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/cpufreq_walt.c</span><br><span class="line">static void waltgov_update_freq(struct waltgov_callback *cb, u64 time, </span><br><span class="line">                unsigned int flags)</span><br><span class="line">|- struct waltgov_cpu *wg_cpu = container_of(cb, struct waltgov_cpu, cb);</span><br><span class="line">|  unsigned long hs_util, rtg_boost_util</span><br><span class="line">|- wg_cpu-&gt;util = waltgov_get_util(wg_cpu);--------------------------------(1)</span><br><span class="line">|  |_ cpu_util_freq_walt(wg_cpu-&gt;cpu, &amp;wg_cpu-&gt;walt_load, &amp;wg_cpu-&gt;reasons)</span><br><span class="line">|     |_ __cpu_util_freq_walt(cpu, walt_load, reason)</span><br><span class="line">|        | //某些场景下会聚合RTG的负载</span><br><span class="line">|        |- scale_time_to_util(freq_policy_load(rq, reason));</span><br><span class="line">|            | //ed_task为true,表示任务唤醒前经过较长时间的睡眠，应该被“关照”</span><br><span class="line">|            |_ if (walt_load &amp;&amp; wrq-&gt;ed_task)</span><br><span class="line">|                  walt_load-&gt;rtgb_active = rtgb_active</span><br><span class="line">|- if (wg_policy-&gt;max != wg_cpu-&gt;max)--------------------------------------（2）</span><br><span class="line">|     rtg_boost_util = target_util(wg_policy,//根据频率获取到目标util</span><br><span class="line">|                         wg_policy-&gt;tunables-&gt;rtg_boost_freq);</span><br><span class="line">|     wg_policy-&gt;rtg_boost_util = rtg_boost_util;//这个目标util用于选频</span><br><span class="line">|- next_f = waltgov_next_freq_shared(wg_cpu, time);</span><br><span class="line">|  |- for_each_cpu(j, policy-&gt;cpus)</span><br><span class="line">|  |     waltgov_walt_adjust(j_wg_cpu, j_util, j_nl, &amp;util, &amp;max);--------（3）</span><br><span class="line">|  |     |- bool is_rtg_boost = wg_cpu-&gt;walt_load.rtgb_active;</span><br><span class="line">|  |     |_if (is_rtg_boost &amp;&amp; (!cpumask_test_cpu(wg_cpu-&gt;cpu,</span><br><span class="line">|  |                cpu_partial_halt_mask) || !is_state1()))</span><br><span class="line">|  |           max_and_reason(util, wg_policy-&gt;rtg_boost_util, wg_cpu,</span><br><span class="line">|  |                      CPUFREQ_REASON_RTG_BOOST);</span><br><span class="line">|  |_return get_next_freq(wg_policy, util, max, wg_cpu, time)-------------（4）</span><br><span class="line">|_ waltgov_fast_switch(wg_policy, time, next_f)---------------------------（5）</span><br></pre></td></tr></table></figure><br>那么RTG任务的聚合发生在什么地方呢？如上rtgb_active又是在何时初始化的呢？主要在walt_irq_work中完成：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.c</span><br><span class="line">                                                                                                                                                                                        static void waltgov_update_freq(struct waltgov_callback *cb, u64 time, </span><br><span class="line">                unsigned int flags)</span><br><span class="line">|- struct waltgov_cpu *wg_cpu = container_of(cb, struct waltgov_cpu, cb);</span><br><span class="line">|  unsigned long hs_util, rtg_boost_util</span><br><span class="line">|- wg_cpu-&gt;util = waltgov_get_util(wg_cpu);--------------------------------(1)</span><br><span class="line">|  |_ cpu_util_freq_walt(wg_cpu-&gt;cpu, &amp;wg_cpu-&gt;walt_load, &amp;wg_cpu-&gt;reasons)</span><br><span class="line">|     |_ __cpu_util_freq_walt(cpu, walt_load, reason)</span><br><span class="line">|        | //某些场景下会聚合RTG的负载</span><br><span class="line">|        |- scale_time_to_util(freq_policy_load(rq, reason));</span><br><span class="line">|            | //ed_task为true,表示任务唤醒前经过较长时间的睡眠，应该被“关照”</span><br><span class="line">|            |_ if (walt_load &amp;&amp; wrq-&gt;ed_task)</span><br><span class="line">|                  walt_load-&gt;rtgb_active = rtgb_active</span><br><span class="line">|- if (wg_policy-&gt;max != wg_cpu-&gt;max)--------------------------------------（2）</span><br><span class="line">|     rtg_boost_util = target_util(wg_policy,//根据频率获取到目标util</span><br><span class="line">|                         wg_policy-&gt;tunables-&gt;rtg_boost_freq);</span><br><span class="line">|     wg_policy-&gt;rtg_boost_util = rtg_boost_util;//这个目标util用于选频</span><br><span class="line">|- next_f = waltgov_next_freq_shared(wg_cpu, time);</span><br><span class="line">|  |- for_each_cpu(j, policy-&gt;cpus)</span><br><span class="line">|  |     waltgov_walt_adjust(j_wg_cpu, j_util, j_nl, &amp;util, &amp;max);--------（3）</span><br><span class="line">|  |     |- bool is_rtg_boost = wg_cpu-&gt;walt_load.rtgb_active;</span><br><span class="line">|  |     |_if (is_rtg_boost &amp;&amp; (!cpumask_test_cpu(wg_cpu-&gt;cpu,</span><br><span class="line">|  |                cpu_partial_halt_mask) || !is_state1()))</span><br><span class="line">|  |           max_and_reason(util, wg_policy-&gt;rtg_boost_util, wg_cpu,</span><br><span class="line">|  |                      CPUFREQ_REASON_RTG_BOOST);</span><br><span class="line">|  |_return get_next_freq(wg_policy, util, max, wg_cpu, time)-------------（4）</span><br><span class="line">|_ waltgov_fast_switch(wg_policy, time, next_f)---------------------------（5）</span><br></pre></td></tr></table></figure><br>那么RTG任务的聚合发生在什么地方呢？如上rtgb_active又是在何时初始化的呢？主要在walt_irq_work中完成：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.c</span><br><span class="line">static void walt_irq_work(struct irq_work *irq_work)</span><br><span class="line">    |- __walt_irq_work_locked(is_migration, is_asym_migration,</span><br><span class="line">    |_        is_shared_rail_migration, &amp;lock_cpus);</span><br><span class="line">        |- u64 total_grp_load = 0;</span><br><span class="line">        |- for_each_sched_cluster(cluster)</span><br><span class="line">        |     u64 aggr_grp_load = 0;</span><br><span class="line">        |     for_each_cpu(cpu, &amp;cluster-&gt;cpus)</span><br><span class="line">        |         /* update aggr_grp_load for all clusters, all cpus */</span><br><span class="line">        |         aggr_grp_load += wrq-&gt;grp_time.prev_runnable_sum;</span><br><span class="line">        |     cluster-&gt;aggr_grp_load = aggr_grp_load;</span><br><span class="line">        |     total_grp_load += aggr_grp_load</span><br><span class="line">        |_ if (total_grp_load)</span><br><span class="line">                 rtgb_active = is_rtgb_active();</span><br><span class="line">           else</span><br><span class="line">                 rtgb_active = false;</span><br></pre></td></tr></table></figure><br>__walt_irq_work_locked中会遍历每个簇中的cpu，将每个cpu上的RTG任务负载累加到簇的aggr_grp_load中，这个累加值就会在某些场景下（滑动或点击）用于CPU的聚合调频。<br>如上对于聚合调频影响路径可以概括为：</p><ol><li>初始化时设定walt_task_group的colocate标记，如果设为true，则task group中的任务会被加入到RTG默认组;</li><li>RTG组任务的util是被单独统计的，在walt负载跟踪时会更新，在walt_irq_work会累加cpu簇的每个cpu上运行的RTG任务的util，保存在簇的aggr_grp_load中;</li><li>在某些sched_boost场景下（如滑动或点击），会将cpu当前util与RTG组的util即簇的aggr_grp_load累加，做聚合调频</li></ol><h1 id="10-RTG-推迟-cpu-进入-idle"><a href="#10-RTG-推迟-cpu-进入-idle" class="headerlink" title="10. RTG 推迟 cpu 进入 idle"></a><strong>10. RTG 推迟 cpu 进入 idle</strong></h1><p>RTG会影响CPU busy的延迟时间，一个典型的例子是CPU进入LPM(Low Power Mode)模式的时间。我们知道当CPU处于空闲状态时，它会执行Idle Task。Idle Task是内核中的一个特殊线程，负责在CPU没有任务执行时管理CPU的电源状&gt;态。Idle Task通过cpuidle_select函数，根据CPU idle governor的策略选择一个合适的LPM模式，并进入到这个模式。当有任务需要执行或者中断发生时，CPU会从LPM模式中退出，恢复到正常工作状态。<br>LPM有多个模式，分为C状态和D状态，其中C状态又分为C0,C1,C4,D状态又分为D0，D1，D4，进出不同的LPM模式，花费的时间是不同的，层级越高花费的时间越多；同时，不同层级引发的功耗也不同。因此系统在保持一定负载量的情<br>况下，CPU在idle间隙，如果频繁进出LPM模式，将会导致性能下降，也会引起一定的功耗。相比来说，此时保持LPM模式浅休眠一定时间，降低进出LPM模式的频率，反而可以避免性能下降，也可减少功耗。在这种背景下，针对RTG任<br>务，设置了CPU busy的延迟时间，避免频繁进出 LPM 状态，减少功耗增加，并且可能避免性能 2ms 的响应延时。如下将分别说明延迟时间的更新方式、更新时机以及对进出LPM模式的影响。</p><h2 id="更新延迟时间"><a href="#更新延迟时间" class="headerlink" title="更新延迟时间"></a>更新延迟时间</h2><p>有如下几种情况会修改这个延迟时间：<br>(1)RTG任务处于boost的时间超过MAX_RTGB_TIME；<br>(2)通过proc文件节点进行修改<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.c</span><br><span class="line">static void walt_irq_work(struct irq_work *irq_work)----------------------(1)</span><br><span class="line">    |_ core_ctl_check(wrq-&gt;window_start, wakeup_ctr_sum)</span><br><span class="line">        |_ update_running_avg(window_start, wakeup_ctr_sum)</span><br><span class="line">            |_ sched_get_nr_running_avg()</span><br><span class="line">                |_ if (any_hyst_time &amp;&amp; get_rtgb_active_time() &gt;= MAX_RTGB_TIME)</span><br><span class="line">                      sched_update_hyst_times();</span><br></pre></td></tr></table></figure><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/sched_avg.c</span><br><span class="line">int sched_busy_hyst_handler(struct ctl_table *table, int write,-----------(2)</span><br><span class="line">            void __user *buffer, size_t *lenp, loff_t *ppos)</span><br><span class="line">    |_ sched_update_hyst_times()</span><br></pre></td></tr></table></figure><br>sched_update_hyst_times判断rtgb_active为true，表示当前cpu具有一定的负荷，就会更新coloc_hyst_time，coloc_hyst_time会影响到busy_hyst_end_time的更新，后者是延迟结束时间，对于CPU busy时间，busy_hyst_end_time会影响CPU进入LPM模式的时间。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/sched_avg.c</span><br><span class="line">void sched_update_hyst_times(void)</span><br><span class="line">    |- bool rtgb_active;</span><br><span class="line">    |  rtgb_active = is_rtgb_active() &amp;&amp; (sched_boost_type != CONSERVATIVE_BOOST)</span><br><span class="line">    |                    &amp;&amp; (get_rtgb_active_time() <span class="tag">&lt; <span class="attr">MAX_RTGB_TIME</span>)</span></span><br><span class="line"><span class="tag">    |<span class="attr">_</span> <span class="attr">for_each_possible_cpu</span>(<span class="attr">cpu</span>)</span></span><br><span class="line"><span class="tag">         <span class="attr">per_cpu</span>(<span class="attr">coloc_hyst_time</span>, <span class="attr">cpu</span>) = <span class="string">((BIT(cpu)</span></span></span><br><span class="line"><span class="tag">                 &amp; <span class="attr">sysctl_sched_coloc_busy_hyst_enable_cpus</span>)</span></span><br><span class="line"><span class="tag">                 &amp;&amp; <span class="attr">rtgb_active</span>) ?</span></span><br><span class="line"><span class="tag">                                                    <span class="attr">sysctl_sched_coloc_busy_hyst_cpu</span>[<span class="attr">cpu</span>] <span class="attr">:</span> <span class="attr">0</span>;</span></span><br></pre></td></tr></table></figure><br>那么busy_hyst_end_time是在哪里更新的呢？在入队、出队、update misfit时都会都会调用sched_update_nr_prod，进而更新busy_hyst_end_time，如下是更新busy_hyst_end_time的时机：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//入队, kernel/sched/walt/walt.c</span><br><span class="line">static void android_rvh_enqueue_task(void *unused, struct rq *rq,</span><br><span class="line">                struct task_struct *p, int flags)</span><br><span class="line">    |_ sched_update_nr_prod(rq-&gt;cpu, 1)</span><br></pre></td></tr></table></figure><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//出队, kernel/sched/walt/walt.c</span><br><span class="line">static void android_rvh_dequeue_task(void *unused, struct rq *rq,</span><br><span class="line">                struct task_struct *p, int flags)</span><br><span class="line">    |_ sched_update_nr_prod(rq-&gt;cpu, -1)</span><br></pre></td></tr></table></figure><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//misfit, kernel/sched/walt/walt.c</span><br><span class="line">static void android_rvh_update_misfit_status(void *unused, struct task_struct *p,</span><br><span class="line">                struct rq *rq, bool *need_update)</span><br><span class="line">    |_ sched_update_nr_prod(rq-&gt;cpu, 0)</span><br></pre></td></tr></table></figure><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其中</span><br><span class="line">sched_update_nr_prod实现如下：</span><br><span class="line"></span><br><span class="line">//kernel/sched/walt/sched_avg.cvoid sched_update_nr_prod(int cpu, int enq)</span><br><span class="line">    |_ if (enq)</span><br><span class="line">        update_busy_hyst_end_time(cpu, enq, nr_running, curr_time);</span><br></pre></td></tr></table></figure><br>update_busy_hyst_end_time的更新如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/sched_avg.c</span><br><span class="line">static inline void update_busy_hyst_end_time(int cpu, int enq,</span><br><span class="line">                                unsigned long prev_nr_run, u64 curr_time)</span><br><span class="line">    |- agg_hyst_time = max(max(hyst_trigger ? per_cpu(hyst_time, cpu) : 0,</span><br><span class="line">    |                        coloc_trigger ? per_cpu(coloc_hyst_time, cpu) : 0),</span><br><span class="line">    |                        util_load_trigger ? per_cpu(util_hyst_time, cpu) : 0);</span><br><span class="line">    |_ atomic64_set(&amp;per_cpu(busy_hyst_end_time, cpu), curr_time + agg_hyst_time);</span><br></pre></td></tr></table></figure></p><h2 id="LPM推迟进入"><a href="#LPM推迟进入" class="headerlink" title="LPM推迟进入"></a>LPM推迟进入</h2><p>RTG对延迟时间的更新有影响，只有rtgb处于active状态才会对percpu变量coloc_hyst_time进行更新,根据前面分析，coloc_hyst_time间接会影响到busy_hyst_end_time的更新，进而会影响到CPU进入LPM模式的时间。我们知道CPU在<br>空闲时会执行idle流程，执行到lpm_select，lpm_select将检查是否符合进入LPM的条件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//drivers/cpuidle/governors/qcom-lpm.c</span><br><span class="line">static int lpm_select(struct cpuidle_driver *drv, struct cpuidle_device *dev,</span><br><span class="line">                      bool *stop_tick)</span><br><span class="line">    |- ktime_t delta_tick;</span><br><span class="line">                            |  uint64_t duration_ns;</span><br><span class="line">    |- duration_ns = tick_nohz_get_sleep_length(&amp;delta_tick);</span><br><span class="line">    |_ if (lpm_disallowed(duration_ns, dev-&gt;cpu))</span><br><span class="line">                goto done;</span><br></pre></td></tr></table></figure><br>lpm_select通过lpm_disallowed来检查是否进LPM莫斯，如果它返回0代表还有剩余时间，不允许进入LPM模式，最终如果lpm_disallowed返回true则表示本轮检查不允许进入lpm模式，具体实现如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static bool lpm_disallowed(s64 sleep_ns, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">#if IS_ENABLED(CONFIG_SCHED_WALT)</span><br><span class="line">        struct lpm_cpu *cpu_gov = per_cpu_ptr(&amp;lpm_cpu_data, cpu);</span><br><span class="line">        uint64_t bias_time = 0;</span><br><span class="line">#endif</span><br><span class="line">        if (!check_cpu_isactive(cpu))</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">        if ((sleep_disabled || sleep_ns <span class="tag">&lt; <span class="attr">0</span>))</span></span><br><span class="line"><span class="tag">                <span class="attr">return</span> <span class="attr">true</span>;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">#<span class="attr">if</span> <span class="attr">IS_ENABLED</span>(<span class="attr">CONFIG_SCHED_WALT</span>)</span></span><br><span class="line"><span class="tag">        <span class="attr">if</span> (!<span class="attr">sched_lpm_disallowed_time</span>(<span class="attr">cpu</span>, &amp;<span class="attr">bias_time</span>)) &#123;</span></span><br><span class="line"><span class="tag">                <span class="attr">cpu_gov-</span>&gt;</span>last_idx = 0;</span><br><span class="line">                cpu_gov-&gt;bias = bias_time;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sched_lpm_disallowed_time用于获取进入LPM前的剩余时间，剩余时间大于0，表示不需要进入LPM模式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//drivers/cpuidle/governors/qcom-lpm.c</span><br><span class="line">static bool lpm_disallowed(s64 sleep_ns, int cpu)</span><br><span class="line">    |_ sched_lpm_disallowed_time(cpu, &amp;bias_time)//获取到timeout剩余时间</span><br><span class="line">        |- u64 now = sched_clock();</span><br><span class="line">        |- u64 bias_end_time = atomic64_read(&amp;per_cpu(busy_hyst_end_time, cpu));</span><br><span class="line">        |_ if (now <span class="tag">&lt; <span class="attr">bias_end_time</span>)</span></span><br><span class="line"><span class="tag">              *<span class="attr">timeout</span> = <span class="string">bias_end_time</span> <span class="attr">-</span> <span class="attr">now</span>;</span></span><br><span class="line"><span class="tag">              <span class="attr">return</span> <span class="attr">0</span>; /* <span class="attr">shallowest</span> <span class="attr">c-state</span> */</span></span><br></pre></td></tr></table></figure></p><h1 id="11-RTG-的优先调度"><a href="#11-RTG-的优先调度" class="headerlink" title="11. RTG 的优先调度"></a><strong>11. RTG 的优先调度</strong></h1><p>在滑动场景 优先级小于119的”top-app” cfs task（RTG默认组）都会进入到mvp list 中进行优先调度，减少runnable时间；walt_cfs_enqueue_task通过获取任务p的mvp优先级，然后插入到mvp list中执行优先调度，其中RTG任务&gt;的mvp优先级为WALT_RTG_MVP：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt_cfs.c</span><br><span class="line">void walt_cfs_enqueue_task(struct rq *rq, struct task_struct *p)</span><br><span class="line">    | //获取任务P的mvp优先级</span><br><span class="line">    |- int mvp_prio = walt_get_mvp_task_prio(p);</span><br><span class="line">    |    |_ if (task_rtg_high_prio(p))</span><br><span class="line">    |            return WALT_RTG_MVP</span><br><span class="line">    |- wts-&gt;mvp_prio = mvp_prio;</span><br><span class="line">    |_ walt_cfs_insert_mvp_task(wrq, wts, task_on_cpu(rq, p));</span><br></pre></td></tr></table></figure><br>这里task_rtg_high_prio主要是为了获取任务p是否为RTG高优先级任务，其中滑动场景sysctl_walt_rtg_cfs_boost_prio为119，非滑动场景sysctl_walt_rtg_cfs_boost_prio为99：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//kernel/sched/walt/walt.h</span><br><span class="line">static inline bool task_rtg_high_prio(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">        return task_in_related_thread_group(p) &amp;&amp;</span><br><span class="line">                (p-&gt;prio <span class="tag">&lt;<span class="name">=</span> <span class="attr">sysctl_walt_rtg_cfs_boost_prio</span>);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a><strong>12. 总结</strong></h1><p>RTG在内核空间并非一个独立的模块存在，而是散落在各处代码中，用户空间可以通过/proc文件节点将某个任务设置到RTG的不同group中；也可以在设置任务到cgroup中时，同时将任务设置到RTG中，默认top-app cgroup中的任务设<br>置到默认RTG组。RTG对调频、选核、优先调度及负载均衡，均产生一定的影响：</p><ol><li>在WALT GOV调频的过程中，根据当前场景（如滑动或点击时）需求，将RTG组的负载累加到当前CPU负载上，从而引起聚合调频；同时，如果当前CPU运行的是RTG任务，其调频频率也不会低于预定的阈值，相当于对RTG任务做了一&gt;定的频率提升;</li><li>在WALT CFS和RT任务选核的过程中会参考CPU当前是否运行RTG任务，或要选核的任务是否位于RTG，如果是则会影响其选核行为，会优先选择算力强的CPU核;</li><li>在RTG的基础上衍生出对优先调度的支持，对top-app的RTG任务，会进行优先调度</li></ol><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h4 id="1-https-mp-weixin-qq-com-s-ESxJdwZKiZkJ-z6eFzxaag-浅析高通-mvp-进程优先调度"><a href="#1-https-mp-weixin-qq-com-s-ESxJdwZKiZkJ-z6eFzxaag-浅析高通-mvp-进程优先调度" class="headerlink" title="[1]https://mp.weixin.qq.com/s/ESxJdwZKiZkJ-z6eFzxaag 浅析高通 mvp 进程优先调度"></a>[1]<a href="https://mp.weixin.qq.com/s/ESxJdwZKiZkJ-z6eFzxaag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ESxJdwZKiZkJ-z6eFzxaag</a> 浅析高通 mvp 进程优先调度</h4><h4 id="2-https-blog-csdn-net-feelabclihu-article-details-124507331-调度器分支之RTG"><a href="#2-https-blog-csdn-net-feelabclihu-article-details-124507331-调度器分支之RTG" class="headerlink" title="[2]https://blog.csdn.net/feelabclihu/article/details/124507331 调度器分支之RTG"></a>[2]<a href="https://blog.csdn.net/feelabclihu/article/details/124507331" target="_blank" rel="noopener">https://blog.csdn.net/feelabclihu/article/details/124507331</a> 调度器分支之RTG</h4><h4 id="3-http-www-wowotech-net-process-management-load-balance-html-CFS任务的负载均衡（概述）"><a href="#3-http-www-wowotech-net-process-management-load-balance-html-CFS任务的负载均衡（概述）" class="headerlink" title="[3]http://www.wowotech.net/process_management/load_balance.html CFS任务的负载均衡（概述）"></a>[3]<a href="http://www.wowotech.net/process_management/load_balance.html" target="_blank" rel="noopener">http://www.wowotech.net/process_management/load_balance.html</a> CFS任务的负载均衡（概述）</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>向 Linux 内核社区提交 patch 实操要点</title>
      <link href="/2024/12/06/Submit-patch-implementations-to-the-Linux-kernel-community/"/>
      <url>/2024/12/06/Submit-patch-implementations-to-the-Linux-kernel-community/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-git-和-git-send-email"><a href="#安装-git-和-git-send-email" class="headerlink" title="安装 git 和 git send-email"></a>安装 git 和 git send-email</h2><blockquote><p>sudo apt-get install git<br>sudo apt-get  install gti-email</p></blockquote><h2 id="配置-git-和-smtp"><a href="#配置-git-和-smtp" class="headerlink" title="配置 git 和 smtp"></a>配置 git 和 smtp</h2><blockquote><p>git config —local user.name “nameVal”<br>git config —local user.email “eamil@qq.com”</p></blockquote><p>vi .git/config<br>// 在文件末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[sendemail]</span><br><span class="line">  smtpencryption&#x3D;tls</span><br><span class="line">  smtpserver&#x3D;smtp.xxxx.com</span><br><span class="line">  smtpuser&#x3D;abc@xxxx.com</span><br><span class="line">  smtpserverport&#x3D;587</span><br></pre></td></tr></table></figure><p>配置好，先发个邮件测试一下：</p><blockquote><p>$ git send-email —to xxx@126.com 0001-.patch</p></blockquote><h2 id="下载-linux-kernel-代码"><a href="#下载-linux-kernel-代码" class="headerlink" title="下载 linux kernel 代码"></a>下载 linux kernel 代码</h2><blockquote><p>git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</p></blockquote><h2 id="制作-patch"><a href="#制作-patch" class="headerlink" title="制作 patch"></a>制作 patch</h2><p>假设找到一个 bug，现在制作 patch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">// commit后才能创建新分支</span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m ""</span><br><span class="line">// 创建新分支</span><br><span class="line">git branch develop</span><br><span class="line">git checkout develop</span><br><span class="line">修改代码后，执行下面的命令</span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -s -v</span><br></pre></td></tr></table></figure><p>写上 commit 的模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drivers: fix some error</span><br><span class="line">Why I do these changes and how I do it.</span><br><span class="line">Signed-off-by: My Name &lt;my_email@gmail.com&gt;</span><br></pre></td></tr></table></figure></p><ul><li>第一部分是 short description，以子系统名打头，比如 mm，注意分号后面加个空格，不知道子系统名的可以看看你修改的这个文件的修改历史，看看之前的开发者是怎么写的。这一部分需要使用一句简短的话描述你所做的修改，要让维护者一眼就看出这个 Patch 大概干了什么事。</li><li>第二部分是 the body of your patch，这一部分要详细的解释你为何要做这个修改，以及怎么做的，注意时态用现在时，语态用主动形式。</li><li>第三部分是之前的 -s 参数自动加上的，不用管。</li><li>必须要注意的是，这三部分之间都要有一个空行隔开。</li></ul><p>如果 commit 之后还想修改 Commit 信息的话需要使用命令 git commit —amend -v。</p><h2 id="生成-patch"><a href="#生成-patch" class="headerlink" title="生成 patch"></a>生成 patch</h2><blockquote><p>git format-patch master</p><p>ls *.patch<br>0001-soc-qcom-qmi-Use-min-instead-of-doing-it-manually.patch</p></blockquote><h2 id="检查patch的格式"><a href="#检查patch的格式" class="headerlink" title="检查patch的格式"></a>检查patch的格式</h2><p>要做到 0 errors, 0 warnings</p><blockquote><p>./scripts/checkpatch.pl 0001-soc-qcom-qmi-Use-min-instead-of-doing-it-manually.patch</p></blockquote><h2 id="发送patch"><a href="#发送patch" class="headerlink" title="发送patch"></a>发送patch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./scripts/get_maintainer.pl  drivers/soc/qcom/qmi_interface.c</span><br><span class="line">Andy Gross agross@kernel.org (maintainer:ARM/QUALCOMM SUPPORT)</span><br><span class="line">Bjorn Andersson bjorn.andersson@linaro.org (maintainer:ARM/QUALCOMM SUPPORT)</span><br><span class="line">linux-arm-msm@vger.kernel.org (open list:ARM/QUALCOMM SUPPORT)</span><br><span class="line">linux-kernel@vger.kernel.org (open list)</span><br></pre></td></tr></table></figure><p>发送前，建议先发送给自己的 gmail 邮箱看看是否正常。</p><h2 id="正式发送"><a href="#正式发送" class="headerlink" title="正式发送"></a>正式发送</h2><blockquote><p>git send-email —to  agross@kernel.org  —to  bjorn.andersson@linaro.org —cc linux-arm-msm@vger.kernel.org  —cc  linux-kernel@vger.kernel.org  0001-soc-qcom-qmi-Use-min-instead-of-doing-it-manually.patch</p></blockquote><p>之后你的 Patch 就发送给上游维护者并抄送到对应的邮件列表了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>尽量基于 next 分支来开发<br><img src="1.webp" alt="图片"></li><li>提交 commit 描述，如果是修复之前的提交引入的问题，就需要写清楚：<br>Fixes: …  a commit hash length of 12 characters (“drm/amdgpu/vcn: Add VCN ras error query support”)<br>git config —global core.abbrev 12  //配置 12chars commit id<br>来源：<a href="https://lkml.org/lkml/2013/9/30/365" target="_blank" rel="noopener">https://lkml.org/lkml/2013/9/30/365</a></li><li>提交 patch 使用 git send-email；回复邮件使用官方推荐的邮箱客户端</li><li>提交 patch 前要先阅读官方指南：Documentation/translations/zh_CN/process/submitting-patches.rst</li><li>maintainer 会回复你的 patch 提供修改意见，所以邮件也是需要规范：<ol><li>使用 纯文本（plain text） 回复</li><li>回复邮件要使用 bottom-posting，不能用国内普遍使用的 top-posting</li></ol></li></ul><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">这里回复，叫 top-posting，国内普遍使用，这会导致打乱阅读顺序，不规范</span><br><span class="line">A: http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Top_post</span><br><span class="line">Q: Were do I find info about this thing called top-posting?</span><br><span class="line">A: Because it messes up the order in which people normally read text.</span><br><span class="line">Q: Why is top-posting such a bad thing?</span><br><span class="line">A: Top-posting.</span><br><span class="line">Q: What is the most annoying thing in e-mail?</span><br><span class="line">A: No.</span><br><span class="line">Q: Should I include quotations after my reply?</span><br><span class="line">http:&#x2F;&#x2F;daringfireball.net&#x2F;2007&#x2F;07&#x2F;on_top</span><br><span class="line">在 3&#x2F;29&#x2F;22 7:28 PM, Dan Carpenter 写道:</span><br><span class="line">&gt; On Tue, Mar 29, 2022 at 07:09:17PM +0800, Haowen Bai wrote:</span><br><span class="line">&gt;&gt; @@ -534,9 +531,6 @@ u8 rtw_init_drv_sw(struct adapter *padapter)</span><br><span class="line">&gt;&gt;  free_mlme_ext:</span><br><span class="line">&gt;&gt;  free_mlme_ext_priv(&amp;padapter-&gt;mlmeextpriv);</span><br><span class="line">&gt;&gt;  </span><br><span class="line">&gt;&gt; -free_mlme_priv:</span><br><span class="line">&gt;&gt; -rtw_free_mlme_priv(&amp;padapter-&gt;mlmepriv);</span><br><span class="line">&gt; Nope.  We still need to free this on the error path.  Just delete the</span><br><span class="line">&gt; unused label but don&#39;t delete the free function.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; -</span><br><span class="line">&gt;&gt;  free_evt_priv:</span><br><span class="line">&gt;&gt;  rtw_free_evt_priv(&amp;padapter-&gt;evtpriv);</span><br><span class="line">&gt; regards,</span><br><span class="line">&gt; dan carpenter</span><br><span class="line">这里回复，叫 bottom-posting.  这就对了。</span><br></pre></td></tr></table></figure></p><ul><li>邮箱的选择和配置，也有讲究，避免使用 outlook 和国内的邮箱。<br>参考：<a href="https://www.kernel.org/doc/html/latest/process/email-clients.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/process/email-clients.html</a></li></ul><h2 id="发送优化"><a href="#发送优化" class="headerlink" title="发送优化"></a>发送优化</h2><p>每次 send-emial 的时候 —cc —to 一个一个复制邮箱，挺麻烦的。可以使用  —to-cmd 来自动化执行：<br><img src="2.webp" alt="图片"><br>在 .git/config 添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[sendemail.linux]</span><br><span class="line">    tocmd &#x3D;&quot;\&#96;pwd\&#96;&#x2F;scripts&#x2F;get_maintainer.pl --nogit --nogit-fallback --norolestats --nol&quot;</span><br><span class="line">    cccmd &#x3D;&quot;\&#96;pwd\&#96;&#x2F;scripts&#x2F;get_maintainer.pl --nogit --nogit-fallback --norolestats --nom&quot;</span><br></pre></td></tr></table></figure></p><p>使用：</p><blockquote><p>git send-email —identity=linux ./0001-my-fancy-patch.patch<br>就会自动过滤出 cc 的列表和 to 的邮箱。</p></blockquote><h2 id="寻找软柿子"><a href="#寻找软柿子" class="headerlink" title="寻找软柿子"></a>寻找软柿子</h2><p>前面的方法大致了解了，所以现在就要找些补丁试试水，大显身手，准备干一番事业。<br>之前有新闻说国外一个 4 岁孩子也提交补丁了，修改了一个空格。<br>如果没有奇遇，大厨一般都是从小工做起的。我们不可能一开始就维护一个重要的模块，或者修复一些非常重要的故障，也不可能提交一个 feature. 建议先是从 warning 入手。社区很多大牛，都是这样成长起来的。</p><p>补丁的内容可以分为：</p><ol><li>warning bug</li><li>bug fix</li><li>feature</li></ol><p>寻找 warning bug 的一些方法：</p><ul><li>编译 warning<br>-———make  allyesconfig 编译所有模块（必要时控制编译选项）<br>-——- make  allyesconfig EXTRA_CFLAGS=“-Wmissing-declarations -Wmissing-prototypes”</li><li>编码格式，例如注释里面的单词拼写错误、对齐不规范、代码格式不符合社区要求<br>-———patchcheck.pl</li><li>静态代码检查工具<br>-———coccinelle<br>-———smatch<br>-———patchcheck.pl<br>-———checkincludes.pl<br>-———sparse<br>-———Section Mismatch</li></ul><p>首先，不要看不起修复 warning bug，国内内卷很多大厂都这么做，甚至安排了专人做这项工作，自动做 report 等。提交了几千个 patch 的大牛，也是不断寻找小 bug 来锻炼起来的，如 smatch 的作者 Dan Carpenter，国内华为weiyongjun，intel fengguang.wu</p><p>fix waning bug 你能获得：</p><ul><li>了解 warning 规则</li><li>写代码更细致规范</li><li>社区工作流程</li><li>英文交流能力</li><li>混个脸熟</li></ul><h2 id="回复技巧"><a href="#回复技巧" class="headerlink" title="回复技巧"></a>回复技巧</h2><p>场景：当发送一个 patch 后，需要修改后再发送 V2 版本 patch</p><p>在 <a href="https://lore.kernel.org" target="_blank" rel="noopener">https://lore.kernel.org</a> 找到你需要回复的邮件，下方写了回复说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Reply instructions:</span><br><span class="line">You may reply publicly to this message via plain-text email</span><br><span class="line">using any one of the following methods:</span><br><span class="line">* Save the following mbox file, import it into your mail client,</span><br><span class="line">  and reply-to-all from there: mbox</span><br><span class="line">  Avoid top-posting and favor interleaved quoting:</span><br><span class="line">  https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Posting_style#Interleaved_style</span><br><span class="line">* Reply using the --to, --cc, and --in-reply-to</span><br><span class="line">  switches of git-send-email(1):</span><br><span class="line">  git send-email \</span><br><span class="line">    --in-reply-to&#x3D; index  \</span><br><span class="line">    --to&#x3D;xx@xx.com \</span><br><span class="line">    --cc&#x3D;Larry.Finger@lwfinger.net \</span><br><span class="line">    --cc&#x3D;dan.carpenter@oracle.com \</span><br><span class="line">    --cc&#x3D;gregkh@linuxfoundation.org \</span><br><span class="line">    --cc&#x3D;linux-kernel@vger.kernel.org \</span><br><span class="line">    --cc&#x3D;linux-staging@lists.linux.dev \</span><br><span class="line">    --cc&#x3D;phil@philpotter.co.uk \</span><br><span class="line">    --subject&#x3D;&#39;Re: [PATCH V3] staging: r8188eu: xxx &#39; \</span><br><span class="line">    &#x2F;path&#x2F;to&#x2F;YOUR_REPLY</span><br><span class="line">  https:&#x2F;&#x2F;kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;docs&#x2F;git-send-email.html</span><br><span class="line">* If your mail client supports setting the In-Reply-To header</span><br><span class="line">  via mailto: links, try the mailto: link</span><br></pre></td></tr></table></figure><p>使用 git send-email 发送这些补丁，利用 —in-reply-to 命令行选项将你的 patch V2 邮件链接到以前的邮件，避免新开 thread.</p><p>参考：<br><a href="https://runebook.dev/zh-CN/docs/git/git-send-email" target="_blank" rel="noopener">https://runebook.dev/zh-CN/docs/git/git-send-email</a><br><a href="https://www.kernel.org/doc/html/next/translations/zh\_TW/process/submitting-patches.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/next/translations/zh\_TW/process/submitting-patches.html</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，这个圈子不大，例如 LDD3 作者 Greg Kroah-Hartman，现在多个模块的 maintainer，stable分支的 maintainer。你会经常见到他，甚至是 Linus Torvalds.</p><p>下面是 patch 提交统计：</p><ul><li>按国籍：<a href="http://www.remword.com/kps\_result/all\_whole\_country.html" target="_blank" rel="noopener">http://www.remword.com/kps\_result/all\_whole\_country.html</a></li><li>按作者：<a href="http://www.remword.com/kps\_result/all\_petop.html" target="_blank" rel="noopener">http://www.remword.com/kps\_result/all\_petop.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一次山重水复疑无路的卡死问题根源分析</title>
      <link href="/2024/12/06/Isolated-count-mismatch-analysis/"/>
      <url>/2024/12/06/Isolated-count-mismatch-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一个项目中偶现几十上百个 D 进程卡住在 shrink_inactive_list，导致卡顿/卡死/android SWT 等问题，前前后后，提交了 3 次修复，还没有彻底解决。</p><h2 id="山重水复疑无路"><a href="#山重水复疑无路" class="headerlink" title="山重水复疑无路"></a>山重水复疑无路</h2><p>LOG：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[149459.897408] [3:2065:watchdog] Binder:1042_16 D 0 9917 635 0x00000008</span><br><span class="line">[149459.897427] [3:2065:watchdog] Call trace:</span><br><span class="line">[149459.897435] [3:2065:watchdog] [&lt;ffffff8bf28852d4&gt;] _switch_to+0xb4&#x2F;0xc0</span><br><span class="line">[149459.897452] [3:2065:watchdog] [&lt;ffffff8bf3a1f6a0&gt;] _schedule+0x7f0&#x2F;0xad0</span><br><span class="line">[149459.897468] [3:2065:watchdog] [&lt;ffffff8bf3a1f9f0&gt;] schedule+0x70&#x2F;0x90</span><br><span class="line">[149459.897485] [3:2065:watchdog] [&lt;ffffff8bf3a23b00&gt;] schedule_timeout+0x548&#x2F;0x668</span><br><span class="line">[149459.897502] [3:2065:watchdog] [&lt;ffffff8bf2959028&gt;] msleep+0x28&#x2F;0x38</span><br><span class="line">[149459.897517] [3:2065:watchdog] [&lt;ffffff8bf2a1ff38&gt;] shrink_inactive_list+0x118&#x2F;0x998</span><br><span class="line">[149459.897534] [3:2065:watchdog] [&lt;ffffff8bf2a1cb10&gt;] shrink_node_memcg+0xa18&#x2F;0x1100</span><br><span class="line">[149459.897552] [3:2065:watchdog] [&lt;ffffff8bf2a1f0b0&gt;] shrink_node+0x108&#x2F;0x2f8</span><br><span class="line">[149459.897568] [3:2065:watchdog] [&lt;ffffff8bf2a1bcb0&gt;] do_try_to_free_pages+0x178&#x2F;0x380</span><br><span class="line">[149459.897586] [3:2065:watchdog] [&lt;ffffff8bf2a1b9d0&gt;] try_to_free_pages+0x370&#x2F;0x4d8</span><br><span class="line">[149459.897605] [3:2065:watchdog] [&lt;ffffff8bf2a071b8&gt;] _alloc_pages_nodemask+0x868&#x2F;0x1380</span><br><span class="line">[149459.897623] [3:2065:watchdog] [&lt;ffffff8bf2a13784&gt;] __do_pagecache_readahead+0xbc&#x2F;0x358</span><br><span class="line">[149459.897640] [3:2065:watchdog] [&lt;ffffff8bf29fde4c&gt;] filemapfault+0x11c&#x2F;0x600</span><br><span class="line">[149459.897647] [3:2065:watchdog] [&lt;ffffff8bf2b479f8&gt;] ext4_filemap_fault+0x30&#x2F;0x50</span><br><span class="line">[149459.897664] [3:2065:watchdog] [&lt;ffffff8bf2a47f38&gt;] handle_pte_fault+0xb38&#x2F;0xfa8</span><br><span class="line">[149459.897681] [3:2065:watchdog] [&lt;ffffff8bf2a485c8&gt;] handle_mm_fault+0x1d0&#x2F;0x328</span><br><span class="line">[149459.897699] [3:2065:watchdog] [&lt;ffffff8bf28a3668&gt;] do_page_fault+0x2a0&#x2F;0x3e0</span><br><span class="line">[149459.897716] [3:2065:watchdog] [&lt;ffffff8bf28a3364&gt;] do_translation_fault+0x44&#x2F;0xa8</span><br><span class="line">[149459.897732] [3:2065:watchdog] [&lt;ffffff8bf2880b74&gt;] do_mem_abort+0x4c&#x2F;0xd0</span><br><span class="line">[149459.897750] [3:2065:watchdog] [&lt;ffffff8bf2882c78&gt;] el0_da+0x20&#x2F;0x24</span><br><span class="line">[149459.897767] [3:2065:watchdog] Binder:1042_19 D 0 11188 635 0x00000008</span><br><span class="line">[149459.897786] [3:2065:watchdog] Call trace:</span><br><span class="line">[149459.897797] [3:2065:watchdog] [&lt;ffffff8bf28852d4&gt;] _switch_to+0xb4&#x2F;0xc0</span><br><span class="line">[149459.897804] [3:2065:watchdog] [&lt;ffffff8bf3a1f6a0&gt;] _schedule+0x7f0&#x2F;0xad0</span><br><span class="line">[149459.897820] [3:2065:watchdog] [&lt;ffffff8bf3a1f9f0&gt;] schedule+0x70&#x2F;0x90</span><br><span class="line">[149459.897835] [3:2065:watchdog] [&lt;ffffff8bf3a23b00&gt;] schedule_timeout+0x548&#x2F;0x668</span><br><span class="line">[149459.897853] [3:2065:watchdog] [&lt;ffffff8bf2959028&gt;] msleep+0x28&#x2F;0x38</span><br><span class="line">[149459.897868] [3:2065:watchdog] [&lt;ffffff8bf2a1ff38&gt;] shrink_inactive_list+0x118&#x2F;0x998</span><br><span class="line">[149459.897887] [3:2065:watchdog] [&lt;ffffff8bf2a1cb10&gt;] shrink_node_memcg+0xa18&#x2F;0x1100</span><br><span class="line">[149459.897904] [3:2065:watchdog] [&lt;ffffff8bf2a1f0b0&gt;] shrink_node+0x108&#x2F;0x2f8</span><br><span class="line">[149459.897922] [3:2065:watchdog] [&lt;ffffff8bf2a1bcb0&gt;] do_try_to_free_pages+0x178&#x2F;0x380</span><br><span class="line">[149459.897940] [3:2065:watchdog] [&lt;ffffff8bf2a1b9d0&gt;] try_to_free_pages+0x370&#x2F;0x4d8</span><br><span class="line">[149459.897957] [3:2065:watchdog] [&lt;ffffff8bf2a071b8&gt;] __alloc_pages_nodemask+0x868&#x2F;0x1380</span><br><span class="line">[149459.897977] [3:2065:watchdog] [&lt;ffffff8bf2a13784&gt;] _do_page_cache_readahead+0xbc&#x2F;0x358</span><br><span class="line">[149459.897996] [3:2065:watchdog] [&lt;ffffff8bf29fde4c&gt;] filemap_fault+0x11c&#x2F;0x600</span><br><span class="line">[149459.898013] [3:2065:watchdog] [&lt;ffffff8bf2b479f8&gt;] ext4_filemap_fault+0x30&#x2F;0x50</span><br><span class="line">[149459.898031] [3:2065:watchdog] [&lt;ffffff8bf2a47f38&gt;] handle_pte_fault+0xb38&#x2F;0xfa8</span><br><span class="line">[149459.898048] [3:2065:watchdog] [&lt;ffffff8bf2a485c8&gt;] handle_mm_fault+0x1d0&#x2F;0x328</span><br><span class="line">[149459.898065] [3:2065:watchdog] [&lt;ffffff8bf28a3668&gt;] do_page_fault+0x2a0&#x2F;0x3e0</span><br><span class="line">[149459.898083] [3:2065:watchdog] [&lt;ffffff8bf28a3364&gt;] do_translation_fault+0x44&#x2F;0xa8</span><br><span class="line">[149459.898100] [3:2065:watchdog] [&lt;ffffff8bf2880d18&gt;] do_el0_ia_bp_hardening+0xc0&#x2F;0x158</span><br><span class="line">[149459.898118] [3:2065:watchdog] [&lt;ffffff8bf2882c98&gt;] el0_ia+0x1c&#x2F;0x20</span><br></pre></td></tr></table></figure></p><p>现象：大量进程从缺页异常入口，调用内存回收接口：shrink_inactive_list -&gt; msleep ，使得该进程状态变为 D.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> msecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout = msecs_to_jiffies(msecs) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (timeout)</span><br><span class="line">        timeout = schedule_timeout_uninterruptible(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">long</span> __sched <span class="title">schedule_timeout_uninterruptible</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">return</span> schedule_timeout(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><table><tr><td bgcolor=    #CD5C5C>D 进程就是被设置了 TASK\_UNINTERRUPTIBLE 进程状态，不可中断的睡眠状态。</td></tr></table><br>不可中断，指的并不是 CPU 不响应外部硬件的中断，而是指进程不响应异步信号，信号只会挂到信号队列，而没有机会去立即执行。它不占用 CPU ，也不能被杀掉，很直观的现象就是，kill -9 一个 D 进程，是没有效果的，只有等进程获得资源被唤醒才处理信号，才处理 SIGKILL。</p><p>「进程是很有脾气的，不知道你们有没有遇到那种钻牛角尖的人，拿我儿子来举例一下，有时候他想找到他的玩具火箭，就一直在那里闹，一定要我们帮他找到他的玩具火箭位置，其他事情就是不干，你用坦克哄他也不行，哄他看小猪佩奇也不行。D进程也是一样，必须要等有他等到的那个事件为止」  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">static</span> noinline_for_stack <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">    shrink_inactive_list(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_to_scan, struct lruvec *lruvec,</span><br><span class="line">             struct scan_control *sc, <span class="keyword">enum</span> lru_list lru)</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">while</span> (unlikely(too_many_isolated(pgdat, file, sc, stalled))) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (stalled)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* wait a bit for the reclaimer. */</span></span><br><span class="line">        msleep(<span class="number">100</span>); <span class="comment">////////////////////// 卡在这里</span></span><br><span class="line">        stalled = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* We are about to die and free our memory. Return now. */</span></span><br><span class="line">        <span class="keyword">if</span> (fatal_signal_pending(current))</span><br><span class="line">          <span class="keyword">return</span> SWAP_CLUSTER_MAX;</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><table><tr><td bgcolor=    #CD5C5C>初步定位：</td></tr></table><br>该函数已经有跳出功能，不会一直卡住，最多 2 次就会退出去。说明是大量的进程疯狂地调用 shrink_inactive_list 又被阻塞了一下子，又退出去，又掉进来。<br>所以，不是一直卡死，而是性能瓶颈拥堵在这个地方，congestion 「拥挤堵车的意思」。<br>从上层 systrace 也能看到，很有规律的大概 110ms 一段的 D 状态，一个进程甚至可以持续几十秒。</p><p><img src="1.webp" alt="图片"></p><p>说明隔离页面过多，sleep 100ms，猜测目的是</p><ol><li>给时间处理隔离页面，回写文件页到磁盘  </li><li>是控制并发，也许另一个 cpu 也在同样的回收流程导致隔离页在时刻变大。  </li></ol><p>所以初步定了两个方向和疑点：<br>一是内存回收瓶颈，内存回收不及时，内存需求量巨大，而 LMK 没触发，内存有很多匿名页，都在回收和回写文件页等。<br>二是 io 读写瓶颈，io 速率慢，某个时间段速率变慢，ufs 频率低，上层读写大量数据，io 占用率过高等。<br>需要澄清这些疑点。<br>插播一些背景知识</p><h2 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h2><p>导致这个情况的原因是：<br>进程在申请内存的时候，发现该 zone 的 freelist 上已经没有足够的内存可用，所以不得不去从该 zone 的 LRU 链表里回收 inactive 的page，这种情况就是 direct reclaim（直接回收）。direct reclaim 会比较消耗时间的原因是，如果回收的是 dirty page，就会触发磁盘 IO 的操作，它会首先把 dirty page 里面的内容给回写到磁盘作同步，再去把该 page 给放到 freelist 里。</p><p>下图来看下 memory，page cache，Disk I/O 的关系。</p><p><img src="2.webp" alt="图片"></p><p>举个简单的例子，比如我们 open 一个文件时，如果没有使用 O_DIRECT 这个flag，那就是 File I/O, 所有对磁盘文件的访问都要经过内存，内存会把这部分数据给缓存起来；但是如果使用了 O_DIRECT 这个flag，那就是 Direct I/O, 它会绕过内存而去直接访问磁盘，访问的这部分数据也不会被缓存起来，自然性能上会降低很多。</p><h2 id="page-reclaim"><a href="#page-reclaim" class="headerlink" title="page reclaim"></a>page reclaim</h2><p>在直观上，我们有一个认知，我们现在读了一个文件，它会被缓存到内存里面，如果接下来的一个月我们一直都不会再次访问它，而且我们这一个月都不会关闭或者重启机器，那么在这一个月之后该文件就不应该再在内存里头了。</p><p>这就是内核对 page cache 的管理策略：LRU（最近最少使用）。即把最近最少使用的 page cache 给回收为 free pages。（页框回收算法 PFRA 远没有这么简单）</p><p>内核的页回收机制有两种：后台周期性回收和直接回收。</p><p>后台回收是有一个内核线程 kswapd 来做，当内存里 free 的 pages 低于一个水位（page_low）时，就会唤醒该内核线程，然后它从 LRU 链表里回收 page cache 到内存的 free_list 里头，它会一直回收直至 free 的 pages 达到另外一个水位 page_high 才停止. 如下图所示：</p><p><img src="3.webp" alt="图片"></p><p>直接回收则是，在发生 page fault/alloc memory 时，没有足够可用的内存，于是线程就自己直接去回收内存，它一次性的会回收 32 个 pages。逻辑过程如下图所示：</p><p><img src="4.webp" alt="图片"></p><p>所以，在内存优化上</p><ol><li>抬高 watermark 可以间接减少内存回收的并发量，减轻卡在 shrink_inactive_list.</li><li>提高回收效率，如 LMK 的效率。  </li></ol><p>然而，还是没彻底解决这个问题，所以我们把疑点再次指向 io。<br>尝试抓取更多的信息，来了解触发瓶颈的微观过程。</p><ol><li>跑 monkey 增加 io 使用率、io 读写速度监控，以时间片为 100ms，监控连续 D 状态，并收集 D 进程堆栈信息、内存信息等。</li><li>打开 ftarce 的 vmscan 和 writeback 两个监控点，apk 监控到持续 D 状态就进dump，从 dump 解析 ftrace，再使用 kernelshark 来观察一些数据。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/writeback/enable</span><br><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/vmscan/enable</span><br><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>为了准备再深入上述的微观过程，需要再补充一些代码和流程图：<br><img src="5.webp" alt="图片"></p><p><img src="6.webp" alt="图片"></p><p>注释的代码不贴了，受微信公众号篇幅限制。</p><h1 id="ftrace-kernelshark-辅助分析"><a href="#ftrace-kernelshark-辅助分析" class="headerlink" title="ftrace + kernelshark 辅助分析"></a>ftrace + kernelshark 辅助分析</h1><p>执行页面回收中页面状态<br>ftrace 会抓取下面这些信息统计，所以提前了解下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reclaim_stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_dirty;<span class="comment">// page_list中脏页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_unqueued_dirty;<span class="comment">// page_list中脏页但是没有放入块设备请求队列中的页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_congested;<span class="comment">// page_list中阻塞的页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_writeback; <span class="comment">// page_list中处于回写中但是不是被回收的页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_immediate; <span class="comment">//page_list中即回写中而且即将被回收的页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_activate;<span class="comment">// page_list中近期被访问过需要添加到 activate list 的页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_ref_keep;<span class="comment">// page_list中近期被访问过的页数</span></span><br><span class="line">    <span class="keyword">unsigned</span> nr_unmap_fail;<span class="comment">//解除映射失败的页数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过一段时间的老化测试，测试同学终于抓到 log 了。<br><img src="7.webp" alt="图片"></p><p>图中显示 nr_dirty，nr_congested，nr_writeback 几乎都是 0，只有零星 nr_activate 被再访问的页面要添加回 active list.  </p><p>说明现场不存在 dirty 页面很多，回写 io 遇到瓶颈的情况。这个猜想不成立了。</p><p><img src="8.webp" alt="图片"></p><p>图中显示在 34 秒内，所有在 pageout() 中的页面，全是 anon 页面，没有 file ?  </p><p>查看 writeback trace event。<br><img src="9.webp" alt="图片"></p><p>同样，没有很多 writeback 量  </p><p>从测试结果看到：</p><ol><li>apk 监控到的 io 使用率不高</li><li>从 ftrace 看到回写量不大</li></ol><p>通过最新的数据信息，回到之前的两个大方向：</p><ul><li><del>一是内存紧缺，内存回收不及时，内存需求量大。LMK 没触发，内存有很多匿名页，都在回收和回写文件页等。</del>（抬高水位、加速 LMK 触发，还有复现，不能彻底解决）</li><li><del>二是 io 速率慢，某个时间段速率变慢，ufs 频率低，上层读写大量数据，io 占用率过高等。</del>（数据证明，io 量不多，没有瓶颈）</li></ul><p>那么，之前的两个方向猜想，都落空了。那会是什么意想不到的原因？那回去看看卡住的代码，too_many_isolated 代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __too_many_isolated(struct pglist_data *pgdat, <span class="keyword">int</span> file,</span><br><span class="line">  struct scan_control *sc, <span class="keyword">bool</span> stalled)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> inactive, isolated;</span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stalled) &#123;</span><br><span class="line">      inactive = node_page_state_snapshot(pgdat,</span><br><span class="line">          NR_INACTIVE_FILE);</span><br><span class="line">      isolated = node_page_state_snapshot(pgdat,</span><br><span class="line">          NR_ISOLATED_FILE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inactive = node_page_state(pgdat, NR_INACTIVE_FILE);</span><br><span class="line">      isolated = node_page_state(pgdat, NR_ISOLATED_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stalled) &#123;</span><br><span class="line">      inactive = node_page_state_snapshot(pgdat,</span><br><span class="line">          NR_INACTIVE_ANON);</span><br><span class="line">      isolated = node_page_state_snapshot(pgdat,</span><br><span class="line">          NR_ISOLATED_ANON);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inactive = node_page_state(pgdat, NR_INACTIVE_ANON);</span><br><span class="line">      isolated = node_page_state(pgdat, NR_ISOLATED_ANON);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * GFP_NOIO/GFP_NOFS callers are allowed to isolate more pages, so they</span></span><br><span class="line"><span class="comment">   * won't get blocked by normal direct-reclaimers, forming a circular</span></span><br><span class="line"><span class="comment">   * deadlock.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((sc-&gt;gfp_mask &amp; (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))</span><br><span class="line">    inactive &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> isolated &gt; inactive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有很复杂的逻辑，只有简单的 isolated 和 inactive 统计计数比较。所以，只能是更直接的猜想：isolated file 统计一直偏大，导致一直判断 too_many_isolated 为真，卡在 shrink_inactive_list。</p><p>根据这个猜想，从 log 中打印的 mem info，也看到 isolated file 一直偏大，一直在增加，不会减少。好像印证了猜想似的。</p><p>LOG：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;6&gt;[95299.607369]  isolated(anon):0kB isolated(file):37880kB</span><br><span class="line">&lt;6&gt;[95318.568833]  isolated(anon):0kB isolated(file):37752kB</span><br><span class="line">&lt;6&gt;[95323.773350]  isolated(anon):0kB isolated(file):37752kB</span><br><span class="line">&lt;6&gt;[97520.184804]  isolated(anon):0kB isolated(file):44604kB</span><br><span class="line">&lt;6&gt;[97525.658037]  isolated(anon):0kB isolated(file):44604kB</span><br><span class="line">&lt;6&gt;[97754.256431]  isolated(anon):0kB isolated(file):44604kB</span><br><span class="line">&lt;6&gt;[97759.418172]  isolated(anon):0kB isolated(file):44604kB</span><br><span class="line">&lt;6&gt;[97764.574908]  isolated(anon):0kB isolated(file):44604kB</span><br><span class="line">&lt;6&gt;[97769.735128]  isolated(anon):0kB isolated(file):44604kB</span><br><span class="line">&lt;6&gt;[98543.638667]  isolated(anon):0kB isolated(file):44684kB</span><br><span class="line">&lt;6&gt;[98548.905397]  isolated(anon):0kB isolated(file):44684kB</span><br><span class="line">&lt;6&gt;[98554.209671]  isolated(anon):0kB isolated(file):44684kB</span><br><span class="line">&lt;6&gt;[99996.798031]  isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100002.122853] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100007.359023] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100146.079882] isolated(anon):0kB isolated(file):51700kB</span><br><span class="line">&lt;6&gt;[100151.313065] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100156.587622] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100328.483071] isolated(anon):0kB isolated(file):51700kB</span><br><span class="line">&lt;6&gt;[100520.245217] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100550.688429] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100555.913634] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100669.226582] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100935.069661] isolated(anon):0kB isolated(file):51688kB</span><br><span class="line">&lt;6&gt;[100940.240279] isolated(anon):0kB isolated(file):51572kB</span><br><span class="line">&lt;6&gt;[100945.476071] isolated(anon):0kB isolated(file):51828kB</span><br><span class="line">&lt;6&gt;[103104.120921] isolated(anon):0kB isolated(file):53344kB</span><br><span class="line">&lt;6&gt;[103121.900214] isolated(anon):0kB isolated(file):53344kB</span><br><span class="line">&lt;6&gt;[103481.197823] isolated(anon):0kB isolated(file):53412kB</span><br><span class="line">&lt;6&gt;[103486.555528] isolated(anon):0kB isolated(file):53412kB</span><br><span class="line">&lt;6&gt;[103721.346234] isolated(anon):0kB isolated(file):53412kB</span><br><span class="line">&lt;6&gt;[103726.655700] isolated(anon):0kB isolated(file):53540kB</span><br><span class="line">&lt;6&gt;[103731.961321] isolated(anon):0kB isolated(file):53540kB</span><br><span class="line">&lt;6&gt;[103737.236295] isolated(anon):0kB isolated(file):53540kB</span><br><span class="line">&lt;6&gt;[103742.470632] isolated(anon):0kB isolated(file):53412kB</span><br><span class="line">&lt;6&gt;[103747.661019] isolated(anon):0kB isolated(file):53284kB</span><br><span class="line">&lt;6&gt;[103752.973978] isolated(anon):0kB isolated(file):53412kB</span><br></pre></td></tr></table></figure></p><h2 id="柳暗花明又一村"><a href="#柳暗花明又一村" class="headerlink" title="柳暗花明又一村"></a>柳暗花明又一村</h2><p>对 NR_ISOLATED_FILE/NR_ISOLATED_ANON 的统计增减主要分布在 vmscan.c migrate.c，和 PPR (高通进程内存回收)模块。理论上内核 vmscan.c（成双成对） migrate.c 都不会有问题，高通 PPR 模块插入在 vmscan. c 和 task_mmu.c 里，而我们 IMS 没有直接使用高通 PPR，嫌疑最大。于是，在上游确实找到了个相关的 patch。</p><p><a href="https://source.codeaurora.org/quic/la/kernel/msm-4.14/commit/fs/proc/task\_mmu.c?h=msm-4.14&amp;id=c800548eac0350391c6d379a89f2e5d4c31366bf" target="_blank" rel="noopener">https://source.codeaurora.org/quic/la/kernel/msm-4.14/commit/fs/proc/task\_mmu.c?h=msm-4.14&amp;id=c800548eac0350391c6d379a89f2e5d4c31366bf</a></p><p>这个 patch 正是修复了 isolated count mismatch 的问题，导致一直让 isolated file 增大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MADV_FREE clears pte dirty bit and then marks the page lazyfree (clear</span><br><span class="line">SwapBacked). PPR increments ISOLATE_FILES count, then isolates page and</span><br><span class="line">invokes a reclaim. Inbetween if this lazyfreed page is touched by user then</span><br><span class="line">it becomes dirty.  PPR in shrink_page_list in try_to_unmap finds the page</span><br><span class="line">dirty, marks it back as PageSwapBacked and skips reclaim. As PageSwapBacked</span><br><span class="line">set, PPR identifies the page as anon and decrements ISOLATED_ANON, thus</span><br><span class="line">creating isolated count mismatch.</span><br><span class="line">This results in too_many_isolated() check causing delay in reclaim. Skip</span><br><span class="line">reclaiming lazyfreed pages in PPR path.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MADV_FREE (since Linux 4.5)</span><br><span class="line">              The application no longer requires the pages in the range</span><br><span class="line">              specified by addr and len.  The kernel can thus free these</span><br><span class="line">              pages, but the freeing could be delayed until memory pressure</span><br><span class="line">              occurs.  For each of the pages that has been marked to be</span><br><span class="line">              freed but has not yet been freed, the free operation will be</span><br><span class="line">              canceled if the caller writes into the page.  After a</span><br><span class="line">              successful MADV_FREE operation, any stale data (i.e., dirty,</span><br><span class="line">              unwritten pages) will be lost when the kernel frees the pages.</span><br><span class="line">              However, subsequent writes to pages in the range will succeed</span><br><span class="line">              and then kernel cannot free those dirtied pages, so that the</span><br><span class="line">              caller can always see just written data.  If there is no</span><br><span class="line">              subsequent write, the kernel can free the pages at any time.</span><br><span class="line">              Once pages in the range have been freed, the caller will see</span><br><span class="line">              zero-fill-on-demand pages upon subsequent page references.</span><br><span class="line">              The MADV_FREE operation can be applied only to private</span><br><span class="line">              anonymous pages (see mmap(2)).  In Linux before version 4.12,</span><br><span class="line">              when freeing pages on a swapless system, the pages in the</span><br><span class="line">              given range are freed instantly, regardless of memory</span><br><span class="line">              pressure.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">madvise(2) is a system call used by processes to tell the kernel how they are going to use their memory, allowing the kernel to optimize the memory management according to these hints to achieve better overall performance.</span><br><span class="line">When an application wants to signal the kernel that it isn&#39;t going to use a range of memory in the near future, it can use the MADV_DONTNEED flag, so the kernel can free resources associated with it. Subsequent accesses in the range will succeed, but will result either in reloading of the memory contents from the underlying mapped file or zero-fill-on-demand pages for mappings without an underlying file. But there are some kind of apps (notably, memory allocators) that can reuse that memory range after a short time, and MADV_DONTNEED forces them to incur in page fault, page allocation, page zeroing, etc. For avoiding that overhead, other OS like BSDs have supported MADV_FREE, which just mark pages as available to free if needed, but it doesn&#39;t free them immediately, making possible to reuse the memory range without incurring in the costs of faulting the pages again. This release adds Linux support for this flag.</span><br><span class="line">Recommended LWN article: Volatile ranges and MADV_FREE</span><br></pre></td></tr></table></figure><p>madvise[1] 系统调用，会建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式，使内核可以选择适当的预读和缓存技术。如果使用 madvise() 函数的程序明确了解其内存访问模式，则使用此函数可以提高系统性能。</p><p>自 4.5 开始，引入 MADV_FREE 参数「这是为什么 4.9 内核才出现该问题，这需要上层和底层同时支持，才会出现本问题」。简单来说，MADV_FREE 就是让上层设置一段内存可以释放内存的标志，但是底层并不会立即释放，以便让上层可以在短时间内重复访问，以免增加缺页异常等性能开销。也叫 lazy free，它只能用于匿名页面。</p><p>根据描述，触发 isolated file 统计增大的路径是：「代码省略不贴」</p><ul><li>上层调用 madvise 系统调用，使用 MADV_FREE 时，清除 dirty bit 和 SwapBacked bit，把 lazyfree page 加入 inactive file list。</li><li>PPR 增加 ISOLATE_FILES 计数（SwapBacked=0），隔离页面并触发回收</li><li>上层访问 lazyfreed 页面，dirty=1</li><li>PPR 执行 reclaim_pte_range -&gt; reclaim_pages_from_list -&gt; shrink_page_list -&gt;try_to_unmap -&gt; try_to_unmap_one 设置 SwapBacked=1, 并跳出回收</li><li>PPR 继续执行 reclaim_pte_range -&gt; reclaim_pages_from_list，putback_lru_page 的时候，因为 SwapBacked=1，减少了 NR_ISOLATED_ANON 计数，而不是减少当初增加的 NR_ISOLATED_FILE 计数。</li><li>导致 NR_ISOLATED_FILE 一直被增加</li></ul><p>所以，需要在 PPR 中过滤 lazyfree 页面，避免这个 NR_ISOLATED_FILE 计数异常，导致的卡 too_many_isolated。</p><p>匿名页面一开始就会设置 SwapBacked=1, 并且只有在上层设置 lazyfree 页面时才会清除 ClearPageSwapBacked(page) ，没别的地方了。所以，PageAnon(page) &amp;&amp; !PageSwapBacked(page) 能指示这是 lazyfree 页面。</p><p>ok，已经理清了前因后果。再退一步，试想下，假如上游没有修复这个 patch。我们能不能想出来？我觉得很难，因为我们缺乏 madvise 的相关认识，并且它经过了 dirty, SwapBacked 标志的变化（好像几乎没办法做这么微观的页面标志追踪？），才导致 NR_ISOLATED_ANON/FLIE 的变化。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><code>[1] madvise: _http://www.man7.org/linux/man-pages/man2/madvise.2.html_</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程冻结技术：深入探究 Linux 内核中的 cgroup freezer 子系统</title>
      <link href="/2024/07/12/sub-system-cgroup-freezer-in-Linux-kernel/"/>
      <url>/2024/07/12/sub-system-cgroup-freezer-in-Linux-kernel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>kernel version：5.15.119<br>cpu architecture：ARM64<br>cgroup version：cgroup v2</p></blockquote><h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>cgroup 最初由 Google 工程师 Paul Menage 和 Rohit Seth 在 2006 年提出，是一种细粒度资源控制的Linux内核机制。于 2007 年合并到 Linux 内核主线中。然而 Google 原生系统直到 Android 11 或更高版本上才支持 CACHE 应用的 CPU 冻结功能。当应用切换到后台并且没有其他活动时，系统会在一定时间内通过状态判断，将进程 ID 迁移到冻结的 cgroup 节点上，实现冻结 CACHE 应用。这项功能可以减少活跃缓存应用在后台存在时所消耗的 CPU 资源，从而达到节电的目的。当应用再次切换到前台时，系统会将该应用的进程解冻，以实现快速启动。</p><p>对于后台进程冻结，有两套方案，一是 cgroup freezer，二是内核信号 signal SIGSTOP 和 SIGCONT，国内很多手机厂商其实是早于 Android 做进程冻结方案的。而使用 cgroup freezer 方案更成熟更完善，接入后其实仅仅第一步，还有 binder 的 BINDER_FREEZE 冻结，framework层还有很多需要特殊场景，如后台下载、应用中使用桌面小组件、正在播放音频等等。</p><p>cgroup中的Freezer子系统可以用来暂停或恢复控制组中的进程，主要作用如下：</p><ol><li>暂停进程：冻结的进程会被暂停，其所有线程的执行将被停止，包括应用程序的主线程以及任何后台线程。</li><li>资源释放：冻结进程占用的资源，例如CPU、内存资源会被释放。这些资源将被系统重新分配给其他需要执行的进程或系统服务</li><li>功耗节省：被冻结的进程不会在后台运行，因此系统在休眠期间不会被频繁唤醒，可以节省设备的电池消耗。</li><li>快速恢复：冻结的进程可以快速恢复其执行状态。当需要重新激活进程时，系统可以迅速将其恢复到之前的运行状态，而无需重新启动或加载应用程序。 冻结进程并不会终止进程的执行或销毁应用程序。冻结只是暂时挂起进程，以优化资源使用。一旦系统需要再次运行该进程（例如用户重新打开应用程序或系统需要其提供服务），它会被解冻并恢复运行。 </li></ol><p>进程冻结是Android系统中重要的资源管理策略，也是目前主流手机厂商常用的后台管控策略之一，它有助于提高系统性能，同时最大限度地节省设备的资源和电量消耗。下面我们针对 cgroup freezer 的底层实现，看 Linux 内核是如何支撑 Android 的墓碑机制功能的。</p><h2 id="二、cgroup相关组件"><a href="#二、cgroup相关组件" class="headerlink" title="二、cgroup相关组件"></a>二、cgroup相关组件</h2><h3 id="1-检查cgroup-2-文件系统是否已经加载"><a href="#1-检查cgroup-2-文件系统是否已经加载" class="headerlink" title="1. 检查cgroup 2 文件系统是否已经加载"></a>1. 检查cgroup 2 文件系统是否已经加载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux:/ # cat /proc/filesystems | grep cgroup2</span><br><span class="line">nodev cgroup2</span><br></pre></td></tr></table></figure><h3 id="2-挂载"><a href="#2-挂载" class="headerlink" title="2. 挂载"></a>2. 挂载</h3><p>可以用如下命令挂载cgroup文件系统到d目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux:/ # mount -t cgroup2 none d           </span><br><span class="line">linux:/ #</span><br></pre></td></tr></table></figure></p><p>系统启动后，默认system已经将cgroup v2的文件系统挂载到/sys/fs/cgroup下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">linux:/ # mount | grep cgroup</span><br><span class="line">none on /dev/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">none on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,memory_recursiveprot)</span><br><span class="line">none on /dev/cpuctl type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">none on /dev/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset,noprefix,release_agent=/sbin/cpuset_release_agent)</span><br><span class="line">none on /dev/memcg type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br></pre></td></tr></table></figure></p><h3 id="3-cgroup的父子关系"><a href="#3-cgroup的父子关系" class="headerlink" title="3. cgroup的父子关系"></a>3. cgroup的父子关系</h3><p>初始状态下只有一个root cgroup根节点，所有进程都归属于这个cgroup，可以使用mkdir指令创建新的子cgroup。cpu、memory、freezer等控制资源是自顶向下（top-down）分配的，只有当一个 cgroup 从 parent 获得了某种资源，它才可以继续向下分发。这意味着所有非根”cgroup.subtree_control”文件只能包含在父级的”cgroup.subtree_control”文件中启用的控制器。只有在父级cgroup中启用了控制器时，子级cgroup才能启用控制器，如果一个或多个子级已经启用了某个控制器，则不能禁用该控制器。子孙cgroup数量有限，内核中使用cgroup.max.depth和cgroup.max.descendants来限制，关系图如下：<br><img src="1.png" alt=""></p><h3 id="4-进程与cgroup的关系"><a href="#4-进程与cgroup的关系" class="headerlink" title="4. 进程与cgroup的关系"></a>4. 进程与cgroup的关系</h3><p>cgroup.procs是cgroup与task进程绑定的接口，当读取该文件时，它会逐行列出属于该cgroup的所有进程的PID。将进程的PID写入到cgroup.procs中即可将目标PID进程绑定到该cgroup。进程与cgroup是多对多的关系，一个进程可以绑定到多个cgroup中，一个cgroup可以被多个进程绑定。在kernel中进程的数据结构task_struct与cgroup有关的是如下<em>cgroups、cg_list两个成员:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">        <span class="comment">/* Control Group info protected by css_set_lock: */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span>            *<span class="title">cgroups</span>;</span></span><br><span class="line">        <span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>                <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></em>cgroups、cg_list成员涉及到了css_set、cgroup_subsys_state、cgroup等几个关键数据结构，下面来分析这几个数据结构</p><h4 id="4-1-css-set数据结构"><a href="#4-1-css-set数据结构" class="headerlink" title="4.1 css_set数据结构"></a>4.1 css_set数据结构</h4><p>task_struct中的*cgroups指针指向了一个css_set结构，而css_set是用来存储与进程相关的cgroups信息，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A css_set is a structure holding pointers to a set of</span></span><br><span class="line"><span class="comment"> * cgroup_subsys_state objects. This saves space in the task struct</span></span><br><span class="line"><span class="comment"> * object and speeds up fork()/exit(), since a single inc/dec and a</span></span><br><span class="line"><span class="comment"> * list_add()/del() can bump the reference count on the entire cgroup</span></span><br><span class="line"><span class="comment"> * set for a task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> &#123;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Set of subsystem states, one for each subsystem. This array is</span></span><br><span class="line"><span class="comment">         * immutable after creation apart from the init_css_set during</span></span><br><span class="line"><span class="comment">         * subsystem registration (at boot time).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span> <span class="comment">//保存子系统状态的集合，初始化后不可修改</span></span><br><span class="line">                                                        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span>         <span class="comment">//用来链接所有使用此css_set的task_struct集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * List running through all cgroup groups in the same hash</span></span><br><span class="line"><span class="comment">         * slot. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span>         <span class="comment">//将所有的css_set组成一个hash表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * List of cgrp_cset_links pointing at cgroups referenced from this</span></span><br><span class="line"><span class="comment">         * css_set.  Protected by css_set_lock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cgrp_links</span>;</span>    <span class="comment">//将这个css_set对应的cgroup链接到一起</span></span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="4-2-cgroup-subsys-state数据结构"><a href="#4-2-cgroup-subsys-state数据结构" class="headerlink" title="4.2 cgroup_subsys_state数据结构"></a>4.2 cgroup_subsys_state数据结构</h4><p>每个子系统都有属于自己的资源控制统计信息结构，而且每个cgroup中都绑定一个这样的结构，这种资源控制统计信息结构就是通过 cgroup_subsys_state 结构体实现的，其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per-subsystem/per-cgroup state maintained by the system.  This is the</span></span><br><span class="line"><span class="comment"> * fundamental structural building block that controllers deal with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Fields marked with "PI:" are public and immutable and may be accessed</span></span><br><span class="line"><span class="comment"> * directly without synchronization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> &#123;</span></span><br><span class="line">        <span class="comment">/* PI: the cgroup that this css is attached to */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgroup</span>;</span>    <span class="comment">//连接到对应的cgroup</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PI: the cgroup subsystem that this css is attached to */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span>;</span>   <span class="comment">//归属于哪个子系统</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * PI: Subsys-unique ID.  0 is unused and root is always 1.  The</span></span><br><span class="line"><span class="comment">         * matching css can be looked up using css_from_id().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* percpu_ref killing and RCU release */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">destroy_work</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_work</span> <span class="title">destroy_rwork</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * PI: the parent css.  Placed here for cache proximity to following</span></span><br><span class="line"><span class="comment">         * fields of the containing structure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">parent</span>;</span>   父css</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="4-3-cgroup数据结构"><a href="#4-3-cgroup数据结构" class="headerlink" title="4.3 cgroup数据结构"></a>4.3 cgroup数据结构</h4><p>cgroup主要用来控制进程组对各种资源的使用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> &#123;</span></span><br><span class="line">        <span class="comment">/* self css with NULL -&gt;ss, points back to this cgroup */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">self</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;            <span class="comment">/* "unsigned long" so bitops work */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The depth this cgroup is at.  The root is at depth zero and each</span></span><br><span class="line"><span class="comment">         * step down the hierarchy increments the level.  This along with</span></span><br><span class="line"><span class="comment">         * ancestor_ids[] can determine whether a given cgroup is a</span></span><br><span class="line"><span class="comment">         * descendant of another without traversing the hierarchy.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Maximum allowed descent tree depth */</span></span><br><span class="line">        <span class="keyword">int</span> max_depth;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_root</span> *<span class="title">root</span>;</span>               <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * List of cgrp_cset_links pointing at css_sets with tasks in this</span></span><br><span class="line"><span class="comment">         * cgroup.  Protected by css_set_lock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cset_links</span>;</span> <span class="comment">//指向 css_sets 的 cgrp_cset_links 列表，其中包含此 cgroup 中的任务。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * On the default hierarchy, a css_set for a cgroup with some</span></span><br><span class="line"><span class="comment">         * susbsys disabled will point to css's which are associated with</span></span><br><span class="line"><span class="comment">         * the closest ancestor which has the subsys enabled.  The</span></span><br><span class="line"><span class="comment">         * following lists all css_sets which point to this cgroup's css</span></span><br><span class="line"><span class="comment">         * for the given subsystem.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">e_csets</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If !threaded, self.  If threaded, it points to the nearest</span></span><br><span class="line"><span class="comment">         * domain ancestor.  Inside a threaded subtree, cgroups are exempt</span></span><br><span class="line"><span class="comment">         * from process granularity and no-internal-task constraint.</span></span><br><span class="line"><span class="comment">         * Domain level resource consumptions which aren't tied to a</span></span><br><span class="line"><span class="comment">         * specific task are charged to the dom_cgrp.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Used to store internal freezer state */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_freezer_state</span> <span class="title">freezer</span>;</span>        <span class="comment">//用于存储内部freezer状态</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从task到其所属的cgroup之间是没有直接指针相连接的，但是task可以通过一个媒介来获取其所属的cgroup，这个媒介就是css_set和cgroup_subsys_state。通过task_struct -&gt; cgroups -&gt; subsys[ssid] -&gt;cgroup即可访问到管理对应子系统的cgroup。之所以这么设计是因为获取子系统状态的操作预计会频繁发生，而且是在性能关键代码中。然而需要一个task实际的cgroup来执行的操作（尤其是task在cgroups之间迁移的操作）则并没有那么常见。task_struct中的cg_list则是用来连接使用同一个css_set的task的链表，css_set通过tasks来遍历访问此链表。</p><p>对应关系图<br><img src="2.jpeg" alt=""></p><h3 id="5-freeze子系统使用"><a href="#5-freeze子系统使用" class="headerlink" title="5. freeze子系统使用"></a>5. freeze子系统使用</h3><p>做一个小实验：后台运行一个cpu_load.sh的脚本使一个cpu 负载达到100%<br><img src="3.png" alt=""></p><p>PID为8855的进程即我们在跑的脚本，此时它的进程状态为R<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux:/ # ps -Ae | grep 8855</span><br><span class="line">root          8855  8619   12470528   4160 0                   0 R sh</span><br></pre></td></tr></table></figure></p><p>在sys/fs/cgroup/目录下面新建一个an_test文件夹，将8855进程加入到an_test组中冻结<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">linux:/sys/fs/cgroup # mkdir an_test</span><br><span class="line">linux:/sys/fs/cgroup #</span><br><span class="line">linux:/sys/fs/cgroup # cd an_test/   </span><br><span class="line">linux:/sys/fs/cgroup/an_test #</span><br><span class="line">linux:/sys/fs/cgroup/an_test # echo 8855 &gt; cgroup.procs</span><br><span class="line">linux:/sys/fs/cgroup/an_test #</span><br><span class="line">linux:/sys/fs/cgroup/an_test # echo 1 &gt; cgroup.freeze</span><br><span class="line">linux:/sys/fs/cgroup/an_test #</span><br></pre></td></tr></table></figure></p><p>这个时候PID为8855的进程已经被我们的cgroup进程组给冻结掉，可以查看进程状态已经从R 切换到S<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux:/ # ps -Ae | grep 8855</span><br><span class="line">root          8855  8619   12470528   4160 do_freezer_trap     0 S sh</span><br></pre></td></tr></table></figure></p><p>观察上面的WCHAN可以看到冻结的进程是阻塞在内核的do_freezer_trap函数中 , do_freezer_trap是cgroup freezer中最核心的函数，后面小节会分析。如下是8855进程的调用栈:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">linux:/ # ps -A | grep do_freezer</span><br><span class="line">u0_a224      12571  1334   17204188  92476 do_freezer_trap     0 S com.baidu.searchbox:widgetProvider</span><br><span class="line">u0_a224      24866  1334   17415500 102640 do_freezer_trap     0 S com.baidu.searchbox:bdservice_v1</span><br><span class="line">u0_a224      32727  1334   35535376 106212 do_freezer_trap     0 S com.baidu.searchbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linux:/proc/8855 # cat stack</span><br><span class="line">[&lt;0&gt;] __switch_to+0x28c/0x4dc</span><br><span class="line">[&lt;0&gt;] do_freezer_trap+0xac/0x1bc</span><br><span class="line">[&lt;0&gt;] get_signal+0x4b8/0x940</span><br><span class="line">[&lt;0&gt;] do_signal+0xe0/0x2b4</span><br><span class="line">[&lt;0&gt;] do_notify_resume+0xac/0x1c4</span><br><span class="line">[&lt;0&gt;] el0_interrupt+0x8c/0x13c</span><br><span class="line">[&lt;0&gt;] __el0_irq_handler_common+0x1c/0x2c</span><br><span class="line">[&lt;0&gt;] el0t_64_irq_handler+0x14/0x24</span><br><span class="line">[&lt;0&gt;] el0t_64_irq+0x1b8/0x1bc</span><br><span class="line">linux:/proc/8855 #</span><br></pre></td></tr></table></figure></p><p>后台查看8855被冻结之后，cpu_load.sh进程已经不在后台运行，CPU的整体loading也降低下来<br><img src="4.png" alt=""></p><p>上面是使用cgroup freeze功能冻结进程的过程，下面小节来分析其实现原理。</p><h2 id="三、cgroup-freezer子系统的实现"><a href="#三、cgroup-freezer子系统的实现" class="headerlink" title="三、cgroup freezer子系统的实现"></a>三、cgroup freezer子系统的实现</h2><h3 id="1-cgroup冻结整体流程"><a href="#1-cgroup冻结整体流程" class="headerlink" title="1. cgroup冻结整体流程"></a>1. cgroup冻结整体流程</h3><p><img src="5.jpeg" alt=""></p><p>内核通过了一个比较巧妙的方式实现了冻结流程。它首先为该进程设置了一个信号pending标志TIF_SIGPENDING，但并不向该进程发送实际的信号，然后通过ipi唤醒该进程执行。由于ipi会进行进程内核的中断处理流程，当其处理完成后，会调用ret_to_user函数返回用户态，而该函数会调用信号处理函数检查是否有pending的中断需要处理，由于先前已经设置了信号的pending标志，因此会执行信号处理流程。在信号处理流程中检查进程冻结相关的全局变量是否设置，然后调用__set_current_state将task 设置为interrupt状态 将task 挂起，执行schedule() 让出cpu，进行上下文切换。</p><h3 id="2-设置freezer冻结与解冻"><a href="#2-设置freezer冻结与解冻" class="headerlink" title="2. 设置freezer冻结与解冻"></a>2. 设置freezer冻结与解冻</h3><p>前面实验通过对cgroup目录cgroup.freeze值的修改，来完成了freezer对task限制的设置。将cgroup.freeze值置为1则该cgroup里的进程会全被freeze，置为0则会被unfreeze。这个小节来看看这个设置过程。当用户读写cgroup.freeze这个文件的时候，cgroup中调用的是cgroup_freeze_write函数，内核数据结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* cgroup core interface files for the default hierarchy */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">cgroup_base_files</span>[] = &#123;</span></span><br><span class="line">        &#123;</span><br><span class="line">                .name = <span class="string">"cgroup.procs"</span>,</span><br><span class="line">                .flags = CFTYPE_NS_DELEGATABLE,</span><br><span class="line">                .file_offset = offsetof(struct cgroup, procs_file),</span><br><span class="line">                .<span class="built_in">release</span> = cgroup_procs_release,</span><br><span class="line">                .seq_start = cgroup_procs_start,</span><br><span class="line">                .seq_next = cgroup_procs_next,</span><br><span class="line">                .seq_show = cgroup_procs_show,</span><br><span class="line">                .<span class="built_in">write</span> = cgroup_procs_write,</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name = <span class="string">"cgroup.freeze"</span>,</span><br><span class="line">                .flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">                .seq_show = cgroup_freeze_show,</span><br><span class="line">                .<span class="built_in">write</span> = cgroup_freeze_write,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件读写处理函数cgroup_freeze_write函数调用cgroup_freeze_task将cgroup中所有task的jobctl位掩码置位为JOBCTL_TRAP_FREEZE，然后将要冻结的task设置为TIF_SIGPENDIN状态，如果是解冻这里会将task中的jobctl位掩码JOBCTL_TRAP_FREEZE清除，然后执行wake_up_process将task唤醒。调用链路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vfs_write</span><br><span class="line">    |-&gt;kernfs_fop_write_iter  </span><br><span class="line">      |-&gt;cgroup_file_write</span><br><span class="line">        |-&gt;cgroup_freeze_write</span><br><span class="line">          |-&gt;cgroup_kn_lock_live       &#x2F;&#x2F;获得文件所在的目录的cgroup实体</span><br><span class="line">          |-&gt;cgroup_freeze</span><br><span class="line">            |-&gt;css_for_each_descendant_pre &#x2F;&#x2F;循环体里对当前目录以及每个子孙目录所代表cgroup实体执行cgroup_do_freeze函数</span><br><span class="line">              |-&gt;cgroup_do_freeze</span><br><span class="line">                |-&gt;set_bit                 &#x2F;&#x2F;将cgroup及子孙cgroup设为freeze状态                  </span><br><span class="line">                |-&gt;cgroup_freeze_task</span><br><span class="line">                  |-&gt;signal_wake_up</span><br><span class="line">                    |-&gt;signal_wake_up_state</span><br><span class="line">                      |-&gt;wake_up_state     </span><br><span class="line">                        |-&gt;try_to_wake_up</span><br><span class="line">                      |-&gt;kick_process      &#x2F;&#x2F;使进程陷入内核态，为返回用户态处理冻结信号做准备    </span><br><span class="line">                  |-&gt;wake_up_process</span><br></pre></td></tr></table></figure></p><p>这里分析几个关键的函数cgroup_freeze、cgroup_do_freeze、cgroup_freeze_task。cgroup_freeze_write会调用到cgroup_kn_lock_live获取要冻结目录的cgroup实体，然后再调到cgroup_freeze中将父cgroup的冻结状态传给各子孙cgroup, cgroup_freeze定义在kernel/cgroup/freezer.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cgroup_freeze</span><span class="params">(struct cgroup *cgrp, <span class="keyword">bool</span> freeze)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Propagate changes downwards the cgroup tree.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        css_for_each_descendant_pre(css, &amp;cgrp-&gt;self) &#123;</span><br><span class="line">                dsct = css-&gt;cgroup;</span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Do change actual state: freeze or unfreeze.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                cgroup_do_freeze(dsct, freeze);</span><br><span class="line">                applied = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cgroup_freeze中通过css_for_each_descendant_pre循环将父cgroup的freeze状态传递到各子孙cgroup中，父cgroup被freeze或者unfreeze，其目录下的子cgroup也会被freeze或者unfreeze，执行动作是在函数cgroup_do_freeze中，cgroup_do_freeze会循环遍历cgroup中的task执行cgroup_freeze_task函数做下一步的冻结/解冻操作。如果遇到内核线程则直接跳出该次循环。注意在信号的设计机制里内核线程不会收到信号，信号是针对用户线程或者进程的一种异步机制。所以在cgroup的冻结流程里没有内核线程的处理，但在suspend的冻结中有针对内核线程的处理，有兴趣的可以去看看。这里只讲cgroup中的冻结。cgroup_do_freeze实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Freeze or unfreeze all tasks in the given cgroup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cgroup_do_freeze</span><span class="params">(struct cgroup *cgrp, <span class="keyword">bool</span> freeze)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">        css_task_iter_start(&amp;cgrp-&gt;self, <span class="number">0</span>, &amp;it);</span><br><span class="line">        <span class="keyword">while</span> ((task = css_task_iter_next(&amp;it))) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Ignore kernel threads here. Freezing cgroups containing</span></span><br><span class="line"><span class="comment">                 * kthreads isn't supported.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (task-&gt;flags &amp; PF_KTHREAD)   <span class="comment">//遇到内核线程直接跳出该次循环       </span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                cgroup_freeze_task(task, freeze);</span><br><span class="line">        &#125;</span><br><span class="line">        css_task_iter_end(&amp;it);</span><br><span class="line">        </span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cgroup_freeze_task中会设置task的jobctl位掩码为JOBCTL_TRAP_FREEZE，然后调用signal_wake_up使进程陷入内核态，只有陷入内核态，后面返回用户态才能够处理冻结信号，cgroup_freeze_task实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Freeze or unfreeze the task by setting or clearing the JOBCTL_TRAP_FREEZE</span></span><br><span class="line"><span class="comment"> * jobctl bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cgroup_freeze_task</span><span class="params">(struct task_struct *task, <span class="keyword">bool</span> freeze)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (freeze) &#123;</span><br><span class="line">                task-&gt;jobctl |= JOBCTL_TRAP_FREEZE;    <span class="comment">//设置冻结标志位</span></span><br><span class="line">                signal_wake_up(task, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                task-&gt;jobctl &amp;= ~JOBCTL_TRAP_FREEZE;   <span class="comment">//清除冻结标志位</span></span><br><span class="line">                wake_up_process(task);                 <span class="comment">//将已经冻结的进程唤醒，选择合适的CPU来运行，这里就是解冻</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unlock_task_sighand(task, &amp;flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>signal_wake_up会调用signal_wake_up_state先为进程设置TIF_SIGPENDING标志，表明该进程有延迟的信号要等待处理。然后再调用 wake_up_state()唤醒目标进程，如果目标进程在其他的CPU上运行，wake_up_state()将返回0，此时调用 kick_process()向该CPU发送一个处理器核间中断。当中断返回前时，直接调用do_notify_resume()处理该进程的信号。signal_wake_up_state函数实现如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell a process that it has a new active signal..</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! we rely on the previous spin_lock to</span></span><br><span class="line"><span class="comment"> * lock interrupts for us! We can only be called with</span></span><br><span class="line"><span class="comment"> * "siglock" held, and the local interrupt must</span></span><br><span class="line"><span class="comment"> * have been disabled when that got acquired!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * No need to set need_resched since signal event passing</span></span><br><span class="line"><span class="comment"> * goes through -&gt;blocked</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_wake_up_state</span><span class="params">(struct task_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * TASK_WAKEKILL also means wake it up in the stopped/traced/killable</span></span><br><span class="line"><span class="comment">         * case. We don't check t-&gt;state here because there is a race with it</span></span><br><span class="line"><span class="comment">         * executing another processor and just now entering stopped state.</span></span><br><span class="line"><span class="comment">         * By using wake_up_state, we ensure the process will wake up and</span></span><br><span class="line"><span class="comment">         * handle its death signal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">                kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据signal_wake_up_state函数的代码逻辑，如果目标进程不在runqueue上，则wake_up_state函数会将其放在runqueue上并返回true；如果进程已经处于runqueue上了，则返回false，才会执行kick_process。下面我们来看看kick_process函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * kick_process - kick a running thread to enter/exit the kernel</span></span><br><span class="line"><span class="comment"> * @p: the to-be-kicked thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cause a process which is running on another CPU to enter</span></span><br><span class="line"><span class="comment"> * kernel-mode, without any delay. (to get signals handled.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this function doesn't have to take the runqueue lock,</span></span><br><span class="line"><span class="comment"> * because all it wants to ensure is that the remote task enters</span></span><br><span class="line"><span class="comment"> * the kernel. If the IPI races and the task has been migrated</span></span><br><span class="line"><span class="comment"> * to another CPU then no harm is done and the purpose has been</span></span><br><span class="line"><span class="comment"> * achieved as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kick_process</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">        preempt_disable();</span><br><span class="line">        cpu = task_cpu(p);</span><br><span class="line">        <span class="keyword">if</span> ((cpu != smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">                smp_send_reschedule(cpu);</span><br><span class="line">        preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的注释已经写得很清楚，kick_process的目的就是让进程陷入内核态。而smp_send_reschedule本质就是给进程所在的核发个IPI中断，从而导致正在运行的进程被打断陷入内核态。到这里cgroup这边freeze的前置工作已经做完，所有即将进入freeze的task已经被kernel置位为JOBCTL_TRAP_FREEZE和处于TIF_SIGPENDING的状态，真正执行进程冻结挂起的操作是放在signal的信号处理这边来执行。</p><h3 id="3-冻结信号处理"><a href="#3-冻结信号处理" class="headerlink" title="3. 冻结信号处理"></a>3. 冻结信号处理</h3><p>信号真正得到执行的时机是进程执行完异常/中断/系统调用，从内核态返回到用户态的时刻，所以永远不要指望你所发送的信号能像硬件中断那般随时处理，进程信号处理只是异步通信机制，没有像真正的硬件中断那样能随时改变cpu的执行流。正常的用户进程是会频繁的在用户态和内核态之间切换的 (这种切换包括：系统调用，缺页异常，系统中断..)，所以信号能很快得到执行。</p><p>前面小节已经讲过cgroup组中要被freeze的task已经将其_TIF_SIGPENDING置位。进程的_TIF_SIGPENDING置位，表明该进程有pending信号需要处理。因此会执行信号处理流程。<br>信号处理过程中会检查task中的freeze标志位已设置，故进程将执行关键冻结函数do_freeze_trap。调用链路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exit_to_user_mode</span><br><span class="line">prepare_exit_to_user_mode</span><br><span class="line">do_notify_resume</span><br><span class="line">  |-&gt;do_signal</span><br><span class="line">    |-&gt;get_signal</span><br><span class="line">      |-&gt;do_freezer_trap</span><br><span class="line">        |-&gt;__set_current_state    &#x2F;&#x2F;进程即将进入冻结休眠，将进程设置为TASK_INTERRUPTIBLE，可以被signal唤醒</span><br><span class="line">        |-&gt;clear_thread_flag</span><br><span class="line">        |-&gt;cgroup_enter_frozen</span><br><span class="line">          |-&gt;cgroup_update_frozen</span><br><span class="line">            |-&gt;cgroup_propagate_frozen</span><br><span class="line">        |-&gt;freezable_schedule</span><br><span class="line">          |-&gt;schedule</span><br><span class="line">            |-&gt;__schedule</span><br><span class="line">              |-&gt;deactivate_task</span><br><span class="line">                |-&gt;dequeue_task</span><br></pre></td></tr></table></figure><p>调用栈打印：<br><img src="6.png" alt=""></p><p>这里分析几个关键函数do_notify_resume、get_signal、do_freezer_trap、freezable_shedule。函数do_notify_resume定义在arch/arm64/kernel/signal.c中，该函数检查如果当前任务设置了标志位_TIF_SIGPENDING，则调用do_signal()处理信号，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_notify_resume</span><span class="params">(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> thread_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">                        <span class="keyword">if</span> (thread_flags &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))</span><br><span class="line">                                do_signal(regs);</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>do_signal中调用到get_signal函数从线程私有的pending链表或者线程组共享的pending链表中，找到pending信号，如果需要投递到用户态去执行，返回1。如果没有需要投递到用户态去执行的pending信号，返回0。如果遇到需要kernel处理的信号，在该函数内部就会消化掉。get_signal实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (unlikely(uprobe_deny_signal()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Do this once, we can't return to user-mode if freezing() == T.</span></span><br><span class="line"><span class="comment">* do_signal_stop() and ptrace_stop() do freezable_schedule() and</span></span><br><span class="line"><span class="comment">* thus do not need another check after return.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的freeze系统在suspend时会调用suspend_freeze_processes()来freeze线程</span></span><br><span class="line"><span class="comment">// 实际上也是唤醒线程，让线程在ret_to_user时刻去freeze自己，这个跟cgroup中的freeze无关</span></span><br><span class="line">try_to_freeze();</span><br><span class="line"></span><br><span class="line">relock:</span><br><span class="line">spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Every stopped thread goes here after wakeup. Check to see if</span></span><br><span class="line"><span class="comment">* we should notify the parent, prepare_signal(SIGCONT) encodes</span></span><br><span class="line"><span class="comment">* the CLD_ si_code into SIGNAL_CLD_MASK bits.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line"><span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">why = CLD_CONTINUED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Notify the parent that we're continuing.  This event is</span></span><br><span class="line"><span class="comment">* always per-process and doesn't make whole lot of sense</span></span><br><span class="line"><span class="comment">* for ptracers, who shouldn't consume the state via</span></span><br><span class="line"><span class="comment">* wait(2) either, but, for backward compatibility, notify</span></span><br><span class="line"><span class="comment">* the ptracer of the group leader too unless it's gonna be</span></span><br><span class="line"><span class="comment">* a duplicate.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line"><span class="literal">true</span>, why);</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Has this task already been marked for death? */</span></span><br><span class="line"><span class="keyword">if</span> (signal_group_exit(signal)) &#123;</span><br><span class="line">ksig-&gt;info.si_signo = signr = SIGKILL;</span><br><span class="line">sigdelset(&amp;current-&gt;pending.signal, SIGKILL);</span><br><span class="line">trace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,</span><br><span class="line">&amp;sighand-&gt;action[SIGKILL - <span class="number">1</span>]);</span><br><span class="line">recalc_sigpending();</span><br><span class="line"><span class="keyword">goto</span> fatal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_STOP_PENDING) &amp;&amp;</span><br><span class="line">do_signal_stop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp;</span><br><span class="line">(JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;jobctl &amp; JOBCTL_TRAP_MASK) &#123;</span><br><span class="line">do_jobctl_trap();</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;jobctl &amp; JOBCTL_TRAP_FREEZE) &#123;</span><br><span class="line">do_freezer_trap();      <span class="comment">//cgroup freeze处理，开始真正执行进程冻结挂起操作，在ret_to_user时刻去执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* If the task is leaving the frozen state, let's update</span></span><br><span class="line"><span class="comment">* cgroup counters and reset the frozen bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cgroup_task_frozen(current))) &#123;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">cgroup_leave_frozen(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Signals generated by the execution of an instruction</span></span><br><span class="line"><span class="comment">* need to be delivered before any other pending signals</span></span><br><span class="line"><span class="comment">* so that the instruction pointer in the signal stack</span></span><br><span class="line"><span class="comment">* frame points to the faulting instruction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signr = dequeue_synchronous_signal(&amp;ksig-&gt;info);</span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line">signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);  <span class="comment">//从信号pending队列中，取出优先级最高的信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;ptrace) &amp;&amp; (signr != SIGKILL) &amp;&amp;</span><br><span class="line">!(sighand-&gt;action[signr <span class="number">-1</span>].sa.sa_flags &amp; SA_IMMUTABLE)) &#123;</span><br><span class="line">signr = ptrace_signal(signr, &amp;ksig-&gt;info);</span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                       <span class="comment">//下面这些逻辑跟冻结没什么关联，备注一下以便日后分析signal机制</span></span><br><span class="line">ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];   <span class="comment">//从信号处理数组sighand中，取出信号对应的处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trace actually delivered signals. */</span></span><br><span class="line">trace_signal_deliver(signr, &amp;ksig-&gt;info, ka);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span>      <span class="comment">//信号处理的第一种方法：忽略</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;    <span class="comment">//信号处理的第二种方法，调用用户态注册的处理函数  </span></span><br><span class="line"><span class="comment">/* Run the handler.  */</span>              <span class="comment">//获取到用户态的处理函数指针，返回调用handle_signal来执行</span></span><br><span class="line">ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Now we are doing the default action for this signal.     //信号处理的第三种方法，调用默认的内核态处理函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Global init gets no signals it doesn't want.</span></span><br><span class="line"><span class="comment">* Container-init gets no signals it doesn't want from same</span></span><br><span class="line"><span class="comment">* container.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note that if global/container-init sees a sig_kernel_only()</span></span><br><span class="line"><span class="comment">* signal here, the signal must have been generated internally</span></span><br><span class="line"><span class="comment">* or must have come from an ancestor namespace. In either</span></span><br><span class="line"><span class="comment">* case, the signal cannot be dropped.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">!sig_kernel_only(signr))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在信号处理流程中检查task中的jobctl标志位是否被设置成JOBCTL_TRAP_FREEZE，条件成立则执行do_freezer_trap开始走进程挂起流程，do_freezer_trap实现如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * do_freezer_trap - handle the freezer jobctl trap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Puts the task into frozen state, if only the task is not about to quit.</span></span><br><span class="line"><span class="comment"> * In this case it drops JOBCTL_TRAP_FREEZE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * Must be called with @current-&gt;sighand-&gt;siglock held,</span></span><br><span class="line"><span class="comment"> * which is always released before returning.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_freezer_trap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        __<span class="title">releases</span><span class="params">(&amp;current-&gt;sighand-&gt;siglock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If there are other trap bits pending except JOBCTL_TRAP_FREEZE,</span></span><br><span class="line"><span class="comment">         * let's make another loop to give it a chance to be handled.</span></span><br><span class="line"><span class="comment">         * In any case, we'll return back.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((current-&gt;jobctl &amp; (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=</span><br><span class="line">             JOBCTL_TRAP_FREEZE) &#123;</span><br><span class="line">                spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Now we're sure that there is no pending fatal signal and no</span></span><br><span class="line"><span class="comment">         * pending traps. Clear TIF_SIGPENDING to not get out of schedule()</span></span><br><span class="line"><span class="comment">         * immediately (if there is a non-fatal signal pending), and</span></span><br><span class="line"><span class="comment">         * put the task into sleep.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        pr_info(<span class="string">"current_jobctl_value: %d"</span>, current-&gt;jobctl);</span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        clear_thread_flag(TIF_SIGPENDING);</span><br><span class="line">        spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">        cgroup_enter_frozen();</span><br><span class="line">        freezable_schedule();  <span class="comment">//进程挂起，主动调度出cpu</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>freezable_schedule调到调度函数<strong>schedule里去，</strong>schedule定义在 kernel/sched/core.c 中，在 __schedule() 中接受一个参数，该参数为 bool 型，false 表示非抢占，自愿调度，而 true 则相反。freeze中的调度是主动调度让出CPU。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Like schedule(), but should not block the freezer. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">freezable_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        freezer_do_not_count();</span><br><span class="line">        schedule();</span><br><span class="line">        freezer_count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h2><p>确定何时冻结、何时解冻、何时再冻结进程其实是一个复杂的问题，需要维护一个流程图来管理不同的场景。在本文中，我们只是简单介绍了内核冻结功能的实现逻辑。在 Android Framework 层还涉及到低内存时内存整理时解冻、dump进程信息时解冻、发送和接收广播临时解冻、持有文件锁解冻等策略。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://juejin.cn/post/7264949719275880482" target="_blank" rel="noopener">https://juejin.cn/post/7264949719275880482</a><br><a href="https://docs.kernel.org/admin-guide/cgroup-v2.html" target="_blank" rel="noopener">https://docs.kernel.org/admin-guide/cgroup-v2.html</a><br><a href="https://lwn.net/Articles/785081/" target="_blank" rel="noopener">https://lwn.net/Articles/785081/</a></p>]]></content>
      
      
      <categories>
          
          <category> 温升与功耗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> freeze_processes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核内存稳定性新特性：Page Table Check 机制解读</title>
      <link href="/2024/05/27/Linux-Page-Table-Check/"/>
      <url>/2024/05/27/Linux-Page-Table-Check/</url>
      
        <content type="html"><![CDATA[<p>Linux内核中内存损坏一直是极难定位但又较为常见的一类问题。在内核中已经有较多的机制来拦截此类问题。比如Kasan/Kfence等等。而内核自5.17版本起又引入了Page Table Check机制，用来检测某些page计数异常导致的内存损坏问题。</p><h2 id="一、-为何引入Page-Table-Check机制："><a href="#一、-为何引入Page-Table-Check机制：" class="headerlink" title="一、 为何引入Page Table Check机制："></a>一、 为何引入Page Table Check机制：</h2><p>Google 的工程师在分析一个进程的dump时，无意间发现了一页不属于该进程的内存。进一步研究发现了内核自4.14起就存在的内存page引用计数的bug。为化解此类内存缺陷，Google 提出了一个全新的“页表检查”（Page Table Check）解决方案。</p><p>我们看看 Google 的修复patch及问题发生的原因：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line"> kernel/events/core.c | 10 +++++-----</span><br><span class="line"> 1 file changed, 5 insertions(+), 5 deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/kernel/events/core.c b/kernel/events/core.c</span><br><span class="line">index 236e7900e3fc..0736508d595b 100644</span><br><span class="line"><span class="comment">--- a/kernel/events/core.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/events/core.c</span></span><br><span class="line">@@ -6110,7 +6110,6 @@ void perf_output_sample(struct perf_output_handle *handle,</span><br><span class="line"> static u64 perf_virt_to_phys(u64 virt)</span><br><span class="line"> &#123;</span><br><span class="line">         u64 phys_addr = 0;</span><br><span class="line"><span class="deletion">-        struct page *p = NULL;</span></span><br><span class="line"> </span><br><span class="line">         if (!virt)</span><br><span class="line">                 return 0;</span><br><span class="line">@@ -6129,14 +6128,15 @@ static u64 perf_virt_to_phys(u64 virt)</span><br><span class="line">                  * If failed, leave phys_addr as 0.</span><br><span class="line">                  */</span><br><span class="line">                 if (current-&gt;mm != NULL) &#123;</span><br><span class="line"><span class="addition">+                        struct page *p;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">                         pagefault_disable();</span><br><span class="line"><span class="deletion">-                        if (__get_user_pages_fast(virt, 1, 0, &amp;p) == 1)</span></span><br><span class="line"><span class="addition">+                        if (__get_user_pages_fast(virt, 1, 0, &amp;p) == 1) &#123;</span></span><br><span class="line">                                 phys_addr = page_to_phys(p) + virt % PAGE_SIZE;</span><br><span class="line"><span class="addition">+                                put_page(p);</span></span><br><span class="line"><span class="addition">+                        &#125;</span></span><br><span class="line">                         pagefault_enable();</span><br><span class="line">                 &#125;</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-                if (p)</span></span><br><span class="line"><span class="deletion">-                        put_page(p);</span></span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         return phys_addr;</span><br><span class="line"><span class="deletion">--</span></span><br></pre></td></tr></table></figure><p>问题发生的根因就在于__get_user_pages_fast函数可能存在先对page指针p赋值了，但是后续因为某个错误直接返回。在此场景下__get_user_pages_fast中是没有调用get_page来增加引用计数的，因此后续的put_page是多余的，会导致引用计数下溢。 修复方式其实比较简单，只有在__get_user_pages_fast成功时，才put_page。</p><p>此问题是很隐秘的，在内核中存在了很长时间。正因为如此，google才推出了Page Table Check机制，希望在第一时间拦截此类问题。</p><h2 id="二、Page-Table-Check-机制的实现："><a href="#二、Page-Table-Check-机制的实现：" class="headerlink" title="二、Page Table Check 机制的实现："></a>二、Page Table Check 机制的实现：</h2><p>新增一个page_ext记录当前page的映射是匿名或者文件映射。在每次映射关系改变时，会判断当前的映射标记，如果出现不允许的情况就会主动panic，保留第一现场。</p><p>具体规则如下：</p><div class="table-container"><table><thead><tr><th>当前映射</th><th>新映射</th><th>映射权限</th><th>规则</th></tr></thead><tbody><tr><td>匿名</td><td>匿名</td><td>读</td><td>允许</td></tr><tr><td>匿名</td><td>匿名</td><td>读/写</td><td>禁止</td></tr><tr><td>匿名</td><td>文件</td><td>任何</td><td>禁止</td></tr><tr><td>文件</td><td>匿名</td><td>任何</td><td>禁止</td></tr><tr><td>文件</td><td>文件</td><td>任何</td><td>允许</td></tr></tbody></table></div><p>我们来看看这个规则的代码实现。在有新的映射发生时，会根据page现有的file_map_count/anon_map_count的标志来判断映射是否合法，并且会修改标志值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_check_set</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgcnt,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">bool</span> rw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">bool</span> anon;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pfn_valid(pfn))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        page = pfn_to_page(pfn);</span><br><span class="line">        page_ext = page_ext_get(page);</span><br><span class="line">        anon = PageAnon(page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pgcnt; i++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page_table_check</span> *<span class="title">ptc</span> = <span class="title">get_page_table_check</span>(<span class="title">page_ext</span>);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (anon) &#123;</span><br><span class="line">                        BUG_ON(atomic_read(&amp;ptc-&gt;file_map_count));</span><br><span class="line">                        BUG_ON(atomic_inc_return(&amp;ptc-&gt;anon_map_count) &gt; <span class="number">1</span> &amp;&amp; rw);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        BUG_ON(atomic_read(&amp;ptc-&gt;anon_map_count));</span><br><span class="line">                        BUG_ON(atomic_inc_return(&amp;ptc-&gt;file_map_count) &lt; <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                page_ext = page_ext_next(page_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        page_ext_put(page_ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的调用逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">缺页中断</span><br><span class="line">  → handle_mm_fault</span><br><span class="line">    → handle_pte_fault</span><br><span class="line">      → do_anonymous_page &#x2F; do_fault</span><br><span class="line">        → set_pte_at</span><br><span class="line">          → page_table_check_set</span><br><span class="line">            ↳ 判断是否合法</span><br></pre></td></tr></table></figure></p><p>同样在unmap时，也会调用page_table_check_clear来判断当前的标志位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_check_clear</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,                                   <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgcnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">bool</span> anon;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pfn_valid(pfn))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        page = pfn_to_page(pfn);</span><br><span class="line">        page_ext = page_ext_get(page);</span><br><span class="line">        anon = PageAnon(page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pgcnt; i++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page_table_check</span> *<span class="title">ptc</span> = <span class="title">get_page_table_check</span>(<span class="title">page_ext</span>);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (anon) &#123;</span><br><span class="line">                        BUG_ON(atomic_read(&amp;ptc-&gt;file_map_count));</span><br><span class="line">                        BUG_ON(atomic_dec_return(&amp;ptc-&gt;anon_map_count) &lt; <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        BUG_ON(atomic_read(&amp;ptc-&gt;anon_map_count));</span><br><span class="line">                        BUG_ON(atomic_dec_return(&amp;ptc-&gt;file_map_count) &lt; <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                page_ext = page_ext_next(page_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        page_ext_put(page_ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在分配 alloc_pages() 和释放 free_pages_prepare() 内存的时候也会调用__page_table_check_zero，保证当前内存没有被映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __page_table_check_zero(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">        page_ext = page_ext_get(page);</span><br><span class="line">        BUG_ON(!page_ext);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="number">1u</span>l &lt;&lt; order); i++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page_table_check</span> *<span class="title">ptc</span> = <span class="title">get_page_table_check</span>(<span class="title">page_ext</span>);</span></span><br><span class="line"></span><br><span class="line">                BUG_ON(atomic_read(&amp;ptc-&gt;anon_map_count));</span><br><span class="line">                BUG_ON(atomic_read(&amp;ptc-&gt;file_map_count));</span><br><span class="line">                page_ext = page_ext_next(page_ext);</span><br><span class="line">        &#125;</span><br><span class="line">        page_ext_put(page_ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Page-Table-Check-机制的配置："><a href="#三、Page-Table-Check-机制的配置：" class="headerlink" title="三、Page Table Check 机制的配置："></a>三、Page Table Check 机制的配置：</h2><p>要使用Page Table Check机制，需要在编译的时候使能PAGE_TABLE_CHECK=y。并且需要在内核的cmdline中增加”page_table_check=on”或者在kconfig中使能CONFIG_PAGE_TABLE_CHECK_ENFORCED=y。<br>比如，我们的配置如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_PAGE_TABLE_CHECK=y</span><br><span class="line">CONFIG_PAGE_TABLE_CHECK_ENFORCED=y</span><br></pre></td></tr></table></figure><h2 id="四、测试方式："><a href="#四、测试方式：" class="headerlink" title="四、测试方式："></a>四、测试方式：</h2><p>前面提到引入page table check的起因是因为异常调用put_page导致的。那么我们人为构建一个多次调用put_page的测试程序来看看page table check如何生效的吧。</p><p>测试程序的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_page_table_check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =  <span class="title">find_task_by_vpid</span>(1);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =  <span class="title">task</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">        addr = mm-&gt;mmap_base - PAGE_SIZE;</span><br><span class="line">        mmap_read_lock(mm);</span><br><span class="line">        vma = find_vma(mm, addr);</span><br><span class="line">        page = follow_page(vma, addr, FOLL_GET);</span><br><span class="line">        put_page(page);</span><br><span class="line">        mmap_read_unlock(mm);</span><br><span class="line"></span><br><span class="line">        put_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取init进程中mmap分配的一页page。我们故意在最后多操作了一遍put_page。从而导致page的引用计数为0，因此会释放掉此内存，而在释放内存时，__page_table_check_zero检查到anon_map_count不为0，因此panic了。</p><p>具体的调用过程可以参考下面的堆栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[  132.032451][2:3990:sh] ------------[ cut here ]------------</span><br><span class="line">[  132.032453][2:3990:sh] kernel BUG at mm&#x2F;page_table_check.c:143!</span><br><span class="line">[  132.032458][2:3990:sh] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP</span><br><span class="line">[  132.032822][2:3990:sh] CPU: 2 PID: 3990 Comm: sh Tainted: G S      W  OE      6.1.25-android14-11-maybe-dirty-qki-consolidate #1</span><br><span class="line">[  132.032829][2:3990:sh] pstate: 82400005 (Nzcv daif +PAN -UAO +TCO -DIT -SSBS BTYPE&#x3D;--)</span><br><span class="line">[  132.032833][2:3990:sh] pc : __page_table_check_zero+0xcc&#x2F;0xdc</span><br><span class="line">[  132.032843][2:3990:sh] lr : __page_table_check_zero+0x30&#x2F;0xdc</span><br><span class="line">[  132.032846][2:3990:sh] sp : ffffffc03094bb10</span><br><span class="line">[  132.032848][2:3990:sh] x29: ffffffc03094bb10 x28: ffffff88c4a00000 x27: 0000000000000000</span><br><span class="line">[  132.032854][2:3990:sh] x26: ffffffe31e256000 x25: ffffffe31e256000 x24: 0000000000000001</span><br><span class="line">[  132.032858][2:3990:sh] x23: 0000000000000000 x22: ffffffe31d36b523 x21: ffffffe31d3cac1c</span><br><span class="line">[  132.032862][2:3990:sh] x20: ffffff8023a81760 x19: fffffffe01baba40 x18: ffffffe31e18b240</span><br><span class="line">[  132.032866][2:3990:sh] x17: 00000000ad6b63b6 x16: 00000000ad6b63b6 x15: ffffffe31c2ad328</span><br><span class="line">[  132.032870][2:3990:sh] x14: ffffffe31b7466fc x13: ffffffc030948000 x12: ffffffc03094c000</span><br><span class="line">[  132.032874][2:3990:sh] x11: 0000000000000060 x10: ffffffe31e178720 x9 : 0000000000000001</span><br><span class="line">[  132.032878][2:3990:sh] x8 : ffffff8023a817b8 x7 : ffffffe31c18cda4 x6 : ffffffe31c1e5ee8</span><br><span class="line">[  132.032882][2:3990:sh] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000002</span><br><span class="line">[  132.032886][2:3990:sh] x2 : 0000000000000000 x1 : ffffffe31d3bf383 x0 : ffffff8023a81760</span><br><span class="line">[  132.032890][2:3990:sh] Call trace:</span><br><span class="line">[  132.032892][2:3990:sh]  __page_table_check_zero+0xcc&#x2F;0xdc</span><br><span class="line">[  132.032896][2:3990:sh]  free_unref_page_prepare+0x36c&#x2F;0x42c</span><br><span class="line">[  132.032903][2:3990:sh]  free_unref_page+0x58&#x2F;0x268</span><br><span class="line">[  132.032907][2:3990:sh]  __folio_put+0x54&#x2F;0x80</span><br><span class="line">[  132.032917][2:3990:sh]  test_page_table_check+0x114&#x2F;0x1f8 [mz_stability_test]</span><br><span class="line">[  132.032930][2:3990:sh]  proc_generate_oops_write+0x960&#x2F;0xa18 [mz_stability_test]</span><br><span class="line">[  132.032939][2:3990:sh]  proc_reg_write+0xfc&#x2F;0x170</span><br><span class="line">[  132.032949][2:3990:sh]  vfs_write+0x110&#x2F;0x2d0</span><br><span class="line">[  132.032956][2:3990:sh]  ksys_write+0x80&#x2F;0xf0</span><br><span class="line">[  132.032960][2:3990:sh]  __arm64_sys_write+0x24&#x2F;0x34</span><br><span class="line">[  132.032965][2:3990:sh]  invoke_syscall+0x60&#x2F;0x124</span><br><span class="line">[  132.032975][2:3990:sh]  el0_svc_common+0xcc&#x2F;0x118</span><br><span class="line">[  132.032980][2:3990:sh]  do_el0_svc+0x34&#x2F;0xb8</span><br><span class="line">[  132.032984][2:3990:sh]  el0_svc+0x30&#x2F;0xb0</span><br><span class="line">[  132.032992][2:3990:sh]  el0t_64_sync_handler+0x68&#x2F;0xb4</span><br><span class="line">[  132.032996][2:3990:sh]  el0t_64_sync+0x1a0&#x2F;0x1a4</span><br></pre></td></tr></table></figure><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>在page table操作时增加校验，从而检查是否存在非法共享等人为软件漏洞，提前发现问题，确保防止某些内存损坏。在生产环境和研发阶段，对硬件和工艺原因导致的随机内存跳变问题，也会有所帮助。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://lwn.net/Articles/876264/" target="_blank" rel="noopener">https://lwn.net/Articles/876264/</a><br><a href="https://lore.kernel.org/all/xr9335nxwc5y.fsf@gthelen2.svl.corp.google.com/" target="_blank" rel="noopener">https://lore.kernel.org/all/xr9335nxwc5y.fsf@gthelen2.svl.corp.google.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 调试与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指尖上的科技：智能手机触摸屏技术与功耗优化</title>
      <link href="/2024/05/16/TouchScreen-Basics/"/>
      <url>/2024/05/16/TouchScreen-Basics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>触摸屏作为现代交互设备中重要的输入方式之一，已广泛应用于手机、平板电脑、电脑显示器等设备中。本文档将从基础知识出发，介绍触摸屏的工作原理，包括传感器感知、信号转换、数据处理和触摸事件传递等关键步骤。接着，将介绍触摸屏的分类，包括电容式触摸屏、电阻式触摸屏等不同技术的特点和应用场景。随后，将探讨触摸屏的工作模式：Actvie/Idle/Sleep Mode，也包括单点触控、多点触控、手势识别等常见模式。本文档还将涵盖触摸屏在手机典型应用中的应用案例和特点。此外，还会介绍触摸屏常见的省电策略，功耗相关常见问题和解决方法，如防误触、双击亮屏、手势唤醒待机等。最后，将提供一些常见的调试方法，帮助用户解决触摸屏功耗相关的问题。</p><h2 id="2-触摸屏的分类"><a href="#2-触摸屏的分类" class="headerlink" title="2. 触摸屏的分类"></a>2. 触摸屏的分类</h2><p>  触摸屏根据其实现原理可分为：<strong>红外线触摸屏</strong> 、 <strong>外表声波触摸屏</strong> 、 <strong>电阻式触摸屏</strong> 、 <strong>电容式触摸屏</strong> 。现在市场上的电子产品主要以电容屏为主，接下会简单介绍一下每种触摸屏的实现原理和优缺点</p><table><colgroup><col width="123"><col width="204"><col width="456"></colgroup><tbody><tr height="80"><td>触摸屏</td><td>含义</td><td>基本原理</td></tr><tr height="100"><td>红外线触摸屏</td><td>一种使用红外线传感器来检<br>测触摸操作的触摸屏技术</td><td>在触摸面板的边缘或角落处放置红外线发射器和接收器，通过检<br>测被触摸物体（如手指）引起的红外线被遮挡的情况来确定触摸<br>位置。</td></tr><tr height="100"><td>外表声波触摸屏</td><td>一种利用声波传播的原理来<br>检测触摸操作的触摸屏技术</td><td>使用超声波传感器在触摸屏表面产生一系列不可听见的声波，并<br>通过接收器检测被触摸物体引起的声波变化，从而确定触摸位置。</td></tr><tr height="100"><td>电阻式触摸屏</td><td>一种基于电阻原理的触摸屏<br>技术</td><td>由两层导电膜组成，当触摸屏表面被按压时，上下两层导电膜会<br>接触，形成电阻变化，通过测量电阻变化来确定触摸位置。</td></tr><tr height="100"><td>电容式触摸屏</td><td>一种基于电容效应的触摸屏<br>技术</td><td>由触摸面板上的一层电容传感器阵列组成，当手指或触摸物体接<br>近触摸面板时，会改变电容场分布，通过测量电容变化来确定触<br>摸位置。</td></tr></tbody></table><table><colgroup><col width="122"><col width="210"><col width="451"></colgroup><tbody><tr height="80"><td>触摸屏</td><td>适用范围</td><td>优缺点</td></tr><tr height="100"><td>红外线触摸屏</td><td>常见于公共信息查询设备、<br>交互展示屏、ATM机</td><td>优点：较高的精度和可靠性，适应室内和室外环境，不受光照<br>影响。<br>缺点：需要额外的红外线感应器，触摸屏表面容易受到污染，<br>需要定期清洁。</td></tr><tr height="100"><td>外表声波触摸屏</td><td>常见于信息亭、自助点餐机、<br>电子导览屏</td><td>优点：高透明度和可触摸性，对图像质量无损失，适用于大尺寸<br>触摸屏和高分辨率要求的应用。<br>缺点：较高的成本，对声波传播环境有一定要求。</td></tr><tr height="100"><td>电阻式触摸屏</td><td>常见于工业控制设备、POS机<br>、便携式终端</td><td>优点：较低的成本和良好的耐用性，对触控笔和手指均支持。<br>缺点：触摸屏表面需要一层特殊的电阻膜，可能会影响显示<br>质量和触摸感应的精度。</td></tr><tr height="100"><td>电容式触摸屏</td><td>广泛应用于智能手机、平板<br>电脑和其他触摸屏设备</td><td>优点：高灵敏度、高分辨率和多点触控支持，支持手指操作，<br>无需压力。<br>缺点：对外界干扰较敏感，可能会受到电磁干扰的影响，较高<br>的成本。</td></tr></tbody></table><p>  前面三种触摸屏的工作原理如图所示：</p><p><img src="1.webp" alt="图片"></p><ul><li><p><strong>电阻式触摸屏（Resistive Touch Screen）</strong>   </p><p>  电阻式触摸屏最早问世，在20世纪70年代开始被广泛应用。它由两层柔性薄膜之间夹层一层透明导电物质组成。当屏幕被按压时，两层薄膜之间的导电物质接触，形成电阻变化，从而检测到触摸位置。</p></li><li><p><strong>电容式触摸屏（Capacitive Touch Screen）</strong>  </p><p>  电容式触摸屏的基本原理早在20世纪就已经被发现，但是由于技术限制和成本问题，直到21世纪才开始流行起来。它利用触摸屏表面的电容变化来检测触摸输入。</p></li><li><p><strong>红外线触摸屏（Infrared Touch Screen）</strong></p><p>  红外线触摸屏在20世纪80年代开始出现。它利用红外线传感器和发射器来创建一个红外线网格，当触摸发生时，被触摸的位置会阻挡红外线，从而被感应器检测到。</p></li><li><p><strong>外表声波触摸屏（Surface Acoustic Wave Touch Screen）</strong></p><p>  外表声波触摸屏在20世纪90年代开始应用。它利用表面声波传输技术，在触摸屏上放置传感器和发射器，通过声波传播检测触摸位置。</p></li></ul><p>现在的智能手机、平板等主要使用的是电容式触摸屏，因此以电容式触摸屏为例来介绍。</p><h2 id="3-电容式触摸屏"><a href="#3-电容式触摸屏" class="headerlink" title="3. 电容式触摸屏"></a>3. 电容式触摸屏</h2><p><img src="2.webp" alt="图片"></p><p>两个带电的导体相互靠近会形成电容。当手指触摸屏幕时，由于人体电场，手指和触摸屏会形成耦合电容，对高频电流来说，电容是直接导体，会影响电路整体的电容特性。手指从接触点吸走一个很小的电流。这个电流分别从触摸屏的四角上的电极中流出，并且流经这四个电极的电流与手指到四角的距离成正比，控制器通过对这四个电流比例的精确计算，得出触摸点的位置。</p><p>电容式触摸屏又分为表面电容式和投射式电容式两种类型。表面电容式触摸屏采用透明导电层覆盖在显示屏表面，通过感应人体电荷来检测触摸。投射式电容式触摸屏则在触摸屏上放置电容传感器，通过电场变化来检测触摸位置。</p><ul><li><strong>表面电容式</strong></li></ul><p><img src="3.webp" alt="图片"></p><table><colgroup><col width="122"><col width="624"></colgroup><tbody><tr height="130"><td>工作原理</td><td>表面电容式触摸屏使用一层透明导电物质（通常是氧化锡或氧化铟锡）覆盖在触摸屏表<br>面。当触摸发生时，人体或其他导电物体接触到触摸屏表面，改变了导电层上的电荷分<br>布。通过检测导电层上电荷分布的变化，触摸屏控制器可以确定触摸的位置。</td></tr><tr height="130"><td>优点</td><td>工作原理简单、价格低廉、设计的电路简单</td></tr><tr height="130"><td>缺点</td><td>透光率不均匀，存在色彩失真；均匀沉积的ITO会导致枕型失真；当温湿度改变时，环境<br>电场发生变化，会引起电容屏的不准确</td></tr></tbody></table><ul><li><strong>投射电容式</strong></li></ul><p><img src="4.webp" alt="图片"></p><p>投射电容式触摸屏又分为自感应电容式和互感应电容式两种类型。</p><p><strong>自感应电容式</strong></p><table><colgroup><col width="122"><col width="624"></colgroup><tbody><tr height="130"><td>工作原理</td><td>自感应电容式触摸屏采用一层导电层（例如，ITO）作为触摸屏表面，当手指或其他导电<br>物体接触到触摸屏表面时，导电层上形成一个电容。触摸屏控制器通过测量导电层上的<br>电容变化来确定触摸位置和触摸操作。自感应电容式触摸屏使用一个电路来感应整个导<br>电层上的电容变化。</td></tr><tr height="130"><td>优点</td><td>扫描速度快（每个扫描周期只需要检测X、Y电极，通过X和Y的检测结果定位触摸位置）</td></tr><tr height="130"><td>缺点</td><td>只能实现单点触摸，多点时有鬼点效应，环境变化较大时需要校准，抗干扰性能差</td></tr></tbody></table><p><strong>互感应电容式</strong></p><table><colgroup><col width="122"><col width="624"></colgroup><tbody><tr height="130"><td>工作原理</td><td>互感应电容式触摸屏在触摸面板上使用两层交叉的导电层，一层作为发送器（Tx层），<br>另一层作为接收器（Rx层）。当手指或其他导电物体接触到触摸屏表面时，触摸位置<br>处的电容值发生变化。触摸屏控制器通过测量接收器层上的电信号变化来确定触摸位<br>置和触摸操作。互感应电容式触摸屏使用两个电路，一个用于发送信号，另一个用于<br>接收信号。</td></tr><tr height="130"><td>优点</td><td>多点触摸时无鬼点效应，无需校准，抗干扰性能较好，能够减少误触发和漂移问题。</td></tr><tr height="130"><td>缺点</td><td>扫描速度慢，次数高（每次扫描周期都要检测每一个X方向的电极与Y方向的所有电极之<br>间的电容，总共需要扫描X乘以Y次）</td></tr></tbody></table><p>现在常用的触摸屏都是自感与互感结合，先进行自感扫描如果需要再进行互感扫描，这样可以减少扫描时间和芯片负担。</p><h2 id="4-基本工作流程"><a href="#4-基本工作流程" class="headerlink" title="4. 基本工作流程"></a>4. 基本工作流程</h2><p>触摸屏的本质是传感器，它由触摸检测部件和控制器组成。检测部分安装在显示屏上面，用于检测用户触摸的位置，然后将触摸信息传给控制器；控制器将其转化为触点坐标传给CPU，同时触摸屏控制器能接收CPU发来的信息，做相应的处理。</p><p>Android触摸屏的工作原理可以简单概括为以下几个步骤：</p><p><img src="5.webp" alt="图片"></p><ol><li><p><strong>传感器感知触摸</strong>：触摸屏通常由一层透明的电容层或压力敏感层组成。当用户触摸屏幕时，这些传感器会感知到触摸输入，并将其转换为电信号。</p></li><li><p><strong>信号转换</strong>：接下来，触摸屏控制器会将感知到的电信号转换为数字信号。这个过程涉及信号放大和模数转换，将连续的电压变化转换为数字值。</p></li><li><p><strong>数据处理</strong>：处理器或控制器会对转换后的数字信号进行处理和解析。它会根据触摸屏的类型和工作原理，确定触摸的位置、压力等信息。</p></li><li><p><strong>触摸事件传递</strong>：处理器将解析后的触摸数据传递给操作系统，通常通过输入子系统。操作系统会根据触摸事件的信息，比如触摸的位置和动作（点击、滑动等），进行相应的处理。</p></li><li><p><strong>应用程序响应</strong>：操作系统将触摸事件传递给当前活动的应用程序。应用程序可以根据触摸事件进行相应的处理，比如触发相应的操作或交互。</p></li></ol><p>需要注意的是，Android触摸屏的具体工作原理会因触摸屏的类型和技术有所不同，常见的触摸屏技术包括电容式触摸屏、电阻式触摸屏、表面声波触摸屏等。不同的技术使用不同的传感器和算法来感知触摸输入，但基本的工作流程是类似的。</p><h2 id="5-工作模式"><a href="#5-工作模式" class="headerlink" title="5. 工作模式"></a>5. 工作模式</h2><h3 id="5-1-触控IC的三种工作模式"><a href="#5-1-触控IC的三种工作模式" class="headerlink" title="5.1 触控IC的三种工作模式"></a>5.1 触控IC的三种工作模式</h3><p>以某款市面常见的触控IC为例，触控IC（GTP）有三种工作模式，分别为 Active mode， Idle mode 以及 Sleep mode。</p><p><img src="6.webp" alt="图片"></p><p><strong>Active Mode</strong></p><p>GTP 在 Active mode 时，会按照已设定的驱动信号频率、刷新率等参数在有触摸或无触摸未超时状态，可进行正常的坐标上报或数据上报。芯片的工作状态完全由软件配置决定。</p><p><strong>Idle Mode</strong></p><p>低功耗模式，在一定的时间没有检测到手之后，通过调整打码方式来降低 IC 功耗。</p><p><strong>Sleep Mode</strong></p><p>Active 模式时，主控通过下发命令使 GTP 进入 Sleep mode。当需要 GTP 退出 Sleep mode 时，</p><p>主控复位唤醒 GTP，唤醒后 GTP 将进入 Active mode。下发 Sleep 命令与唤醒之间的时间间隔要求大于 100ms。</p><p><img src="7.webp" alt="图片"></p><h3 id="5-2-不同工作模式下的功耗"><a href="#5-2-不同工作模式下的功耗" class="headerlink" title="5.2 不同工作模式下的功耗"></a>5.2 不同工作模式下的功耗</h3><p>触控IC的供电主要由两路供电组成：AVDD和DVDD</p><p>工作条件：环境温度为 25℃， AVDD=3.3V， DVDD=1.8V ， VDDIO=1.8V</p><table data-ace-table-col-widths="208;100;100;100;163"><colgroup><col width="208"><col width="100"><col width="100"><col width="100"><col width="163"></colgroup><tbody><tr><td colspan="1" rowspan="1"><p><strong>参数</strong></p></td><td colspan="1" rowspan="1"><p><strong>最小值</strong></p></td><td colspan="1" rowspan="1"><p><strong>典型值</strong></p></td><td colspan="1" rowspan="1"><p><strong>最大值</strong></p></td><td colspan="1" rowspan="1"><p><strong>单位</strong></p></td></tr><tr><td colspan="1" rowspan="1"><p>AVDD</p></td><td colspan="1" rowspan="1"><p>2.7</p></td><td colspan="1" rowspan="1"><p>2.8/3.0/3.3</p></td><td colspan="1" rowspan="1"><p>3.4</p></td><td colspan="1" rowspan="1"><p>V</p></td></tr><tr><td colspan="1" rowspan="1"><p>DVDD</p></td><td colspan="1" rowspan="1"><p>1.65</p></td><td colspan="1" rowspan="1"><p>1.8</p></td><td colspan="1" rowspan="1"><p>1.95</p></td><td colspan="1" rowspan="1"><p>V</p></td></tr><tr><td colspan="1" rowspan="1"><p>VDDIO</p></td><td colspan="1" rowspan="1"><p>-</p></td><td colspan="1" rowspan="1"><p>1.8</p></td><td colspan="1" rowspan="1"><p>-</p></td><td colspan="1" rowspan="1"><p>V</p></td></tr><tr><td colspan="1" rowspan="1"><p>电源纹波</p></td><td colspan="1" rowspan="1"><p>-</p></td><td colspan="1" rowspan="1"><p>-</p></td><td colspan="1" rowspan="1"><p>100</p></td><td colspan="1" rowspan="1"><p>mV（peak-to-peak）</p></td></tr><tr><td colspan="1" rowspan="1"><p>工作温度范围</p></td><td colspan="1" rowspan="1"><p>-20</p></td><td colspan="1" rowspan="1"><p>25</p></td><td colspan="1" rowspan="1"><p>85</p></td><td colspan="1" rowspan="1"><p>℃</p></td></tr></tbody></table><p>以下数据是datasheet里面提供的不同工作模式下的功耗典型值。（注：数据仅供参考，只提供了120hz报点率下的功耗参考）</p><div class="table-container"><table><thead><tr><th>参数</th><th>最小值</th><th>典型值</th><th>最大值</th><th>单位</th></tr></thead><tbody><tr><td>Active Mode AVDD 工作电流@120hz</td><td>-</td><td>8</td><td>-</td><td>mA</td></tr><tr><td>Idle Mode AVDD 工作电流@120hz</td><td>-</td><td>1</td><td>-</td><td>mA</td></tr><tr><td>Sleep Mode AVDD 工作电流</td><td>-</td><td>14</td><td>-</td><td>uA</td></tr><tr><td>Normal Mode DVDD 工作电流@120hz</td><td>-</td><td>8</td><td>-</td><td>mA</td></tr><tr><td>Idle Mode DVDD 工作电流@120hz</td><td>-</td><td>1</td><td>-</td><td>mA</td></tr><tr><td>Sleep Mode DVDD 工作电流</td><td>-</td><td>33</td><td>-</td><td>uA</td></tr></tbody></table></div><h2 id="6-关键参数"><a href="#6-关键参数" class="headerlink" title="6. 关键参数"></a>6. 关键参数</h2><table data-ace-table-col-widths="216;601"><colgroup><col width="216"><col width="601"></colgroup><tbody><tr><td colspan="1" rowspan="1"><p><strong>参数</strong></p></td><td colspan="1" rowspan="1"><p><strong>含义</strong></p></td></tr><tr><td colspan="1" rowspan="1"><p>Accuracy</p></td><td colspan="1" rowspan="1"><p>各种情况下的精度（手指、薄手套、厚手套模式、触控笔下）</p></td></tr><tr><td colspan="1" rowspan="1"><p>Linearity</p></td><td colspan="1" rowspan="1"><p>横、竖、对角线滑动时的线性情况（特定滑动速度等条件下的）</p></td></tr><tr><td colspan="1" rowspan="1"><p>Jitter</p></td><td colspan="1" rowspan="1"><p>各种情况下的抖动，即滑动偏差</p></td></tr><tr><td colspan="1" rowspan="1"><p>Scan Period</p></td><td colspan="1" rowspan="1"><p>扫描周期</p></td></tr><tr><td colspan="1" rowspan="1"><p>Sampling Rate</p></td><td colspan="1" rowspan="1"><p>采样率</p></td></tr><tr><td colspan="1" rowspan="1"><p>Reporting Rate</p></td><td colspan="1" rowspan="1"><p>报点率</p></td></tr><tr><td colspan="1" rowspan="1"><p>Automatic Calibration</p></td><td colspan="1" rowspan="1"><p>自动校准</p></td></tr><tr><td colspan="1" rowspan="1"><p>Clicking Sensitivity</p></td><td colspan="1" rowspan="1"><p>点击的灵敏度</p></td></tr><tr><td colspan="1" rowspan="1"><p>Drawing Sensitivity</p></td><td colspan="1" rowspan="1"><p>拉伸的灵敏度</p></td></tr><tr><td colspan="1" rowspan="1"><p>Water rejection</p></td><td colspan="1" rowspan="1"><p>水滴对touch电容特性的影响</p></td></tr><tr><td colspan="1" rowspan="1"><p>Noise rejection</p></td><td colspan="1" rowspan="1"><p>充电器（大电流）对touch电容特性的影响</p></td></tr><tr><td colspan="1" rowspan="1"><p>Response time</p></td><td colspan="1" rowspan="1"><p>响应时间，包括从Sleep Mode to Active Mode和从Idle Mode to Active Mode</p></td></tr><tr><td colspan="1" rowspan="1"><p>Tracking finger separation</p></td><td colspan="1" rowspan="1"><p>两个手指滑动时，两个手指之间最小能区分开的距离</p></td></tr></tbody></table><p>在触摸屏相关的领域，存在着扫描周期、采样率和报点率这三个概念，它们有一些区别和联系。</p><table><colgroup><col width="80"><col width="248"><col width="488"></colgroup><tbody><tr height="80"><td>参数</td><td>含义</td><td>区别和联系</td></tr><tr height="100"><td>扫描周期</td><td>触摸屏控制器在一个周期内完成<br>对触摸输入的扫描操作的时间间隔。</td><td>扫描周期决定了触摸屏硬件对触摸输入进行采样的频率，而采样率<br>表示在一个扫描周期内进行了多少次采样操作。</td></tr><tr height="100"><td>采样率</td><td>触摸屏控制器在一个扫描周期内对<br>触摸输入进行采样的次数。</td><td>采样率和报点率都对触摸屏的精度和响应性产生影响。较高的采样率<br>和报点率可以提供更准确和实时的触摸输入。</td></tr><tr height="100"><td>报点率</td><td>触摸屏向系统报告触摸事件的频率，<br>即触摸屏将采样到的触摸数据传递<br>给系统的速率。</td><td>报点率是触摸屏向系统报告触摸事件的频率，它受到扫描周期和采样<br>率的影响。较高的扫描周期和采样率通常会导致较高的报点率。</td></tr></tbody></table><p><strong>扫描周期（Scan Cycle）</strong></p><p>扫描周期是指触摸屏控制器在一个周期内完成对触摸输入的扫描操作的时间间隔。它表示触摸屏硬件对触摸输入进行采样的频率，通常以赫兹（Hz）为单位表示。较短的扫描周期意味着触摸屏控制器更频繁地扫描触摸输入，可以提供更高的采样率。</p><p><strong>采样率（Sampling Rate）</strong></p><p>采样率是指触摸屏控制器在一个扫描周期内对触摸输入进行采样的次数。它表示触摸屏硬件对触摸输入进行测量的频率，通常以赫兹（Hz）为单位表示。较高的采样率意味着触摸屏硬件更频繁地测量触摸输入，可以提供更高的精度和灵敏度。</p><p><strong>报点率（Reporting Rate）</strong></p><p>报点率是指触摸屏向系统报告触摸事件的频率，即触摸屏将采样到的触摸数据传递给系统的速率。它表示触摸屏硬件向系统发送触摸事件的次数，通常以报告次数（Reports per Second）为单位表示。较高的报点率意味着触摸屏向系统提供更实时和准确的触摸事件信息。</p><h2 id="7-典型应用"><a href="#7-典型应用" class="headerlink" title="7. 典型应用"></a>7. 典型应用</h2><p>常见的触摸屏技术：电阻式、表面电容式(surface capacitive touch panel)、投射电容式(project capacitive touch panel)、电磁式等等，如今应用于手机、平板产品的主要是<strong>投射电容式</strong>、电磁式(主要突出的是手写笔功能,如三星的GalaxyNote系列)。</p><p>目前生产触控IC的厂家有新思、赛普拉斯、ATMEL、敦泰、汇顶、奕力、义隆、晨星、美发思、矽创等。</p><p>国内的模组厂有欧菲、信利、胜华、帝晶、华意、TPK、合力泰、超声、创维等。</p><h3 id="7-1-常见触摸操作"><a href="#7-1-常见触摸操作" class="headerlink" title="7.1 常见触摸操作"></a>7.1 常见触摸操作</h3><table><colgroup><col width="80"><col width="238"><col width="488"></colgroup><tbody><tr height="80"><td>模式</td><td>含义</td><td>适用范围</td></tr><tr height="100"><td>单点触控</td><td>在触摸屏上只能检测到一个触摸<br>点的操作</td><td>适用于简单的操作需求，如选择、点击或滚动等。</td></tr><tr height="100"><td>多点触控</td><td>在触摸屏上可以同时检测到多个<br>触摸点的操作</td><td>用户可以使用多根手指在触摸屏上进行同时触摸、滑动、捏合、<br>旋转等操作</td></tr><tr height="100"><td>手势识别</td><td>通过分析用户在触摸屏上的手势<br>动作来进行识别和响应的技术</td><td>手势可以是单点触摸或多点触摸的组合，如滑动、捏合、<br>旋转、双击等</td></tr></tbody></table><p><strong>单点触控（Single Touch）</strong></p><p>单点触控是最基本和最常见的触摸屏工作模式。在单点触控模式下，触摸屏只能感知到单个触点，即一次只能检测到一个位置的触摸。当用户用手指或触控笔接触屏幕时，触摸屏会识别触点的位置，并将其转化为相应的操作，如点击、滑动等。</p><p><strong>多点触控（Multi-Touch）</strong></p><p>多点触控模式允许触摸屏同时感知和跟踪多个触点。这意味着用户可以用多个手指或触控笔在屏幕上进行操作。多点触控模式为更复杂的手势操作提供了支持，如缩放、旋转、双指滑动等。触摸屏会跟踪每个触点的位置和动作，并将其转化为相应的操作指令。</p><p><strong>手势识别（Gesture Recognition）</strong></p><p>手势识别是在多点触控的基础上，通过分析和识别手指或触控笔的运动模式和轨迹来识别特定的手势动作。手势可以是简单的，如单击、双击、长按，也可以是复杂的，如滑动、缩放、旋转等。触摸屏通过算法和模式识别技术，将用户的手势动作转化为相应的操作指令，从而实现更丰富和直观的交互体验。</p><h3 id="7-2-手机常见功能"><a href="#7-2-手机常见功能" class="headerlink" title="7.2 手机常见功能"></a>7.2 手机常见功能</h3><table><colgroup><col width="122"><col width="216"><col width="451"></colgroup><tbody><tr height="80"><td>常见功能</td><td>特点</td><td>区别</td></tr><tr height="100"><td>防误触</td><td>旨在减少意外触摸或误触引起<br>的误操作。</td><td>主要关注的是减少误操作，例如在设备放在口袋中或触摸屏靠近<br>面部时，避免意外触发屏幕上的操作。</td></tr><tr height="100"><td>双击亮屏</td><td>允许用户通过快速双击屏幕来<br>唤醒设备的屏幕或将其从待机<br>状态切换到活动状态</td><td>主要用于快速唤醒屏幕，以便用户能够方便地查看或响应设备上<br>的信息，而不需要按下物理按钮或使用其他手势。</td></tr><tr height="100"><td>手势唤醒</td><td>允许用户使用预定义的手势<br>或动作在设备休眠或屏幕关闭<br>状态下唤醒设备。</td><td>提供了更多的灵活性，用户可以通过特定的手势或动作来自定义<br>唤醒设备的方式，以满足个人偏好或方便操作。</td></tr></tbody></table><p><strong>防误触功能</strong></p><p>防误触功能旨在减少或避免在触摸屏上发生意外触摸操作。由于触摸屏可能会被意外的手指接触或其他物体触碰，防误触功能通过一系列算法和策略来识别并区分意外触摸和真实的用户操作。常见的防误触功能包括屏幕灵敏度调节、手掌识别、触摸抑制等，旨在提高用户的操作准确性和体验。</p><p>手机解锁时遮挡屏幕时触发防误触提醒，如下图所示</p><p><img src="8.webp" alt="图片"></p><p><strong>双击亮屏功能</strong></p><p>双击亮屏功能是一种方便的操作方式，允许用户通过在触摸屏上快速连续地双击，将设备的屏幕从休眠状态唤醒。这样用户无需按下物理按键或使用其他复杂的操作来开启设备屏幕，提供了更快速、直观的亮屏体验。双击亮屏功能在许多智能手机和平板电脑等设备中得到广泛支持，并可以在设备设置中进行配置和启用。</p><p>手机双击亮屏功能开关，如下图所示</p><p><img src="9.webp" alt="图片"></p><p><strong>手势唤醒功能</strong></p><p>手势唤醒功能允许用户使用特定的手势动作来唤醒设备屏幕，而无需按下物理按键。用户可以在设备休眠状态下，在触摸屏上执行预定义的手势，如双击、画字母等，以激活设备并亮屏。手势唤醒功能通过使用传感器和模式识别技术，识别和解释用户手势的意图，并触发相应的操作。这种功能提供了更便捷的操作方式，使用户能够快速访问设备功能，如查看通知、启动应用程序等。</p><p>手机手势唤醒功能，如下图所示</p><p><img src="10.webp" alt="图片"></p><h2 id="8-功耗问题及对应策略"><a href="#8-功耗问题及对应策略" class="headerlink" title="8. 功耗问题及对应策略"></a>8. 功耗问题及对应策略</h2><p><strong>常见的功耗问题：</strong></p><ol><li>开启手势功能（双击亮屏/手势唤醒）后待机功耗</li><li>亮屏下单指点击、滑动、长按屏幕的功耗</li><li>亮屏下多指点击、滑动、长按屏幕的功耗</li></ol><p><strong>常见的省电策略：</strong></p><ol><li>针对不同场景需求，适当降低报点率</li><li>缩短TP从active恢复idle时间</li><li>延长TP扫描周期</li><li>限制Touch boost场景下CPU的调度和频率</li><li>提高电源供电效率</li><li>降低active模式下的工作电流</li><li>非用即关，外设器件休眠下电（厂商一般不建议休眠下电）</li></ol><h3 id="8-1-降低TP报点率（采样率）"><a href="#8-1-降低TP报点率（采样率）" class="headerlink" title="8.1 降低TP报点率（采样率）"></a>8.1 降低TP报点率（采样率）</h3><p>亮灭屏下两个参数含义是一样，配置稍有点不一样，报点率（采样率）越高，所需要的功耗代价也越高，和竞品机对比时也可以考虑平衡这个参数配置。</p><p>查看方法：<code>adb shell getevent -lrt</code>,最右侧的就是TP的报点率</p><p><img src="11.webp" alt="图片"></p><p>常见的报点率有这几个挡位：60hz  90hz  120hz  180hz  240hz  480hz，因为游戏场景对于触控体验的实时性要求比较高，所以游戏场景的TP报点率一般是480hz，非游戏场景下的TP报点率一般是120hz或者180hz，开启手势模式的待机场景下一般是90hz或者120hz。一般情况下为了避免卡顿丢帧，触摸屏的报点率都要高于当前屏幕的显示刷新率。</p><p>在有功耗板下可以测试TP不同报点率下的功耗数据，为整机功耗优化提供数据依据和支持。以120hzTP报点率下的功耗测试为例，也可以通过实测各路供电消耗的实际电流和厂商提供的典型值进行对比，检查不同报点率下的功耗数据是否符合要求。</p><table><colgroup><col width="105"><col width="105"><col width="105"><col width="105"><col width="105"><col width="105"><col width="105"><col width="105"></colgroup><tbody><tr height="34"><td colspan="8">触控功耗测试</td></tr><tr height="27"><td rowspan="2">电源</td><td rowspan="2">报点率</td><td rowspan="2">工作状态</td><td colspan="3">工作电流</td><td rowspan="2">实测</td><td rowspan="2">单位</td></tr><tr height="27"><td>Min</td><td>Typ</td><td>Max</td></tr><tr height="27"><td rowspan="3">AVDD</td><td rowspan="3">120Hz</td><td>Active</td><td><br></td><td><br></td><td><br></td><td><br></td><td>mA</td></tr><tr height="27"><td>Idle</td><td><br></td><td><br></td><td><br></td><td><br></td><td>mA</td></tr><tr height="27"><td>Sleep</td><td><br></td><td><br></td><td><br></td><td><br></td><td>uA</td></tr><tr height="27"><td rowspan="3">DVDD</td><td rowspan="3">120Hz</td><td>Active</td><td><br></td><td><br></td><td><br></td><td><br></td><td>mA</td></tr><tr height="27"><td>Idle</td><td><br></td><td><br></td><td><br></td><td><br></td><td>mA</td></tr><tr height="27"><td>Sleep</td><td><br></td><td><br></td><td><br></td><td><br></td><td>uA</td></tr><tr height="27"><td>*参考数据依据不同芯片类型变化</td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td><td><br></td></tr></tbody></table><h3 id="8-2-减少Active持续检测时长"><a href="#8-2-减少Active持续检测时长" class="headerlink" title="8.2 减少Active持续检测时长"></a>8.2 减少Active持续检测时长</h3><p>触摸屏的 Active 持续检测时长是指触摸屏不断地进行触摸检测的能力。这个时长取决于触摸屏的硬件和驱动程序的设计。对于在无触摸或者触摸状态下Active Mode切到Idle Mode的时间，不同触控IC厂商设置的都不太一样，需要兼顾效果体验和功耗，但是理论上TP从active状态恢复到idle状态的时间越快，器件耗电越低。</p><p>以遇到的功耗问题为例：开启手势唤醒功能后待机，长按屏幕测试一段时间的功耗，整机功耗要差于竞品机。</p><p>竞品机的active持续时长（2.5秒）如下图所示：</p><p><img src="12.webp" alt="图片"></p><p>对比机的active持续时长（5秒）如下图所示：</p><p><img src="13.webp" alt="图片"></p><p>解决方法：只修改了灭屏下触摸时TP从active恢复到idle的时间（5秒改成2.5秒），亮屏下体验效果优先还是保持5秒持续active检测时间。还有可以优化的部分是Active Mode下的工作电流。</p><h3 id="8-3-延长TP扫描周期"><a href="#8-3-延长TP扫描周期" class="headerlink" title="8.3 延长TP扫描周期"></a>8.3 延长TP扫描周期</h3><p>在待机休眠时，可以适当延长触摸屏的扫描周期，让触摸屏控制器减少扫描触摸输入的频率，可以节省待机功耗。</p><p>以遇到的功耗问题为例：开启手势唤醒功能后待机，测试一段时间的平均功耗，整机功耗要差于竞品机。</p><p>竞品机的扫描周期（1.5秒）如下图所示：</p><p><img src="14.webp" alt="图片"></p><p>对比机的扫描周期（1秒）如下图所示：</p><p><img src="15.webp" alt="图片"></p><p>解决方法：延长对比机的扫描周期，和竞品机保持一致，并同步评估效果体验影响。</p><h3 id="8-4-降低灵敏度"><a href="#8-4-降低灵敏度" class="headerlink" title="8.4 降低灵敏度"></a>8.4 降低灵敏度</h3><p><strong>初始化校准</strong></p><p>不同的温度、湿度及物理空间结构均会影响到电容传感器在闲置状态的基准值， 触控IC会在初始化的 200ms 内根据环境情况自动获得新的检测基准，完成触摸屏检测的初始化。</p><p><strong>自动温漂补偿</strong>  </p><p>温度、湿度或灰尘等环境因素的缓慢变化，也会影响到电容传感器在闲置状态的基准值。触控IC实时检测各点数据的变化，对历史数据进行统计分析，由此来修正检测基准。从而降低环境变化对触摸屏检测的影响。  </p><p>如果在触摸屏的灵敏度调节过程中，灵敏度设置的越高，TP越容易受到环境干扰。灭屏待机时容易受到微小环境干扰，触控IC做自校准导致功耗增加。</p><p>以遇到的功耗问题为例：在长待机功耗测试中，高概率出现周期为11ms左右，频率90hz左右，峰值为60mA的周期性波形，且波形持续存在，经过较长时间才会消失，目前看到最近一次波形35分钟左右会消失。该周期性波形抬高了长待机的平均电流，导致功耗增加。此时AP和子系统均正常休眠，功耗板复现问题从电流拆解来看该波形来自TP器件。</p><p>如下是待机进入异常的波形图</p><p><img src="16.webp" alt="图片"></p><p>解决方法：略微降低灵敏度值以及在进入Idle Mode前进行校准，避免待机休眠后触摸屏受到微小干扰后一直处于自校准状态。</p><h2 id="9-功耗debug方法"><a href="#9-功耗debug方法" class="headerlink" title="9. 功耗debug方法"></a>9. 功耗debug方法</h2><ol><li>通过分析电流波形图，检查当前TP的工作模式和状态</li><li>通过功耗拆解板对TP器件进行电流拆解</li><li>通过读取TP的状态寄存器信息来确认，TP是否处于正确的工作状态，这里主要包含了报点率、采样率等</li><li>可以通过WiFi adb的方式模拟触摸动作，进行问题拆解</li><li>待机场景下可以动态移除TP驱动，对比移除前后的波形和整机功耗来检查是否有功耗异常</li><li>检查GPIO配置是否合理，防止配置不当导致漏电</li></ol><h2 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10. 参考资料"></a>10. 参考资料</h2><ol><li><a href="https://wenku.baidu.com/view/70a45e43f524ccbff02184a4.html" target="_blank" rel="noopener">touch简介</a></li><li><a href="https://wenku.baidu.com/view/8aff98d233d4b14e85246872.html" target="_blank" rel="noopener">电阻式触摸屏工作原理</a></li><li><a href="https://wenku.baidu.com/view/0bb031ebd15abe23482f4d61.html" target="_blank" rel="noopener">电容式触摸屏原理</a></li><li><a href="https://blog.csdn.net/weixin_44904296/article/details/113371087" target="_blank" rel="noopener">Android Touch详解(1)工作原理_android触摸屏工作原理-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 温升与功耗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thermal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能打磨手记：记一段 Futex 机制的内核优化之旅</title>
      <link href="/2024/03/15/Futex%E6%9C%BA%E5%88%B6%E7%9A%84%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96/"/>
      <url>/2024/03/15/Futex%E6%9C%BA%E5%88%B6%E7%9A%84%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-futex简介"><a href="#1-futex简介" class="headerlink" title="1. futex简介"></a><strong>1. futex简介</strong></h1><p>Futex 是Fast Userspace muTexes的缩写，由 Linux 2.5.7开始引入。传统的SYSTEM V IPC机制需要系统调用进入内核态去操作某个内核对象，由内核来仲裁同步，事实上大部分情况下并没有资源竞争，此种情况下仍然进入内核态会显得很浪费，系统开销增加进而造成性能折扣，由此引入futex的概念。</p><p>futex是一种用户态和内核态混合机制，需要两个部分合作完成。在用户态，futex指的是一个原子变量，用来记录某种锁状态。需要持锁时，如果锁空闲则直接改变futex变量值，即表明持有该锁，不需要陷入内核。释放锁时，如果锁状态中没有线程等锁，则直接置锁状态为空闲，也无需陷入内核。</p><p>对于内核而言，futex是一个系统调用。当用户态出现锁竞争，线程需要休眠等待时，通过futex系统调用陷入内核并挂在wait queue中。当释放锁发现有线程在休眠等锁时，通过futex系统调用陷入内核去唤醒等锁的线程。</p><p>相比传统的SYSTEM V IPC机制，在无竞争时，用户态通过futex原子变量操作，替代内核对象操作，来提升性能。而绝大部分情况下，锁都是无竞争的，所以futex机制实现用户空间锁非常高效。</p><h2 id="1-1-用户态futex同步机制"><a href="#1-1-用户态futex同步机制" class="headerlink" title="1.1 用户态futex同步机制"></a>1.1 用户态futex同步机制</h2><p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex原子变量。其中以pthread_mutex的锁操作过程为例，state表示其持有和竞争状态，0为无人持锁，1为有人持锁但无人竞争，2为有人持锁且有竞争。</p><ol><li>当线程A准备lock持锁，发现state\=\=0，则直接通过CAS(Compare and Swap)原子操作将state=1，表示持有该锁就结束了lock过程，整个过程并不需要内核参与，非常高效；</li><li>当线程B到来准备lock持锁，发现state\=\=1，锁已经被别人持有，于是使state=2表示有竞争，然后通过futex_wait(&amp;state) 操作陷入内核，内核会根据用户空间地址&amp;state创建一个等待队列，然后将B加入到&amp;state的等待队列中，将B休眠；</li><li>当线程A退出临界区unlock释放该锁时，发现state\=\=2意识到有人竞争，会将state=0，然后通过futex_wake(&amp;state) 陷入内核来唤醒等待&amp;state的线程B。线程A返回用户空间继续执行，退出unlock流程；</li><li>线程B从futex等待队列中移除，并加入调度程序的就绪队列，等待调度。得到调度后返回用户空间重新判断state\=\=0，于是重复步骤1；</li></ol><h2 id="1-2-内核态futex系统调用"><a href="#1-2-内核态futex系统调用" class="headerlink" title="1.2 内核态futex系统调用"></a>1.2 内核态futex系统调用</h2><p>linux上提供了sys_futex系统调用，对进程竞争情况下的同步处理提供支持。其原型和系统调用号为如下，参数常用的就是三个。uaddr就是用户态下共享内存的地址，也就是用户态的futex变量地址。op存放着操作类型，最常用的是futex_wait和futex_wake。val表示要操作的线程个数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/futex.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line">int futex (int *uaddr, int op, int val, const struct timespec *timeout,int *uaddr2, int val3);</span><br><span class="line"><span class="comment">#define __NR_futex 240</span></span><br></pre></td></tr></table></figure><p>内核中futex内部采用了哈希表的数据结构，保存那些需要睡眠的任务。通过用户空间地址 uaddr，flag，以及 futex的读写状态可以计算出hash key值，将需要睡眠的任务的task_struct放到对应的哈希桶上的优先链表的节点中。</p><p><img src="1.png" alt=""></p><p>futex_wait(uaddr，val，abs_time) 流程：</p><ol><li>计算 futex 对应的 key，获取 key 对应的哈希表链表。</li><li>获取哈希桶链表自旋锁，如果 *uaddr == val 返回错误给用户态。</li><li>否则将当前任务状态改为 TASK_INTERRUPTIBLE，并将当前任务插入到 futex 等待队列，释放哈希桶链表自旋锁，然后调度器重新调度。</li><li>当该线程从睡眠中被唤醒时，例如超时或者被wakeup，做相应处理后，返回用户态。</li></ol><p>futex_wake(uaddr，nr_wake) 流程：</p><ol><li>计算 futex 对应的 key，获取 key 对应的哈希桶。</li><li>获取哈希桶的自旋锁，遍历这个哈希桶上的优先链表，找到key匹配的任务，说明该任务在等待 futex，将当前任务添加到唤醒队列 wake_q 中，如果达到了 nr_wake 个，则退出循环。</li><li>释放哈希桶自旋锁，唤醒队列 wake_q 中每一个任务。</li></ol><h1 id="2-futex在Android的应用"><a href="#2-futex在Android的应用" class="headerlink" title="2. futex在Android的应用"></a><strong>2. futex在Android的应用</strong></h1><p>下面是安卓系统中用户空间通用的同步机制框图，最终基本上都是基于 futex 系统调用来实现的。其中java部分同步机制，主要是由ART虚拟机实现的synchronize，和java.util.concurrent库实现的lock机制。C++部分主要是pthread库中实现的锁机制。</p><p><img src="2.png" alt=""></p><h2 id="2-1-ART锁"><a href="#2-1-ART锁" class="headerlink" title="2.1 ART锁"></a>2.1 ART锁</h2><p>Synchronize是java中的隐式锁，它的获取锁和释放锁都是隐式的，完全交由虚拟机实现。Synchronize生成的字节码会对应两条指令，分别是monitor-enter和monitor-exit。虚拟机锁一开始会通过CAS(Compare and swap)原子操作自旋，但是随着等锁时间增加，锁会不断升级，如果迟迟没有等到锁，最终升级为重量级锁，需要陷入内核休眠。</p><p><img src="3.png" alt=""></p><p>重量级锁最终会通过futex系统调用，由内核参与实现线程的挂起和唤醒。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Monitor::Lock(Thread* self) </span><br><span class="line">|--&gt;monitor_lock_.ExclusiveLock(self);   </span><br><span class="line">    |--&gt;futex(state_and_contenders_.Address(), FUTEX_WAIT_PRIVATE, cur_state,</span><br><span class="line">                      enable_monitor_timeout_ ? &amp;timeout_ts : nullptr , nullptr, 0)</span><br><span class="line"></span><br><span class="line">bool Monitor::Deflate(Thread* self, ObjPtr<span class="tag">&lt;<span class="name">mirror::Object</span>&gt;</span> obj) &#123;</span><br><span class="line">|--&gt;monitor-&gt;monitor_lock_.ExclusiveUnlock(self);</span><br><span class="line">    |--&gt;futex(state_.Address(), FUTEX_WAKE_PRIVATE, kWakeAll, nullptr, nullptr, 0);</span><br></pre></td></tr></table></figure><h2 id="2-2-JUC锁"><a href="#2-2-JUC锁" class="headerlink" title="2.2 JUC锁"></a>2.2 JUC锁</h2><p>java.util.concurrent包中提供的锁机制，称为JUC锁。相比Synchronize更加灵活，功能也更丰富，但是安全性也更低，需要开发者对JUC锁有足够的理解。根据功能分为下面几类</p><p><img src="4.png" alt=""></p><p><img src="5.jpg" alt=""></p><h2 id="2-3-pthread锁"><a href="#2-3-pthread锁" class="headerlink" title="2.3 pthread锁"></a>2.3 pthread锁</h2><p>pthread锁是native层提供的pthread库中的一部分，提供给native层代码使用，来实现各种同步机制。</p><h3 id="2-3-1-pthread-mutex"><a href="#2-3-1-pthread-mutex" class="headerlink" title="2.3.1 pthread_mutex"></a>2.3.1 pthread_mutex</h3><p>下面这段代码是pthread_mutex_lock核心部分，通过原子操作atomic_exchange_explicit，这个操作是将锁原子变量_Atomic(uint16_t) state替换为locked_contended，即置为处于竞争状态，并返回原本的state值。如果原本的锁状态不为unlocked即已经被人持有了，则调用__futex_wait_ex陷入内核休眠。如果原本锁状态就是unlocked，也就是没有人持有，则不休眠，也不需要内核参与。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">594      const uint16_t unlocked           = shared | MUTEX_STATE_BITS_UNLOCKED;</span><br><span class="line">595      const uint16_t locked_contended = shared | MUTEX_STATE_BITS_LOCKED_CONTENDED;</span><br><span class="line">605      while (atomic_exchange_explicit(&amp;mutex-&gt;state, locked_contended,</span><br><span class="line">606                                      memory_order_acquire) != unlocked) &#123;</span><br><span class="line">607          if (__futex_wait_ex(&amp;mutex-&gt;state, shared, locked_contended, use_realtime_clock,</span><br><span class="line">608                              abs_timeout_or_null) == -ETIMEDOUT) &#123;</span><br><span class="line">609              return ETIMEDOUT;</span><br><span class="line">610          &#125;</span><br><span class="line">611      &#125;</span><br></pre></td></tr></table></figure><p>同样pthread_mutex_unlock核心代码，首先通过原子操作将锁状态state置为unlocked，然后判断原本的锁状态state是否为竞争状态，如果是竞争状态则调用__futex_wake_ex陷入内核来唤醒一个等待该state变量的线程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">629      if (atomic_exchange_explicit(&amp;mutex-&gt;state, unlocked,</span><br><span class="line">630                                   memory_order_release) == locked_contended) &#123;</span><br><span class="line">658          __futex_wake_ex(&amp;mutex-&gt;state, shared, 1);</span><br><span class="line">659      &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-pthread-cond"><a href="#2-3-2-pthread-cond" class="headerlink" title="2.3.2 pthread_cond"></a>2.3.2 pthread_cond</h3><p>条件变量pthread_cond，2个典型操作wait和signal，等待和发射某个条件，对应的底层实现分别是futex_wait和futex_wake。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_wait(pthread_cond_t* cond_interface, pthread_mutex_t* mutex) &#123; </span><br><span class="line">    int status = __futex_wait_ex(&amp;cond-&gt;state, cond-&gt;process_shared(), old_state,</span><br><span class="line">                               use_realtime_clock, abs_timeout_or_null);</span><br><span class="line">&#125;</span><br><span class="line">int pthread_cond_signal(pthread_cond_t* cond_interface) &#123;</span><br><span class="line">  __futex_wake_ex(&amp;cond-&gt;state, cond-&gt;process_shared(), thread_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-pthread-rwlock"><a href="#2-3-3-pthread-rwlock" class="headerlink" title="2.3.3 pthread_rwlock"></a>2.3.3 pthread_rwlock</h3><p>  读写锁，加读锁或写锁时，如果遇到互斥情况，通过futex_wait陷入内核休眠等待。释放读写锁时，通过futex_wake陷入内核唤醒等锁线程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock_interface) &#123;</span><br><span class="line">      futex_result = __futex_wait_ex(&amp;rwlock-&gt;pending_writer_wakeup_serial, rwlock-&gt;pshared,</span><br><span class="line">                                     old_serial, use_realtime_clock, abs_timeout_or_null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __pthread_rwlock_timedrdlock(pthread_rwlock_internal_t* rwlock, bool use_realtime_clock,</span><br><span class="line">                                        const timespec* abs_timeout_or_null) &#123;</span><br><span class="line">      futex_result = __futex_wait_ex(&amp;rwlock-&gt;pending_reader_wakeup_serial, rwlock-&gt;pshared,</span><br><span class="line">                                     old_serial, use_realtime_clock, abs_timeout_or_null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int pthread_rwlock_unlock(pthread_rwlock_t* rwlock_interface) &#123;</span><br><span class="line">    __futex_wake_ex(&amp;rwlock-&gt;pending_writer_wakeup_serial, rwlock-&gt;pshared, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-内核社区的futex优化方案"><a href="#3-内核社区的futex优化方案" class="headerlink" title="3. 内核社区的futex优化方案"></a><strong>3. 内核社区的futex优化方案</strong></h1><p>谷歌通过增加内核futex_swap接口，实现用户态任务调度框架 SwitchTo，来提高两个线程唤醒+休眠的效率。并在此基础上实现direct-thread-switch功能，使被唤醒线程直接利用即将休眠的线程时间片运行，减少调度开销。优化主要是在线程协作的场景，例如IPC通信，client线程切换到特定的server线程，或者server线程切换回到client线程。</p><p>移动终端厂商利用futex传递Ux属性，使锁的owner线程继承Ux属性一段时间。具备Ux属性的线程在调度、io、内存等资源的竞争上更优先，owner线程执行更快，这样可以减少原Ux线程等待该futex的时间。</p><p>下面分5节分别介绍futex_swap、current_cpu，direct-thread-switch、futex vip优化思路，及实际调试验证结果。</p><h2 id="3-1-futex-swap"><a href="#3-1-futex-swap" class="headerlink" title="3.1 futex_swap"></a>3.1 <strong>futex_swap</strong></h2><p>在谷歌内部有一套闭源的用户态任务调度框架 SwitchTo，这个框架可以为谷歌提供延迟敏感的服务，对运行的内容进行细粒度的用户空间控制/调度，它可以让内核来实现上下文的切换，同时将任务何时切换，何时恢复的工作交给了用户态的程序来做，这样既可以实现在任务间协作式切换的功能，又可以不丧失内核对于任务的控制和观察能力。这是使用 SwitchTo 和使用其他线程间切换的组件的上下文切换性能对比，可以看到在使用 SwitchTo 后切换的性能比其他组件提高了一个数量级别。</p><p><img src="6.png" alt=""></p><p>谷歌工程师Peter Oskolkov <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x70;&#x6f;&#x73;&#107;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#x70;&#x6f;&#x73;&#107;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#46;&#99;&#111;&#x6d;</a>向 LKML（Linux Kernel Mail List） 提出的补丁中有关 futex_swap() 的实现。可以确定的是，SwitchTo 构建在这个futex_swap内核函数之上。futex_swap接口引出：[2] <a href="https://lore.kernel.org/lkml/48058b850de10f949f96b4f311adb649b1fb3ff2.camel@posk.io/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/48058b850de10f949f96b4f311adb649b1fb3ff2.camel@posk.io/</a></p><p>对于一些线程交互的场景，例如线程T1与线程T2协助完成一项任务，T1完成一个阶段任务后，需要移交给T2然后等待T2的结果，T2完成阶段任务后再移交给T1。常见的RPC通信一般都是这种交互模式，例如client唤醒server执行相应的任务，client自己休眠，然后server执行完成后唤醒client。用futex操作简化成下面的三个步骤。</p><blockquote><blockquote><p>a. T1: futex-wake T2, futex-wait<br>b. T2: wakes, does what it has been woken to do<br>c. T2: futex-wake T1, futex-wait</p></blockquote></blockquote><p>其中步骤a和c都有2次系统调用，如果有一个futex内核接口，能一次实现两个过程，即一个接口完成1个线程的唤醒和1个线程的休眠，将会带来一些的性能提升。</p><p><img src="7.png" alt=""></p><p>futex_swap(uaddr，val，abs_time，uaddr2) 流程：</p><ol><li>获得等待在 uaddr2 上的预备唤醒队列，记录队列第一个任务为 next，对其他任务则执行唤醒。</li><li>对 uaddr1 执行 futex_wait()，传入 next。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_swap</span><span class="params">(u32 __user *uaddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, u32 val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">ktime_t</span> *abs_time, u32 __user *uaddr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u32 <span class="built_in">bitset</span> = FUTEX_BITSET_MATCH_ANY;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        DEFINE_WAKE_Q(wake_q);</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = prepare_wake_q(uaddr2, flags, <span class="number">1</span>, <span class="built_in">bitset</span>, &amp;wake_q);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (!wake_q_empty(&amp;wake_q)) &#123;</span><br><span class="line">                <span class="comment">/* At most one wakee can be present. Pull it out. */</span></span><br><span class="line">                next = container_of(wake_q.first, struct task_struct, wake_q);</span><br><span class="line">                next-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> futex_wait(uaddr, flags, val, abs_time, <span class="built_in">bitset</span>, next);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futex_wait_queue_me</span><span class="params">(struct futex_hash_bucket *hb, struct futex_q *q,</span></span></span><br><span class="line"><span class="function"><span class="params">-                                struct hrtimer_sleeper *timeout)</span></span></span><br><span class="line">+                                struct hrtimer_sleeper *timeout,</span><br><span class="line">+                                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">+                <span class="keyword">if</span> (!timeout || timeout-&gt;task) &#123;</span><br><span class="line">+                        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">+                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">+                                 * wake_up_process() below will be replaced</span></span><br><span class="line"><span class="comment">+                                 * in the next patch with</span></span><br><span class="line"><span class="comment">+                                 * wake_up_process_prefer_current_cpu().</span></span><br><span class="line"><span class="comment">+                                 */</span></span><br><span class="line">+                                wake_up_process(next);</span><br><span class="line">+                                put_task_struct(next);</span><br><span class="line">+                                next = <span class="literal">NULL</span>;</span><br><span class="line">+                        &#125;</span><br><span class="line">                         freezable_schedule();</span><br><span class="line">+                &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>移植到Android平台后，实际测试数据结果futex_swap较FUTEX_WAKE_WAIT相差不大，与社区的提升29.5%有一定出入，不知是不是有什么前置条件。</p><p><img src="8.png" alt=""></p><p>为了究其原因，从耗时角度对两种运行模式进行拆解，得到下面的流程图。在多核情况下，T1和T2线程会分别在不同cpu上运行。</p><p><img src="9.png" alt=""></p><p><img src="10.png" alt=""></p><p>从整体上对比分析，FUTEX_SWAP相比FUTEX_WAKE_WAIT，虽然少了2次syscall的耗时，但是这2次都是在并行的时间里完成的，并不影响测试用例链路耗时，仅仅是减少了系统的整体负载损耗。经过抽离简化，2种模式下的执行耗时其实都是下面这样，并没有多大差异，所以耗时相同也符合预期。</p><p><img src="11.png" alt=""></p><p>虽然futex_swap操作并没有能减少2个线程切换的耗时，但是成功将futex_wake+futex_wait操作融合为一个系统调用，为后续的深度优化提供了可能。</p><h2 id="3-2-wake-up-process-prefer-current-cpu"><a href="#3-2-wake-up-process-prefer-current-cpu" class="headerlink" title="3.2 wake_up_process_prefer_current_cpu"></a>3.2 <strong>wake_up_process_prefer_current_cpu</strong></h2><p>谷歌工程师 Peter Oskolkov的优化patch[3] ，<a href="https://lore.kernel.org/lkml/d5cf58486a6a5e41581bed9183e8a831908ede0b.camel@posk.io/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/d5cf58486a6a5e41581bed9183e8a831908ede0b.camel@posk.io/</a></p><p>在T1通过futex_swap操作唤醒T2并休眠自己时，优先将T2选核到T1的cpu上。</p><p><img src="12.png" alt=""></p><p>优化patch比较简单，在try_to_wake_up时传入自定义的WF_CURRENT_CPU标志位，在select_task_rq_fair选核时，判断如果有该标志位就将T2的cpu选到当前T1的cpu。这样T1 通过schedule()调度出去时，在next = pick_next_task(rq, prev, &amp;rf)中，极大概率可以直接选中T2，进行无缝切换。同理T2切换到T1时也是如此。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/futex.c b/kernel/futex.c</span><br><span class="line">index f3833190886f..a426671e4bbb <span class="number">100644</span></span><br><span class="line">--- a/kernel/futex.c</span><br><span class="line">+++ b/kernel/futex.c</span><br><span class="line">@@ <span class="number">-2646</span>,<span class="number">12</span> +<span class="number">2646</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futex_wait_queue_me</span><span class="params">(struct futex_hash_bucket *hb, struct futex_q *q,</span></span></span><br><span class="line"><span class="function"><span class="params">                  */</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">if</span> (!timeout || timeout-&gt;task) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">if</span> (next) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">-                                wake_up_process(next);</span></span></span><br><span class="line"><span class="function"><span class="params">+                                wake_up_process_prefer_current_cpu(next);</span></span></span><br><span class="line"><span class="function"><span class="params">                                 put_task_struct(next);</span></span></span><br><span class="line"><span class="function"><span class="params">                                 next = <span class="literal">NULL</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">                         &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span></span></span><br><span class="line"><span class="function"><span class="params">index <span class="number">9</span>a2fbf98fd6f..f894b3e6c9ed <span class="number">100644</span></span></span></span><br><span class="line"><span class="function"><span class="params">--- a/kernel/sched/core.c</span></span></span><br><span class="line"><span class="function"><span class="params">+++ b/kernel/sched/core.c</span></span></span><br><span class="line"><span class="function"><span class="params">@@ <span class="number">-6180</span>,<span class="number">6</span> +<span class="number">6180</span>,<span class="number">11</span> @@ <span class="keyword">void</span> sched_setnuma(struct task_struct *p, <span class="keyword">int</span> nid)</span></span></span><br><span class="line"><span class="function"><span class="params"> &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> #endif <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">+<span class="keyword">int</span> wake_up_process_prefer_current_cpu(struct task_struct *next)</span></span></span><br><span class="line"><span class="function"><span class="params">+&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+        <span class="keyword">return</span> try_to_wake_up(next, TASK_NORMAL, WF_CURRENT_CPU);</span></span></span><br><span class="line"><span class="function"><span class="params">+&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">+</span></span></span><br><span class="line"><span class="function"><span class="params"> #ifdef CONFIG_HOTPLUG_CPU</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span></span></span><br><span class="line"><span class="function"><span class="params">index <span class="number">538b</span>a5d94e99.<span class="number">.80</span>f927bb62eb <span class="number">100644</span></span></span></span><br><span class="line"><span class="function"><span class="params">--- a/kernel/sched/fair.c</span></span></span><br><span class="line"><span class="function"><span class="params">+++ b/kernel/sched/fair.c</span></span></span><br><span class="line"><span class="function"><span class="params">@@ <span class="number">-6656</span>,<span class="number">6</span> +<span class="number">6656</span>,<span class="number">9</span> @@ select_task_rq_fair(struct task_struct *p, <span class="keyword">int</span> prev_cpu, <span class="keyword">int</span> sd_flag, <span class="keyword">int</span> wake_f</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> want_affine = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> sync = (wake_flags &amp; WF_SYNC) &amp;&amp; !(current-&gt;flags &amp; PF_EXITING);</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">+        <span class="keyword">if</span> ((wake_flags &amp; WF_CURRENT_CPU) &amp;&amp; cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span></span></span><br><span class="line"><span class="function"><span class="params">+                <span class="keyword">return</span> cpu;</span></span></span><br><span class="line"><span class="function"><span class="params">+</span></span></span><br></pre></td></tr></table></figure><p>通过实测数据，经过current_cpu优化后的FUTEX_SWAP执行耗时降低92.69%，令人惊讶。</p><p><img src="13.png" alt=""></p><p>通过trace分析，截取2种测试模式运行时三次切换的片段，FUTEX_WAKE_WAIT时2个线程在不同cpu上来回切换，cpu实际频率只有500MHz，因为负载分配在2个cpu上，每个cpu的占用率不到50%。current_cpu优化后的FUTEX_SWAP时，2个线程跑在同一个cpu上，实际cpu频率有2.5GHz，因为负载集中在1个cpu上，cpu的占用率接近100%，所以频率自动调的也高。虽然速度提升10倍，但是其中有5倍是cpu频率影响。</p><p>FUTEX_WAKE_WAIT模式：3轮切换耗时182us</p><p><img src="14.png" alt=""></p><p>FUTEX_SWAP模式：3轮切换耗时18.4us</p><p><img src="15.png" alt=""></p><p>综上分析，执行时间降低10倍原因:</p><ol><li>cpu频率高5倍：跑在单核上，cpu利用率高，更有效触发提频</li><li>调度效率高2倍：同一个cpu，无缝切换，避免从idle退出的耗时，调度尾延更低，同时cache命中率更高。</li></ol><p>所以从patch优化效率上来看，实际优化了2倍。在Android上，binder作为主要的IPC通信手段，运行场景跟这很类似，一个binder线程A唤醒另一个binder线程B，线程B执行完任务后反过来唤醒线程A，2个线程交替执行。如果把这里的current_cpu优化放在binder上，或许也有一定的优化效果。</p><h2 id="3-3-direct-thread-switch"><a href="#3-3-direct-thread-switch" class="headerlink" title="3.3 direct-thread-switch"></a>3.3 <strong>direct-thread-switch</strong></h2><p>脱离 Android 的全自研鸿蒙 next 宣称支持轻量级线程并发模型，可能就是 direct-thread-switch，已合入服务器欧拉操作系统。</p><p><img src="16.png" alt=""></p><p>本节内容引自华为欧拉操作系统论坛：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在操作系统中，线程是一个独立的运行单元，一般认为每个线程是独立运行的；但是在实际应用中，经常出现一个业务功能需要多个线程协同处理，这时候线程和线程之间存在逻辑上的关联关系，经常出现线程之间的唤醒与被唤醒。线程的每次“交互”需要内核调度模块参与，一次完整的交互，内核调度模块需要参与选核，入队列，更新负载信息，选任务等流程。系统中如果线程比较多（有数千个线程）,线程负载比较小的场景下，会导致内核调度开销比较大，而且线程之间交互的效率比较低（线程B需要入队列，等待CPU资源，导致runable的时间比较长）。在《The Case <span class="keyword">for</span> Thread Migration- Predictable IPC in a Customizable <span class="keyword">and</span> Reliable OS》这篇论文中讲述了一种新的线程切换思路：执行实体与调度实体分离。在同步IPC场景中，线程之间发生切换，只切换执行实体不切换调度实体，从而提升IPC的通信效率，降低调度开销。通过测试，这种技术可以使得同步IPC的效率提升近<span class="number">10</span>倍。 引用</span><br><span class="line">执行实体与调度实体分离的技术适用于微内核架构，在linux系统中并不适用，主要因为linux系统在设计之初就将执行实体与调度实体融合成一个结构体：task_struct, 经过多年的开发，task_struct结构体已经散布到linux内核的各个模块中，此时拆分执行实体和调度实体，工作量大，难度高，质量难以保障。 我们可以重新审视执行实体和调度实体分离的技术原理，在线程交互时，切换执行实体而不切换调度实体，本质上是利用了原任务的剩余时间片来运行新任务，bypass调度，降低了内核调度开销，同时原任务直接切换到新任务时，新任务不用重新入队列等待CPU资源，这时没有尾时延（runnable时间），大大提升线程交互的效率。这种往往用在同步线程模型中（原任务进入休眠，新任务执行）。</span><br></pre></td></tr></table></figure><p>将原任务直接切换到新任务，bypass调度的技术命名为direct-thread-switch，bypass调度的前提必须是利用原任务的剩余时间片，否则会打破CFS调度的公平性。具体由briansun <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#105;&#109;&#98;&#114;&#x69;&#97;&#110;&#x73;&#x75;&#x6e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#105;&#109;&#98;&#114;&#x69;&#97;&#110;&#x73;&#x75;&#x6e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a>提交到华为欧拉操作系统论坛上实现的patch</p><p><a href="https://gitee.com/openeuler/kernel/commit/dad99a5750c4c942300c6626888a6ad52e62bf24" target="_blank" rel="noopener">https://gitee.com/openeuler/kernel/commit/dad99a5750c4c942300c6626888a6ad52e62bf24</a></p><p>从patch的描述看，direct-thread-switch是在futex_swap的基础上实现的，是对futex_swap的进一步优化。futex_swap将futex_wake+futex_wait融合到一次系统调用，实现线程T2的唤醒和线程T1的休眠，涉及2次调度。而direct-thread-switch则是在此基础上，bypass调度，直接利用线程T1的剩余时间片来运行线程T2，避免了2次调度的开销。由于是基于futex_swap，所以使用场景也同样有限制，典型的场景是IPC通信，线程模型为T1-&gt;T2—-T2-&gt;T1。</p><p>direct-thread-switch代码实现很复杂，目前也只理解了很少一部分。在原有futex_swap基础上，在T1-&gt;T2线程切换时另起炉灶，替代了原有的schedule()函数，以__direct_thread_switch(next)函数直接从T1切换到T2。并提出共享调度实体shared sched_entry的概念，来保证CFS调度的公平性及调度器稳定性。</p><p>futex_swap：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+                                <span class="keyword">if</span> (flags &amp; FUTEX_FLAGS_DTS_MODE)</span><br><span class="line">+                                       do_dts_switch = direct_thread_switch(next);</span><br></pre></td></tr></table></figure><p>由于内核版本差异等因素，该patch并未移植成功，无法实际测试效果，借用openEuler内核社区测试了(futex_wake+futex_wait)、futex_swap、(futex_swap+direct-thread-switch)的切换耗时，futex_swap相比(futex_wake+futex_wait)提升了29.5%，(futex_swap+direct-thread-switch)相比(futex_wake+futex_wait)提升了37.1%</p><p><img src="17.png" alt=""></p><h2 id="3-4-futex-vip插队优化"><a href="#3-4-futex-vip插队优化" class="headerlink" title="3.4 futex vip插队优化"></a>3.4 <strong>futex vip插队优化</strong></h2><p>目前已有的针对锁的优化特性都是针对内核锁，用户空间锁则不在这些优化范围内，两者有共性。</p><p>如果某个用户锁有大量线程并发竞争在等待，等锁造成的响应延迟将非常大。对于用户体验相关的前台vip线程来说非常不友好，需要适当向vip线程倾斜。线程B被加入futex等待队列，这个队列排序原则是RT线程按照其线程优先级0~99来排序，普通线程全部按照优先级100，然后FIFO先进先出原则排序。用户体验相关的vip线程很多是普通线程，所以在这里排队没有优势，需要改变规则，将vip线程排在普通线程之前，RT线程之后。</p><p><img src="18.png" alt=""></p><p>通过测试用例，创建一个持锁线程A(demo 10622)，然后创建9个普通线程B和一个vip线程C(demo 10630)。线程A先持mutex锁，9个普通线程B等锁，线程C等锁，然后通过命令将线程C设置为vip线程。</p><p>当线程A释放锁时，可以看到vip线程C最先被唤醒，即使是最后一个入队也最先被唤醒，其他普通线程则是按照等锁入队FIFO顺序唤醒。所以vip线程的等锁时间也是最短的</p><p><img src="19.png" alt=""></p><p>为了防止普通线程饿死，还采取了规避措施，如果队列中第一个普通线程等待时间已经超过一定时间，则本次不做vip插队操作。可以看到，当vip线程 12446在等锁入队时，前面其他线程等锁时间超过347.2ms，所以本次不插队，vip线程按照入队顺序出队。</p><p><img src="20.png" alt=""></p><h2 id="3-5-futex-vip继承优化"><a href="#3-5-futex-vip继承优化" class="headerlink" title="3.5 futex vip继承优化"></a>3.5 <strong>futex vip继承优化</strong></h2><p>在 vip_task 特性中，vip线程享有CFS优先调度、内核锁插队、内存快速分配，binder 优先与继承等优势，vip线程在等普通线程持有的用户空间锁时，普通线程没有相应的资源倾斜，可能导致其在临界区运行很慢，造成”优先级”翻转，vip线程的优势也得不到发挥。参考进程优先级继承的优化思路，vip线程在等用户锁时，临时赋予non-vip线程vip特权一段时间，让其尽快执行脱离临界区，最大程度减少vip线程的等待时延。</p><p><img src="21.png" alt=""></p><p>futex vip继承在内核实现上，有一些需要解决的问题，即vip线程在等futex锁时，需要知道持锁的线程holder是谁，才能针对持锁线程做boost。不同于内核中的mutex，现有基于futex实现的接口，并没有包含锁owner信息，所以需要对用户空间中相关接口做调整。</p><p>对于native的pthread_mutex锁，在调用futex_wait时增加一个参数用来传递futex_info信息，其中就包括owner_id。</p><p>内核实现，首先判断等锁线程是不是vip线程，如果是vip则解析其owner_id参数，找到owner task并对其赋予临时的vip特权，直到该owner通过futex_wake来唤醒等待的vip线程，解除vip特权。</p><h1 id="4-futex-vip收益测试"><a href="#4-futex-vip收益测试" class="headerlink" title="4. futex vip收益测试"></a><strong>4. futex vip收益测试</strong></h1><p>由于3.1-3.3节的优化依赖于上层的具体应用场景来实现，在安卓上并未找到合适的软件场景，所以没有做过多收益测试。3.4，3.5节契合安卓手机场景，我们分别模拟用户使用场景测试做了实测数据，测得对比数据。</p><p>正常使用场景，vip等futex的最大等待时间减少70%，超过100ms的次数减少25%，vip线程等futex总时间减少24%。</p><p>重载使用场景，vip等futex的最大等待时间减少67%，超过100ms的次数减少38%，超过200ms次数减少45%，vip线程等futex总时间减少21%。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h1><p>本文首先介绍了linux的futex系统调用，及基于futex的同步机制。然后列举了futex在Android上的几种应用，包括ART锁、JUC锁、pthread锁。</p><p>介绍了几种futex性能优化相关的开源案例，其中futex_swap(包含current_cpu)优化和direct-thread-switch优化，线程切换性能分别提升了29.5%和37.1%。futex vip插队及属性继承优化，最大程度保证用户交互线程的响应速度。</p><p>最后futex vip插队及属性继承优化，实际模拟用户场景测试收益，取得不错的收益。改善优先级翻转和锁等待的性能延时问题，提高前台应用响应速度，降低偶现卡顿的机率。</p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机温控中枢：高通 Thermal Engine 框架分析</title>
      <link href="/2024/01/12/Qcom-Thermal-Engine-frame-analysis/"/>
      <url>/2024/01/12/Qcom-Thermal-Engine-frame-analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>在当前移动处理芯片性能过剩的时代，用户对手机的温度要求越来越高，更加苛刻的标准，最好永不发热。在这种背景下，温控领域的工作变得日益重要，众多大厂都在不断魔改和优化他们的温控技术。今天我们也带大家看看温控技术的其中一部分：Thermal Engine。下面，我们将基于 GitHub 上的源代码，对 Thermal Engine 的工作原理进行深入剖析。</p><p>Thermal Engine是高通开发的用于温升控制的native层应用，它是一个守护进程，开机后将由init进程启动，最初在MSM8660 平台引入。Thermal Engine作为高通平台用户空间温控的处理中枢，会根据温度变化，按照预先设定的算法，来调整硬件的工作行为或强度级别，从而达到节能降温的目的。Thermal Engine也提供了对外交互的接口，用于与其它应用或服务进行通信，应用或服务可以通过socket向Thermal Engine注册温控发生时的回调处理，也可以通过socket动态修改温控配置。</p><h1 id="2-总体架构"><a href="#2-总体架构" class="headerlink" title="2. 总体架构"></a>2. 总体架构</h1><p>为了更好的说明Thermal Engine的架构，我们先要了解下Thermal Engine在整个温控架构的位置。</p><p><img src="1.PNG" alt=""></p><p>整个温控架构可以划分为硬件层/kernel层/Native层/System层/App层，如图可见Thermal Engine主要是基于Linux kernel的thermal子系统而构建，它通过socket监听Thermal core上报的温度信息，并通过sysfs完成对温控设备的控温操作。同时其它服务或应用也可以通过socket来与Thermal Engine通信，这主要包含两种情况：一种情况是其它服务向Thermal Engine注册了温度触发回调；另一种情况则是其它服务通过socket对Thermal Engine进行动态配置，修改温控参数，如触发阈值/行为主体/行为主体限制值等。</p><p>下面我们具体看下Thermal Engine的主体架构：</p><p><img src="2.PNG" alt=""></p><p>源码文件位于：vendor/qcom/proprietary/thermal-Engine</p><p>Thermal Engine作为用户空间温控的核心，主要负责对对thermal sensors, thermal algorithms, thermal cooling devices的管理，这些thermal sensors和cooling devices一般来自于对thermal core相关sysfs文件节点的解析；同时thermal Engine也管理着一组温控算法，它根据输入的温度等级，来做出不同的控温操作；thermal Engine支持socket通信，thermal-Engine作为服务端，client可以通过向thermal-Engine注册不同的回调函数，当触发温控时，就可以通过这些回调通知client，或执行相应的回调操作。Thermal Engine的典型目标就是将芯片的目标温度限制在85度~95度以内的范围，金属壳温限制在40度左右，塑料壳温限制在40~45度左右</p><ul><li><p>Thermal sensors：主要来源于内核thermal core创建的thermal zone文件节点，代表各路温度传感器。这些温度包含了SOC内部的Tj温度和位于PCB板的NTC温度，值得一提的是，Thermal Engine的传感器概念已经被泛化，除了监测温度，还监控功率、电流、电压和流量等这些类温度的指标。thermal sensor主要通过uevent接收来自内核thermal core的温度上报，唤醒sensor的线程，再由sensor线程唤醒关联的thermal algorithm线程</p></li><li><p>Thermal cooling devices：主要来源于内核thermal core创建的thermal cooling devices文件节点，可实现对各个cooling device的功率等级控制。</p></li><li><p>Thermal Algorithms：会将thermal sensors和thermal cooling devices联系起来，管理着触发温度/解除触发温度/主体行为/主体行为等级等。它是整个thermal Engine的核心，每个Thermal Algorithm都有一个线程，它被thermal sensor线程唤醒后，根据预设的触发/解除触发温度阈值，对关联的cooling devices进行功率等级控制。目前Algorithms包含了很多种：monitor, ss, pid, virtual sensor等</p></li><li><p>Thermal config：主要用于加载并解析温控配置文件，它会解析温控配置文件中的每一个section(参考温控配置示例一节)，根据section中设定的温控算法，下发给对应的Thermal algorithm</p></li><li><p>Thermal util netlink：主要用于监听内核thermal subsystem上报的uevent事件，这些事件往往是达到了温控的触发点</p></li><li><p>Thermal server：作为socket服务端主要用于接收Service/App发起的请求，这些请求包含对温控配置的查询和更新；client端可以预先向server端注册回调，发生温控时Thermal server会通知给注册的客户端，执行其注册的回调</p></li><li><p>Thermal client：是Thermal Engine对外封装的动态库，主要用于其它Services或App向Thermal server发起请求或接收数据</p></li></ul><h1 id="3-高通温控算法介绍"><a href="#3-高通温控算法介绍" class="headerlink" title="3. 高通温控算法介绍"></a>3. 高通温控算法介绍</h1><h2 id="ss算法"><a href="#ss算法" class="headerlink" title="ss算法"></a>ss算法</h2><p>通过设定一个单个温度作为控温的目标，这个算法会通过动态的对特定的硬件进行降温来维持温度值，如对CPU降频。这个算法适合于PCB温度和SOC片内温度的调节</p><h2 id="monitor算法"><a href="#monitor算法" class="headerlink" title="monitor算法"></a>monitor算法</h2><p>monitor算法会根据温度设定多个阈值，针对每个阈值设定特定的控温操作，适合于LCD, MODEM</p><h2 id="pid算法"><a href="#pid算法" class="headerlink" title="pid算法"></a>pid算法</h2><p>PID 算法基于反馈控制原理，通过不断地调整输出信号来使系统的实际温度尽可能接近目标温度。它由三个组成部分组成：</p><p>比例项（Proportional）：根据实际温度与目标温度之间的差异，产生一个与差异成比例的输出。比例项的作用是使系统快速响应温度变化，但可能会导致温度在目标值附近产生偏差。</p><p>积分项（Integral）：根据时间和温度差异的累积量，产生一个用于消除稳态误差的输出。积分项的作用是消除温度稳态下的偏差，使实际温度更接近目标温度。</p><p>微分项（Derivative）：根据温度变化速率的变化率，产生一个用于抑制温度变化速度的输出。微分项的作用是减小温度的震荡和过冲，提高系统的稳定性。</p><p>计算公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output = Kp * Error + Ki * Integral(Error) + Kd * Derivative(Error)</span><br></pre></td></tr></table></figure><p>其中，<code>Kp</code>、<code>Ki</code> 和 <code>Kd</code> 是控制参数，用于调节比例项、积分项和微分项的影响程度。<code>Error</code> 是实际温度与目标温度之间的差异</p><h2 id="virtual算法"><a href="#virtual算法" class="headerlink" title="virtual算法"></a>virtual算法</h2><p>virtual算法就是对一组传感器的运用，这一组传感器被抽象为一个虚拟传感器，虚拟传感器主要用作两种功能使用：</p><ul><li><p>一种功能是用作多传感器触发，就是检查这一组传感器中的每一个传感器是否达到触发阈值，根据设定的逻辑关系 “或” “与” 来决定是否触发温控；</p></li><li><p>另一种是用作算法传感器，支持多种算法，也就是对组内的每个传感器温度值，经过某算法处理（如加权拟合）得到一个处理后的温度值，以此温度值作为触发温控的温度</p></li></ul><h1 id="4-Thermal-Engine-全景图"><a href="#4-Thermal-Engine-全景图" class="headerlink" title="4. Thermal Engine 全景图"></a>4. Thermal Engine 全景图</h1><p><img src="3.png" alt=""></p><blockquote><p>如上框图主要以monitor算法为例进行说明</p></blockquote><p>从前面的介绍，我们了解到Thermal Engine主要分为3个部分，sensor部分主要对各种传感器的管理；cooling device部分主要是对降温设备的管理；algorithm部分主要是提供的各种算法的管理，典型算法：monitor、ss、pid等。Thermal Engine的温控策略主要来自于各个温控配置文件，以及内嵌的温控配置，这些配置以setting section作为一个温控配置单元。温控配置文件和内嵌配置中包含了多个setting section，这里主要以monitor算法为例，展开介绍Thermal Engine各个组件的功能。</p><p>如下是一个温控配置的setting section举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[MONITOR-THERM-GOLD]</span><br><span class="line">algo_type monitor</span><br><span class="line">sampling 500 </span><br><span class="line">sensor skin-msm-therm</span><br><span class="line">thresholds 43500</span><br><span class="line">thresholds_clr  43000</span><br><span class="line">actions  cpu0+cpu3+cpu7</span><br><span class="line">action_info  1555200+1920000+1132800</span><br></pre></td></tr></table></figure><ul><li><strong>tm_instance_info</strong></li></ul><p>每个setting section都只会创建一个对应的实例，依据不同的算法，创建的实例也不同，如上示例中采用thermal monitor算法，会创建tm_instance_info实例，tm_instance_info代表一个thermal monitor算法的实例。tm_instance_info有两个比较关键的成员：ts_client和dev_client_list。首先来说ts_client，ts_client是一个struct sensor_client_type *指针，主要指明了这个tm_instance_info与哪个sensor关联，从图上可以看到每个tm_instance_info只有一个sensor关联，当然这个sensor可能是virture sensor（多个传感器通过权重拟合）。而这个ts_client也会加入到一个链表，因为对于每个sensor来说，有很多个算法实例会使用到它，这个链表就是方便记录本sensor被哪些实例所使用，ts_client会关联到这个sensor；</p><p>再看另一个成员dev_client_list，它是一个指针数组，主要与具体的cooling设备关联，也就是tm_instance_info会对哪些降温设备进行操作，每个device_clnt_handle就是一个device_clnt指针，与一个devices_manager_dev的device_clnt关联，而devices_manager_dev就是实现对降温设备管理的结构体，目前对每个tm_instance_info实例只支持最多16个设备进行控温</p><ul><li><strong>settings_info</strong></li></ul><p>tm_instance_info实例的信息实际是通过settings_info来记录的,，settings_info中记录了具体的算法、触发sense、触发阈值、发生温控时对哪个设备进行温控操作、执行的操作值actions_info是多少，所有的settings_info组成一个全局链表thermal_setting_t</p><ul><li><strong>sensors_mgr_sensor_info</strong></li></ul><p>sensors_mgr_sensor_info实现对sensor的管理，每个sensor对应一个sensors_mgr_sensor_info，它会链接到全局链表sensor_list</p><ul><li><strong>devices_manager_dev</strong></li></ul><p>devices_manager_dev实现对cooling device的管理，每个cooling device对应一个devices_manager_dev，它会链接到全局链表dev_list, 每个cooling device也会分很多等级，用device_lvl_info来管理。devices_manager_dev在初始化时也会创建device_clnt，所有的device_clnt会链接为一个链表，tm_instance_info的dev_clnt_list数组引用的就是device_clnt链表中的成员。</p><h1 id="5-初始化流程"><a href="#5-初始化流程" class="headerlink" title="5. 初始化流程"></a>5. 初始化流程</h1><p><img src="4.png" alt=""></p><p>当thermal-Engine守护进程运行后，主要完成sensor初始化、cooling device初始化以及各种算法（以monitor为例）的初始化。</p><p>具体包含如下：</p><ol><li>parse_commandline：解析命令行参数</li><li>get_thermal_zone_info：遍历获取所有的sensor信息，保存在全局thermal_zone_info数组中</li><li><strong>devices_init：对所有cooling devcie进行初始化</strong></li><li><strong>sensors_init：对所有的sensor进行初始化</strong></li><li>配置项分为内嵌配置section和配置文件，此处是解析各算法内嵌的配置section，解析所有的配置section保存在全局thermal_settings中</li><li>load_config：解析配置文件的配置section，并保存到全局thermal_settings</li><li>thermal_server_init：thermal_Engine需要接收thermal core上报的sensor信息，也接收其它app或服务的交互信息，此处进行socket相关设置</li><li><strong>对各算法进行初始化，创建每个算法的实例，这个实例会将device和sensor联系起来。每个算法都对应一个线程，启动这个线程</strong></li></ol><p>下面会分别说明上述各个初始化的流程</p><h2 id="5-1-devices-init"><a href="#5-1-devices-init" class="headerlink" title="5.1 devices_init"></a>5.1 devices_init</h2><p>devices_init是对所有cooling devcie进行初始化，Thermal Engine全景图章节的cooling device部分就是通过devcies_init来构建出来的，核心工作包括：</p><ul><li><p>为每个cooling device创建devices_manager_dev</p></li><li><p>初始化devices_manager_dev；</p></li><li><p>为每个devices_manager_dev创建一个client</p></li></ul><p><img src="5.png" alt=""></p><p>具体将cooling device进行了如下类别的划分：</p><ol><li><p>gpu设备初始化<br>主要通过gpufreq_init获取频率表，通过tmd_init_gpu_devs为每个gpu创建devices_manager_dev，并初始化后链入全局dev_list，同时也会为每个gpu会创建一个client</p></li><li><p>cpu设备初始化<br>tmd_init_cpu_devs初始化每个cpu的频率，并为每个cpu创建devices_manager_dev，初始化并炼入全局dev_list，为每个cpu会创建一个client；为每个cpuplug设备创建devices_manager_dev，初始化创建的devices_manager_dev，并炼入全局dev_list，为每个cpuplug device会创建一个client</p></li><li><p>QMI远程设备初始化<br>qmi_communication_init为每个远程client创建线程，用于与远程QMI服务通信，这些远程设备包含了modem、adsp、cdsp等</p></li><li><p>通用设备初始化<br>通用设备是一些通用的降温设备，也可能是一些抽象的设备，不对应具体的硬件，高通给出的通用设备包含了：shutdown, none, report, report_rule, camera, camcorder, lcd等，init_generic_devs为每个通用设备创建devices_manager_dev，初始化创建的devices_manager_dev，并炼入全局dev_list</p></li><li><p>Thermal Engine的tmd设备<br>这里主要添加了除前述4种设备之外的cooling device，从打印上看主要包含了如下的cooling devcie.<br>这里需要注意的是，这些cooling device要排除thermal core中已经使用的cooling device，thermal Engine如果要使用thermal core已经使用的cooling device，需要为cooling device创建不同名的cooling device。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Added cooling device: battery <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">41</span></span><br><span class="line">Added cooling device: mmw2_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">58</span></span><br><span class="line">Added cooling device: sdr0_nr_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">48</span></span><br><span class="line">Added cooling device: ufs <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">28</span></span><br><span class="line">Added cooling device: mmw0_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">56</span></span><br><span class="line">Added cooling device: pause-cpu6 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">18</span></span><br><span class="line">Added cooling device: sdr0_lte_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">46</span></span><br><span class="line">Added cooling device: pause-cpu3 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">6</span></span><br><span class="line">Added cooling device: pa_nr_sdr0_scg_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">54</span></span><br><span class="line">Added cooling device: modem_bw_backoff <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">62</span></span><br><span class="line">Added cooling device: pa_nr_sdr0_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">52</span></span><br><span class="line">Added cooling device: modem_vdd <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">42</span></span><br><span class="line">Added cooling device: mmw_ific_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">60</span></span><br><span class="line">Added cooling device: pa_lte_sdr0_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">50</span></span><br><span class="line">Added cooling device: pause-cpu7 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">12</span></span><br><span class="line">Added cooling device: wsa <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">40</span></span><br><span class="line">Added cooling device: mmw3_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">59</span></span><br><span class="line">Added cooling device: cpufreq-cpu0 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">0</span></span><br><span class="line">Added cooling device: sdr1_nr_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">49</span></span><br><span class="line">Added cooling device: pause-cpu5 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">9</span></span><br><span class="line">Added cooling device: thermal-cluster<span class="number">-3</span><span class="number">-7</span> <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">29</span></span><br><span class="line">Added cooling device: mmw1_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">57</span></span><br><span class="line">Added cooling device: sdr1_lte_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">47</span></span><br><span class="line">Added cooling device: panel0-backlight <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">37</span></span><br><span class="line">Added cooling device: pause-cpu2 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">7</span></span><br><span class="line">Added cooling device: pa_nr_sdr1_scg_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">55</span></span><br><span class="line">Added cooling device: pause-cpu4 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">5</span></span><br><span class="line">Added cooling device: pa_nr_sdr1_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">53</span></span><br><span class="line">Added cooling device: wlan <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">61</span></span><br><span class="line">Added cooling device: pause-cpu1 <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">3</span></span><br><span class="line">Added cooling device: pa_lte_sdr1_dsc <span class="keyword">with</span> cdev <span class="keyword">id</span>:<span class="number">51</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="5-2-sensors-init"><a href="#5-2-sensors-init" class="headerlink" title="5.2 sensors_init"></a>5.2 sensors_init</h2><p>sensors_init主要是对各个sensor传感器进行初始化，核心的工作就是：</p><ul><li><p>为每个sensor创建一个sensors_mgr_sensor_info；</p></li><li><p>初始化sensors_mgr_sensor_info；</p></li><li><p>并为每个sense创建一个线程</p></li></ul><p><img src="6.png" alt=""></p><p>主要包含了三类sensor:</p><ol><li><p>modem的sense<br>首先会通过modem_ts_qmi_init初始化与modem的通信，包含了modem、adsp、cdsp、fusion等, 之后通过add_tgt_sensors_set(mdm_sensors)添加modem的sense，创建sensors_mgr_sensor_info</p></li><li><p>来自thermal zone的sense<br>parse_thermal_zones解析底层thermal core注册的thermal zone，为每个thermal zone创建sensors_mgr_sensor_info。这里的thermal_nl_init，它执行通讯链路的初始化，这个通信链路就是用于与thermal core进行通信</p></li><li><p>band width的sense<br>从代码看主要包含了camera_bw和显示带宽display_bw，创建完每个sensor的sensors_mgr_sensor_info后就会为每个sense创建一个线程，线程处理函数为sensor_monitor;<br>add_tgt_sensor为每个sensor创建sensors_mgr_sensor_info，并创建线程的函数如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int add_tgt_sensor(struct sensor_info *sensor)</span><br><span class="line">    |-sensor_mgr = malloc(sizeof(struct sensors_mgr_sensor_info));</span><br><span class="line">    |-sensor_mgr-&gt;get_temperature = generic_read;</span><br><span class="line">    | sensor_mgr-&gt;shutdown = generic_shutdown;</span><br><span class="line">    |-if (sensor-&gt;interrupt_wait)</span><br><span class="line">    |        sensor_mgr-&gt;wait = generic_wait;//sensor_monitor线程将在此wait上阻塞</span><br><span class="line">    | if (sensor-&gt;update_thresholds)</span><br><span class="line">    |        sensor_mgr-&gt;update_thresholds = generic_update_thresholds;</span><br><span class="line">    | if (sensor-&gt;get_trip_temperature)</span><br><span class="line">    |        sensor_mgr-&gt;get_trip_temperature = generic_trip_temp_read;</span><br><span class="line">    \-sensors_manager_add_sensor(sensor_mgr);</span><br><span class="line">        |-sensor_mgr-&gt;default_polling_interval = SENSOR_DEFAULT_POLLING_INTERVAL;</span><br><span class="line">        |-sensor_mgr-&gt;next_sensor = sensor_list;</span><br><span class="line">        | sensor_list = sensor_mgr;</span><br><span class="line">        | sensor_cnt++;</span><br><span class="line">        \-pthread_create(&amp;(sensor_mgr-&gt;monitor_thread), NULL,</span><br><span class="line">                               sensor_monitor, sensor_mgr);</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-3-thermal-monitor"><a href="#5-3-thermal-monitor" class="headerlink" title="5.3 thermal_monitor"></a>5.3 thermal_monitor</h2><p>初始化过程中会对各种算法进行初始化，此处主要以monitor算法为例。</p><p>thermal monitor初始化的主要工作就是设置tm_instance_info实例的setting信息，它包含了内嵌或配置文件中配置section的主要信息，核心工作包括：</p><ul><li><p>通过devices_manager_get_list就可以获取到使用的cooling device信息；</p></li><li><p>通过sensors_setup用于为thermal_monitor设置sensor信息，并创建必要的sensor client;</p></li><li><p>最后则创建了 monitor算法的处理线程sensor_monitor</p></li></ul><p><img src="7.png" alt=""></p><h2 id="5-4-thermal-nl-init"><a href="#5-4-thermal-nl-init" class="headerlink" title="5.4 thermal_nl_init"></a>5.4 thermal_nl_init</h2><p>前面在介绍sensors_init时，有一个thermal_nl_init函数，通过它建立起与thermal core的通信链路，会创建单独的线程thermal_sensor_netlink和thermal_sensor_netlink_sample来处理，其中thermal_sensor_netlink用于处理thermal core发送的trip事件，用于更新温度触发点；thermal_sensor_netlink_sample主要用于采样thermal core的温度，当thermal core产生温度更新事件就会上报，thermal_sensor_netlink_sample就会去查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int thermal_nl_init(void)</span><br><span class="line">    |//创建nl_socket，用于监控温度触发阈值设置</span><br><span class="line">    |-nl_socket.soc = nl_socket_alloc()</span><br><span class="line">    |-genl_connect(nl_socket.soc)</span><br><span class="line">    |//创建nl_sample_socket，用于监控温度变化</span><br><span class="line">    |-nl_sample_socket.soc = nl_socket_alloc()</span><br><span class="line">    |-genl_connect(nl_sample_socket.soc)</span><br><span class="line">    |-thermal_nl_fetch_id()</span><br><span class="line">    |//创建线程监控温度阈值变化</span><br><span class="line">    |-pthread_create(&amp;thermal_sensor_event_thread, NULL,</span><br><span class="line">    |                            thermal_sensor_netlink, NULL);</span><br><span class="line">    |//创建线程用于监控温度变化</span><br><span class="line">    \-pthread_create(&amp;thermal_sensor_sample_thread, NULL,</span><br><span class="line">                                thermal_sensor_netlink_sample, NULL);</span><br></pre></td></tr></table></figure><p>我们主要看下thermal_sensor_netlink_sample的实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void *thermal_sensor_netlink_sample(void *data)</span><br><span class="line">    nl_socket_disable_seq_check(nl_sample_socket.soc);</span><br><span class="line">    nl_socket_modify_cb(nl_sample_socket.soc, NL_CB_VALID, NL_CB_CUSTOM,</span><br><span class="line">                                thermal_nl_sample_cb, &amp;nl_sample_socket);</span><br><span class="line">    while (!<span class="keyword">stop</span>)</span><br><span class="line">            nl_recvmsgs_default(nl_sample_socket.soc);</span><br></pre></td></tr></table></figure><p>thermal_nl_sample_cb回调函数如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int thermal_nl_sample_cb(struct nl_msg *n, void *data)</span><br><span class="line">    |-genlmsg_parse(nl_hdr, 0, attrs, THERMAL_GENL_ATTR_MAX, NULL);</span><br><span class="line">    |-tz_id = nla_get_u32(attrs[THERMAL_GENL_ATTR_TZ_ID]);</span><br><span class="line">    |-temp = nla_get_u32(attrs[THERMAL_GENL_ATTR_TZ_TEMP]);</span><br><span class="line">    \-notify_sample_cb(soc_data, tz_id, temp, THERMAL_NL_TEMP_SAMPLE);</span><br><span class="line">        |-struct thermal_nl_cb_data *ptr = soc_data-&gt;head_ptr;</span><br><span class="line">        |-ptr = soc_data-&gt;head_ptr;</span><br><span class="line">        \-while (ptr)</span><br><span class="line">            |-(ptr-&gt;cb.temp_cb)(tz_id, temp, ptr-&gt;data);</span><br><span class="line">            \-ptr = ptr-&gt;next;</span><br></pre></td></tr></table></figure><p>这里的temp_cb回调是thermal_sensor_temp_sample，当thermal core上报温度时就会执行thermal_sensor_temp_sample回调函数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void thermal_sensor_temp_sample(int tz_id, int temp, void *data)</span><br><span class="line">    |-struct __sensor_list_data *sensor_list =</span><br><span class="line">    |            (struct __sensor_list_data *)data;</span><br><span class="line">    |-struct thermal_sensor_data *sensor_dt = NULL;</span><br><span class="line">    |-sensor_dt = fetch_sensor(sensor_list, tz_id);</span><br><span class="line">    |-sensor_dt-&gt;temperature = temp;</span><br><span class="line">    \-search_and_notify(sensor_list, tz_id);</span><br><span class="line">        \-pthread_cond_broadcast(&amp;(sensor_dt-&gt;thermal_sensor_condition));</span><br></pre></td></tr></table></figure><p>thermal_sensor_temp_sample获取到温度后将通过search_and_notify发出通知, 最终唤醒等待在thermal_sensor_condition上面的线程，这个线程就是sensor的sensor_monitor线程处理函数。</p><p>那么这里的temp_cb回调是在何时初始化的呢？总体流程就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">parse_thermal_zones</span><br><span class="line">    \-add_tgt_gen_sensors</span><br><span class="line">        |-sensor-&gt;setup = thermal_sensor_setup;</span><br><span class="line">        \-add_tgt_sensor(sensor);</span><br><span class="line">            \-sensor-&gt;setup(sensor)//以add_tgt_gen_sensors为例，会设置sensor-&gt;setup = thermal_sensor_setup;</span><br><span class="line">                \-thermal_sensor_setup</span><br><span class="line">                    \-thermal_sensor_init()</span><br><span class="line">                        |-thermal_nl_register_trip(thermal_sensor_trip_violation,</span><br><span class="line">                        |                                &amp;sensor_list_ptr);</span><br><span class="line">                        \-thermal_nl_register_temp_sample(thermal_sensor_temp_sample,</span><br><span class="line">                            |                                    &amp;sensor_list_ptr);</span><br><span class="line">                            |-local_cb.temp_cb = cb</span><br><span class="line">                            \-thermal_nl_add_cb(&amp;nl_sample_socket, local_cb, data, THERMAL_NL_TEMP_SAMPLE);</span><br></pre></td></tr></table></figure><p>thermal_sensor_init的函数在thermal_sensor_setup或tsens_sensors_setup都有调用, setup回调初始化如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void parse_thermal_zones(void)</span><br><span class="line">.....</span><br><span class="line">    |-for (cnt = 0; cnt &lt; sensor_cnt; cnt++) &#123;</span><br><span class="line">        if (!strncmp(sensors[cnt].type, TSENS_TYPE,strlen(TSENS_TYPE))</span><br><span class="line">                || !strncmp(sensors[cnt].type, LLM_TYPE, strlen(LLM_TYPE))) &#123;</span><br><span class="line">                add_tgt_tsens_sensors(sensors[cnt].name, &amp;sensors[cnt]);</span><br><span class="line">                    |-sensor-&gt;setup = tsens_sensors_setup;</span><br><span class="line">        &#125; else if (!strncmp(sensors[cnt].type, ALARM_TYPE,</span><br><span class="line">                        strlen(ALARM_TYPE)) ||  (!strncmp(sensors[cnt].type, ADC_TYPE,strlen(ADC_TYPE)))) &#123;</span><br><span class="line">                add_tgt_gen_sensors(sensors[cnt].name,&amp;sensors[cnt]);</span><br><span class="line">                    |-sensor-&gt;setup = thermal_sensor_setup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-thermal-server-init"><a href="#5-5-thermal-server-init" class="headerlink" title="5.5 thermal_server_init"></a>5.5 thermal_server_init</h2><p>thermal_server_init主要创建了thermal socket，包括发送和接收socket，用于与用户空间的客户端进行socket通信，thermal_server_init创建了单独的线程，监听来自用户空间客户端的请求，并处理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">thermal_server_init(void)</span><br><span class="line">    |</span><br><span class="line">    |-sockfd_server_send = android_get_control_socket(THERMAL_SEND_SOCKET_NAME)</span><br><span class="line">    |-sockfd_server_recv = android_get_control_socket(THERMAL_RECV_SOCKET_NAME)</span><br><span class="line">    |-sockfd_server_recv_passive = android_get_control_socket(THERMAL_RECV_PASSIVE_SOCKET_NAME)</span><br><span class="line">    |-sockfd_server_rule = android_get_control_socket(THERMAL_SEND_RULE_SOCKET_NAME)</span><br><span class="line">    |//创建socket</span><br><span class="line">    |-sockfd_server_send = socket(AF_LOCAL, SOCK_STREAM, 0)</span><br><span class="line">    |-sockfd_server_recv = socket(AF_LOCAL, SOCK_STREAM, 0)</span><br><span class="line">    |-sockfd_server_recv_passive = socket(AF_LOCAL, SOCK_STREAM, 0)</span><br><span class="line">    |-sockfd_server_rule = socket(AF_LOCAL, SOCK_STREAM, 0)</span><br><span class="line">    |//socket bind</span><br><span class="line">    |-bind(sockfd_server_send,(struct sockaddr  const *)&amp;server_addr_send, sizeof(struct sockaddr_un))</span><br><span class="line">    |-bind(sockfd_server_recv,(struct sockaddr  const *)&amp;server_addr_recv, sizeof(struct sockaddr_un))</span><br><span class="line">    |-bind(sockfd_server_recv_passive,(struct sockaddr  const *)&amp;server_addr_recv_passive, sizeof(struct sockaddr_un))</span><br><span class="line">    |-bind(sockfd_server_rule,(struct sockaddr  const *)&amp;server_addr_rule, sizeof(struct sockaddr_un))</span><br><span class="line">    |//创建server log socket并绑定</span><br><span class="line">    |-sockfd_server_log = socket(AF_LOCAL, SOCK_STREAM, 0)</span><br><span class="line">    |-bind(sockfd_server_log,...)</span><br><span class="line">    |//执行监听</span><br><span class="line">    |-listen(sockfd_server_send, NUM_LISTEN_QUEUE)</span><br><span class="line">    |-listen(sockfd_server_recv, NUM_LISTEN_QUEUE)</span><br><span class="line">    |-listen(sockfd_server_recv_passive, NUM_LISTEN_QUEUE)</span><br><span class="line">    |-listen(sockfd_server_log, NUM_LISTEN_QUEUE)</span><br><span class="line">    |-listen(sockfd_server_rule, NUM_LISTEN_QUEUE)</span><br><span class="line">    |//创建socket监听线程，监听来自client的请求并处理</span><br><span class="line">    \-pthread_create(&amp;listen_client_fd_thread, NULL, do_listen_client_fd, NULL)</span><br></pre></td></tr></table></figure><h1 id="6-sensor传感器处理线程"><a href="#6-sensor传感器处理线程" class="headerlink" title="6. sensor传感器处理线程"></a>6. sensor传感器处理线程</h1><blockquote><p>注：有两个线程处理函数的名字都是sensor_monitor，其中一个是sensor线程的处理函数；另一个是monitor算法的线程处理函数，此处介绍的sensor端的线程处理函数</p></blockquote><p>sensor_monitor线程平时在没有温度触发请求时是处于休眠态，一旦接收到底层thermal core上报的温度信息，就会从睡眠态唤醒，唤醒后的核心工作包括：</p><ul><li><p>唤醒后它会获取温度</p></li><li><p>并会发出通知，通知等待此sensor的线程，而monitor算法线程就是其中一个</p></li></ul><p><img src="8.png" alt=""></p><ol><li><p>第一次休眠<br>sensor_monitor线程在没有激活的请求时，就会阻塞睡眠，此时sensor_mgr-&gt;req_active为0，因此可以看到打印：<br><code>D ThermalEngine: sensor_monitor: skin-msm-therm Wait for client request</code><br>之后monitor算法在update_active_thresh更新有效阈值时会唤醒sensor_monitor线程；</p></li><li><p>第二次休眠<br>第二个发生阻塞睡眠的点是sensor_wait，表示当前没有温度触发请求,打印：<br><code>D ThermalEngine: sensor_monitor: skin-msm-therm Sensor wait</code><br>当底层kernel有发送uevent就会唤醒sensor线程继续执行<br>sensor_wait的实现如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void sensor_wait(struct sensors_mgr_sensor_info *sensor_mgr)</span><br><span class="line">&#123;</span><br><span class="line">        if (sensor_mgr-&gt;wait)</span><br><span class="line">                sensor_mgr-&gt;wait(sensor_mgr);</span><br><span class="line">        else &#123;</span><br><span class="line">                uint32_t polling_interval =</span><br><span class="line">                        (sensor_mgr-&gt;active_thresh.polling_interval_valid)?</span><br><span class="line">                        (sensor_mgr-&gt;active_thresh.polling_interval):</span><br><span class="line">                        (sensor_mgr-&gt;default_polling_interval);</span><br><span class="line">                dbgmsg("%s: %s Wait start. %dms\n<span class="string">", __func__, sensor_mgr-&gt;name, polling_interval);</span></span><br><span class="line"><span class="string">                usleep(polling_interval*1000);</span></span><br><span class="line"><span class="string">                dbgmsg("</span>%s: %s <span class="keyword">Wait</span> done.\n<span class="string">", __func__, sensor_mgr-&gt;name);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>由前述知，在add_tgt_sensor时已经将sensor_mgr-&gt;wait初始化为generic_wait</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sensors.c</span><br><span class="line">static void generic_wait(struct sensors_mgr_sensor_info *sensor_mgr)</span><br><span class="line">&#123;</span><br><span class="line">        struct sensor_info *sensor = (struct sensor_info *)sensor_mgr-&gt;data;</span><br><span class="line">        sensor-&gt;interrupt_wait(sensor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interrupt_wait初始化如下（以add_tgt_gen_sensors为例）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parse_thermal_zones</span><br><span class="line">    |-add_tgt_gen_sensors</span><br><span class="line">        |-sensor-&gt;interrupt_wait = thermal_sensor_interrupt_wait;</span><br></pre></td></tr></table></figure><p>thermal_sensor_interrupt_wait的实现如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void thermal_sensor_interrupt_wait(struct sensor_info *sensor)</span><br><span class="line">    |-while (!sensor_data-&gt;threshold_reached) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;(sensor_data-&gt;thermal_sensor_condition),</span><br><span class="line">                                &amp;(sensor_data-&gt;thermal_sensor_mutex));</span><br></pre></td></tr></table></figure><p>sensor_monitor线程等待在thermal_sensor_condition，以通用sensor为例，这个条件变量的唤醒，是通过底层kernel发送的uevent来唤醒，具体是由thermal_sensor_temp_sample来唤醒（见sensors_init一节），底层一旦触发event上报后，将由之前的中断方式改为轮询方式进行event上报；</p></li><li><p>获取温度信息，通知等待此sensor的所有client，通过调用client-&gt;request.notify_cb_func（thresh_event）来通知，以monitor算法为例，这个notify_cb_func回调在thermal_monitor算法初始化时设置为sensor_thresh_notify函数，它主要的实现就是发出唤醒信号，通知算法线程，对于monitor算法，唤醒的线程就是monitor算法的sensor_monitor线程，从这里我们可以看出，每个温控算法都会给它对应的sensor client rquest设定一个notify，当sensor线程被唤醒后就会通过这个notify去唤醒对应的算法线程，本例唤醒的就是thermal monitor算法的线程，后者会更新阈值，并重新置位sensor_mgr-&gt;req_active，之后sensor的线程会重新进入上述第二次休眠，循环往复。</p></li></ol><h1 id="7-monitor算法处理线程"><a href="#7-monitor算法处理线程" class="headerlink" title="7. monitor算法处理线程"></a>7. monitor算法处理线程</h1><blockquote><p>注：有两个线程处理函数的名字都是sensor_monitor，其中一个是sensor线程的处理函数；另一个是monitor算法的线程处理函数，此处介绍的montior算法端的线程处理函数</p></blockquote><p><img src="9.png" alt=""></p><p>sensor_monitor为monitor算法的处理程序，最初它处于阻塞态，当接收到thermal core的event事件，sensor线程会被唤醒，sensor线程进一步唤醒monitor线程，monitor线程唤醒后的核心工作包括：</p><ul><li><p>monitor线程唤醒后会遍历所有的<strong>tm_instance_info</strong>实例，获取sensor温度，与<strong>tm_instance_info</strong>实例中的每个阈值进行比较，根据比较情况更新新的阈值；</p></li><li><p>唤醒等待的线程，这其中主要包含thermal server线程，用于通知client，发生了温控事件；</p></li><li><p>执行cooling操作；</p></li><li><p>处理完毕之后将再次进入睡眠态，等待sensor线程唤醒</p></li></ul><h1 id="8-Thermal-server-amp-client通信过程"><a href="#8-Thermal-server-amp-client通信过程" class="headerlink" title="8. Thermal server &amp; client通信过程"></a>8. Thermal server &amp; client通信过程</h1><p>Thermal client向Thermal Engine服务端注册回调，服务端监听客户端请求执行回调；除此之外，Thermal客户端还可以向Thermal服务端动态设置温控配置参数或查询温控配置参数。</p><h2 id="8-1-客户端注册回调"><a href="#8-1-客户端注册回调" class="headerlink" title="8.1 客户端注册回调"></a>8.1 客户端注册回调</h2><p>thermal_client_register_callback用于客户端向服务端注册回调，服务端会记录客户端注册的回调，通过name可以查询到对应的回调，这样客户端发送请求时，服务端监听到就可以执行对应的回调，核心工作包括：</p><p>（1）向server端注册回调；</p><p>（2）创建客户端监听线程，监听服务端发送过来的信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thermal_client.c</span><br><span class="line"></span><br><span class="line">int thermal_client_register_callback(char *client_name, int (*callback)(int, void *, void *), void *data)</span><br><span class="line">    |<span class="comment">/* Check for client is supported  or not*/</span></span><br><span class="line">    |-for (i = 0; i &lt; ARRAY_SIZE(notify_clients); i++)</span><br><span class="line">    |            if (0 == strncmp(notify_clients[i].name, client_name, CLIENT_NAME_MAX))</span><br><span class="line">    |                    break;</span><br><span class="line">    |//client端注册回调</span><br><span class="line">    |-client_cb_handle = add_to_list(client_name, callback, data)</span><br><span class="line">    |//创建客户端监听线程</span><br><span class="line">    \-if (first_client == 1) &#123;</span><br><span class="line">                rc = pthread_create(&amp;thermal_client_recv_thread, NULL, do_listen,</span><br><span class="line">                        (void *)THERMAL_SEND_CLIENT_SOCKET);</span><br></pre></td></tr></table></figure><ol><li><p>首先会检测客户端是否是合法的，目前它只支持在notify_clients数组中列出的客户端</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static struct notify_client notify_clients[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .name = "camera",</span><br><span class="line">                .min_req_data = 0,</span><br><span class="line">                .max_req_data = MAX_CAMERA_MITIGATION_LEVEL,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = "camcorder",</span><br><span class="line">                .min_req_data = 0,</span><br><span class="line">                .max_req_data = MAX_CAMCORDER_MITIGATION_LEVEL,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = "spkr",</span><br><span class="line">                .min_req_data = -30,</span><br><span class="line">                .max_req_data = 150,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = CONFIG_QUERY_CLIENT,</span><br><span class="line">                .min_req_data = 0,</span><br><span class="line">                .max_req_data = LEVEL_MAX,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过add_to_list将客户端名字和回调记录到server端的list_head全局链表</p></li><li>如果是第一个注册的客户端，则会创建单独的线程thermal_client_recv_thread与服务端进行交互</li></ol><h2 id="8-2-服务端监听并执行回调"><a href="#8-2-服务端监听并执行回调" class="headerlink" title="8.2 服务端监听并执行回调"></a>8.2 服务端监听并执行回调</h2><p>服务端创建专门的线程来监听客户端的注册回调请求，注册了回调的客户端通过向sockfd_server_send socket发送请求将自己加入到thermal_send_fds数组，这样当回调发生后就可以通知到客户端；通过sockfd_server_recv来接收客户端请求，服务端会根据请求执行查询配置或更新配置的回调操作。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">thermal_server.c</span><br><span class="line"></span><br><span class="line">static void *do_listen_client_fd(void *data)</span><br><span class="line">    //初始化监听描述符集合</span><br><span class="line">    FD_ZERO(&amp;t_readfds);</span><br><span class="line">    FD_SET(sockfd_server_send, &amp;t_readfds);</span><br><span class="line">    FD_SET(sockfd_server_recv, &amp;t_readfds);</span><br><span class="line">    FD_SET(sockfd_server_recv_passive, &amp;t_readfds);</span><br><span class="line">    FD_SET(sockfd_server_log, &amp;t_readfds);</span><br><span class="line">    FD_SET(sockfd_server_rule, &amp;t_readfds);</span><br><span class="line">    </span><br><span class="line">    result = <span class="keyword">select</span>(FD_SETSIZE, &amp;testfds, (fd_set *)<span class="number">0</span>,</span><br><span class="line">                               (fd_set *)<span class="number">0</span>, (<span class="keyword">struct</span> timeval *) <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    //注册回调的客户端通过sockfd_server_send接收到当前的thermalcurrent level</span><br><span class="line">    if (fd == sockfd_server_send) &#123;</span><br><span class="line">            FD_SET(client_fd, &amp;t_readfds);</span><br><span class="line">            thermal_send_fds[i] = client_fd;</span><br><span class="line">            notify_client_on_register(client_fd);</span><br><span class="line">    //接收客户端请求执行回调</span><br><span class="line">    &#125; else if (fd == sockfd_server_recv) &#123;</span><br><span class="line">            client_len = sizeof(struct sockaddr_un);</span><br><span class="line">            client_fd = accept(fd,</span><br><span class="line">                              (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                               &amp;client_len);</span><br><span class="line">            thermal_recv_data_from_client(client_fd, fd);</span><br><span class="line">            FD_SET(client_fd, &amp;t_readfds);</span><br><span class="line">            close(client_fd);</span><br><span class="line">    &#125; else if (fd == sockfd_server_recv_passive) &#123;</span><br><span class="line">            client_len = sizeof(struct sockaddr_un);</span><br><span class="line">            client_fd = accept(fd,</span><br><span class="line">                              (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                               &amp;client_len);</span><br><span class="line">            thermal_recv_data_from_client(client_fd, fd)</span><br><span class="line">            FD_SET(client_fd, &amp;t_readfds);</span><br><span class="line">    &#125; else if (fd == sockfd_server_log || fd == sockfd_server_rule) &#123;</span><br><span class="line">            client_len = sizeof(struct sockaddr_un);</span><br><span class="line">            client_fd = accept(fd,</span><br><span class="line">                               (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                                &amp;client_len);</span><br><span class="line">            FD_SET(client_fd, &amp;t_readfds);</span><br><span class="line">            if (fd == sockfd_server_log)</span><br><span class="line">                    add_local_socket_fd(SOCKET_RPT_LOG, client_fd);</span><br><span class="line">            else</span><br><span class="line">                    add_local_socket_fd(SOCKET_RPT_RULE, client_fd);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            ioctl(fd, FIONREAD, &amp;nread);</span><br><span class="line">            if (nread == 0) &#123;</span><br><span class="line">                    close(fd);</span><br><span class="line">                    FD_CLR(fd, &amp;t_readfds);</span><br><span class="line">                    info("Thermal-Server: removing client on fd %d\n", fd);</span><br><span class="line">                    for (i = 0; i &lt; NUM_LISTEN_QUEUE &amp;&amp; thermal_send_fds[i] != fd; i++)</span><br><span class="line">                            continue;</span><br><span class="line">                    if (i &lt; NUM_LISTEN_QUEUE) &#123;</span><br><span class="line">                            thermal_send_fds[i] = -1;</span><br><span class="line"><span class="comment">#ifdef ENABLE_CAMERA_REG_BW_CALLBACK</span></span><br><span class="line">                            thermal_recv_bw_data("camera", 0);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                            if (check_for_bw_client_update(fd, 1) == 0)</span><br><span class="line">                                    remove_local_socket_fd(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                    <span class="comment">/* BW client notification update */</span></span><br><span class="line">                    if (check_for_bw_client_update(fd, 0) == 0)&#123;</span><br><span class="line">                            for (i = 0; i &lt; NUM_LISTEN_QUEUE &amp;&amp; thermal_send_fds[i] != fd; i++)</span><br><span class="line">                                    continue;</span><br><span class="line">                            if (i &lt; NUM_LISTEN_QUEUE) &#123;</span><br><span class="line">                                    thermal_recv_data_from_client(thermal_send_fds[i], sockfd_server_send);</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                    dbg("Thermal-Server: Unknown fd:%d notification\n", fd);</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>thermal_server_init创建了单独的线程，监听来自用户空间客户端的请求，并处理，线程处理函数为do_listen_client_fd，它主要通过select监听的文件描述符集变化，包括：sockfd_server_send，sockfd_server_recv，sockfd_server_recv_passive，sockfd_server_log，sockfd_server_rule。</li><li>sockfd_server_send主要用于监听客户端消息，将接收的fd加入到thermal_send_fds监听列表<blockquote><p>连接到thermal server服务端的客户端可以提前向服务端注册回调，所有客户端的回调通过list_head链表链接</p></blockquote></li><li>sockfd_server_recv是用来监听客户端的查询温控配置或更新温控配置的请求信息，并执行客户端对应的回调，即返回查询配置结果给客户端或更新温控配置</li></ol><h1 id="9-动态配置参数"><a href="#9-动态配置参数" class="headerlink" title="9. 动态配置参数"></a>9. 动态配置参数</h1><p>Thermal Engine对外提供了如下的接口用于不同的Servcie/App与之交互：</p><ol><li><p>如下的接口用于不同的Servcie/App动态查询、清空或更新温控配置参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//允许外部获取温控配置参数</span><br><span class="line">int thermal_client_config_query(char *algo_type, struct config_instance **configs);</span><br><span class="line">//允许外部清除温控配置参数</span><br><span class="line">void thermal_client_config_cleanup(struct config_instance *configs, unsigned int config_size);</span><br><span class="line">//允许外部更新设置温控配置参数</span><br><span class="line">int thermal_client_config_set(struct config_instance *configs, unsigned int config_size);</span><br></pre></td></tr></table></figure></li><li><p>如下的接口用于不同的Servcie/App向Thermal Engine注册回调、发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int thermal_client_register_callback(char *client_name, int (*callback)(int , void *, void *), void *data);</span><br><span class="line">int thermal_client_register_report_callback(int (*callback)(char *, void *, void*), void *data);</span><br><span class="line">int thermal_client_request(char *client_name, int req_data);</span><br><span class="line">void thermal_client_unregister_callback(int client_cb_handle);</span><br></pre></td></tr></table></figure></li><li><p>如下的接口用于向Thermal Engine发送带宽请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* APIs <span class="keyword">for</span> bandwidth clients to send/clear bandwidth perf levels to thermal-Engine */</span><br><span class="line">int thermal_bandwidth_client_request(char *client_name, int req_data);</span><br><span class="line">void thermal_bandwidth_client_cancel_request(char *client_name);</span><br></pre></td></tr></table></figure></li></ol><h1 id="10-温控配置示例"><a href="#10-温控配置示例" class="headerlink" title="10. 温控配置示例"></a>10. 温控配置示例</h1><p>Thermal Engine温控的主要思想是监测传感器触发温度，并采用预先设定的算法完成对相应设备的控温操作，这被称之为一条规则，每一条规则是通过一个配置来体现的，我们称之为一个section，如下是一个温控section的格式说明：</p><blockquote><p>注：关于温控配置的说明可参考thermal-Engine目录下的readme.txt文件</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Algorithm instance label&gt;]</span><br><span class="line">algo_type      monitor</span><br><span class="line">sensor         &lt;sensor name&gt;</span><br><span class="line">sampling       &lt;sampling rate in ms&gt;</span><br><span class="line">descending     &lt;OPTIONAL threshold trigger direction is falling below value</span><br><span class="line">                as opposed to default behavior rising above.&gt;</span><br><span class="line">thresholds     &lt;threshold values in degree mC or mA&gt; ...</span><br><span class="line">thresholds_clr &lt;temperature value to clear thresholds&gt; ...</span><br><span class="line">actions        &lt;action to perform at threshold;</span><br><span class="line">                multiple actions separated by '+'&gt; ...</span><br><span class="line">action_info    &lt;additional info for action;</span><br><span class="line">                multiple action_info separated by '+'&gt; ...</span><br></pre></td></tr></table></figure><p>如下是一个具体的温控配置section举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[MONITOR-THERM-GOLD]</span><br><span class="line">algo_type monitor</span><br><span class="line">sampling 500 </span><br><span class="line">sensor skin-msm-therm</span><br><span class="line">thresholds 43500</span><br><span class="line">thresholds_clr  43000</span><br><span class="line">actions  cpu0+cpu3+cpu7</span><br><span class="line">action_info  1555200+1920000+1132800</span><br></pre></td></tr></table></figure><ul><li><p>温控section的名字：MONITOR-THERM-GOLD，这个温控section的名字必须全局唯一</p></li><li><p>温控算法：为monitor算法</p></li><li><p>采样时间：500ms</p></li><li><p>温控传感器：触发温控的传感器名字为skin-msm-therm</p></li><li><p>温控阈值：当达到43.5度时会触发温控操作，可支持多个温控阈值</p></li><li><p>取消温控的阈值：当达到43度时会取消温控操作，可支持多个阈值</p></li><li><p>温控发生时的行为主体：当温控发生时将对cpu0,cpu3,cpu7执行限频</p></li><li><p>温控发生时的行为主体温控值：当温控发生时将对cpu0,cpu3,cpu7执行限频分别为1555200，1920000，1132800</p></li></ul><p>Thermal Engine对传感器进行扩展，实现了虚拟传感器，可以将多个传感器按照一定的权重进行拟合，如下是一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>-sensor<span class="number">-0</span>]</span><br><span class="line">algo_type          <span class="keyword">virtual</span></span><br><span class="line">sensors        skin-msm-therm xo-therm</span><br><span class="line">weights            <span class="number">40</span> <span class="number">60</span></span><br><span class="line">sampling           <span class="number">500</span></span><br><span class="line"></span><br><span class="line">[MONITOR-THERM-GOLD]</span><br><span class="line">algo_type monitor</span><br><span class="line">sampling <span class="number">500</span></span><br><span class="line">sensor <span class="keyword">virtual</span>-sensor<span class="number">-0</span></span><br><span class="line">thresholds  <span class="number">50000</span></span><br><span class="line">thresholds_clr <span class="number">40000</span></span><br><span class="line">actions  cpu0+cpu3+cpu7</span><br><span class="line">action_info  <span class="number">1555200</span>+<span class="number">1920000</span>+<span class="number">1132800</span></span><br></pre></td></tr></table></figure><p>通过对skin-msm-therm和xo-therm传感器按照一定的权重进行累加，得到虚拟传感器的温度值，此处虚拟传感器温度的计算公式为：(skin-msm-therm温度值 <em> 40 + xo-therm温度值 </em> 60) / (40 + 60)。</p><blockquote><p>注：在将虚拟传感器作为触发条件时，与普通传感器没有区别。</p></blockquote><h1 id="11-thermal-Engine调试方法"><a href="#11-thermal-Engine调试方法" class="headerlink" title="11. thermal-Engine调试方法"></a>11. thermal-Engine调试方法</h1><ol><li><p>启动和停止thermal-Engine<br>stop thermal-Engine和start thermal-Engine</p></li><li><p>打印当前温控配置<br>thermal-Engine-v2 -o可打印当前的温控配置</p></li><li><p>开启thermal Engine打印信息<br>thermal-Engine-v2 —debug可开启调试信息</p></li><li><p>查看logcat中的温控打印信息<br>Logcat |grep ThermalEngine，查看thermal Engine的打印信息</p></li><li><p>如何判断何时发生了温控？何时温控取消？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">如下打印表示发生了温控</span><br><span class="line">130| # logcat | grep ThermalEngine | grep "raised"                                                                                                                                            </span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.132</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">7</span> at <span class="number">50.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.133</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">6</span> at <span class="number">50.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.133</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">5</span> at <span class="number">50.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.133</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">4</span> at <span class="number">50.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.133</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">3</span> at <span class="number">50.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.133</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">2</span> at <span class="number">50.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">06.133</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm  raised <span class="number">1</span> at <span class="number">50.0</span> degC</span><br><span class="line">如下打印表示温控触发取消</span><br><span class="line">130|  # logcat | grep ThermalEngine | grep "clear"                                                                                                                                             </span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">7</span> at <span class="number">30.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">6</span> at <span class="number">30.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">5</span> at <span class="number">30.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">4</span> at <span class="number">30.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">3</span> at <span class="number">30.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">2</span> at <span class="number">30.0</span> degC</span><br><span class="line"><span class="number">07</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">30.636</span>  <span class="number">6346</span>  <span class="number">6564</span> I ThermalEngine: TM Id <span class="string">'MONITOR-THERM-GOLD'</span> Sensor <span class="string">'skin-msm-therm'</span> - alarm cleared <span class="number">1</span> at <span class="number">30.0</span> degC</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 温升与功耗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thermal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从硬件到软件，Linux 时间子系统全栈解析</title>
      <link href="/2023/12/13/Full-stack-resolution-of-the-Linux-time-subsystem/"/>
      <url>/2023/12/13/Full-stack-resolution-of-the-Linux-time-subsystem/</url>
      
        <content type="html"><![CDATA[<p>Linux 时间子系统为构建分时多任务操作系统提供了基础设施，使得系统能够准确地管理和处理与时间相关的任务，为任务调度、资源管理、驱动开发和应用程序开发等等都提供了强大的支撑。魅族博客之前也介绍过时间相关的文章：<a href="https://kernel.meizu.com/2018/07/12//linux-time.html/">《Linux Time》</a>、<a href="https://kernel.meizu.com/2016/07/20//linux-tick-and-tickless.html/">《Linux Tick 和 Tickless》</a>、<a href="https://kernel.meizu.com/2016/05/28//cpuidle.html/">《CPUIDLE 之低功耗定时器》</a>，温故而知新，我们再来一篇从入门到放弃。</p><h1 id="1-整体软件架构"><a href="#1-整体软件架构" class="headerlink" title="1. 整体软件架构"></a>1. 整体软件架构</h1><p>linux时间子系统从功能上分为定时和计时，定时用于定时触发中断事件，计时则用于记录现实世界的时间线。其软件架构示意图如下：</p><p><img src="1.PNG" alt=""></p><p>定时部分，系统有一个全局计数器counter，每个cpu核心有一个硬件定时器timer。定时器内部有比较器，当设定值达到全局计数器值就触发中断。每cpu定时器timer在软件上被抽象成时钟事件设备(Clock event device)，在高精度版本，每个Clock event device创建一个本地高精度定时器hrtimer管理结构。hrtimer基于事件触发，通过红黑树来管理该cpu上的各种类型软件定时任务，每次执行完超期任务，都会选取超期时间最近的定时任务来设定下次超期值。基于hrtimer还封装了各种类型和精度的软件定时器，为了方便内核使用，定义了节拍定时器(sched_timer)作为系统心跳来驱动任务调度、负载计算、以及其他基于timer wheel的低精度定时器。为了方便用户空间使用，定义了posix-timer、alarm、timer_fd、nanosleep、itimer等定时器接口。</p><p>计时部分，全局计数器counter在软件上被抽象成时钟源设备ClockSource device，其特点是计数频率高精度高，而且不休眠，通过寄存器可以高效地读出其计数值。timekeeping作为linux计时维护的核心，由counter提供持续不断的高精度计时，由RTC或者网络NTP提供真实世界时间基准，来维护各种系统时间的精准可靠。timekeeping除了给内核模块提供丰富的获取时间接口，也封装了很多系统调用给用户空间使用，特别地还通过VDSO技术绕过系统调用使用户空间高效地获取系统时间。另外任务调度模块(sched)，printk/ftrace时间戳等也依赖计数器counter提供高精度计时。</p><h1 id="2-定时器和时钟源初始化"><a href="#2-定时器和时钟源初始化" class="headerlink" title="2 定时器和时钟源初始化"></a>2 定时器和时钟源初始化</h1><p>  armv8文档《Architecture Reference Manual ARMv8, for ARMv8-A architecture profile》描述了关于定时器和时钟源的示例结构图如下。其中System counter是全局计数器，位于Always-powered域，保证系统休眠期也能正确计数。Timer_x是cpu本地定时器，每个执行单元(PE)至少有一个专属定时器。所有本地定时器都以System counter作为时钟源，共享全局计数器的计数值，以保证时间同步。本地定时器通过中断控制器，向cpu发起PPI私有中断。</p><p><img src="2.PNG" alt=""></p><h2 id="2-1-解析dts"><a href="#2-1-解析dts" class="headerlink" title="2.1 解析dts"></a>2.1 解析dts</h2><p>以qcom 8核armv8的SOC为例，把cpu本地定时器称为arch_timer，全局计数器System counter不需要专门的dts节点，配置如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arch_timer: timer &#123;</span><br><span class="line">    compatible = "arm,armv8-timer";</span><br><span class="line">    interrupts = &lt;GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(8) | IRQ_TYPE_LEVEL_LOW)&gt;,</span><br><span class="line">                 &lt;GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(8) | IRQ_TYPE_LEVEL_LOW)&gt;,</span><br><span class="line">                 &lt;GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(8) | IRQ_TYPE_LEVEL_LOW)&gt;,</span><br><span class="line">                 &lt;GIC_PPI 12 (GIC_CPU_MASK_SIMPLE(8) | IRQ_TYPE_LEVEL_LOW)&gt;;</span><br><span class="line">    clock-frequency = &lt;19200000&gt;;</span><br><span class="line">    always-on；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>匹配字符串：”arm,armv8-timer”</li><li>interrupts：4组PPI私有外设中断，对应4个软件中断号，实际只会选择其一。8个cpu共用同一个中断号，但会各自产生中断。</li><li>clock-frequency： 时钟源计数频率19200000Hz = 19.2MHz</li><li>always-on：计数器常开不休眠</li></ul><p>出于虚拟化及安全执行等级考虑，armv8为每个cpu核心提供至少下面4种定时器用于不同的执行环境</p><p><img src="3.png" alt=""></p><p>4种定时器与dts中的对应关系如下：</p><p>  软件中断号13： ARCH_TIMER_PHYS_SECURE_PPI，安全世界物理定时器私有中断，Secure EL1 physical timer</p><p>  软件中断号14：ARCH_TIMER_PHYS_NONSECURE_PPI，非安全世界物理定时器私有中断，Non-secure EL1 physical timer</p><p>  软件中断号11：ARCH_TIMER_VIRT_PPI，虚拟定时器私有中断，vitual timer</p><p>  软件中断号12：ARCH_TIMER_HYP_PPI，hypervisor定时器私有中断，Non-secure EL2 physical timer</p><p>  虚拟定时器和物理定时器的差别在于，虚拟定时器的System counter计数输入会在实际System counter基础上添加一个偏移量，这个偏移量由host控制，来实现不同guest的无感切换。</p><p>  一般外设中断都是dts配置硬件中断号，然后软件映射到一个软件中断号，最后用软件中断号向系统注册中断，这里dts配置的直接就是软件中断号，因为linux中断系统中为SGI和PPI预留有专用软件中断号。</p><p>  上面配置的定时器，cpu可以通过cp15协处理器来访问定时器寄存器，称为cp15类型定时器。arm还提供一种内存映射方式访问的定时器，称为内存映射定时器(Memory Map Timer)，是将定时器寄存器映射到io区域，注册在系统中的名称为 “arch_mem_timer”，主要为了没有协处理器的版本使用。</p><h2 id="2-2-本地定时器初始化"><a href="#2-2-本地定时器初始化" class="headerlink" title="2.2 本地定时器初始化"></a>2.2 本地定时器初始化</h2><p>初始化代码跟具体的体系架构有关，arm初始化代码在drivers/clocksource/arm_arch_timer.c中，初始化代码中添加下面的声明，通过一个简洁的TIMER_OF_DECLARE()宏，将dts匹配字符串和初始化函数静态绑定到一个表中，</p><p>TIMER_OF_DECLARE(armv8_arch_timer, “arm,armv8-timer”, arch_timer_of_init);</p><p>在内核初始化流中路径如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">|--&gt;time_init()</span><br><span class="line">  |--&gt;timer_probe()//根据定时器列表__timer_of_table[]依次初始化</span><br><span class="line">    |--&gt;arch_timer_of_init() //对应"arm,armv8-timer"的定时器初始化</span><br><span class="line">      |--&gt;arch_timer_populate_kvm_info();//判断kernel是否为hyp模式</span><br><span class="line">      |--&gt;rate = arch_timer_get_cntfrq();//通过寄存器读取计数频率</span><br><span class="line">      |--&gt;arch_timer_of_configure_rate(rate,np);  //通过dts解析时钟源频率</span><br><span class="line">      |--&gt;arch_timer_select_pp();//如果kernel不是hyp模式，ppi中断号选择ARCH_TIMER_VIRT_PPI，否则选择ARCH_TIMER_HYP_PPI</span><br><span class="line">      |--&gt;arch_timer_register();//注册arch_timer定时器中断</span><br><span class="line">         |--&gt;alloc_percpu(struct clock_event_device);  //分配per-cpu定时器结构体</span><br><span class="line">         |--&gt;request_percpu_irq(ppi, arch_timer_handler_virt，"arch_timer", arch_timer_evt);//为每cpu注册名为"arch_timer"的ppi中断</span><br><span class="line">         |--&gt;arch_timer_cpu_pm_init(); //注册pm-notifier</span><br><span class="line">         |--&gt;cpuhp_setup_state(arch_timer_starting_cpu, arch_timer_dying_cpu);//注册cpu热插拔start/dying回调，来注册和注销定时器</span><br><span class="line">             |--&gt;arch_timer_starting_cpu</span><br><span class="line">                 |--&gt;__arch_timer_setup(ARCH_TIMER_TYPE_CP15, clk);//注册CP15寄存器类型的定时器。</span><br><span class="line">                     |--&gt;dev-&gt;name = "arch_sys_timer";</span><br><span class="line">                     |--&gt;clockevents_config_and_register(dev, freq)</span><br><span class="line">                         |--&gt;clockevents_register_device(dev); //向系统注册clockevents设备</span><br></pre></td></tr></table></figure><p>总结起来就是根据dts配置和linux运行模式，来选择注册对应中断和选择寄存器，来初始化arch_timer的一些功能函数指针，并最终向系统注册ClockEvent device。</p><p>从开机0s的log中看到arch_timer的初始化情况，初始化了cp15和mmio 2种定时器，时钟频率都是19.2MHz，都是虚拟的timer。系统启动早期只初始化cpu0的arch_timer，然后通过cpuhp_setup_state()设置了热插拔cpu时的注册和注销定时器函数，随着后续多核的启动以及下线，其他cpu的arch_timer也会陆续初始化注册或注销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] arch_timer: cp15 and mmio timer(s) running at 19.20MHz (virt/virt).</span><br></pre></td></tr></table></figure><p>运行时查看当前系统的ClockEvent device，一个内存映射定时器arch_mem_timer和8个本地定时器arch_sys_timer</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">adb shell head /sys/devices/system/clockevents<span class="comment">/*/current_device                                                                                                              </span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/broadcast/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_mem_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent0/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent1/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent2/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent3/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent4/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent5/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent6/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br><span class="line"><span class="comment">==&gt; /sys/devices/system/clockevents/clockevent7/current_device &lt;==</span></span><br><span class="line"><span class="comment">arch_sys_timer</span></span><br></pre></td></tr></table></figure><p>通过cat /proc/interrupts查看中断计数，arch_timer中断触发频率非常高，仅次于2个高频的IPI中断，可见其重要性。软件IRQ号11，对应dts中的第3个ARCH_TIMER_VIRT_PPI，硬件中断号27。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IRQ      CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7</span><br><span class="line"> 11:      74138      12926       5138       5122      23732       7418       6985      11742     GICv3  27 Level     arch_timer</span><br><span class="line">IPI0:     28488      14481      30406      29440      32710      20024      23508      30199       Rescheduling interrupts</span><br><span class="line">IPI1:      5789      17668       3344       1752       1605       1609       1665       1262       Function <span class="keyword">call</span> interrupts</span><br><span class="line">IPI2:         <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>       CPU <span class="keyword">stop</span> interrupts</span><br><span class="line">IPI3:         <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>       CPU <span class="keyword">stop</span> (<span class="keyword">for</span> crash dump) interrupts</span><br><span class="line">IPI4:         <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>       Timer broadcast interrupts</span><br><span class="line">IPI5:     <span class="number">36289</span>       <span class="number">9561</span>      <span class="number">13993</span>      <span class="number">13809</span>      <span class="number">19441</span>      <span class="number">14737</span>      <span class="number">15691</span>      <span class="number">17867</span>       IRQ <span class="keyword">work</span> interrupts</span><br><span class="line">IPI6:         <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>       CPU wake-up interrupts</span><br></pre></td></tr></table></figure><h2 id="2-3-时钟源clockSource初始化"><a href="#2-3-时钟源clockSource初始化" class="headerlink" title="2.3 时钟源clockSource初始化"></a>2.3 时钟源clockSource初始化</h2><p>初始化完定时器arch_timer，接下来就会初始化时钟源，arm上称为arch_counter，通过clocksource结构体描述，成员初值如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct clocksource clocksource_counter = &#123;</span><br><span class="line"> .name = "arch_sys_counter",</span><br><span class="line"> .rating = 400,</span><br><span class="line"> .read = arch_counter_read,</span><br><span class="line"> .mask = CLOCKSOURCE_MASK(56),</span><br><span class="line"> .flags = CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  .name = “arch_sys_counter”，时钟源名称为”arch_sys_counter”<br>  .rating = 400表示其精度很高，是理想的时钟源<br>  .mask = CLOCKSOURCE_MASK(56)，56位有效bit<br>  .flags = CLOCK_SOURCE_IS_CONTINUOUS，连续计数</p><p>软件初始化过程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arch_timer_of_init()；</span><br><span class="line">|--&gt;arch_timer_common_init()</span><br><span class="line">  |--&gt;  arch_counter_register() <span class="comment">//注册arch_counter</span></span><br><span class="line">  |--&gt;  arch_timer_read_counter <span class="comment">//根据  linux  处在hyp模式还是guest模式，确定通过哪个寄存器读计数值</span></span><br><span class="line">  |--&gt;  clocksource_register_hz() <span class="comment">//向clocksource模块注册名为"arch_sys_counter"的时钟源</span></span><br><span class="line">  |--&gt;  timecounter_init() <span class="comment">//初始化timecounter，比较少用</span></span><br><span class="line">  |--&gt;  sched_clock_register() <span class="comment">//给调度程序注册读cycle函数</span></span><br></pre></td></tr></table></figure><p>arch_counter功能相对简单，只需要一个读寄存器函数arch_timer_read_counter，最终会内嵌汇编语句，读cntvct_el0寄存器来读出计数值。cntvct_el0寄存器命名以el0结尾，表明一定条件下可以用户态也可以访问该寄存器，这一点结合vdso技术可以实现用户空间中高效读取系统时间。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">u64 (*arch_timer_read_counter)(void) __ro_after_init = arch_counter_get_cntvct;</span><br><span class="line">static __always_inline u64 __arch_counter_get_cntvct(void)</span><br><span class="line">&#123;</span><br><span class="line">    u64 cnt;</span><br><span class="line">    asm volatile(ALTERNATIVE("isb\n mrs %0, cntvct_el0",</span><br><span class="line">                 "nop\n" __mrs_s("%0", SYS_CNTVCTSS_EL0),</span><br><span class="line">                 ARM64_HAS_ECV)</span><br><span class="line">             : "=r" (cnt));</span><br><span class="line">    arch_counter_enforce_ordering(cnt);</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从开机log看出，创建了一个clocksource，名为arch_sys_counter，mask: 0xffffffffffffff表示56位有效位数，然后注册了sched_clock，56bit有效位，19MHz频率，分辨率52ns。系统还有一个jiffies时钟源，但是精度太低了，最后系统选择arch_sys_counter作为clocksource device</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x46d987e47, max_idle_ns: 440795202767 ns</span><br><span class="line">[    0.000000] sched_clock: 56 bits at 19MHz, resolution 52ns, wraps every 4398046511078ns</span><br><span class="line">[    0.044957] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns</span><br><span class="line">[    0.075704] clocksource: Switched to clocksource arch_sys_counter</span><br></pre></td></tr></table></figure><p>运行时查看当前时钟源为arch_sys_counter</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span><br><span class="line">arch_sys_counter</span><br></pre></td></tr></table></figure><h1 id="3-timekeeping"><a href="#3-timekeeping" class="headerlink" title="3 timekeeping"></a>3 timekeeping</h1><h2 id="3-1-时间类型及接口"><a href="#3-1-时间类型及接口" class="headerlink" title="3.1 时间类型及接口"></a>3.1 时间类型及接口</h2><p>  timekeeping时间维护层主要负责维护以下几种类型的时间，其中jiffies由节拍定时器累计，本不属于timekeeping模块，也列出来对比：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>时间类型</td><td>宏定义</td><td>时间基准</td><td>特性</td><td>使用场景</td></tr><tr><td>真实时间/<br><br>墙上时间</td><td>CLOCK_REALTIME</td><td>1970年1月1日0时</td><td>世界标准时间(UTC)</td><td>用户时间/安卓log时间戳/网络传输</td></tr><tr><td>单调时间</td><td>CLOCK_MONOTONIC</td><td>系统启动</td><td>系统uptime，单调增加，休眠不会增加，可能受NTP影响</td><td>定时器、内核log时间戳</td></tr><tr><td>原始单调时间</td><td>CLOCK_MONOTONIC_RAW</td><td>系统启动</td><td>系统uptime，单调增加，休眠不会增加，不受NTP影响</td><td>很少用</td></tr><tr><td>启动时间</td><td>CLOCK_BOOTTIME</td><td>系统启动</td><td>系统上电时间，单调增加，休眠也会增加</td><td>ftrace时间戳</td></tr><tr><td>原子时间</td><td>CLOCK_TAI</td><td>1970年1月1日0时</td><td>表示原子国际时间(TAI)</td><td>很少用</td></tr><tr><td>节拍计数</td><td>jiffies</td><td>系统启动</td><td>系统节拍累计计数，休眠不会增加</td><td>低精度时间计时</td></tr></tbody></table></div><p>  timekeeping管理的数据结构，变量关系交织比较杂乱，大致整理了如下简化的软件框图。维护主时间基数base，每个节拍定时器周期都会读取全局计数器的值来更新base。各种类型时间有一个相对该base的offset值，其中单调时间offset为0。这里的base并不是上表中的时间基准，而是上一次节拍定时器触发时的时间值。正常情况下只需要更新base，保持offset不变，就能使各种时间齐步走。除非一些修改特定时间的时机，例如RTC驱动或者用户空间通过settimeofday来更新实时时间，此时只需要计算更新真实时间和原子时间的offset。再例如系统休眠后，系统节拍停止，由于单调时间和原始单调时间不包含休眠时间，其他时间都包含休眠时间，所以需要更新部分时间的offset。全局计数器是不休眠的，所以根据唤醒后计数器的值与休眠前的差值，将休眠的时间补偿到offs_real、offs_boot、offs_tai上，以维持其正确性。</p><p>  由于tick节拍触发频率相对较低，如果CONFIG_HZ=250，则每4ms触发一次，也就是base每4ms更新一次。如果获取的系统时间是base+offset，精度也就只有4ms，显然不够。所以在真正获取系统时间时，会重新读取时钟源的counter值，并计算出与base的差值时间ns_delta，补偿上ns_delta来获最终高精度的系统时间。</p><p><img src="4.png" alt=""></p><p>  timekeeping时间格式有3种，timespec64、ktime_t和tm。timespec64用2个64位变量分别记录秒数tv_sec和剩余的纳秒数tv_nsec，ktime_t则是一个有符号的64位变量，记录总的纳秒数。timespec64和ktime_t转换关系很简单，但需要注意的是，这2个时间都表示从某个基准时间开始的累计值。在include/linux/ktime.h中提供了各种转换时间的函数和宏。</p><p>  tm则是我们正常理解的日期时间，是一个包含年月日时分秒的结构体，精度是秒，通过time64_to_tm函数将累计秒数转换成日期时间</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct timespec64 &#123;</span><br><span class="line">    time64_t    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    long        tv_nsec;        <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef s64        ktime_t;</span><br><span class="line"></span><br><span class="line">struct tm &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the number of seconds after the minute, normally in the range</span></span><br><span class="line"><span class="comment">     * 0 to 59, but can be up to 60 to allow for leap seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    int tm_sec;</span><br><span class="line">    <span class="comment">/* the number of minutes after the hour, in the range 0 to 59*/</span></span><br><span class="line">    int tm_min;</span><br><span class="line">    <span class="comment">/* the number of hours past midnight, in the range 0 to 23 */</span></span><br><span class="line">    int tm_hour;</span><br><span class="line">    <span class="comment">/* the day of the month, in the range 1 to 31 */</span></span><br><span class="line">    int tm_mday;</span><br><span class="line">    <span class="comment">/* the number of months since January, in the range 0 to 11 */</span></span><br><span class="line">    int tm_mon;</span><br><span class="line">    <span class="comment">/* the number of years since 1900 */</span></span><br><span class="line">    long tm_year;</span><br><span class="line">    <span class="comment">/* the number of days since Sunday, in the range 0 to 6 */</span></span><br><span class="line">    int tm_wday;</span><br><span class="line">    <span class="comment">/* the number of days since January 1, in the range 0 to 365 */</span></span><br><span class="line">    int tm_yday;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>timekeeping提供了各自接口来获取各种类型和格式的时间，主要从精度和速度上分为：</p><p>高精度版本：高精度版本会读取硬件计数器值来保证纳秒级精度，访问临界区时加顺序锁，精度最高，速度相对其他版本较慢；</p><p>低精度版本：低精度版本直接返回上次tick更新的base值，不涉及硬件操作，精度低，速度快；</p><p>高精度快速版本：相对于高精度版本区别在于访问临界区时加顺序锁类型不同，精度和速度都介于上两者。</p><p>下面是提供的内核接口函数，根据函数名和参数类型大致可以顾名思义，函数名以_ts64结尾的表示获取timespec64格式，函数名带_coarse表示低精度版本，带_fast_ns的表示高精度快速版本。</p><p><img src="5.png" alt=""></p><h2 id="3-2-RTC时间管理"><a href="#3-2-RTC时间管理" class="headerlink" title="3.2 RTC时间管理"></a>3.2 RTC时间管理</h2><p>  RTC是实时时钟，在系统下电后依赖CMOS电池保持计时功能，系统上电后再把RTC时间读出来，可以保持开机后时间正确。RTC虽然很重要，但毕竟是外设，timekeeping作为必要内核组件没有将RTC驱动纳入其中，所以开机后需要RTC驱动通过timekeeping提供的do_settimeofday64接口来更新时间。RTC相关开机log如下，rtc-pm8xxx驱动初始化后，设置了系统时间为1970-02-26T17:12:04 UTC (4900324)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[    0.250020] rtc-pm8xxx c42d000.qcom,spmi:qcom,pmk8550@0:rtc@6100: registered as rtc0</span><br><span class="line">[    0.250064] rtc-pm8xxx c42d000.qcom,spmi:qcom,pmk8550@0:rtc@6100: setting system clock to 1970-02-26T17:12:04 UTC (4900324)</span><br></pre></td></tr></table></figure><p>  不同设备在RTC功能的实现逻辑不同，有的系统会在联网后或设置时间时将新时间回写到RTC中，而有的系统则把RTC当做不断计时的只读设备，然后在系统用户文件中维护一个偏移量，每次更新时间只修改文件中的偏移量。这样的好处一方面是避免对RTC的写操作可能导致的数据破坏，另一方面也是方便对多用户系统差异时间管理，只需要维护各自用户的文件时间偏移量。下图是高通手机设备ATS时间管理机制流程框图，RTC只作为一个只读设备，在其生产出厂后从0秒(1970年1月1日0时)开始计时且不被干扰。开机联网后，安卓侧从互联网更新时间，并通过广播通知TimeService(高通时间服务)，TimeService计算最新时间与RTC的偏移量offset给到time_daemon进程，time_daemon将时间偏移量offset写到用户文件。下次开机time_daemon读出RTC值和文件中的offset，相加后通过settimeofday设置到kernel和其他子系统。</p><p><img src="6.jpg" alt=""></p><h2 id="3-3-内核时间戳"><a href="#3-3-内核时间戳" class="headerlink" title="3.3 内核时间戳"></a>3.3 内核时间戳</h2><p>  内核中依赖时间戳的模块，例如printk、ftrace等，根据各自的需要选择不同的时间获取方式。</p><p>  根据printk的调用路径，printk并没有使用timekeeping的时间接口，而是使用调度模块的接口sched_clock()，sched_clock直接使用时钟源的arch_counter_read()接口读取计数器寄存器值，来转换成时间戳。由此可知，printk的时间戳即使系统休眠也会累计。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">printk()-&gt;</span><span class="bash">_printk()-&gt;vprintk()-&gt; vprintk_default()-&gt;vprintk_emit()-&gt;vprintk_store()-</span></span><br><span class="line">    &gt;local_clock()-&gt;sched_clock()-&gt;read_sched_clock()-&gt;arch_counter_read()</span><br></pre></td></tr></table></figure><p>  ftrace依赖timekeeping，通过sys节点可以看到ftrace可以使用的时间戳类型，默认使用boot开机时间作为时间戳，可以echo修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /sys/kernel/tracing/trace_clock</span></span><br><span class="line">local global counter uptime perf mono mono_raw [boot] tai</span><br></pre></td></tr></table></figure><h2 id="3-4-vdso系统调用加速"><a href="#3-4-vdso系统调用加速" class="headerlink" title="3.4 vdso系统调用加速"></a>3.4 vdso系统调用加速</h2><p>用户态有很多进程需要频繁地获取系统高精度时间戳，如日志系统，如果每次都陷入内核通过timekeeping提供的系统调用来获取时间，损耗会非常大。VDSO（Virtual Dynamic Shared Object）是Linux内核提供的一种特殊机制，它可以让用户空间的程序在不切换到内核态的情况下，直接访问一些内核函数和数据，避免高频地系统调用，提高性能。vdso是一个冷门且复杂的技术，涉及内存共享和elf加载原理，这里不做深入讨论，只简单说明其用意。</p><p><img src="7.png" alt=""></p><p>vdso目前主要应用在用户空间获取时间的接口上，将内核timekeeping中维护的一些时间数据，在vdso.so上创建一个vdso_data副本，内核会加载映射这个so，并获取其中的vdso_data指针，每个节拍更新时间也会同步更新这个副本。每个进程加载时也会将vdso.so映射到自己的地址空间，保证内核和所有进程都是用的同一份副本，进程只需要通过libc提供的接口获取vdso_data内存中的数据，而不需要系统调用。但是vdso_data是每次tick更新的，精度不够，用户进程想获取到ns级高精度的时间，还需要时钟源计数器的值，好在用户态也可以读时钟源寄存器值，以此来获取高精度部分。vdso中的代码实质上还是执行用户态，没有进入内核，所以效率高。</p><p>vdso整个执行过程代码调用流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gettimeofday // libc接口</span><br><span class="line">|--&gt;vdso_gettimeofday //通过vdso库</span><br><span class="line">  |--&gt;  __kernel_gettimeofday</span><br><span class="line">    |--&gt;    __cvdso_gettimeofday</span><br><span class="line">    |--&gt;    vdso_data = __arch_get_vdso_data() //获取共享的vdso_data结构体</span><br><span class="line">    |--&gt;    __cvdso_gettimeofday_data(vdso_data）</span><br><span class="line">      |--&gt;      do_hres   //获取高精度的补偿值</span><br><span class="line">        |--&gt;        cycles = __arch_get_hw_counter(vd-&gt;clock_mode, vd); //读时钟源counter计数器，最后转换成ns</span><br></pre></td></tr></table></figure><p>__arch_get_hw_counter同2.3节中内核函数__arch_counter_get_cntvct，都是通过相同汇编语句读cntvct_el0系统计数器值。经过一些配置后，用户态可以直接访问cntvct_el0寄存器，也就保证了获取时间的精度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline u64 __arch_get_hw_counter(s32 clock_mode,70                                                   const struct vdso_data *vd)</span><br><span class="line">&#123;</span><br><span class="line">        u64 res;</span><br><span class="line">         * If FEAT_ECV is available, use the self-synchronizing counter.</span><br><span class="line">         * Otherwise the isb is required to prevent that the counter value</span><br><span class="line">         * is speculated.</span><br><span class="line">        */</span><br><span class="line">        asm volatile(</span><br><span class="line">        ALTERNATIVE("isb\n"</span><br><span class="line">                    "mrs %0, cntvct_el0",</span><br><span class="line">                    "nop\n"</span><br><span class="line">                    __mrs_s("%0", SYS_CNTVCTSS_EL0),</span><br><span class="line">                    ARM64_HAS_ECV)</span><br><span class="line">        : "=r" (res)</span><br><span class="line">        :</span><br><span class="line">        : "memory");</span><br><span class="line">        arch_counter_enforce_ordering(res);</span><br><span class="line">        return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linux-vdso.so.1这个库不依赖其他库，并且会被系统绝大部分so依赖，包括libc.so，非常有牌面。所有用户进程都会映射vdso到自己的地址空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell ldd /system/lib64/libc.so                                           </span><br><span class="line">        linux-vdso.so.1 =&gt; [vdso] (0x731767a000)</span><br><span class="line"></span><br><span class="line">adb shell cat /proc/1/maps</span><br><span class="line">7fa0766000-7fa0767000 r-xp 00000000 00:00 0                          [vdso]</span><br></pre></td></tr></table></figure><h2 id="3-5-NTP对时"><a href="#3-5-NTP对时" class="headerlink" title="3.5 NTP对时"></a>3.5 NTP对时</h2><p>NTP(Network Time Protocol)是一种用于在计算机网络中同步时间的协议，客户端通过NTP报文向服务端发送对时请求，服务端处理完后回应报文，通信过程非常简洁。NTP对时并不是简单的从服务端获得一个时间，然后同步到本地，还要考虑报文传输时间，服务器响应时间。核心原理如下，细节的地方省略掉。</p><p><img src="8.png" alt=""></p><p>客户端发送请求报文D(t1)附带当前本地时间戳t1，服务端在t2时刻收到报文，并记录服务器接收时间戳t2，服务端在t3时刻处理完报文并正式发送回应报文D(t1,t2,t3)，客户端在本地t4时间收到报文D(t1,t2,t3)并添加t4得到D(t1,t2,t3,t4)。一次对时通信过程完毕，接下来需要根据报文D(t1,t2,t3,t4)计算出一个准确时间来更新本地时间。这里有1个假设前提，就是来回报文的传输时间ts相同。所以客户端需要计算的时间其实是t4时刻，服务器的时间t5。t5=t3+ts，t3已知，只需要计算ts。由于t1和t4都是本地时间戳，t2和t3是服务器时间戳，两种时间戳不能直接相减。可以通过下面的公式计算ts，由此可以得到t5</p><script type="math/tex; mode=display">ts = [(t4 - t1) -(t3 - t2)]/2</script><h1 id="4-高精度定时器hrtimer"><a href="#4-高精度定时器hrtimer" class="headerlink" title="4 高精度定时器hrtimer"></a>4 高精度定时器hrtimer</h1><p>从最早的嵌入式设备到大型计算机系统，定时器都是必备的模块。随着各种硬件的升级，linux上的定时器软件也在不断变化，这里不去过多追溯历史版本和兼容情况，以当前linux 6.1版本arm64安卓设备为例做介绍。</p><p>在有高精度计数器的linux设备中，会开启高精度定时器hrtimer。在多核架构中，每个cpu都有一个本地硬件定时器，软件上也会创建对应的ClockEvent device，hrtimer层也会对应绑定一个hrtimer_cpu_base结构，利用对应ClockEvent模块来操控定时器硬件，实现定时功能。出于性能考虑，每个cpu上都会创建自己专属的软件定时任务，最典型的是schedule tick timer等，但是每个cpu定时器硬件只有一个，无法同时设置多个定时值。hrtimer通过红黑树来管理该cpu上所有的定时任务，对任务的超期的时间进行排名，每次选择最左边(最早超期)的任务去设置定时器值，定时器触发后，然后再选择最左边的任务继续设定下次超时值。也就是说hrtimer是一次触发的，对于一些周期性的任务，在触发一次后更新超时值，以改变在红黑树中的位置重新去竞争。</p><h2 id="4-1-hrtimer初始化"><a href="#4-1-hrtimer初始化" class="headerlink" title="4.1 hrtimer初始化"></a>4.1 hrtimer初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void __init hrtimers_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    hrtimers_prepare_cpu(smp_processor_id());</span><br><span class="line">    open_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hrtimer层初始化在start_kernel() -&gt; hrtimers_init()-&gt;hrtimers_prepare_cpu(0)中，首先初始化了cpu0的每cpu结构体hrtimer_cpu_base，用来管理当cpu0上所有的软件定时器。每个hrtimer_cpu_base根据4种时间类型和2种中断执行环境，分为8种clock_base来分别管理。2种中断执行环境是指定时器任务在硬中断上下文还是软中断上下文执行，可以在创建定时任务时指定。借用<code>https://zhuanlan.zhihu.com/p/450089796</code>中的结构图，每个clock_base对应一棵红黑树，对于8核处理器总共有8*8=64棵hrtimer红黑树</p><p><img src="9.png" alt=""></p><p>在定时器中断到来时进入硬中断处理函数hrtimer_interrupt()，如果最近到期的任务是硬timer，则继续在当前中断环境下处理。如果是软timer，则挂起软中断HRTIMER_SOFTIRQ，软中断在hrtimer_run_softirq()中处理软timer任务。</p><p>hrtimers_init()只初始化cpu0的hrtimer，如cpuhp_hp_states结构体数组中列出的热插拔相关模块，其他cpu会在各自启动时调用hrtimers_prepare_cpu()初始化自己的hrtimer_cpu_base，在cpu下线时调用hrtimers_dead_cpu()将该cpu上的定时任务迁移到别的cpu。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct cpuhp_step cpuhp_hp_states[] = &#123;</span><br><span class="line">        [CPUHP_HRTIMERS_PREPARE] = &#123;</span><br><span class="line">                .name                        = "hrtimers:prepare",</span><br><span class="line">                .startup.single                = hrtimers_prepare_cpu,</span><br><span class="line">                .teardown.single        = hrtimers_dead_cpu,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-hrtimer的使用"><a href="#4-2-hrtimer的使用" class="headerlink" title="4.2 hrtimer的使用"></a>4.2 hrtimer的使用</h2><p>在内核中直接使用hrtimer示例代码如下，每8.3ms周期性触发并打印log。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static struct hrtimer timer; //创建hrtimer定时器</span><br><span class="line"></span><br><span class="line">//定时器到期处理函数</span><br><span class="line">static enum hrtimer_restart hrtimer_handler(struct hrtimer *hrt)</span><br><span class="line">&#123;</span><br><span class="line">        printk("hrtimer_handler");</span><br><span class="line">        hrtimer_forward_now(hrt, 8300000);//将超时时间向后移8300000ns=8.3ms</span><br><span class="line">        return HRTIMER_RESTART; //返回重新启动标志，无需再次调用hrtimer_start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __init hrtimer_test_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        //初始化hrtimer，使用CLOCK_MONOTONIC时间，HRTIMER_MODE_REL_HARD表示在硬中断环境下处理</span><br><span class="line">        hrtimer_init(&amp;timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);</span><br><span class="line">        timer.function = hrtimer_handler; //设置超时处理函数</span><br><span class="line">        //启动定时器</span><br><span class="line">        hrtimer_start(&amp;timer, 8300000, HRTIMER_MODE_REL_HARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit hrtimer_test_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">        hrtimer_cancel(&amp;timer);  //取消定时器  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-sched-timer"><a href="#4-3-sched-timer" class="headerlink" title="4.3 sched_timer"></a>4.3 sched_timer</h2><p>早期linux使用低精度定时器timer，代码位于kernel/time/timer.c中，虽然精度比较低，但是很多内核定时触发代码都是在这个基础上搭建的，例如调度、时间更新、各种低精度定时任务。在高精度时钟模式下，内核仍然需要周期性的tick中断，以便刷新内核的一些任务，所以仍然保留了低精度timer的角色和运作模式，通过hrtimer模拟出原本的timer，称之为sched_timer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p><p>sched_timer触发频率为CONFIG_HZ，在CONFIG_HZ=250的系统中，每4ms触发一次，也就是一个jiffies时间间隔。虽然触发时间粒度比较大，但是精度仍然是纳秒级，属于高精度定时器。</p><p>其初始化入口为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()</span><br><span class="line">|--&gt;init_timers()</span><br><span class="line">  |--&gt;  init_timer_cpus()</span><br><span class="line">  |--&gt;  posix_cputimers_init_work()</span><br><span class="line">  |--&gt;  open_softirq(TIMER_SOFTIRQ, run_timer_softirq)</span><br></pre></td></tr></table></figure><p>hrtimer切换到高精度模式时，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_switch_to_hres(void)</span><br><span class="line">|--&gt;tick_setup_sched_timer(); //设置sched_timer</span><br><span class="line">|--&gt;hrtimer_init(&amp;ts-&gt;sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);//创建一个hrtimer任务，使用mono时间，硬中断执行</span><br><span class="line">|--&gt;ts-&gt;sched_timer.function = tick_sched_timer; //设置sched_timer定时器处理函数</span><br><span class="line">|--&gt;hrtimer_set_expires(&amp;ts-&gt;sched_timer, tick_init_jiffy_update()); //设置过期时间为下个jiffies时间</span><br></pre></td></tr></table></figure><p>sched_timer定时器中断处理程序内容如下，sched_timer此时就是系统节拍定时器，不仅给调度程序提供心跳，更新jiffies，还充当了一个管理者，以jiffies时间精度给内核其他程序提供定时服务。原有的timer的功能接口，如timer_setup()、add_timer()以及其经典的time wheel方式被保留，继续给内核中其他程序提供定时服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tick_sched_timer(struct hrtimer *timer）</span><br><span class="line">|--&gt;tick_sched_do_timer(ts, now);</span><br><span class="line">    |--&gt;tick_do_update_jiffies64(now);</span><br><span class="line">      |--&gt;  jiffies_64 += ticks;     //更新jiffies变量</span><br><span class="line">    |--&gt;  calc_global_load();    //每10 jiffies计算1次全局负载</span><br><span class="line">    |--&gt;  update_wall_time();   //更新墙上时间(系统时间)</span><br><span class="line">|--&gt;tick_sched_handle(ts, regs);</span><br><span class="line">  |--&gt;  update_process_times(user_mode(regs)); //更新当前进程时间</span><br><span class="line">  |--&gt;  account_process_tick(p, user_tick); //计算进程运行tick</span><br><span class="line">  |--&gt;  run_local_timers(); //运行自己管理的低精度定时任务</span><br><span class="line">  |--&gt;  rraise_softirq(TIMER_SOFTIRQ); //通过TIMER_SOFTIRQ处理本地定时任务</span><br><span class="line">  |--&gt;  rcu_sched_clock_irq(user_tick);</span><br><span class="line">  |--&gt;  scheduler_tick(); //调度程序tick处理</span><br><span class="line">  |--&gt;  run_posix_cpu_timers(); //处理posix timer与  cpu  运行时间相关的事务</span><br><span class="line">|--&gt;hrtimer_forward(timer, now, TICK_NSEC); //下次超期时间往前推TICK_NSEC</span><br></pre></td></tr></table></figure><h1 id="5-低精度定时器timer"><a href="#5-低精度定时器timer" class="headerlink" title="5 低精度定时器timer"></a>5 低精度定时器timer</h1><h2 id="5-1-timer-wheel"><a href="#5-1-timer-wheel" class="headerlink" title="5.1 timer wheel"></a>5.1 timer wheel</h2><p>系统中可能有成千上万个低精度定时器，为了在tick到来时快速查找超期的timer，以及插入是快速找到正确的插入点，linux设计了时间轮(timer wheel)的管理方式。每个cpu都有至少一个timer_base结构管理当前cpu上的低精度定时器，有BASE_STD和BASE_DEF两种类型，前者是标准定时器必须存在，后者表示可延时定时器，当配置了NO_HZ模式，才会有BASE_DEF。每个timer_base通过64*9=576个桶(bucket)来记录所有定时器，下图中的数字是桶编号，而非时间。这个排列不是线性的，而是每隔64个桶，设定一个等级(level)，随着level升高，相邻2个桶之间的时间差值也越来越大。例如level 0中每个桶之间间隔时间为1个tick，level 1为8个tick，level2为8*8=64个。相邻2桶差值越大，意味着插入定时器时，多个时间将会被折叠到同一个桶中，时间精度也就越低，同一个桶将在同一时间被触发执行。</p><p><img src="10.png" alt=""></p><p>  经过多个版本迭代，在目前6.1版本上，查找和插入的已经达到了O(1)的复杂度，非常高效，但是高效是通过牺牲精度换来的。插入定时器时，timer wheel根据超期时间(expires)距离当前的时间长短，分为不同等级(level)的时间轮中。如下表中HZ=250配置下的粒度(精度的倒数)及定时范围表，距离当前时间越久的任务会被放置到level越高的时间轮，精度牺牲也越大。选择好level后，再根据超期绝对时间expires，将该定时器散列到所选level中的64个桶之一，来确定桶编号。在每tick查找超期定时器时，由于level=0粒度为1 tick，所以在每个tick时都会查找level 0时间轮有没有超期；level 1粒度为8 ticks，每8个tick才会查找level=1有没有超期，以此类推，每64个tick查找level 2。</p><p>  例如想定时在4097个tick(16.388s)后触发，该任务将会被加入到level=3的时间轮中，会在(4097+511)=4608 tick时触发该定时器，这就意味着比原定时时间整整晚了2.044s。牺牲这部分精度，保证了查找的效率，这是权衡的结果，毕竟定时时间越长往往意味着对精度的要求越低。如果定时时间刚好是该level粒度的整数倍，例如4096、4608都为level=3粒度512的整数倍，那么将不会有精度损失。</p><p><img src="11.png" alt=""></p><p>  为了严谨，写一个测试程序定时4097个ticks，然后超时触发时打印当前与上次触发的jiffies时间差，发现log打印时间间隔确实为4608。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static struct timer_list low_timer;</span><br><span class="line">static unsigned long last_jiffies = 0;</span><br><span class="line">static void low_timer_handler(struct timer_list *low_timer)</span><br><span class="line">&#123;</span><br><span class="line">    low_timer-&gt;expires = jiffies + 4097;</span><br><span class="line">    add_timer(low_timer);</span><br><span class="line">    printk("timer trigger delta jiffies=%lu", jiffies - last_jiffies);</span><br><span class="line">    last_jiffies = jiffies;</span><br><span class="line">&#125;</span><br><span class="line">static void low_timer_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    low_timer.expires = jiffies + 4097;</span><br><span class="line">    last_jiffies = jiffies;</span><br><span class="line">    timer_setup(&amp;low_timer, low_timer_handler, 0);</span><br><span class="line">    add_timer(&amp;low_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log打印如下</span><br><span class="line">[   41.954607] timer trigger delta jiffies=4608</span><br><span class="line">[   60.386567] timer trigger delta jiffies=4608</span><br><span class="line">[   78.818564] timer trigger delta jiffies=4608</span><br></pre></td></tr></table></figure><p>  首先看插入定时器逻辑，从add_timer开始，假设已经初始化完成了struct timer_list结构体的expires超时时间(绝对jiffies)和处理函数。核心是calc_index函数，根据超期绝对时间expires，当前时间clk，计算出将要插入的桶以及这个桶对应的绝对超时时间bucket_expiry。idx表示将要插入的桶编号，而桶超时时间bucket_expiry，受level精度的影响，是定时器超时时间expires对粒度向上取整对齐。</p><p>  根据相对时间(expires - clk)确定level，然后对expires按照level精度向上取整得到bucket_expiry。idx计算比较难理解，以level=1举例，expires/8得到当前level粒度的倍数，然后对64取余抹除不相关的高位，得到在level 1中的位置偏移量，然后加上level 1的初始偏移64得到最终的idx。之所以这样做是为了查找方便，查找时根据expires可以方便的找出idx。得到idx和bucket_expiry，就将该定时器插入到idx对应的桶链表中，并将桶到期时间更新为bucket_expiry，然后将idx对应的pending_map位置1，完成定时器插入。idx和bucket_expiry计算都是O(1)，链表插入也是O(1)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add_timer(struct timer_list *timer)；</span><br><span class="line">|--&gt;__mod_timer(timer, timer-&gt;expires, MOD_TIMER_NOTPENDING);</span><br><span class="line">    |--&gt;internal_add_timer(base, timer);</span><br><span class="line">        |--&gt;idx = calc_wheel_index(timer-&gt;expires, base-&gt;clk, &amp;bucket_expiry)；</span><br><span class="line">            |--&gt;return calc_index(expires, lvl, bucket_expiry);</span><br><span class="line">        |--&gt;enqueue_timer(base, timer, idx, bucket_expiry);</span><br><span class="line">                </span><br><span class="line">static inline unsigned calc_index(unsigned long expires, unsigned lvl,</span><br><span class="line">                  unsigned long *bucket_expiry)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned idx;</span><br><span class="line">    trace_android_vh_timer_calc_index(lvl, &amp;expires); //*expires-=1</span><br><span class="line">    expires = (expires &gt;&gt; LVL_SHIFT(lvl)) + 1;</span><br><span class="line">    *bucket_expiry = expires &lt;&lt; LVL_SHIFT(lvl);</span><br><span class="line">    idx = LVL_OFFS(lvl) + (expires &amp; LVL_MASK);</span><br><span class="line">    return idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  下面是定时器查找过程，也就是到达某个tick时，应该如何判断哪些定时器超时。处理流程从run_local_timers开始，也就是sched_timer定时处理事务中的一环。run_local_timers不会直接处理定时器任务，而是发起软中断TIMER_SOFTIRQ，处理函数为run_timer_softirq来处理当前cpu的定时器任务。核心函数是collect_expired_timers，该函数查找出所有超时的定时器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">run_local_timers</span><br><span class="line">|--&gt;hrtimer_run_queues(); //通知hrtimer，因为在开启高精度模式之前，由timer驱动hrtimer</span><br><span class="line">    |--&gt;if (__hrtimer_hres_active(cpu_base))return; //如果开启了高精度模式，则直接退出</span><br><span class="line">|--&gt;raise_softirq(TIMER_SOFTIRQ); //唤醒TIMER_SOFTIRQ软中断，对应中断函数为run_timer_softirq</span><br><span class="line">//以下为软中断处理</span><br><span class="line">run_timer_softirq</span><br><span class="line">|--&gt;base = this_cpu_ptr(&amp;timer_bases[BASE_STD]); //获取当前cpu的timer_base</span><br><span class="line">|--&gt;__run_timers(base)</span><br><span class="line">    |--&gt;levels = collect_expired_timers(base, heads) //根据pending_map位图获取到期的bucket，并移动到heads中</span><br><span class="line">    |--&gt;base-&gt;next_expiry = __next_timer_interrupt(base)</span><br><span class="line">    |--&gt;while (levels--)expire_timers(base, heads + levels); //依次处理heads中的超期定时器</span><br></pre></td></tr></table></figure><p>  collect_expired_timers会根据当前时间clk从level 0开始逐级查找，是否查找当前level的判断标准是clk是否为8^level的倍数。level 0必然会被查找到，查找的idx为clk对64取余忽略掉高于6bit的所有位，得到0~63的编号，然后看该idx的pending_map是否置位(是否有定时器)，如果有就加入到待处理链表heads。level0处理完后，判断clk如果不是8的倍数，也就更不可能是64等更高的倍数，所以直接退出查找过程；如果clk是8的倍数，则让clk=clk/8，然后按照level 0的方式查找level1，依次类推。每个level最多查找1次，共9个level，时间复杂度O1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int collect_expired_timers(struct timer_base *base,</span><br><span class="line">                  struct hlist_head *heads)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long clk = base-&gt;clk = base-&gt;next_expiry;</span><br><span class="line">    struct hlist_head *vec;</span><br><span class="line">    int i, levels = 0;</span><br><span class="line">    unsigned int idx;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; LVL_DEPTH; i++) &#123;</span><br><span class="line">        idx = (clk &amp; LVL_MASK) + i * LVL_SIZE;</span><br><span class="line"></span><br><span class="line">        if (__test_and_clear_bit(idx, base-&gt;pending_map)) &#123;</span><br><span class="line">            vec = base-&gt;vectors + idx;</span><br><span class="line">            hlist_move_list(vec, heads++);</span><br><span class="line">            levels++;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Is it time to look at the next level? */</span><br><span class="line">        if (clk &amp; LVL_CLK_MASK)</span><br><span class="line">            break;</span><br><span class="line">        /* Shift clock for the next level granularity */</span><br><span class="line">        clk &gt;&gt;= LVL_CLK_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    return levels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面举一个例子说明timer whell工作过程，假设当前时间clk=100 jiffies。此时添加2个定时器，超时时间分别为162，164，delta分别为62，64，根据add_timer逻辑，2个定时器会被分别添加到level 0和level1对应的桶中。其中162的实际超时时间为162，164的实际超时时间为168。</p><p><img src="12.png" alt=""></p><p>当时间进行到clk=150时，再次添加同样的超时时间为164的定时器，由于此时的delta时间为164-150=14，所以添加到level 0中idx为(164%64)=36桶中，</p><p><img src="13.png" alt=""></p><p>当时间到clk=164时，查找命中level 0中164，所以直接处理。由于level 1中的164实际超时时间为168，并没有得到处理。</p><p><img src="14.png" alt=""></p><p>当时间来到clk=168时，为8的倍数，查找level 1中168桶，其中的定时器全部移除，包括之前插入的164。可见先插入的164实际执行晚于后插入的164，因为其插入是delta较大，被安排到更低精度的level中</p><p><img src="15.png" alt=""></p><h2 id="5-2-使用实例watchdog-timer"><a href="#5-2-使用实例watchdog-timer" class="headerlink" title="5.2 使用实例watchdog timer"></a>5.2 使用实例watchdog timer</h2><p>Watchdog timer分为硬件看门狗和软件喂狗定时器，如果linux运行在虚拟机中，硬件看门狗定时器被host主机管理，linux通过smc调用与host通信来设置硬件看门狗bark/bite时间。linux上创建watchdog线程，并以最高优先级prio=0调度。通过软件sched_timer低精度定时器创建定时任务，每隔pet时间触发一次。当喂狗时间到期(expires)，watchdog线程通过smp_call_function_single ping其他cpu，也就是向其他cpu发送函数调用中断(Function call interrupts，IPI核间中断之一)，并等待其全部返回，如果全部返回，说明所有cpu正常响应中断，于是通过smc调用到host给清除硬件看门狗计数。然后watchdog线程通过软件定时器设置下次喂狗时间，如此往复。另外，喂狗时间配置为15.360s，也就是3840个ticks(HZ=250)，根据时间轮的算法，3840位于level 2且正好是精度64tick的整数倍，这可以将精度损失降到最小。</p><p>但是如果某个cpu长时间关闭中断，无法响应IPI请求，watchdog线程阻塞无法去喂狗，host的看门狗计数超过bark时间，会向linux发送bark中断触发panic。如果到bite时间，host会向TZ发送FIQ中断来拉低PS_HOLD进入ramdump，主要是防止linux上所有cpu都无法响应，无法触发panic的情况。</p><p><img src="16.png" alt=""></p><h1 id="6-用户态定时器API"><a href="#6-用户态定时器API" class="headerlink" title="6 用户态定时器API"></a>6 用户态定时器API</h1><h2 id="6-1-nanosleep"><a href="#6-1-nanosleep" class="headerlink" title="6.1 nanosleep"></a>6.1 nanosleep</h2><p>nanosleep基于hrtimer来实现纳秒级延时，内核中提供hrtimer_nanosleep接口，并且封装成系统调用nanosleep给用户空间使用。其核心是do_nanosleep，会将线程设置为TASK_INTERRUPTIBLE|TASK_FREEZABLE状态，然后调度出去，当定时时间到期后，定时器中断唤醒该task。从2.3时钟源精度52ns就可以看出，在加上这里会有任务调度，和代码执行耗时，真想实现ns级延时是不现实的，微秒级应该是可以的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)</span><br><span class="line">&#123;</span><br><span class="line">    struct restart_block *restart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);</span><br><span class="line">        hrtimer_sleeper_start_expires(t, mode);</span><br><span class="line"></span><br><span class="line">        if (likely(t-&gt;task))</span><br><span class="line">            schedule();</span><br><span class="line"></span><br><span class="line">        hrtimer_cancel(&amp;t-&gt;timer);</span><br><span class="line">        mode = HRTIMER_MODE_ABS;</span><br><span class="line"></span><br><span class="line">    &#125; while (t-&gt;task &amp;&amp; !signal_pending(current));</span><br><span class="line"></span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-itimer"><a href="#6-2-itimer" class="headerlink" title="6.2 itimer"></a>6.2 itimer</h2><p>itimer基于hrtimer和信号配合实现，通过hrtimer设置高精度超时时间，到期后通过信号方式通知进程。itimer提供下面三种定时方式，收到的信号也不同。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>定时类型</td><td>含义</td><td>到期信号</td></tr><tr><td>ITIMER_REAL</td><td>真实时间</td><td>SIGALRM</td></tr><tr><td>ITIMER_VIRTUAL</td><td>当前进程在用户态实际执行时间</td><td>SIGVTALRM</td></tr><tr><td>ITIMER_PROF</td><td>当前进程在用户态和内核态实际执行时间</td><td>SIGPROF</td></tr></tbody></table></div><p>如下signal_struct结构体定义中包含的定时器相关的成员，与itimer相关的有，real_timer是该线程对应真实时间hrtimer定时器，it[2]是2种cpu执行时间定时的cpu_itimer定时器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct signal_struct &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ifdef CONFIG_POSIX_TIMERS</span></span><br><span class="line"></span><br><span class="line">        /* POSIX.1b Interval Timers */</span><br><span class="line">        int                        posix_timer_id;</span><br><span class="line">        struct list_head        posix_timers;</span><br><span class="line"></span><br><span class="line">        /* ITIMER_REAL timer for the process */</span><br><span class="line">        struct hrtimer real_timer;</span><br><span class="line">        ktime_t it_real_incr;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * ITIMER_PROF and ITIMER_VIRTUAL timers for the process, we use</span><br><span class="line">         * CPUCLOCK_PROF and CPUCLOCK_VIRT for indexing array as these</span><br><span class="line">         * values are defined to 0 and 1 respectively</span><br><span class="line">         */</span><br><span class="line">        struct cpu_itimer it[2];</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Thread group totals for process CPU timers.</span><br><span class="line">         * See thread_group_cputimer(), et al, for details.</span><br><span class="line">         */</span><br><span class="line">        struct thread_group_cputimer cputimer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line">        /* Empty if CONFIG_POSIX_TIMERS=n */</span><br><span class="line">        struct posix_cputimers posix_cputimers;</span><br><span class="line"></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>ITIMER_REAL是真实时间定时，也是最常规的，在线程被fork出来时，会在copy_signal中初始化real_timer，设置超时函数it_real_fn。在超时函数中发送SIGALRM给当前线程所属的进程tgid，所以同一个进程内，同时只能有一个线程使用ITIMER_REAL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#</span><span class="bash">ifdef CONFIG_POSIX_TIMERS</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;sig-&gt;posix_timers);</span><br><span class="line">    hrtimer_init(&amp;sig-&gt;real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">    sig-&gt;real_timer.function = it_real_fn;</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum hrtimer_restart it_real_fn(struct hrtimer *timer)</span><br><span class="line">&#123;</span><br><span class="line">    struct signal_struct *sig =</span><br><span class="line">        container_of(timer, struct signal_struct, real_timer);</span><br><span class="line">    struct pid *leader_pid = sig-&gt;pids[PIDTYPE_TGID];</span><br><span class="line"></span><br><span class="line">    trace_itimer_expire(ITIMER_REAL, leader_pid, 0);</span><br><span class="line">    kill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);</span><br><span class="line"></span><br><span class="line">    return HRTIMER_NORESTART;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ITIMER_REAL使用示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;signal.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">static int itimer_count = 0;</span><br><span class="line">struct itimerval timer_set;</span><br><span class="line">void sig_handler(int signo)</span><br><span class="line">&#123;</span><br><span class="line">    if(++itimer_count&gt;=5)&#123;</span><br><span class="line">        timer_set.it_value.tv_sec = 0;</span><br><span class="line">        timer_set.it_value.tv_usec = 0;</span><br><span class="line">        timer_set.it_interval.tv_sec = 0;</span><br><span class="line">        timer_set.it_interval.tv_usec = 0;</span><br><span class="line">        //5*2=10s后，将timer_set所有成员清0，然后调用setitimer停止定时器</span><br><span class="line">        setitimer(ITIMER_REAL, &amp;timer_set, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;"recieve sigal: "&lt;&lt;signo&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGALRM, sig_handler);</span><br><span class="line"></span><br><span class="line">    //2s后启动</span><br><span class="line">    timer_set.it_value.tv_sec = 2;</span><br><span class="line">    timer_set.it_value.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    //定时器间隔：2s</span><br><span class="line">    timer_set.it_interval.tv_sec = 2;</span><br><span class="line">    timer_set.it_interval.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    //设置定时器</span><br><span class="line">    if(setitimer(ITIMER_REAL, &amp;timer_set, NULL) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;"start timer failed..."&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    std::cin&gt;&gt;temp;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于另外2种cpu运行时间相关定时器，设置接口也是setitimer，但是clock类型选择ITIMER_VIRTUAL或者ITIMER_PROF。cpu timer实现方式比较复杂，流程是在tick事件处理时，通过run_posix_cpu_timers来检查cpu_timer，并向到期的timer发送对应的信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">run_posix_cpu_timers</span><br><span class="line">|--&gt;struct task_struct *tsk = current</span><br><span class="line">|--&gt;__run_posix_cpu_timers(tsk)</span><br><span class="line">    |--&gt;handle_posix_cpu_timers(tsk)</span><br><span class="line">        |--&gt;check_thread_timers(tsk, &amp;firing);  //检查线程时间tsk-&gt;cpu_timers[N]</span><br><span class="line">        |--&gt;check_process_timers(tsk, &amp;firing); //检查进程时间tsk-&gt;signal-&gt;cpu_timers[N]</span><br><span class="line">            |--&gt;collect_posix_cputimers(pct, samples, firing);</span><br><span class="line">            |--&gt;check_cpu_itimer(SIGPROF)   //检查用户态和内核态总时间</span><br><span class="line">                |--&gt;send_signal_locked(SIGPROF, SEND_SIG_PRIV, tsk, PIDTYPE_TGID);//如果到期则发送SIGPROF信号</span><br><span class="line">            |--&gt;check_cpu_itimer(SIGVTALRM) //检查用户态时间</span><br><span class="line">                |--&gt;send_signal_locked(SIGVTALRM, SEND_SIG_PRIV, tsk, PIDTYPE_TGID);//如果到期则发送SIGVTALRM信号</span><br></pre></td></tr></table></figure><h2 id="6-3-alarm"><a href="#6-3-alarm" class="headerlink" title="6.3 alarm"></a>6.3 alarm</h2><p>alarm基于itimer实现来定时，并且以秒为单位，时间到内核会给该进程发送SIGALRM信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(alarm, unsigned int, seconds)</span><br><span class="line">&#123;</span><br><span class="line">    return alarm_setitimer(seconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static unsigned int alarm_setitimer(unsigned int seconds)</span><br><span class="line">&#123;</span><br><span class="line">    struct itimerspec64 it_new, it_old;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> BITS_PER_LONG &lt; 64</span></span><br><span class="line">    if (seconds &gt; INT_MAX)</span><br><span class="line">        seconds = INT_MAX;</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br><span class="line">    it_new.it_value.tv_sec = seconds;</span><br><span class="line">    it_new.it_value.tv_nsec = 0;</span><br><span class="line">    it_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;</span><br><span class="line"></span><br><span class="line">    do_setitimer(ITIMER_REAL, &amp;it_new, &amp;it_old);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We can't return 0 if we have an alarm pending ...  And we'd</span><br><span class="line">     * better return too much than too little anyway</span><br><span class="line">     */</span><br><span class="line">    if ((!it_old.it_value.tv_sec &amp;&amp; it_old.it_value.tv_nsec) ||</span><br><span class="line">          it_old.it_value.tv_nsec &gt;= (NSEC_PER_SEC / 2))</span><br><span class="line">        it_old.it_value.tv_sec++;</span><br><span class="line"></span><br><span class="line">    return it_old.it_value.tv_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程在调用alarm定时之前，需要设置SIGALRM信号的处理函数。参数很简单，只有一个秒，使用代码示例如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"></span><br><span class="line">void sig_handler(int signum) &#123;</span><br><span class="line">    printf("Received SIGALRM, timer expired!\n");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    signal(SIGALRM, sig_handler);</span><br><span class="line">    alarm(5);</span><br><span class="line">    printf("Waiting for alarm...\n");</span><br><span class="line">    pause(); // Suspend the process until a signal is received</span><br><span class="line">    printf("Exiting...\n");</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-Posix-timer"><a href="#6-4-Posix-timer" class="headerlink" title="6.4 Posix timer"></a>6.4 Posix timer</h2><p>Posix timer大大扩展了itimer的功能，一个进程可以同时创建任意个timer，并且可以指定到期信号。Posix timer封装了多个syscall接口：</p><p>  创建定时器：timer_create<br>  删除定时器：timer_delete<br>  设置定时器时间：timer_settime<br>  获取定时器剩余：timer_gettime</p><p>通过which_clock参数来区分使用哪种时间类型来计时，下面是支持的时间类型。此外还提供了clock_gettime()、clock_settime()、clock_adjtime()、clock_getres()系统调用来获取和设置各种类型时间信息，属于大一统的接口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static const struct k_clock * const posix_clocks[] = &#123;</span><br><span class="line">    [CLOCK_REALTIME]        = &amp;clock_realtime,</span><br><span class="line">    [CLOCK_MONOTONIC]       = &amp;clock_monotonic,</span><br><span class="line">    [CLOCK_PROCESS_CPUTIME_ID]  = &amp;clock_process,</span><br><span class="line">    [CLOCK_THREAD_CPUTIME_ID]   = &amp;clock_thread,</span><br><span class="line">    [CLOCK_MONOTONIC_RAW]       = &amp;clock_monotonic_raw,</span><br><span class="line">    [CLOCK_REALTIME_COARSE]     = &amp;clock_realtime_coarse,</span><br><span class="line">    [CLOCK_MONOTONIC_COARSE]    = &amp;clock_monotonic_coarse,</span><br><span class="line">    [CLOCK_BOOTTIME]        = &amp;clock_boottime,</span><br><span class="line">    [CLOCK_REALTIME_ALARM]      = &amp;alarm_clock,</span><br><span class="line">    [CLOCK_BOOTTIME_ALARM]      = &amp;alarm_clock,</span><br><span class="line">    [CLOCK_TAI]         = &amp;clock_tai,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-5-timer-fd"><a href="#6-5-timer-fd" class="headerlink" title="6.5 timer_fd"></a>6.5 timer_fd</h2><p>timer_fd是一个基于文件描述符的定时器接口，精度为纳秒级，直接基于hrtimer实现。提供三个接口函数，通过文件描述符的可读事件进行超时通知。通过timerfd_create在内核创建一个定时器实例，并返回一个文件描述符fd，通过timerfd_settime(fd)设置超时时间。由于不是基于信号通知，进程需要通过select、poll、epoll等io机制，监听fd的事件，来实现异步事件通知。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/timerfd.h&gt;</span></span><br><span class="line">int timerfd_create(int clockid, int flags);</span><br><span class="line">int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);</span><br><span class="line">int timerfd_gettime(int fd, struct itimerspec *curr_value);</span><br></pre></td></tr></table></figure><p>以下是timer_fd的使用示例代码，每隔1s触发一次，每次触发都要重新设置，并且设置的时间都是绝对时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Timers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mTimerFd, mEpollFd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_set_timer</span><span class="params">(<span class="keyword">int</span> TimerFd, <span class="keyword">int64_t</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">old_timer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">new_timer</span> &#123;</span></span><br><span class="line">        .it_interval = &#123;.tv_sec = <span class="number">0</span>, .tv_nsec = <span class="number">0</span>&#125;,</span><br><span class="line">        .it_value = &#123;.tv_sec = (<span class="keyword">long</span>)(time / <span class="number">1000000000</span>),</span><br><span class="line">                     .tv_nsec = (<span class="keyword">long</span>)(time % <span class="number">1000000000</span>)&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timerfd_settime(TimerFd, TFD_TIMER_ABSTIME, &amp;new_timer, &amp;old_timer))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Failed to set timerfd %s (%i)"</span>, strerror(errno), errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_loop</span><span class="params">(<span class="keyword">int</span> mTimerFd, <span class="keyword">int</span> mEpollFd)</span></span>&#123;</span><br><span class="line">    epoll_event timerEvent;</span><br><span class="line">    timerEvent.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mTimerFd, &amp;timerEvent) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error adding timer fd to epoll dispatch loop"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        epoll_event events;</span><br><span class="line">        <span class="keyword">uint64_t</span> mIgnored = <span class="number">0</span>;</span><br><span class="line">        epoll_wait(mEpollFd, &amp;events, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">read</span>(mTimerFd, &amp;mIgnored, <span class="keyword">sizeof</span>(mIgnored));</span><br><span class="line"></span><br><span class="line">        my_set_timer(mTimerFd, systemTime(SYSTEM_TIME_MONOTONIC) + <span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timer_fd triggerd, do something\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mTimerFd, mEpollFd;</span><br><span class="line">    mTimerFd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);</span><br><span class="line">    mEpollFd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create mTimerFd=%d, mEpollFd=%d\n"</span>, mTimerFd, mEpollFd);</span><br><span class="line"></span><br><span class="line">    my_set_timer(mTimerFd, systemTime(SYSTEM_TIME_MONOTONIC) + <span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>); <span class="comment">//1s</span></span><br><span class="line"></span><br><span class="line">    timer_loop(mTimerFd, mEpollFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>  <a href="https://kernel.meizu.com/2018/07/12//linux-time.html/">https://kernel.meizu.com/2018/07/12//linux-time.html/</a><br>  <a href="https://kernel.meizu.com/2016/07/20//linux-tick-and-tickless.html/">https://kernel.meizu.com/2016/07/20//linux-tick-and-tickless.html/</a><br>  <a href="https://www.zhihu.com/question/271018947/answer/2146053897" target="_blank" rel="noopener">https://www.zhihu.com/question/271018947/answer/2146053897</a><br>  <a href="http://t.csdnimg.cn/2HrYd" target="_blank" rel="noopener">http://t.csdnimg.cn/2HrYd</a><br>  <a href="https://blog.csdn.net/flyingnosky/article/details/126310866" target="_blank" rel="noopener">https://blog.csdn.net/flyingnosky/article/details/126310866</a><br>  <a href="https://zhuanlan.zhihu.com/p/450089796" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/450089796</a><br>  <a href="https://zhuanlan.zhihu.com/p/611286101" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/611286101</a><br>  <a href="https://blog.csdn.net/weixin_43705457/article/details/124393182" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43705457/article/details/124393182</a></p>]]></content>
      
      
      <categories>
          
          <category> 时间管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hrtimer </tag>
            
            <tag> 定时器 </tag>
            
            <tag> monotonic time </tag>
            
            <tag> timekeeper </tag>
            
            <tag> clocksource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>焕新存储技术：UFS 4.0 FBO 底层逻辑剖析</title>
      <link href="/2023/11/23/Analysis-of-the-USB-4-0-FBO/"/>
      <url>/2023/11/23/Analysis-of-the-USB-4-0-FBO/</url>
      
        <content type="html"><![CDATA[<p>FBO (File Based Optimization) 是 UFS 4.0 标准中新引入的功能，用于优化 UFS 长久使用后由于文件碎片导致的读写性能下降问题。了解 FBO 之前我们先了解下 UFS 的一些基本概念及文件碎片问题。</p><h2 id="一、FBO-诞生的原因"><a href="#一、FBO-诞生的原因" class="headerlink" title="一、FBO 诞生的原因"></a>一、FBO 诞生的原因</h2><p>UFS (Universal Flash Storage) 通用闪存存储器以良好的性能被广泛用在手机、平板等设备上。UFS 协议由 JEDEC 协会制定，2022年推出了4.0标准。UFS 由闪存和控制器组成，闪存 (Flash) 是存储数据的实际介质，控制器处理主机 (Host) 指令和管理闪存。控制器负责磨损均衡、垃圾回收、掉电恢复、坏块管理等功能外，维护了 L2P (Logical To Physical) 逻辑地址到物理地址的映射表来管理闪存数据的读取写入地址。</p><p><img src="1.png" alt=""></p><p>闪存将存储空间划分为一个个物理块，使用 PBA (Physical Block Address) 物理块地址来寻址。操作系统在逻辑空间划分了逻辑块，使用LBA (Logical Block Address) 逻辑块地址来寻址。用户访问文件数据时，系统先找到文件对应的 LBA 发送给 UFS，UFS 控制器查阅 L2P 映射表找到对应的 PBA，通过访问物理空间得到要访问的数据。理想情况下在逻辑空间和物理空间用连续的块来存储一个文件，这样用起始地址和长度可以一次性访问更多的空间，如果文件被分散存储则需要更多的查阅映射表和执行 IO 操作。</p><p><img src="2.png" alt=""></p><p>现实中受多用户同时写入，文件大小变化等因素影响，一个文件在逻辑空间和物理空间被存放在了多个不连续的块中。逻辑空间不连续称为逻辑碎片化，物理空间不连续称为物理碎片化。除了写入的不连续外，UFS 控制器在执行垃圾回收、坏块管理等块搬移操作时也可能把原本连续块的数据搬移到不连续的块上。UFS 使用较长的时间后，闪存上的文件碎片会越来越多，新的文件可能由于没有分配到连续的物理空间在写入时写到了不连续的块上，久而久之，存储卡的读写性能下降，设备越来越卡。</p><p><img src="3.png" alt=""></p><p>为了优化这个问题，FBO 诞生了！FBO 的功能是消除物理碎片化，也就是将物理空间上不连续的文件整理成物理连续的文件，从而优化由于文件碎片导致的 UFS 读写性能问题。实验证明，使用 FBO 功能的 UFS 测试组在经过长期读写测试，性能未见明显下降，与未使用 FBO 功能的测试组形成鲜明对比，该性能测试对于采用“本地更新”机制的文件系统如 ext4 更明显。</p><p><img src="4.png" alt=""></p><h2 id="二、FBO-功能的实现"><a href="#二、FBO-功能的实现" class="headerlink" title="二、FBO 功能的实现"></a>二、FBO 功能的实现</h2><p>FBO 的实现依赖于主机 (Host) 端驱动和 UFS (Device) 端固件的共同协作，在 UFS 4.0 标准中描述了FBO 实现的流程。主机负责整个流程的控制，通过 bFBOControl 值请求 UFS 执行相应的操作。UFS 负责处理主机指令对闪存进行基于文件的优化，通过 bFBOProgressState 值告知主机 FBO 操作的状态。UFS 端固件一般由 UFS 供应商实现，我们主要关注主机端驱动的实现。FBO 分为两个阶段：分析阶段和优化阶段。</p><p><img src="5.png" alt=""></p><h3 id="2-1-分析阶段"><a href="#2-1-分析阶段" class="headerlink" title="2.1 分析阶段"></a>2.1 分析阶段</h3><p>分析阶段主机获取 UFS 设备 FBO 信息，主机将想要优化的文件的 LBA 告诉 UFS，UFS 查询这个文件在闪存中物理碎片化的程度并告知主机。</p><p><img src="6.png" alt=""></p><ul><li>Get FBO_Descriptor：主机端发起请求获取 UFS 设备 FBO Descriptor。UFS 回复信息：FBO 版本、建议的 LBA 范围大小、最大 LBA 范围大小、最小 LBA 范围大小、最大 LBA 范围个数、LBA 范围对齐。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* FBO Descriptor idn&#x3D;0xA *&#x2F;</span><br><span class="line">int ufshcd_query_descriptor_retry(struct ufs_hba *hba,</span><br><span class="line">                  enum query_opcode opcode,</span><br><span class="line">                  enum desc_idn idn, u8 index,</span><br><span class="line">                  u8 selector,</span><br><span class="line">                  u8 *desc_buf, int *buf_len);</span><br></pre></td></tr></table></figure><ul><li>Set FBO_WriteBuffer：主机端发送想要进行整理的文件的信息给 UFS 设备，信息按 FBO WriteBuffer 格式发送。文件的一个逻辑块碎片作为一个 ENTRY 最多存放255个 ENTRY，ENTRY 中包含逻辑块起始地址和长度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* cmd[0]&#x3D;WRITE_BUFFER; cmd[2]&#x3D;0x1; opf&#x3D;REQ_OP_DRV_OUT;*&#x2F;</span><br><span class="line">int scsi_execute_cmd(struct scsi_device *sdev, const unsigned char *cmd,</span><br><span class="line">                     blk_opf_t opf, void *buffer, unsigned int bufflen,</span><br><span class="line">                     int timeout, int retries,</span><br><span class="line">                     const struct scsi_exec_args *args);</span><br></pre></td></tr></table></figure><p><img src="7.png" alt=""></p><ul><li>Set bFBOControl=0x1：主机端请求 UFS 进行分析，UFS 收到后对文件的物理碎片化进行分析</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* opcode&#x3D;UPIU_QUERY_OPCODE_WRITE_ATTR; FBO Control idn&#x3D;0x31; *attr_val&#x3D;0x1 *&#x2F;</span><br><span class="line">int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,</span><br><span class="line">                      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);</span><br></pre></td></tr></table></figure><ul><li>Get bFBOProgressState：主机端发起获取 UFS 分析状态的请求，UFS 返回分析状态，主机轮询等待设备分析完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* opcode&#x3D;UPIU_QUERY_OPCODE_READ_ATTR; FBO Progress State idn&#x3D;0x33 *&#x2F;</span><br><span class="line">int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,</span><br><span class="line">                      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);</span><br></pre></td></tr></table></figure><ul><li>Get FBOReadBuffer：主机收到 UFS 返回的分析完成状态后，读取 FBOReadBuffer 获取 FBO 分析结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* cmd[0]&#x3D;READ_BUFFER; cmd[2]&#x3D;0x2; opf&#x3D;REQ_OP_DRV_IN;*&#x2F;</span><br><span class="line">int scsi_execute_cmd(struct scsi_device *sdev, const unsigned char *cmd,</span><br><span class="line">                     blk_opf_t opf, void *buffer, unsigned int bufflen,</span><br><span class="line">                     int timeout, int retries,</span><br><span class="line">                     const struct scsi_exec_args *args);</span><br></pre></td></tr></table></figure><p><img src="8.png" alt=""></p><h3 id="2-2-优化阶段"><a href="#2-2-优化阶段" class="headerlink" title="2.2 优化阶段"></a>2.2 优化阶段</h3><p>优化阶段主机告诉 UFS 设备要执行 FBO 的 Regression Level 范围，UFS 根据等级范围和前面 WriteBuffer 找到的文件进行闪存碎片化整理。</p><p><img src="9.png" alt=""></p><ul><li>Set FBOExecuteThreshold：主机发送想要 UFS 设备对那个 Regression Level 范围执行文件优化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* opcode&#x3D;UPIU_QUERY_OPCODE_WRITE_ATTR; FBO Execute Threshold idn&#x3D;0x32 *&#x2F;</span><br><span class="line">int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,</span><br><span class="line">                      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);</span><br></pre></td></tr></table></figure><p><img src="10.png" alt=""></p><ul><li>Set bFBOControl=0x2：主机端请求 UFS 执行 FBO，UFS 收到后进行基于文件的优化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* opcode&#x3D;UPIU_QUERY_OPCODE_WRITE_ATTR; FBO Control idn&#x3D;0x31; *attr_val&#x3D;0x2 *&#x2F;</span><br><span class="line">int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,</span><br><span class="line">                      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);</span><br></pre></td></tr></table></figure><ul><li>Get bFBOProgressState：主机端发起获取 UFS 优化状态的请求，UFS 返回优化状态，主机轮询等待设备优化完成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* opcode&#x3D;UPIU_QUERY_OPCODE_READ_ATTR; FBO Progress State idn&#x3D;0x33 *&#x2F;</span><br><span class="line">int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,</span><br><span class="line">                      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);</span><br></pre></td></tr></table></figure><h3 id="NOTE-FBO-操作和-UFS-其他操作是独立的，不会相互影响。"><a href="#NOTE-FBO-操作和-UFS-其他操作是独立的，不会相互影响。" class="headerlink" title="NOTE: FBO 操作和 UFS 其他操作是独立的，不会相互影响。"></a><em><strong>NOTE:</strong></em> <em><strong>FBO 操作和 UFS 其他操作是独立的，不会相互影响。</strong></em></h3><h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><ol><li>JEDEC STANDARD - JESD231JEDEC STANDARD</li></ol>]]></content>
      
      
      <categories>
          
          <category> 储存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析高通 mvp 进程优先调度</title>
      <link href="/2023/11/10/Qcom_mvp/"/>
      <url>/2023/11/10/Qcom_mvp/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>众所周知，原生 Linux 内核大部分进程是采用完全公平调度CFS（Completely Fair Scheduler），服务于 PC 机/服务器/Android设备/嵌入式设备等等。然而 Android 设备要求前台应用具有交互和UI的高响应性和高流畅性。原来不区分前后台应用的 CFS 机制似乎没有专门为交互设备考虑到这点，以至于国内大厂纷纷魔改内核调度策略，如 vip 线程、不公平调度、UI First、Turbo X等，慢半拍的厂商甚至名字都取不上了。下面我们基于 github 已公开的源码，梳理一下芯片原厂高通的 cfs 线程 mvp 优先调度策略。</p><p><img src="1.png" alt=""></p><p>Linux 标准内核完全公平调度总是选择虚拟时间最小的进程进行调度，这样对于滑动、游戏等游戏场景的任务调度来讲会导致重要进程的 runnable 时间长，schedule latency 时间长，没有能够及时调度执行，导致丢帧卡顿、响应不及时等问题。为了解决卡顿丢帧等问题，需要对哪些重要的线程进行优先调度呢？</p><h1 id="二、内核调度流程简介"><a href="#二、内核调度流程简介" class="headerlink" title="二、内核调度流程简介"></a>二、内核调度流程简介</h1><h2 id="2-1-相关结构体"><a href="#2-1-相关结构体" class="headerlink" title="2.1 相关结构体"></a>2.1 相关结构体</h2><ol><li><p>task_struct<br>linux 内核采用进程描述符来抽象和描述一个进程，使用 task_struct 数据结构来描述。task_struct 用于描述进程运行状况和控制进程运行的全部信息。</p></li><li><p>sched_entity<br>进程调度中有一个非常重要的数据结构 task_entity，称为调度实体，它描述进程作为一个调度实体参与调度所需要的全部信息。</p></li><li><p>rq<br>rq 数据结构是描述 cpu 的通用就绪队列，rq 数据结构中记录了一个就绪队列所需要的全部信息，包括一个 cfs 就绪队列数据结构 cfs_rq，一个实时进程调度器就绪队列数据结构 rt_rq 和一个实时调度器 deadline 就绪队列数据结构 dl_rq。</p></li></ol><p>相关数据结构关系如下图所示</p><p><img src="2.png" alt=""></p><h2 id="2-2-task-enqueue入队流程"><a href="#2-2-task-enqueue入队流程" class="headerlink" title="2.2 task enqueue入队流程"></a>2.2 task enqueue入队流程</h2><p>Task入队调用路径：</p><p><img src="3.png" alt=""></p><h2 id="2-3-CFS选择-task-路径"><a href="#2-3-CFS选择-task-路径" class="headerlink" title="2.3 CFS选择 task 路径"></a>2.3 CFS选择 task 路径</h2><p>在cpu进行上下文切换的时候，会进行task的选择，根据调度器的不同，会执行到不同的pick_next_task回调函数。cfs调度器会调用到pick_next_task_fair函数：</p><p><img src="4.png" alt=""></p><p>cfs调度器总是选择红黑树最左边的task，进行调度。</p><p><img src="5.png" alt=""></p><h1 id="三、选择什么样的进程进行优先调度？"><a href="#三、选择什么样的进程进行优先调度？" class="headerlink" title="三、选择什么样的进程进行优先调度？"></a>三、选择什么样的进程进行优先调度？</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Higher prio mvp can preempt lower prio mvp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, the lower prio MVP slice will be more since we expect them to</span></span><br><span class="line"><span class="comment"> * be the work horses. For example, binders will have higher prio MVP and</span></span><br><span class="line"><span class="comment"> * they can preempt long running rtg prio tasks but binders loose their</span></span><br><span class="line"><span class="comment"> * powers with in 3 msec where as rtg prio tasks can run more than that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">walt_get_mvp_task_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (walt_procfs_low_latency_task(p) ||</span><br><span class="line">          walt_pipeline_low_latency_task(p))</span><br><span class="line">      <span class="keyword">return</span> WALT_LL_PIPE_MVP</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (per_task_boost(p) == TASK_BOOST_STRICT_MAX)</span><br><span class="line">      <span class="keyword">return</span> WALT_TASK_BOOST_MVP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (walt_binder_low_latency_task(p))</span><br><span class="line">      <span class="keyword">return</span> WALT_BINDER_MVP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_rtg_high_prio(p))</span><br><span class="line">      <span class="keyword">return</span> WALT_RTG_MVP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> WALT_NOT_MVP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 walt_get_mvp_task_prio 中可以看出一共有 4 类 task 可以进行优先调度，分别为</p><ul><li>walt_procfs_low_latency_task || walt_pipeline_low_latency_task</li><li>per_task_boost</li><li>walt_binder_low_latency_task</li><li>task_rtg_high_prio</li></ul><h1 id="四、4-种mvp-task类型解析"><a href="#四、4-种mvp-task类型解析" class="headerlink" title="四、4 种mvp task类型解析"></a>四、4 种mvp task类型解析</h1><p>mvp task flag基本定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_MVP_SLICE                3000000U</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_MVP_LIMIT                (4 * WALT_MVP_SLICE)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* higher number, better priority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_RTG_MVP                0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_BINDER_MVP                1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_TASK_BOOST_MVP        2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_LL_PIPE_MVP        3</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALT_NOT_MVP                -1</span></span><br></pre></td></tr></table></figure><p>即定义了4种不同类型的task，并为这些task限制了running time。</p><h2 id="4-1-低延迟任务"><a href="#4-1-低延迟任务" class="headerlink" title="4.1 低延迟任务"></a>4.1 低延迟任务</h2><p>低延迟任务是第一优先级，包括以下两类：</p><ul><li>walt_procfs_low_latency_task：</li></ul><p>即 task-&gt;low_latency 需要赋值 WALT_LOW_LATENCY_PROCFS，并且 task 的负载需要小于 sysctl_walt_low_latency_task_threshold。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">walt_procfs_low_latency_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (wts-&gt;low_latency &amp; WALT_LOW_LATENCY_PROCFS) &amp;&amp;</span><br><span class="line">      (task_util(p) &lt; sysctl_walt_low_latency_task_threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>walt_procfs_low_latency_task 通过 proc/sys/walt/sched_low_latency 来进行设置，属于 per task 类型，user空间可以自行对该类型的 task 进行设置。</p><p>调用函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sched_task_handler</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> LOW_LATENCY:</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">      wts-&gt;low_latency |= WALT_LOW_LATENCY_PROCFS;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ts-&gt;low_latency &amp;= ~WALT_LOW_LATENCY_PROCFS;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>walt_pipeline_low_latency_task：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">walt_pipeline_low_latency_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wts-&gt;low_latency &amp; WALT_LOW_LATENCY_PIPELINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同 WALT_LOW_LATENCY_PROCFS，只不过少了对 task_util 的限制。同样在 sysctl中sched_task_handler 中来进行赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPELINE:</span><br><span class="line">  <span class="keyword">if</span> (val)</span><br><span class="line">  wts-&gt;low_latency |= WALT_LOW_LATENCY_PIPELINE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  wts-&gt;low_latency &amp;= ~WALT_LOW_LATENCY_PIPELINE;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="4-2-per-task-类型-boost-任务"><a href="#4-2-per-task-类型-boost-任务" class="headerlink" title="4.2 per-task 类型 boost 任务"></a>4.2 per-task 类型 boost 任务</h2><p>per-task 类型 boost task是第二优先级，即 WALT_TASK_BOOST_MVP。</p><ol><li><p>底层通过提供接口，上层进行设置sched_per_task_boost，使该 task 变成 mvp task 进行优先调度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PER_TASK_BOOST:</span><br><span class="line"><span class="keyword">if</span> (val &lt; TASK_BOOST_NONE || val &gt;= TASK_BOOST_END) &#123;</span><br><span class="line">  ret = -EINVAL;</span><br><span class="line">  <span class="keyword">goto</span> put_task;</span><br><span class="line">&#125;</span><br><span class="line">wts-&gt;boost = val;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">0</span>)</span><br><span class="line">  wts-&gt;boost_period = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>将 task 变为 mvp task 进行优先调度。boost类型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> task_boost_type &#123;</span><br><span class="line">TASK_BOOST_NONE = <span class="number">0</span>,</span><br><span class="line">TASK_BOOST_ON_MID,</span><br><span class="line">TASK_BOOST_ON_MAX,</span><br><span class="line">TASK_BOOST_STRICT_MAX,</span><br><span class="line">TASK_BOOST_END,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只有设置了 wts-&gt;boost = 3才会生效。</p></li><li><p>在 binder set prio 处进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_set_priority_hook</span><span class="params">(<span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">struct binder_transaction *bndrtrans, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">task</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">current_wts</span> =</span></span><br><span class="line"><span class="class">      (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">current</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(walt_disabled))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bndrtrans &amp;&amp; bndrtrans-&gt;need_reply &amp;&amp; current_wts-&gt;boost == TASK_BOOST_STRICT_MAX) &#123;</span><br><span class="line">       bndrtrans-&gt;android_vendor_data1  = wts-&gt;boost;</span><br><span class="line">        wts-&gt;boost = TASK_BOOST_STRICT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的 task-&gt;boost == TASK_BOOST_STRICT_MAX, 即能够把对端的 task-&gt;boost 赋值为TASK_BOOST_STRICT_MAX，成为 mvp task。</p></li></ol><h2 id="4-3-binder-类型优先调度任务"><a href="#4-3-binder-类型优先调度任务" class="headerlink" title="4.3 binder 类型优先调度任务"></a>4.3 binder 类型优先调度任务</h2><p>binder 类型优先调度是第三优先级，即 WALT_BINDER_MVP。</p><p>在 binder 进程间通信时，客户端进程唤醒等待的 rtg 进程的时候，把将要唤醒的 rtg 线程当作 mvp task 进行优先调度。</p><p>Vendor hook 为 trace_android_vh_binder_wakeup_ilocked。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walt_binder_low_latency_set</span><span class="params">(<span class="keyword">void</span> *unused, struct task_struct *task,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">bool</span> sync, struct binder_proc *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">task</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(walt_disabled))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (task &amp;&amp; ((task_in_related_thread_group(current) &amp;&amp;</span><br><span class="line">                        task-&gt;group_leader-&gt;prio &lt; MAX_RT_PRIO) ||</span><br><span class="line">                        (current-&gt;group_leader-&gt;prio &lt; MAX_RT_PRIO &amp;&amp;</span><br><span class="line">                        task_in_related_thread_group(task))))</span><br><span class="line">                wts-&gt;low_latency |= WALT_LOW_LATENCY_BINDER;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Clear low_latency flag if criterion above is not met, this</span></span><br><span class="line"><span class="comment">                 * will handle usecase where for a binder thread WALT_LOW_LATENCY_BINDER</span></span><br><span class="line"><span class="comment">                 * is set by one task and before WALT clears this flag after timer expiry</span></span><br><span class="line"><span class="comment">                 * some other task tries to use same binder thread.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * The only gets cleared when binder transaction is initiated</span></span><br><span class="line"><span class="comment">                 * and the above condition to set flasg is nto satisfied.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                wts-&gt;low_latency &amp;= ~WALT_LOW_LATENCY_BINDER;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 task 需要满足如下条件：</p><ul><li>当前 waker 在 related thread group 组中，目前可以直接理解为 top app 线程 &amp;&amp; 该 waker 为 rt 线程或者该 waker 的主进程为 rt 并且 wakee 的线程也需要在 rtg 组里面。</li><li>当进行优先调度的时候，还需满足该 task 的负载 &lt; sysctl_walt_low_latency_task_threshold。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">walt_binder_low_latency_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (wts-&gt;low_latency &amp; WALT_LOW_LATENCY_BINDER) &amp;&amp;</span><br><span class="line">                (task_util(p) &lt; sysctl_walt_low_latency_task_threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-特定-RTG-类型任务"><a href="#4-4-特定-RTG-类型任务" class="headerlink" title="4.4 特定 RTG 类型任务"></a>4.4 特定 RTG 类型任务</h2><p>RTG task 类型是第四优先级，即WALT_RTG_MVP。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">task_rtg_high_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> task_in_related_thread_group(p) &amp;&amp;</span><br><span class="line">                (p-&gt;prio &lt;= sysctl_walt_rtg_cfs_boost_prio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-1-加入-related-thread-group-时机"><a href="#4-4-1-加入-related-thread-group-时机" class="headerlink" title="4.4.1 加入 related thread group 时机"></a>4.4.1 加入 related thread group 时机</h4><p>在 walt 初始化的时候，会给 related_thread_group 分配空间，为 20 个分组。在 cpu_cgroup_attach 中调用vendor hook trace_android_rvh_cpu_cgroup_attach，将 topapp 分组里面的线程默认加入到DEFAULT_CGROUP_COLOC_ID 分组中。其他 non-topapp task 可根据需要由user空间进行分到其他不同的组中。</p><h4 id="4-4-2-成为-mvp-task-的条件"><a href="#4-4-2-成为-mvp-task-的条件" class="headerlink" title="4.4.2 成为 mvp task 的条件"></a>4.4.2 成为 mvp task 的条件</h4><ul><li>task需要在related thread group中</li><li>优先级需小于或等于sysctl_walt_rtg_cfs_boost_prio</li></ul><p>正常情况下是不会进行 rtg 组优先调度的，不同场景区分 sysctl_walt_rtg_cfs_boost_prio 也不同。正常情况sysctl_walt_rtg_cfs_boost_prio 默认为 99，fps变化刷新的时候如滑动场景sysctl_walt_rtg_cfs_boost_prio=119，该节点上层通过 perflock 来进行设置。</p><h4 id="4-4-3-用户调用接口"><a href="#4-4-3-用户调用接口" class="headerlink" title="4.4.3 用户调用接口"></a>4.4.3 用户调用接口</h4><p>加入到 rtg 分组接口：</p><p>echo xxx（xxx为线程号） y(y为rtg分组) &gt; sched_group_id</p><h1 id="五、mvp-task调用过程"><a href="#五、mvp-task调用过程" class="headerlink" title="五、mvp task调用过程"></a>五、mvp task调用过程</h1><p>在介绍 mvp task 如何被调度前，我们先简要看一下 Linux 内核调度触发时机图：</p><p><img src="6.png" alt=""></p><p>在 task 入队的时候，去调用 walt_get_mvt_task_prio 获取该 task 的 mvp 调度的 prio，根据 prio 来决定加入 mvp list中的顺序。</p><p><img src="7.png" alt=""></p><p>cfs调度器选择mvp task的流程：</p><p><img src="8.png" alt=""></p><p>walt_cfs_enqueue_task—&gt;walt_get_mvp_task_prio</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">walt_cfs_enqueue_task</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_rq</span> *<span class="title">wrq</span> = (<span class="title">struct</span> <span class="title">walt_rq</span> *) <span class="title">rq</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="keyword">int</span> mvp_prio = walt_get_mvp_task_prio(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mvp_prio == WALT_NOT_MVP)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This can happen during migration or enq/deq for prio/class change.</span></span><br><span class="line"><span class="comment">         * it was once MVP but got demoted, it will not be MVP until</span></span><br><span class="line"><span class="comment">         * it goes to sleep again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (wts-&gt;total_exec &gt; walt_cfs_mvp_task_limit(p))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        wts-&gt;mvp_prio = mvp_prio;</span><br><span class="line">        walt_cfs_insert_mvp_task(wrq, wts, task_running(rq, p));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We inserted the task at the appropriate position. Take the</span></span><br><span class="line"><span class="comment">         * task runtime snapshot. From now onwards we use this point as a</span></span><br><span class="line"><span class="comment">         * baseline to enforce the slice and demotion.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!wts-&gt;total_exec) <span class="comment">/* queue after sleep */</span> &#123;</span><br><span class="line">                wts-&gt;sum_exec_snapshot_for_total = p-&gt;se.sum_exec_runtime;</span><br><span class="line">                wts-&gt;sum_exec_snapshot_for_slice = p-&gt;se.sum_exec_runtime;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>total_exec 记录了 task 运行的总时间，如果超过了该 mvp task time limit 就不会加入到 mvp task list 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">walt_cfs_mvp_task_limit</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Binder MVP tasks are high prio but have only single slice */</span></span><br><span class="line">        <span class="keyword">if</span> (wts-&gt;mvp_prio == WALT_BINDER_MVP)</span><br><span class="line">                <span class="keyword">return</span> WALT_MVP_SLICE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> WALT_MVP_LIMIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binder mvp 调度运行时间默认为 3ms，其他 mvp task time limit 为 12ms。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walt_cfs_insert_mvp_task</span><span class="params">(struct walt_rq *wrq, struct walt_task_struct *wts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">bool</span> at_front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span>;</span></span><br><span class="line"></span><br><span class="line">        list_for_each(pos, &amp;wrq-&gt;mvp_tasks) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">tmp_wts</span> = <span class="title">container_of</span>(<span class="title">pos</span>, <span class="title">struct</span> <span class="title">walt_task_struct</span>,</span></span><br><span class="line"><span class="class">                                                                <span class="title">mvp_list</span>);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (at_front) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (wts-&gt;mvp_prio &gt;= tmp_wts-&gt;mvp_prio)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (wts-&gt;mvp_prio &gt; tmp_wts-&gt;mvp_prio)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list_add(&amp;wts-&gt;mvp_list, pos-&gt;prev);</span><br><span class="line">        wrq-&gt;num_mvp_tasks++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 mvp prio 的不同，决定了该 task 在 mvp task list 中的位置。</p><p>紧接着，在 scheduler_tick 中去调用 walt_cfs_tick</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">walt_cfs_tick</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_rq</span> *<span class="title">wrq</span> = (<span class="title">struct</span> <span class="title">walt_rq</span> *) <span class="title">rq</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">rq</span>-&gt;<span class="title">curr</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(walt_disabled))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        raw_spin_lock(&amp;rq-&gt;__lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;wts-&gt;mvp_list) || (wts-&gt;mvp_list.next == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        walt_cfs_account_mvp_runtime(rq, rq-&gt;curr);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the current is not MVP means, we have to re-schedule to</span></span><br><span class="line"><span class="comment">         * see if we can run any other task including MVP tasks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wrq-&gt;mvp_tasks.next != &amp;wts-&gt;mvp_list) &amp;&amp; rq-&gt;cfs.h_nr_running &gt; <span class="number">1</span>)</span><br><span class="line">                resched_curr(rq);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">        raw_spin_unlock(&amp;rq-&gt;__lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即统计当前 mvp task 是否超过了exec time limit，并且在该点有个抢占点，如果当前 task 不是 mvp task，则会标记该 task 需要抢占，在下一个调度时机到来的时候，会切换task。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When preempt = false and nopreempt = false, we leave the preemption</span></span><br><span class="line"><span class="comment"> * decision to CFS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walt_cfs_check_preempt_wakeup</span><span class="params">(<span class="keyword">void</span> *unused, struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">bool</span> *preempt, <span class="keyword">bool</span> *nopreempt, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          struct sched_entity *se, struct sched_entity *pse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> next_buddy_marked, <span class="keyword">unsigned</span> <span class="keyword">int</span> granularity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_rq</span> *<span class="title">wrq</span> = (<span class="title">struct</span> <span class="title">walt_rq</span> *) <span class="title">rq</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts_p</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">c</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts_c</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">rq</span>-&gt;<span class="title">curr</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="keyword">bool</span> resched = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> p_is_mvp, curr_is_mvp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(walt_disabled))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        p_is_mvp = !list_empty(&amp;wts_p-&gt;mvp_list) &amp;&amp; wts_p-&gt;mvp_list.next;</span><br><span class="line">        curr_is_mvp = !list_empty(&amp;wts_c-&gt;mvp_list) &amp;&amp; wts_c-&gt;mvp_list.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * current is not MVP, so preemption decision</span></span><br><span class="line"><span class="comment">         * is simple.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!curr_is_mvp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p_is_mvp)</span><br><span class="line">                        <span class="keyword">goto</span> preempt;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">/* CFS decides preemption */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * current is MVP. update its runtime before deciding the</span></span><br><span class="line"><span class="comment">         * preemption.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        walt_cfs_account_mvp_runtime(rq, c);</span><br><span class="line">        resched = (wrq-&gt;mvp_tasks.next != &amp;wts_c-&gt;mvp_list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * current is no longer eligible to run. It must have been</span></span><br><span class="line"><span class="comment">         * picked (because of MVP) ahead of other tasks in the CFS</span></span><br><span class="line"><span class="comment">         * tree, so drive preemption to pick up the next task from</span></span><br><span class="line"><span class="comment">         * the tree, which also includes picking up the first in</span></span><br><span class="line"><span class="comment">         * the MVP queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (resched)</span><br><span class="line">                <span class="keyword">goto</span> preempt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* current is the first in the queue, so no preemption */</span></span><br><span class="line">        *nopreempt = <span class="literal">true</span>;</span><br><span class="line">        trace_walt_cfs_mvp_wakeup_nopreempt(c, wts_c, walt_cfs_mvp_task_limit(c));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">preempt:</span><br><span class="line">        *preempt = <span class="literal">true</span>;</span><br><span class="line">        trace_walt_cfs_mvp_wakeup_preempt(p, wts_p, walt_cfs_mvp_task_limit(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检查抢占处，来判定 mvp task 是否能够被其他线程抢占，或者抢占其他线程</p><ol><li>如果当前 task 不是 mvp，需要被抢占</li><li>如果当前 task 为 mvp，根据 mvp prio 的大小来决定是否能够被抢占</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MVP task runtime update happens here. Three possibilities:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * de-activated: The MVP consumed its runtime. Non MVP can preempt.</span></span><br><span class="line"><span class="comment"> * slice expired: MVP slice is expired and other MVP can preempt.</span></span><br><span class="line"><span class="comment"> * slice not expired: This MVP task can continue to run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walt_cfs_account_mvp_runtime</span><span class="params">(struct rq *rq, struct task_struct *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_rq</span> *<span class="title">wrq</span> = (<span class="title">struct</span> <span class="title">walt_rq</span> *) <span class="title">rq</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">curr</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        u64 slice;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">        lockdep_assert_held(&amp;rq-&gt;__lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * RQ clock update happens in tick path in the scheduler.</span></span><br><span class="line"><span class="comment">         * Since we drop the lock in the scheduler before calling</span></span><br><span class="line"><span class="comment">         * into vendor hook, it is possible that update flags are</span></span><br><span class="line"><span class="comment">         * reset by another rq lock and unlock. Do the update here</span></span><br><span class="line"><span class="comment">         * if required.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!(rq-&gt;clock_update_flags &amp; RQCF_UPDATED))</span><br><span class="line">                update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;se.sum_exec_runtime &gt; wts-&gt;sum_exec_snapshot_for_total)</span><br><span class="line">                wts-&gt;total_exec = curr-&gt;se.sum_exec_runtime - wts-&gt;sum_exec_snapshot_for_total;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                wts-&gt;total_exec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;se.sum_exec_runtime &gt; wts-&gt;sum_exec_snapshot_for_slice)</span><br><span class="line">                slice = curr-&gt;se.sum_exec_runtime - wts-&gt;sum_exec_snapshot_for_slice;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                slice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* slice is not expired */</span></span><br><span class="line">        <span class="keyword">if</span> (slice &lt; WALT_MVP_SLICE)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        wts-&gt;sum_exec_snapshot_for_slice = curr-&gt;se.sum_exec_runtime;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * slice is expired, check if we have to deactivate the</span></span><br><span class="line"><span class="comment">         * MVP task, otherwise requeue the task in the list so</span></span><br><span class="line"><span class="comment">         * that other MVP tasks gets a chance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        limit = walt_cfs_mvp_task_limit(curr);</span><br><span class="line">        <span class="keyword">if</span> (wts-&gt;total_exec &gt; limit) &#123;</span><br><span class="line">                walt_cfs_deactivate_mvp_task(rq, curr);</span><br><span class="line">                trace_walt_cfs_deactivate_mvp_task(curr, wts, limit);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wrq-&gt;num_mvp_tasks == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* slice expired. re-queue the task */</span></span><br><span class="line">        list_del(&amp;wts-&gt;mvp_list);</span><br><span class="line">        wrq-&gt;num_mvp_tasks--;</span><br><span class="line">        walt_cfs_insert_mvp_task(wrq, wts, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的主要作用为 更新 task 的运行时间即 total_exec ，判断该 task 是否能够继续被优先调度下去，如果不能就移除 mvp task list，否则需要重新加入到 mvp task list 中。</p><p>在上下文切换中，来进行 mvp task 的选择: walt_cfs_replace_next_task_fair 函数。在选择 task 的时候，去优先选择 mvp task list 中的 task，进行优先调度。如果 mvp task list 中 没有mvp task，则进行cfs 原生的完全公平调度，根据虚拟时间最小的 task 来进行选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walt_cfs_replace_next_task_fair</span><span class="params">(<span class="keyword">void</span> *unused, struct rq *rq, struct task_struct **p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            struct sched_entity **se, <span class="keyword">bool</span> *repick, <span class="keyword">bool</span> simple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            struct task_struct *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_rq</span> *<span class="title">wrq</span> = (<span class="title">struct</span> <span class="title">walt_rq</span> *) <span class="title">rq</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">mvp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(walt_disabled))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((*p) &amp;&amp; (*p) != prev &amp;&amp; ((*p)-&gt;on_cpu == <span class="number">1</span> || (*p)-&gt;on_rq == <span class="number">0</span> ||</span><br><span class="line">                                     (*p)-&gt;on_rq == TASK_ON_RQ_MIGRATING ||</span><br><span class="line">                                     (*p)-&gt;cpu != cpu_of(rq)))</span><br><span class="line">                WALT_BUG(WALT_BUG_UPSTREAM, *p,</span><br><span class="line">                         <span class="string">"picked %s(%d) on_cpu=%d on_rq=%d p-&gt;cpu=%d cpu_of(rq)=%d kthread=%d\n"</span>,</span><br><span class="line">                         (*p)-&gt;comm, (*p)-&gt;pid, (*p)-&gt;on_cpu,</span><br><span class="line">                         (*p)-&gt;on_rq, (*p)-&gt;cpu, cpu_of(rq), ((*p)-&gt;flags &amp; PF_KTHREAD));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We don't have MVP tasks queued */</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;wrq-&gt;mvp_tasks))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return the first task from MVP queue */</span></span><br><span class="line">        wts = list_first_entry(&amp;wrq-&gt;mvp_tasks, struct walt_task_struct, mvp_list);</span><br><span class="line">        mvp = wts_to_ts(wts);</span><br><span class="line"></span><br><span class="line">        *p = mvp;</span><br><span class="line">        *se = &amp;mvp-&gt;se;</span><br><span class="line">        *repick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (simple) &#123;</span><br><span class="line">                for_each_sched_entity((*se)) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * TODO If CFS_BANDWIDTH is enabled, we might pick</span></span><br><span class="line"><span class="comment">                         * from a throttled cfs_rq</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        cfs_rq = cfs_rq_of(*se);</span><br><span class="line">                        set_next_entity(cfs_rq, *se);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((*p) &amp;&amp; (*p) != prev &amp;&amp; ((*p)-&gt;on_cpu == <span class="number">1</span> || (*p)-&gt;on_rq == <span class="number">0</span> ||</span><br><span class="line">                                     (*p)-&gt;on_rq == TASK_ON_RQ_MIGRATING ||</span><br><span class="line">                                     (*p)-&gt;cpu != cpu_of(rq)))</span><br><span class="line">                WALT_BUG(WALT_BUG_UPSTREAM, *p,</span><br><span class="line">                         <span class="string">"picked %s(%d) on_cpu=%d on_rq=%d p-&gt;cpu=%d cpu_of(rq)=%d kthread=%d\n"</span>,</span><br><span class="line">                         (*p)-&gt;comm, (*p)-&gt;pid, (*p)-&gt;on_cpu,</span><br><span class="line">                         (*p)-&gt;on_rq, (*p)-&gt;cpu, cpu_of(rq), ((*p)-&gt;flags &amp; PF_KTHREAD));</span><br><span class="line"></span><br><span class="line">        trace_walt_cfs_mvp_pick_next(mvp, wts, walt_cfs_mvp_task_limit(mvp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除 mvp task：将该 task 移除 mvp task list 并且在 出队的时候将 wts-&gt;total_exec 重置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">walt_cfs_dequeue_task</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">walt_task_struct</span> *<span class="title">wts</span> = (<span class="title">struct</span> <span class="title">walt_task_struct</span> *) <span class="title">p</span>-&gt;<span class="title">android_vendor_data1</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;wts-&gt;mvp_list) &amp;&amp; wts-&gt;mvp_list.next)</span><br><span class="line">                walt_cfs_deactivate_mvp_task(rq, p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Reset the exec time during sleep so that it starts</span></span><br><span class="line"><span class="comment">         * from scratch upon next wakeup. total_exec should</span></span><br><span class="line"><span class="comment">         * be preserved when task is enq/deq while it is on</span></span><br><span class="line"><span class="comment">         * runqueue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (READ_ONCE(p-&gt;__state) != TASK_RUNNING)</span><br><span class="line">                wts-&gt;total_exec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>以上为高通原生的 mvp 调度，我们可以看到如下特点：</p><ul><li>覆盖面广，加入 mvp 的粒度大，根据进程的 prio 和 related thread group，而不明确是否和绘制/动画/显示/交互相关的进程，需要被优先调度的进程数量可能会过多</li><li>部分具体控制入口不开源</li><li>根据上层典型场景来动态设置，如在 FPS 变化 以及游戏重负载线程等场景（逻辑线程、渲染线程等）进行动态设置</li><li>过多的调度细节暴露给用户层去操作，粒度过细，条件复杂，用户层很难理解和真正运用起来</li></ul><h1 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h1><p>rtg相关：<a href="https://www.seaxiang.com/blog/809240c5a1144be0a252ec13103beb6a" target="_blank" rel="noopener">https://www.seaxiang.com/blog/809240c5a1144be0a252ec13103beb6a</a><br>调度相关：<a href="https://www.codedump.info/post/20200503-sgfap-process-schedule/" target="_blank" rel="noopener">https://www.codedump.info/post/20200503-sgfap-process-schedule/</a><br><a href="https://blog.csdn.net/u012489236/article/details/122399231?spm=1001.2014.3001.5501" target="_blank" rel="noopener">https://blog.csdn.net/u012489236/article/details/122399231?spm=1001.2014.3001.5501</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
          <category> 调度器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eBPF初体验：Android设备网络优化实践</title>
      <link href="/2023/11/06/Optimization-practice-and-exploration-of-Android-devices-based-on-eBPF/"/>
      <url>/2023/11/06/Optimization-practice-and-exploration-of-Android-devices-based-on-eBPF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-eBPF是什么"><a href="#1-1-eBPF是什么" class="headerlink" title="1.1 eBPF是什么"></a>1.1 eBPF是什么</h2><p>先看看官方原文释惑</p><blockquote><p>eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in a privileged context such as the operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.</p><p>Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system.</p><p>eBPF changes this formula fundamentally. By allowing to run sandboxed programs within the operating system, application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality.</p><p>Today, eBPF is used extensively to drive a wide variety of use cases: Providing high-performance networking and load-balancing in modern data centers and cloud native environments, extracting fine-grained security observability data at low overhead, helping application developers trace applications, providing insights for performance troubleshooting, preventive application and container runtime security enforcement, and much more. The possibilities are endless, and the innovation that eBPF is unlocking has only just begun.</p></blockquote><p>  摘自<a href="https://ebpf.io/what-is-ebpf/" target="_blank" rel="noopener">What is eBPF? An Introduction and Deep Dive into the eBPF Technology</a>。</p><p>eBPF是extended BPF的缩写，它的前身是BPF（Berkeley Packet Filter）技术。</p><p>而BPF是一个有着较长年头的技术，抓包软件Wireshark就是基于BPF实现的，经过若干年发展，eBPF脱胎换骨，成为Linux内核可观测技术事实上的标准。</p><p>Linux内核的主要目的是抽象硬件或虚拟硬件，并提供API（系统调用）供应用调用和共享资源。为了实现这一点，需要维护一些子系统和模块来完成这些职责。每个模块通常维护了几种通用的配置，以满足用户的不同需求。而当现有配置无法满足用户需求时，只能通过修改内核来达到目的，根据历史经验有两个途径：</p><ol><li><p>直接修改内核源码，同时将相关修改提交，为保证一致性可能还需要将源码提交到kernel社区，在等待漫长的时间后可能会被合入新的linux版本中，或者干脆自己持续维护该修改，在每次的版本更新后移植适配。</p></li><li><p>写一个ko模块，在每次的kernel新版本中移植适配，可能还会遇到某些兼容性或安全性问题需要调整。</p></li></ol><p>而eBPF提供了一个新的选择途径，它通过在内核中实现一个轻量级虚拟机，将类C代码编译成字节码，挂在到内核的钩子上，当钩子被触发时，kernel在虚拟机的”沙盒”中运行字节码，这样就可以在无需修改内核源码或者挂载内核模块的情况下，轻松的拓展内核功能。</p><h3 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1   简介"></a>1.1.1   简介</h3><p>eBPF是一个转发层的驱动模型，通过下图可了解第一印象。</p><p><img src="eBPF_driver.png" alt=""></p><p>它包含用户层和内核层：</p><p>用户层：主要是负责业务逻辑处理和响应，同时也兼顾着内核中的 epbf 的逻辑 bytescode 生成，并将 bytescode 注入到内核中。</p><p>内核层：主要是接收 bytescode，然后在内核层内完成对 bytescode 执行。</p><h2 id="1-2-eBPF的工作流程"><a href="#1-2-eBPF的工作流程" class="headerlink" title="1.2 eBPF的工作流程"></a>1.2 eBPF的工作流程</h2><p>  可先大致了解下eBPF工作的全流程</p><p><img src="eBPF_workflow.png" alt=""></p><p>  接下来对几个核心概念以及工作过程做个简单介绍</p><h3 id="1-2-1-Hook"><a href="#1-2-1-Hook" class="headerlink" title="1.2.1 Hook"></a>1.2.1 Hook</h3><p>在 eBPF的世界里看 Linux 内核所有核心调用都可以 Hook，可以理解成为万物皆可挂钩子做 Callback。它是事件驱动，在内核或应用程序通过某个hook点时会被触发运行。</p><p>预设的hook点包括系统调用、函数进入/退出、内核tracepoint、网络事件等等。</p><p>如果有特定需求不在上述已有的hook点中时，可通过内核探测（kprobe）或用户探测（uprobe）来在期望的地方挂载eBPF程序。</p><h3 id="1-2-2-Map"><a href="#1-2-2-Map" class="headerlink" title="1.2.2 Map"></a>1.2.2 Map</h3><p>BPF Map用于在内核和用户空间之间共享数据，它不同类型的通用存储，</p><p>有几种可用的存储类型：</p><ul><li>Hash tables, Arrays</li><li>LRU (Least Recently Used)</li><li>Ring Buffer</li><li>Stack Trace</li><li>LPM (Longest Prefix match)</li><li>…</li></ul><p>通过bpf-syscall在用户空间被访问，bpf-syscall提供创建映射、查找元素、更新元素和删除元素等命令。涉及到Map的场景有以下几种：</p><ul><li>eBPF-prog和用户态程序的交互：prog运行完，得到的结果存储到map，供用户态通过文件描述符访问。</li><li>eBPF-prog和内核态程序的交互：和 prog以外的内核程序交互，也可以使用map作为中介。</li><li>eBPF-prog间交互：如果prog内部需要用全局变量来交互，但是由于安全原因prog不允许访问全局变量，可以使用 map 来充当全局变量。</li><li>Tail call：Tail call 是从prog-A跳转到prog-B，prog-A通过BPF_MAP_TYPE_PROG_ARRAY类型的map来知道prog-B的指针，然后调用tail_call()的helper function来执行Tail call。</li></ul><p>共享map的eBPF-prog不要求是相同的程序类型，例如tracing程序可以和网络程序共享map，单个eBPF-prog目前最多可直接访问64个不同 map。</p><h3 id="1-2-3-JIT-Compailation"><a href="#1-2-3-JIT-Compailation" class="headerlink" title="1.2.3 JIT Compailation"></a>1.2.3 JIT Compailation</h3><p>JIT (Just-in-Time)编译将程序的通用字节码转换为汇编代码，来优化执行速度。</p><p>这使得eBPF程序像本地编译的内核代码或作为内核模块加载的代码一样有效地运行。</p><h3 id="1-2-4-eBPF-Safety"><a href="#1-2-4-eBPF-Safety" class="headerlink" title="1.2.4 eBPF Safety"></a>1.2.4 eBPF Safety</h3><p>每一个 eBPF 程序加载到内核都要经过“检查”，用来保证 eBPF 程序的安全性，主要包括：</p><h4 id="i、Verifier"><a href="#i、Verifier" class="headerlink" title="i、Verifier"></a>i、Verifier</h4><ul><li>要保证prog必须满足系统要求的大小，过大的 eBPF 程序不允许被加载进内核，<br>堆栈大小被限制在MAX_BPF_STACK（512字节）内，<br>编译的字节码大小被限制在BPF_COMPLEXITY_LIMIT_INSNS（1M）；  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BPF program can access up to 512 bytes of stack space. */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BPF_STACK        512</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_COMPLEXITY_LIMIT_INSNS      1000000 <span class="comment">/* yes. 1M insns */</span></span></span><br></pre></td></tr></table></figure></li><li>要保证程序的复杂度有限，Verifier 会评估 eBPF 程序所有可能的执行路径，必须能在有限时间内完成；</li><li>要保证程序不会崩溃或者使得系统出故障；  </li></ul><h4 id="ii、Privileges"><a href="#ii、Privileges" class="headerlink" title="ii、Privileges"></a>ii、Privileges</h4><p>除非启用了非特权eBPF，否则所有打算将eBPF程序加载到Linux内核中的进程必须以特权模式(root)运行，或者需要CAP_BPF功能。这意味着不受信任的程序不能加载eBPF程序。</p><ol><li><p>内核提供了一个配置项 /proc/sys/kernel/unprivileged_bpf_disabled 来禁止非 特权用户使用 bpf(2) 系统调用，可以通过 sysctl 命令修改</p></li><li><p>比较特殊的一点是，这个配置项特意设计为一次性开关（one-time kill switch）， 这 意味着一旦将它设为 1，就没有办法再改为 0 了，除非重启内核</p></li><li><p>一旦设置为 1 之后，只有初始命名空间中有 CAP_SYS_ADMIN 特权的进程才可以调用 bpf(2) 系统调用 。Cilium 启动后也会将这个配置项设为 1 # echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled</p></li></ol><p>如果启用非特权eBPF，非特权进程可以加载某些eBPF程序，这些程序的功能集减少，并且对内核的访问受限。</p><h4 id="iii、Hardening"><a href="#iii、Hardening" class="headerlink" title="iii、Hardening"></a>iii、Hardening</h4><p>当程序成功校验后，会依据特权进程或非特权进程来加载，来决定eBPF的加固处理，包含以下：</p><ol><li><p>程序执行保护：eBPF程序所在的kernel内存空间会变更为只读。所以无论是kernel异常或其他误操作，当尝试修改eBPF程序时都会触发崩溃，而不是允许该操作继续下去。</p></li><li><p>抵御Spectre攻击：eBPF程序会屏蔽内存访问，将瞬时指令下的访问定位重定向到受控区域</p></li><li><p>常量屏蔽：程序中所有的常量都将被屏蔽，以防发生注入攻击。</p></li></ol><h4 id="iv、Abstracted-Runtime-Context"><a href="#iv、Abstracted-Runtime-Context" class="headerlink" title="iv、Abstracted Runtime Context"></a>iv、Abstracted Runtime Context</h4><p>eBPF程序不能直接访问任意内核内存，程序上下文之外的数据和数据结构必须通过eBPF-helper访问。</p><p>这样使得访问数据的接口统一化，且均受到eBPF程序的限制。比如只有与程序相关的数据才允许读写或修改，确保加载时永远都不会发生越界；或者当eBPF程序在运行中尝试修改数据的行为只有在确保安全的前提下才会被允许执行。eBPF程序不能随意修改内核中的数据结构。</p><h3 id="1-2-5-Tail-Calls"><a href="#1-2-5-Tail-Calls" class="headerlink" title="1.2.5 Tail Calls"></a>1.2.5 Tail Calls</h3><p>bpf允许在prog中调用另一个prog，并且执行完后不需要返回之前的prog</p><p><img src="eBPF_Tail_Calls.png" alt=""></p><h2 id="1-3-eBPF能做什么"><a href="#1-3-eBPF能做什么" class="headerlink" title="1.3 eBPF能做什么"></a>1.3 eBPF能做什么</h2><p><img src="eBPF_cando.png" alt=""></p><p>鉴于它的起源，eBPF特别适合编写网络程序，将该网络程序附加到网络socket，进行流量过滤，流量分类以及执行网络分类器的动作，甚至可以修改一个已建链的网络socket的配置。</p><p>它还可以通过各种钩子，能在用户空间得到系统各种性能指标。大到监控整机状态，小到系统函数的运行时间。比如有开源项目BCC，基于eBPF实现的系统监视工具</p><p><img src="bcc_BPF_tracing_tools.png" alt=""></p><p>  它能监控到</p><p>  1、应用及虚拟机的各种指标<br>  2、系统库性能监控<br>  3、kernel系统调用性能<br>  4、文件系统性能<br>  5、网络调用性能<br>  6、CPU调度器性能<br>  7、内存管理性能<br>  8、中断性能</p><p>在了解到以上概念后，我们再来基于android平台深入了解下eBPF的工作过程</p><h1 id="2-eBPF的加载bpfloader"><a href="#2-eBPF的加载bpfloader" class="headerlink" title="2. eBPF的加载bpfloader"></a>2. eBPF的加载bpfloader</h1><p>在系统启动阶段，会把位于 /system/etc/bpf/ 下的eBPF目标文件通过bpfloader服务加载到内核<br>system/bpf/bpfloader/bpfloader.rc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">on load_bpf_programs</span><br><span class="line">    # Linux <span class="number">5.16</span>-rc1 has changed the <span class="keyword">default</span> to <span class="number">2</span> (disabled but changeable),</span><br><span class="line">    <span class="meta"># but we need 0</span></span><br><span class="line"><span class="built_in">write</span> /proc/sys/kernel/unprivileged_bpf_disabled <span class="number">0</span></span><br><span class="line"># Enable the eBPF JIT -- but <span class="keyword">do</span> note that on <span class="number">64</span>-<span class="built_in">bit</span> kernels it is likely</span><br><span class="line"><span class="meta"># already force enabled by the kernel config option BPF_JIT_ALWAYS_ON</span></span><br><span class="line"><span class="built_in">write</span> /proc/sys/net/core/bpf_jit_enable <span class="number">1</span></span><br><span class="line"># Enable JIT kallsyms <span class="keyword">export</span> <span class="keyword">for</span> privileged users only</span><br><span class="line"><span class="built_in">write</span> /proc/sys/net/core/bpf_jit_kallsyms <span class="number">1</span></span><br><span class="line">exec_start bpfloader</span><br><span class="line"></span><br><span class="line">service bpfloader /system/bin/bpfloader</span><br><span class="line">capabilities CHOWN SYS_ADMIN NET_ADMIN</span><br><span class="line">#</span><br><span class="line"># Set RLIMIT_MEMLOCK to <span class="number">1</span>GiB <span class="keyword">for</span> bpfloader</span><br><span class="line">#</span><br><span class="line"># Actually only <span class="number">8</span>MiB would be needed <span class="keyword">if</span> bpfloader ran as its own uid.</span><br><span class="line">#</span><br><span class="line"># As such we simply use <span class="number">1</span>GiB as a reasonable approximation of infinity.</span><br><span class="line">#</span><br><span class="line">rlimit memlock <span class="number">1073741824</span> <span class="number">1073741824</span></span><br><span class="line">oneshot</span><br><span class="line">reboot_on_failure reboot,bpfloader-failed</span><br><span class="line">updatable</span><br></pre></td></tr></table></figure><p>  在bpfloader.te中有限制bpf执行的sepolicy，指定bpfloader是唯一可以加载bpfprog的的程序<br>  /system/sepolicy/private/bpfloader.te</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neverallow &#123; domain -bpfloader &#125; *:bpf &#123; map_create prog_load &#125;;</span><br></pre></td></tr></table></figure><p>  而bpfloader只在启动时执行一次，确保其他模块无法额外加载系统之外的bpfprog。</p><p>  进入 /system/bpf/bpfloader/BpfLoader.cpp 看下它的加载过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">(<span class="keyword">void</span>)argc;</span><br><span class="line">android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create all the pin subdirectories</span></span><br><span class="line"><span class="comment">// (this must be done first to allow selinux_context and pin_subdir functionality,</span></span><br><span class="line"><span class="comment">//  which could otherwise fail with ENOENT during object pinning or renaming,</span></span><br><span class="line"><span class="comment">//  due to ordering issues)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; location : locations) &#123;</span><br><span class="line">createSysFsBpfSubDir(location.prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load all ELF objects, create programs and maps, and pin them</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; location : locations) &#123;</span><br><span class="line"><span class="keyword">if</span> (loadAllElfObjects(location) != <span class="number">0</span>) &#123;</span><br><span class="line">ALOGE(<span class="string">"=== CRITICAL FAILURE LOADING BPF PROGRAMS FROM %s ==="</span>, location.dir);</span><br><span class="line">ALOGE(<span class="string">"If this triggers reliably, you're probably missing kernel options or patches."</span>);</span><br><span class="line">ALOGE(<span class="string">"If this triggers randomly, you might be hitting some memory allocation "</span></span><br><span class="line">  <span class="string">"problems or startup script race."</span>);</span><br><span class="line">ALOGE(<span class="string">"--- DO NOT EXPECT SYSTEM TO BOOT SUCCESSFULLY ---"</span>);</span><br><span class="line">sleep(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (android::base::SetProperty(<span class="string">"bpf.progs_loaded"</span>, <span class="string">"1"</span>) == <span class="literal">false</span>) &#123;</span><br><span class="line">ALOGE(<span class="string">"Failed to set bpf.progs_loaded property"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实际是调用 <em>loadAllElfObjects</em> 加载各个ELF文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAllElfObjects</span><span class="params">(<span class="keyword">const</span> Location&amp; location)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">DIR* dir;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((dir = opendir(location.dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> ((ent = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">string</span> s = ent-&gt;d_name;</span><br><span class="line"><span class="keyword">if</span> (!EndsWith(s, <span class="string">".o"</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">progPath</span><span class="params">(location.dir)</span></span>;</span><br><span class="line">progPath += s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> critical;</span><br><span class="line"><span class="keyword">int</span> ret = android::bpf::loadProg(progPath.c_str(), &amp;critical,</span><br><span class="line"> location.prefix,</span><br><span class="line"> location.allowedDomainBitmask,</span><br><span class="line"> location.allowedProgTypes,</span><br><span class="line"> location.allowedProgTypesLength);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  读取几个指定路径下面所有.o结束的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Location locations[] = &#123;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Core operating system</span></span><br><span class="line"> &#123;</span><br><span class="line"> .dir = <span class="string">"/system/etc/bpf/"</span>,</span><br><span class="line"> .prefix = <span class="string">""</span>,</span><br><span class="line"> .allowedDomainBitmask = domainToBitmask(domain::platform),</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// Vendor operating system</span></span><br><span class="line"> &#123;</span><br><span class="line"> .dir = <span class="string">"/vendor/etc/bpf/"</span>,</span><br><span class="line"> .prefix = <span class="string">"vendor/"</span>,</span><br><span class="line"> .allowedDomainBitmask = domainToBitmask(domain::vendor),</span><br><span class="line"> .allowedProgTypes = kVendorAllowedProgTypes,</span><br><span class="line"> .allowedProgTypesLength = arraysize(kVendorAllowedProgTypes),</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  函数 <em>loadProg</em> 根据eBPF目标文件中的段创建容器类型，并加载代码到内核：</p><ul><li><p>首先检查是否存在证书的段（SECTION）</p></li><li><p>readCodeSections: 读取ELF文件中段信息, 生成代码段codeSection的列表</p></li><li><p>createMaps: 根据ELF文件中的maps段信息创建对应的map对象供内核空间与用户空间通讯</p></li><li><p>loadCodeSections: 加载目标文件到内核, 并将加载后的fd固定到特定的路径</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadProg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* elfPath, <span class="keyword">bool</span>* isCritical, <span class="keyword">const</span> <span class="keyword">char</span>* prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> allowedDomainBitmask, <span class="keyword">const</span> bpf_prog_type* allowed,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">size_t</span> numAllowed)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; license;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; critical;</span><br><span class="line"> <span class="built_in">vector</span>&lt;codeSection&gt; cs;</span><br><span class="line"> <span class="built_in">vector</span>&lt;unique_fd&gt; mapFds;</span><br><span class="line"> <span class="keyword">int</span> ret;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (!isCritical) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> *isCritical = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function">ifstream <span class="title">elfFile</span><span class="params">(elfPath, ios::in | ios::binary)</span></span>;</span><br><span class="line"> <span class="keyword">if</span> (!elfFile.is_open()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//检查证书</span></span><br><span class="line"> ret = readSectionByName(<span class="string">"critical"</span>, elfFile, critical);</span><br><span class="line"> *isCritical = !ret;</span><br><span class="line"> </span><br><span class="line"> ret = readSectionByName(<span class="string">"license"</span>, elfFile, license);</span><br><span class="line"> </span><br><span class="line"> . . .</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//检查bpf版本</span></span><br><span class="line"> <span class="comment">// the following default values are for bpfloader V0.0 format which does not include them</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> bpfLoaderMinVer =</span><br><span class="line"> readSectionUint(<span class="string">"bpfloader_min_ver"</span>, elfFile, DEFAULT_BPFLOADER_MIN_VER);</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> bpfLoaderMaxVer =</span><br><span class="line"> readSectionUint(<span class="string">"bpfloader_max_ver"</span>, elfFile, DEFAULT_BPFLOADER_MAX_VER);</span><br><span class="line"> <span class="keyword">size_t</span> sizeOfBpfMapDef =</span><br><span class="line"> readSectionUint(<span class="string">"size_of_bpf_map_def"</span>, elfFile, DEFAULT_SIZEOF_BPF_MAP_DEF);</span><br><span class="line"> <span class="keyword">size_t</span> sizeOfBpfProgDef =</span><br><span class="line"> readSectionUint(<span class="string">"size_of_bpf_prog_def"</span>, elfFile, DEFAULT_SIZEOF_BPF_PROG_DEF);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// inclusive lower bound check</span></span><br><span class="line"> <span class="keyword">if</span> (BPFLOADER_VERSION &lt; bpfLoaderMinVer) &#123;</span><br><span class="line"> ALOGI(<span class="string">"BpfLoader version 0x%05x ignoring ELF object %s with min ver 0x%05x"</span>,</span><br><span class="line">   BPFLOADER_VERSION, elfPath, bpfLoaderMinVer);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// exclusive upper bound check</span></span><br><span class="line"> <span class="keyword">if</span> (BPFLOADER_VERSION &gt;= bpfLoaderMaxVer) &#123;</span><br><span class="line"> ALOGI(<span class="string">"BpfLoader version 0x%05x ignoring ELF object %s with max ver 0x%05x"</span>,</span><br><span class="line">   BPFLOADER_VERSION, elfPath, bpfLoaderMaxVer);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ALOGI(<span class="string">"BpfLoader version 0x%05x processing ELF object %s with ver [0x%05x,0x%05x)"</span>,</span><br><span class="line">   BPFLOADER_VERSION, elfPath, bpfLoaderMinVer, bpfLoaderMaxVer);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (sizeOfBpfMapDef &lt; DEFAULT_SIZEOF_BPF_MAP_DEF) &#123;</span><br><span class="line"> ALOGE(<span class="string">"sizeof(bpf_map_def) of %zu is too small (&lt; %d)"</span>, sizeOfBpfMapDef,</span><br><span class="line">   DEFAULT_SIZEOF_BPF_MAP_DEF);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//检查bpfprog堆栈大小</span></span><br><span class="line"> <span class="keyword">if</span> (sizeOfBpfProgDef &lt; DEFAULT_SIZEOF_BPF_PROG_DEF) &#123;</span><br><span class="line"> ALOGE(<span class="string">"sizeof(bpf_prog_def) of %zu is too small (&lt; %d)"</span>, sizeOfBpfProgDef,</span><br><span class="line">   DEFAULT_SIZEOF_BPF_PROG_DEF);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ret = readCodeSections(elfFile, cs, sizeOfBpfProgDef, allowed, numAllowed);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> ALOGE(<span class="string">"Couldn't read all code sections in %s"</span>, elfPath);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Just for future debugging */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span>) dumpAllCs(cs);</span><br><span class="line"> </span><br><span class="line"> ret = createMaps(elfPath, elfFile, mapFds, prefix, allowedDomainBitmask, sizeOfBpfMapDef);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> ALOGE(<span class="string">"Failed to create maps: (ret=%d) in %s"</span>, ret, elfPath);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)mapFds.<span class="built_in">size</span>(); i++)</span><br><span class="line"> ALOGD(<span class="string">"map_fd found at %d is %d in %s"</span>, i, mapFds[i].<span class="built_in">get</span>(), elfPath);</span><br><span class="line"> </span><br><span class="line"> applyMapRelo(elfFile, mapFds, cs);</span><br><span class="line"> </span><br><span class="line"> ret = loadCodeSections(elfPath, cs, <span class="built_in">string</span>(license.data()), prefix, allowedDomainBitmask);</span><br><span class="line"> <span class="keyword">if</span> (ret) ALOGE(<span class="string">"Failed to load programs, loadCodeSections ret=%d"</span>, ret);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过几步安全检查后，接下来执行重要的三个步骤</p><h2 id="2-1-生成代码段"><a href="#2-1-生成代码段" class="headerlink" title="2.1 生成代码段"></a>2.1 生成代码段</h2><p>  读取ELF目标文件中的段头信息，获取到每个BPF段的代码类型，常见有BPF_PROG_TYPE_KPROBE、BPF_PROG_TYPE_TRACEPOINT等，接着查看该段位是否需要重定位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read a section by its index - for ex to get sec hdr strtab blob */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readCodeSections</span><span class="params">(ifstream&amp; elfFile, <span class="built_in">vector</span>&lt;codeSection&gt;&amp; cs, <span class="keyword">size_t</span> sizeOfBpfProgDef,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> bpf_prog_type* allowed, <span class="keyword">size_t</span> numAllowed)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Elf64_Shdr&gt; shTable;</span><br><span class="line"><span class="keyword">int</span> entries, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = readSectionHeadersAll(elfFile, shTable);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">entries = shTable.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;struct bpf_prog_def&gt; pd;</span><br><span class="line">ret = readProgDefs(elfFile, pd, sizeOfBpfProgDef);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; progDefNames;</span><br><span class="line">ret = getSectionSymNames(elfFile, <span class="string">"progs"</span>, progDefNames);</span><br><span class="line"><span class="keyword">if</span> (!pd.empty() &amp;&amp; ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">codeSection cs_temp;</span><br><span class="line">cs_temp.type = BPF_PROG_TYPE_UNSPEC;</span><br><span class="line"></span><br><span class="line">ret = getSymName(elfFile, shTable[i].sh_name, name);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> bpf_prog_type ptype = getSectionType(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptype == BPF_PROG_TYPE_UNSPEC) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!IsAllowed(ptype, allowed, numAllowed)) &#123;</span><br><span class="line">ALOGE(<span class="string">"Program type %s not permitted here"</span>, getSectionName(ptype).c_str());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This must be done before '/' is replaced with '_'.</span></span><br><span class="line">cs_temp.expected_attach_type = getExpectedAttachType(name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> oldName = name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert all slashes to underscores</span></span><br><span class="line"><span class="built_in">std</span>::replace(name.<span class="built_in">begin</span>(), name.<span class="built_in">end</span>(), <span class="string">'/'</span>, <span class="string">'_'</span>);</span><br><span class="line"></span><br><span class="line">cs_temp.type = ptype;</span><br><span class="line">cs_temp.name = name;</span><br><span class="line"></span><br><span class="line">ret = readSectionByIdx(elfFile, i, cs_temp.data);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">ALOGD(<span class="string">"Loaded code section %d (%s)"</span>, i, name.c_str());</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; csSymNames;</span><br><span class="line">ret = getSectionSymNames(elfFile, oldName, csSymNames, STT_FUNC);</span><br><span class="line"><span class="keyword">if</span> (ret || !csSymNames.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; progDefNames.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!progDefNames[i].compare(csSymNames[<span class="number">0</span>] + <span class="string">"_def"</span>)) &#123;</span><br><span class="line">cs_temp.prog_def = pd[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for rel section */</span></span><br><span class="line"><span class="keyword">if</span> (cs_temp.data.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; i &lt; entries) &#123;</span><br><span class="line">ret = getSymName(elfFile, shTable[i + <span class="number">1</span>].sh_name, name);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name == (<span class="string">".rel"</span> + oldName)) &#123;</span><br><span class="line">ret = readSectionByIdx(elfFile, i + <span class="number">1</span>, cs_temp.rel_data);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">ALOGD(<span class="string">"Loaded relo section %d (%s)"</span>, i, name.c_str());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_temp.data.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cs.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(cs_temp));</span><br><span class="line">ALOGD(<span class="string">"Adding section %d to cs list"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  常见的类型有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Map section name prefixes to program types, the section name will be:</span></span><br><span class="line"><span class="comment"> *   SECTION(&lt;prefix&gt;/&lt;name-of-program&gt;)</span></span><br><span class="line"><span class="comment"> * For example:</span></span><br><span class="line"><span class="comment"> *   SECTION("tracepoint/sched_switch_func") where sched_switch_funcs</span></span><br><span class="line"><span class="comment"> * is the name of the program, and tracepoint is the type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, be aware that you should not be directly using the SECTION() macro.</span></span><br><span class="line"><span class="comment"> * Instead use the DEFINE_(BPF|XDP)_(PROG|MAP)... &amp; LICENSE/CRITICAL macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sectionType sectionNameTypes[] = &#123;</span><br><span class="line">&#123;<span class="string">"bind4/"</span>, BPF_PROG_TYPE_CGROUP_SOCK_ADDR, BPF_CGROUP_INET4_BIND&#125;,</span><br><span class="line">&#123;<span class="string">"bind6/"</span>, BPF_PROG_TYPE_CGROUP_SOCK_ADDR, BPF_CGROUP_INET6_BIND&#125;,</span><br><span class="line">&#123;<span class="string">"cgroupskb/"</span>, BPF_PROG_TYPE_CGROUP_SKB, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"cgroupsock/"</span>, BPF_PROG_TYPE_CGROUP_SOCK, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"kprobe/"</span>, BPF_PROG_TYPE_KPROBE, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"perf_event/"</span>, BPF_PROG_TYPE_PERF_EVENT, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"schedact/"</span>, BPF_PROG_TYPE_SCHED_ACT, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"schedcls/"</span>, BPF_PROG_TYPE_SCHED_CLS, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"skfilter/"</span>, BPF_PROG_TYPE_SOCKET_FILTER, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"tracepoint/"</span>, BPF_PROG_TYPE_TRACEPOINT, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#123;<span class="string">"xdp/"</span>, BPF_PROG_TYPE_XDP, BPF_ATTACH_TYPE_UNSPEC&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-创建map对象"><a href="#2-2-创建map对象" class="headerlink" title="2.2 创建map对象"></a>2.2 创建map对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_FS_PATH <span class="meta-string">"/sys/fs/bpf/"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">createMaps</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* elfPath, ifstream&amp; elfFile, <span class="built_in">vector</span>&lt;unique_fd&gt;&amp; mapFds,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">char</span>* prefix, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> allowedDomainBitmask,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">size_t</span> sizeOfBpfMapDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; mdData, btfData;</span><br><span class="line"><span class="built_in">vector</span>&lt;struct bpf_map_def&gt; md;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; mapNames;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">std</span>::pair&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt;&gt; btfTypeIdMap;</span><br><span class="line"><span class="built_in">string</span> fname = pathToFilename(<span class="built_in">string</span>(elfPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">ret = readSectionByName(<span class="string">"maps"</span>, elfFile, mdData);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-2</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// no maps to read</span></span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ret = getSectionSymNames(elfFile, <span class="string">"maps"</span>, mapNames);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> btfMinBpfLoaderVer = readSectionUint(<span class="string">"btf_min_bpfloader_ver"</span>, elfFile, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">unsigned</span> btfMinKernelVer = readSectionUint(<span class="string">"btf_min_kernel_ver"</span>, elfFile, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">unsigned</span> kvers = kernelVersion();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::optional&lt;unique_fd&gt; btfFd;</span><br><span class="line"><span class="keyword">if</span> ((BPFLOADER_VERSION &gt;= btfMinBpfLoaderVer) &amp;&amp; (kvers &gt;= btfMinKernelVer) &amp;&amp;</span><br><span class="line">(!readSectionByName(<span class="string">".BTF"</span>, elfFile, btfData))) &#123;</span><br><span class="line">btfFd = getMapBtfInfo(elfPath, btfTypeIdMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)mapNames.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">enum</span> bpf_map_type type = md[i].type;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line"> <span class="keyword">if</span> (specified(selinux_context)) &#123;</span><br><span class="line"> <span class="built_in">string</span> createLoc = <span class="built_in">string</span>(BPF_FS_PATH) + lookupPinSubdir(selinux_context) +</span><br><span class="line"><span class="string">"tmp_map_"</span> + fname + <span class="string">"_"</span> + mapNames[i];</span><br><span class="line"> ret = bpf_obj_pin(fd, createLoc.c_str());</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="keyword">int</span> err = errno;</span><br><span class="line"> ALOGE(<span class="string">"create %s -&gt; %d [%d:%s]"</span>, createLoc.c_str(), ret, err, strerror(err));</span><br><span class="line"> <span class="keyword">return</span> -err;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = rename(createLoc.c_str(), mapPinLoc.c_str());</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="keyword">int</span> err = errno;</span><br><span class="line"> ALOGE(<span class="string">"rename %s %s -&gt; %d [%d:%s]"</span>, createLoc.c_str(), mapPinLoc.c_str(), ret,</span><br><span class="line">   err, strerror(err));</span><br><span class="line"> <span class="keyword">return</span> -err;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ret = bpf_obj_pin(fd, mapPinLoc.c_str());</span><br><span class="line"> <span class="keyword">if</span> (ret) <span class="keyword">return</span> -errno;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">map_info</span> = &#123;</span>&#125;;</span><br><span class="line">__u32 map_info_len = <span class="keyword">sizeof</span>(map_info);</span><br><span class="line"><span class="keyword">int</span> rv = bpf_obj_get_info_by_fd(fd, &amp;map_info, &amp;map_info_len);</span><br><span class="line"><span class="keyword">if</span> (rv) &#123;</span><br><span class="line">ALOGE(<span class="string">"bpf_obj_get_info_by_fd failed, ret: %d [%d]"</span>, rv, errno);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ALOGI(<span class="string">"map %s id %d"</span>, mapPinLoc.c_str(), map_info.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapFds.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(fd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">903</span>,<span class="number">0</span><span class="number">-1</span>                                                                                     <span class="number">672</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure><p>  为了避免map对象在bpfloader服务退出之后被销毁，会通过bpf_obj_pin将这些对象固定到/sys/fs/bpf/文件节点</p><p>  映射的文件节点，其命名有特定规则，以便其他prog能通过文件路径名称来找到对应的bpfprog。</p><h2 id="2-3-加载prog"><a href="#2-3-加载prog" class="headerlink" title="2.3 加载prog"></a>2.3 加载prog</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loadCodeSections</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* elfPath, <span class="built_in">vector</span>&lt;codeSection&gt;&amp; cs, <span class="keyword">const</span> <span class="built_in">string</span>&amp; license,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">char</span>* prefix, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> allowedDomainBitmask)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> kvers = kernelVersion();</span><br><span class="line">   <span class="keyword">int</span> ret, fd;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!kvers) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">string</span> fname = pathToFilename(<span class="built_in">string</span>(elfPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)cs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">   <span class="built_in">string</span> name = cs[i].name;</span><br><span class="line">   <span class="keyword">unsigned</span> bpfMinVer = DEFAULT_BPFLOADER_MIN_VER;  <span class="comment">// v0.0</span></span><br><span class="line">   <span class="keyword">unsigned</span> bpfMaxVer = DEFAULT_BPFLOADER_MAX_VER;  <span class="comment">// v1.0</span></span><br><span class="line">   domain selinux_context = domain::unspecified;</span><br><span class="line">   domain pin_subdir = domain::unspecified;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cs[i].prog_def.has_value()) &#123;</span><br><span class="line">   <span class="keyword">unsigned</span> min_kver = cs[i].prog_def-&gt;min_kver;</span><br><span class="line">   <span class="keyword">unsigned</span> max_kver = cs[i].prog_def-&gt;max_kver;</span><br><span class="line">   ALOGD(<span class="string">"cs[%d].name:%s min_kver:%x .max_kver:%x (kvers:%x)"</span>, i, name.c_str(), min_kver,</span><br><span class="line"> max_kver, kvers);</span><br><span class="line">   <span class="keyword">if</span> (kvers &lt; min_kver) <span class="keyword">continue</span>;</span><br><span class="line">   <span class="keyword">if</span> (kvers &gt;= max_kver) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">bpfMinVer = cs[i].prog_def-&gt;bpfloader_min_ver;</span><br><span class="line">bpfMaxVer = cs[i].prog_def-&gt;bpfloader_max_ver;</span><br><span class="line">selinux_context = getDomainFromSelinuxContext(cs[i].prog_def-&gt;selinux_context);</span><br><span class="line">pin_subdir = getDomainFromPinSubdir(cs[i].prog_def-&gt;pin_subdir);</span><br><span class="line"><span class="comment">// Note: make sure to only check for unrecognized *after* verifying bpfloader</span></span><br><span class="line"><span class="comment">// version limits include this bpfloader's version.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGD(<span class="string">"cs[%d].name:%s requires bpfloader version [0x%05x,0x%05x)"</span>, i, name.c_str(),</span><br><span class="line">  bpfMinVer, bpfMaxVer);</span><br><span class="line"><span class="keyword">if</span> (BPFLOADER_VERSION &lt; bpfMinVer) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (BPFLOADER_VERSION &gt;= bpfMaxVer) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (unrecognized(pin_subdir)) <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (specified(selinux_context)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!inDomainBitmask(selinux_context, allowedDomainBitmask)) &#123;</span><br><span class="line">ALOGE(<span class="string">"prog %s has invalid selinux_context of %d (allowed bitmask 0x%llx)"</span>,</span><br><span class="line">  name.c_str(), selinux_context, allowedDomainBitmask);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ALOGI(<span class="string">"prog %s selinux_context [%32s] -&gt; %d -&gt; '%s' (%s)"</span>, name.c_str(),</span><br><span class="line">  cs[i].prog_def-&gt;selinux_context, selinux_context,</span><br><span class="line">  lookupSelinuxContext(selinux_context), lookupPinSubdir(selinux_context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (specified(pin_subdir)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!inDomainBitmask(pin_subdir, allowedDomainBitmask)) &#123;</span><br><span class="line">ALOGE(<span class="string">"prog %s has invalid pin_subdir of %d (allowed bitmask 0x%llx)"</span>, name.c_str(),</span><br><span class="line">  pin_subdir, allowedDomainBitmask);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ALOGI(<span class="string">"prog %s pin_subdir [%32s] -&gt; %d -&gt; '%s'"</span>, name.c_str(),</span><br><span class="line">  cs[i].prog_def-&gt;pin_subdir, pin_subdir, lookupPinSubdir(pin_subdir));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strip any potential $foo suffix</span></span><br><span class="line"><span class="comment">// this can be used to provide duplicate programs</span></span><br><span class="line"><span class="comment">// conditionally loaded based on running kernel version</span></span><br><span class="line">name = name.substr(<span class="number">0</span>, name.find_last_of(<span class="string">'$'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> reuse = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// Format of pin location is</span></span><br><span class="line"><span class="comment">// /sys/fs/bpf/&lt;prefix&gt;prog_&lt;filename&gt;_&lt;mapname&gt;</span></span><br><span class="line"><span class="built_in">string</span> progPinLoc = <span class="built_in">string</span>(BPF_FS_PATH) + lookupPinSubdir(pin_subdir, prefix) + <span class="string">"prog_"</span> +</span><br><span class="line">fname + <span class="string">'_'</span> + <span class="built_in">string</span>(name);</span><br><span class="line"><span class="keyword">if</span> (access(progPinLoc.c_str(), F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">fd = retrieveProgram(progPinLoc.c_str());</span><br><span class="line">ALOGD(<span class="string">"New bpf prog load reusing prog %s, ret: %d (%s)"</span>, progPinLoc.c_str(), fd,</span><br><span class="line">  (fd &lt; <span class="number">0</span> ? <span class="built_in">std</span>::strerror(errno) : <span class="string">"no error"</span>));</span><br><span class="line">reuse = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; log_buf(BPF_LOAD_LOG_SZ, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_load_program_attr</span> <span class="title">attr</span> = &#123;</span></span><br><span class="line">.prog_type = cs[i].type,</span><br><span class="line">.name = name.c_str(),</span><br><span class="line">.insns = (struct bpf_insn*)cs[i].data.data(),</span><br><span class="line">.license = license.c_str(),</span><br><span class="line">.log_level = <span class="number">0</span>,</span><br><span class="line">.expected_attach_type = cs[i].expected_attach_type,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd = bcc_prog_load_xattr(&amp;attr, cs[i].data.<span class="built_in">size</span>(), log_buf.data(), log_buf.<span class="built_in">size</span>(),</span><br><span class="line"><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> fd;</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">0</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line"><span class="keyword">if</span> (specified(selinux_context)) &#123;</span><br><span class="line"><span class="built_in">string</span> createLoc = <span class="built_in">string</span>(BPF_FS_PATH) + lookupPinSubdir(selinux_context) +</span><br><span class="line">   <span class="string">"tmp_prog_"</span> + fname + <span class="string">'_'</span> + <span class="built_in">string</span>(name);</span><br><span class="line">ret = bpf_obj_pin(fd, createLoc.c_str());</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = bpf_obj_pin(fd, progPinLoc.c_str());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_info</span> <span class="title">prog_info</span> = &#123;</span>&#125;;</span><br><span class="line">__u32 prog_info_len = <span class="keyword">sizeof</span>(prog_info);</span><br><span class="line"><span class="keyword">int</span> rv = bpf_obj_get_info_by_fd(fd, &amp;prog_info, &amp;prog_info_len);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cs[i].prog_fd.reset(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在上面的load过程中，loader通过attr来明确该prog的信息，将其加载到指定位置，并将加载结果返回给句柄fd，再通过bpf_obj_pin 将该prog固定到/sys/fs/bpf/，防止bpfloader加载完退出后eBPF-prog被销毁。</p><p>  到这一步，eBPF-prog完成了初始化，并且prog也load到了内核。</p><p>  此时只要内核有相应事件发生，都会调到prog处理，并将结果保存在对应的map对象中，用户进程只需要通过bpf的接口BPF_MAP_LOOKUP_ELEM等即可获取map对象中的数据，以完成响应的处理工作</p><h1 id="3-eBPF实例"><a href="#3-eBPF实例" class="headerlink" title="3.  eBPF实例"></a>3.  eBPF实例</h1><p>  接下来，再通过几个实例来进一步认识eBPF的功能</p><h2 id="3-1-Hello，-eBPF-！"><a href="#3-1-Hello，-eBPF-！" class="headerlink" title="3.1 Hello， eBPF ！"></a>3.1 Hello， eBPF ！</h2><p>  先来一个简单的例子，</p><p>  kernel层hello_kern.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf/bpf_helpers.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"tracepoint/syscalls/sys_enter_execve"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"Hello, eBPF !!!\n"</span>;</span><br><span class="line">bpf_trace_printk(str, <span class="keyword">sizeof</span>(str)); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>  user层hello_user.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf_load.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(load_bpf_file(<span class="string">"hello_kern.o"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The kernel didn't load eBPF-prog\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">read_trace_pipe();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  将其放到samples/bpf目录下，在makefile中，添加我们的模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tprogs-y += hello_ebpf</span><br><span class="line">hello-objs := bpf_load.o hello_user.o</span><br><span class="line">always-y += hello_kern.o</span><br></pre></td></tr></table></figure><p>  接着</p><ol><li><p>通过运行<code>./hello_user</code>命令来完成。这将加载<code>hello_kern.o</code>到内核中。<code>load_bpf_file</code>函数负责加载内核模块并将其附加到内核。在这个过程中，内核模块中的eBPF程序（<code>bpf_prog</code>）会被加载到内核中。</p></li><li><p>运行可执行程序<code>./hello</code>（随意一个可执行执行程序），就会触发<code>sys_enter_execve</code> tracepoint。当触发该tracepoint时，内核中已加载的 <code>hello_kern.o</code> eBPF程序（<code>bpf_prog</code>）会被执行，打印一条消息：”Hello, eBPF !!!”。用户空间程序（<code>hello_user</code>）通过读取tracepoint输出，可以看到eBPF程序打印的消息。</p></li></ol><p>  这个简单的示例展示了如何在Linux内核中使用eBPF跟踪tracepoint并打印一条消息。通过这个示例，你可以了解eBPF的基本概念和使用方法。</p><h2 id="3-2-网络管控"><a href="#3-2-网络管控" class="headerlink" title="3.2 网络管控"></a>3.2 网络管控</h2><p>  我们知道在android中有一个doze模式，用来优化息屏下的待机功耗，它定义了一系列的策略，其中有一个是限制息屏下的网络，我们来研究下它是如何实现的。</p><p>  先看下大概流程图，参考如下</p><p><img src="Android_Doze.png" alt=""></p><p>  在 Android Doze模式下，系统会对网络连接进行限制，以减少后台应用程序的网络活动和降低功耗。</p><p>  进入idle后，上层会在deviceidlecontroller 中调用接口实现策略更新，随后将更新后的策略通过 setUidFirewallRule 接口从fwk侧传递到网络侧 packages/modules/Connectivity，最终在ConnectivityService 中来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUidFirewallRule</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> chain, <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> rule)</span> </span>&#123;</span><br><span class="line">enforceNetworkStackOrSettingsPermission();</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mBpfNetMaps.setUidRule(chain, uid, firewallRule);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ServiceSpecificException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set firewall rule for uid</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childChain   target chain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uid          uid to allow/deny</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firewallRule either FIREWALL_RULE_ALLOW or FIREWALL_RULE_DENY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServiceSpecificException in case of failure, with an error code indicating the</span></span><br><span class="line"><span class="comment"> *                                  cause of the failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUidRule</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> childChain, <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> firewallRule)</span> </span>&#123;</span><br><span class="line">throwIfPreT(<span class="string">"setUidRule is not available on pre-T devices"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sEnableJavaBpfMap) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> match = getMatchByFirewallChain(childChain);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isAllowList = isFirewallAllowList(childChain);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> add = (firewallRule == FIREWALL_RULE_ALLOW &amp;&amp; isAllowList)</span><br><span class="line">|| (firewallRule == FIREWALL_RULE_DENY &amp;&amp; !isAllowList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (add) &#123;</span><br><span class="line">addRule(uid, match, <span class="string">"setUidRule"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">removeRule(uid, match, <span class="string">"setUidRule"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> err = native_setUidRule(childChain, uid, firewallRule);</span><br><span class="line">maybeThrow(err, <span class="string">"Unable to set uid rule"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">native_setChildChain</span><span class="params">(JNIEnv* env, jobject self, jint childChain, jboolean enable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> chain = <span class="keyword">static_cast</span>&lt;ChildChain&gt;(childChain);</span><br><span class="line">  <span class="keyword">int</span> res = mTc.toggleUidOwnerMap(chain, enable);</span><br><span class="line">  <span class="keyword">if</span> (res) ALOGE(<span class="string">"%s failed, error code = %d"</span>, __func__, res);</span><br><span class="line">  <span class="keyword">return</span> (jint)res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最终在 TrafficController 中完成规则的更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> TrafficController::toggleUidOwnerMap(ChildChain chain, bool enable) &#123;</span><br><span class="line">std::<span class="function">lock_guard <span class="title">guard</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">uint32_t key = UID_RULES_CONFIGURATION_KEY;</span><br><span class="line">auto oldConfigure = mConfigurationMap.readValue(key);</span><br><span class="line"><span class="keyword">if</span> (!oldConfigure.ok()) &#123;</span><br><span class="line">ALOGE(<span class="string">"Cannot read the old configuration from map: %s"</span>,</span><br><span class="line">  oldConfigure.error().message().c_str());</span><br><span class="line"><span class="keyword">return</span> -oldConfigure.error().code();</span><br><span class="line">&#125;</span><br><span class="line">uint32_t match;</span><br><span class="line"><span class="keyword">switch</span> (chain) &#123;</span><br><span class="line"><span class="keyword">case</span> DOZABLE:</span><br><span class="line">match = DOZABLE_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STANDBY:</span><br><span class="line">match = STANDBY_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> POWERSAVE:</span><br><span class="line">match = POWERSAVE_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RESTRICTED:</span><br><span class="line">match = RESTRICTED_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LOW_POWER_STANDBY:</span><br><span class="line">match = LOW_POWER_STANDBY_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OEM_DENY_1:</span><br><span class="line">match = OEM_DENY_1_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OEM_DENY_2:</span><br><span class="line">match = OEM_DENY_2_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OEM_DENY_3:</span><br><span class="line">match = OEM_DENY_3_MATCH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">BpfConfig newConfiguration =</span><br><span class="line">enable ? (oldConfigure.value() | match) : (oldConfigure.value() &amp; ~match);</span><br><span class="line">Status res = mConfigurationMap.writeValue(key, newConfiguration, BPF_EXIST);</span><br><span class="line"><span class="keyword">if</span> (!isOk(res)) &#123;</span><br><span class="line">ALOGE(<span class="string">"Failed to toggleUidOwnerMap(%d): %s"</span>, chain, res.msg().c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -res.code();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当手机处于doze模式下待机，网卡接收到数据包通过中断唤醒CPU后，经由协议栈解析socket包（这里假设是tcp的包）时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The socket must have it's spinlock held when we get</span></span><br><span class="line"><span class="comment"> * here, unless it is a TCP_LISTEN socket.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We have a potential double-lock case here, so even when</span></span><br><span class="line"><span class="comment"> * doing backlog processing we use the BH locking scheme.</span></span><br><span class="line"><span class="comment"> * This is because we cannot sleep with the original spinlock</span></span><br><span class="line"><span class="comment"> * held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_do_rcv</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> skb_drop_reason reason;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rsk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设需要我们处理的是 ESTABLISH 状态下的包  </span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) &#123; <span class="comment">/* Fast path */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span>;</span></span><br><span class="line"></span><br><span class="line">dst = rcu_dereference_protected(sk-&gt;sk_rx_dst,</span><br><span class="line">lockdep_sock_is_held(sk));</span><br><span class="line"></span><br><span class="line">sock_rps_save_rxhash(sk, skb);</span><br><span class="line">sk_mark_napi_id(sk, skb);</span><br><span class="line"><span class="keyword">if</span> (dst) &#123;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_rx_dst_ifindex != skb-&gt;skb_iif ||</span><br><span class="line">!INDIRECT_CALL_1(dst-&gt;ops-&gt;check, ipv4_dst_check,</span><br><span class="line"> dst, <span class="number">0</span>)) &#123;</span><br><span class="line">RCU_INIT_POINTER(sk-&gt;sk_rx_dst, <span class="literal">NULL</span>);</span><br><span class="line">dst_release(dst);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tcp_rcv_established(sk, skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reason = SKB_DROP_REASON_NOT_SPECIFIED;</span><br><span class="line"><span class="keyword">if</span> (tcp_checksum_complete(skb))</span><br><span class="line"><span class="keyword">goto</span> csum_err;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_v4_do_rcv);</span><br></pre></td></tr></table></figure><p>  进一处理处于连接状态下的skb数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_rcv_established</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">. . .    </span><br><span class="line"><span class="comment">//关于协议栈处理数据包的源码太长，只关注我们需要的部分</span></span><br><span class="line"><span class="keyword">if</span> (!tcp_validate_incoming(sk, skb, th, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_rcv_established);</span><br></pre></td></tr></table></figure><p>  这里会根据skb里header的source和dest信息来查找对应socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_validate_incoming</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> struct tcphdr *th, <span class="keyword">int</span> syn_inerr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">SKB_DR(reason);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">bpf_skops_parse_hdr(sk, skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">discard:</span><br><span class="line">tcp_drop_reason(sk, skb, reason);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  走到这里，终于回到了我们的eBPF程序上。当一个网络数据包到达设备时，eBPF会根据预先定义的过滤规则来决定是否允许该数据包通过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bpf_skops_parse_hdr</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">/* The skb will be handled in the</span></span><br><span class="line"><span class="comment"> * bpf_skops_established() or</span></span><br><span class="line"><span class="comment"> * bpf_skops_write_hdr_opt().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line"><span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line"><span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sock_owned_by_me(sk);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;sock_ops, <span class="number">0</span>, offsetof(struct bpf_sock_ops_kern, temp));</span><br><span class="line">sock_ops.op = BPF_SOCK_OPS_PARSE_HDR_OPT_CB;</span><br><span class="line">sock_ops.is_fullsock = <span class="number">1</span>;</span><br><span class="line">sock_ops.sk = sk;</span><br><span class="line">bpf_skops_init_skb(&amp;sock_ops, skb, tcp_hdrlen(skb));</span><br><span class="line"></span><br><span class="line">BPF_CGROUP_RUN_PROG_SOCK_OPS(&amp;sock_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_CGROUP_RUN_PROG_SOCK_OPS(sock_ops)                                       \</span></span><br><span class="line">(&#123;                                                                               \</span><br><span class="line"><span class="keyword">int</span> __ret = <span class="number">0</span>;                                                               \</span><br><span class="line"><span class="keyword">if</span> (cgroup_bpf_enabled(CGROUP_SOCK_OPS) &amp;&amp; (sock_ops)-&gt;sk) &#123;       \</span><br><span class="line">typeof(sk) __sk = sk_to_full_sk((sock_ops)-&gt;sk);               \</span><br><span class="line"><span class="keyword">if</span> (__sk &amp;&amp; sk_fullsock(__sk))                                       \</span><br><span class="line">__ret = __cgroup_bpf_run_filter_sock_ops(__sk,               \</span><br><span class="line"> sock_ops,     \</span><br><span class="line"> CGROUP_SOCK_OPS); \</span><br><span class="line">&#125;                                                                       \</span><br><span class="line">__ret;                                                                       \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  在cgroup中实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __cgroup_bpf_run_filter_sock_ops() - Run a program on a sock</span></span><br><span class="line"><span class="comment"> * @sk: socket to get cgroup from</span></span><br><span class="line"><span class="comment"> * @sock_ops: bpf_sock_ops_kern struct to pass to program. Contains</span></span><br><span class="line"><span class="comment"> * sk with connection information (IP addresses, etc.) May not contain</span></span><br><span class="line"><span class="comment"> * cgroup info if it is a req sock.</span></span><br><span class="line"><span class="comment"> * @type: The type of program to be executed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * socket passed is expected to be of type INET or INET6.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The program type passed in via @type must be suitable for sock_ops</span></span><br><span class="line"><span class="comment"> * filtering. No further check is performed to assert that.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will return %-EPERM if any if an attached program was found</span></span><br><span class="line"><span class="comment"> * and if it returned != 1 during execution. In all other cases, 0 is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __cgroup_bpf_run_filter_sock_ops(struct sock *sk,</span><br><span class="line"> struct bpf_sock_ops_kern *sock_ops,</span><br><span class="line"> <span class="keyword">enum</span> cgroup_bpf_attach_type atype)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span> = <span class="title">sock_cgroup_ptr</span>(&amp;<span class="title">sk</span>-&gt;<span class="title">sk_cgrp_data</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bpf_prog_run_array_cg(&amp;cgrp-&gt;bpf, atype, sock_ops, bpf_prog_run,</span><br><span class="line"> <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__cgroup_bpf_run_filter_sock_ops);</span><br></pre></td></tr></table></figure><p>  走到这里，就调到了hook的eBPF-prog，这里挂载的是网络侧的netd，源码位于</p><p>  packages/modules/Connectivity/bpf_progs/netd.c，与之相关的挂载点如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_BPF_PROG_EXT(<span class="string">"cgroupskb/ingress/stats$trace"</span>, AID_ROOT, AID_SYSTEM,</span><br><span class="line">bpf_cgroup_ingress_trace, KVER(<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>), KVER_INF,</span><br><span class="line">BPFLOADER_IGNORED_ON_VERSION, BPFLOADER_MAX_VER, <span class="literal">false</span>,</span><br><span class="line"><span class="string">"fs_bpf_netd_readonly"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">(struct __sk_buff* skb) &#123;</span><br><span class="line"><span class="keyword">return</span> bpf_traffic_account(skb, INGRESS, TRACE_ON, KVER(<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_NETD_BPF_PROG_KVER_RANGE(<span class="string">"cgroupskb/ingress/stats$4_19"</span>, AID_ROOT, AID_SYSTEM,</span><br><span class="line">bpf_cgroup_ingress_4_19, KVER(<span class="number">4</span>, <span class="number">19</span>, <span class="number">0</span>), KVER_INF)</span><br><span class="line">(struct __sk_buff* skb) &#123;</span><br><span class="line"><span class="keyword">return</span> bpf_traffic_account(skb, INGRESS, TRACE_OFF, KVER(<span class="number">4</span>, <span class="number">19</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_NETD_BPF_PROG_KVER_RANGE(<span class="string">"cgroupskb/ingress/stats$4_14"</span>, AID_ROOT, AID_SYSTEM,</span><br><span class="line">bpf_cgroup_ingress_4_14, KVER_NONE, KVER(<span class="number">4</span>, <span class="number">19</span>, <span class="number">0</span>))</span><br><span class="line">(struct __sk_buff* skb) &#123;</span><br><span class="line"><span class="keyword">return</span> bpf_traffic_account(skb, INGRESS, TRACE_OFF, KVER_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_BPF_PROG_EXT(<span class="string">"cgroupskb/egress/stats$trace"</span>, AID_ROOT, AID_SYSTEM,</span><br><span class="line">bpf_cgroup_egress_trace, KVER(<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>), KVER_INF,</span><br><span class="line">BPFLOADER_IGNORED_ON_VERSION, BPFLOADER_MAX_VER, <span class="literal">false</span>,</span><br><span class="line"><span class="string">"fs_bpf_netd_readonly"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">(struct __sk_buff* skb) &#123;</span><br><span class="line"><span class="keyword">return</span> bpf_traffic_account(skb, EGRESS, TRACE_ON, KVER(<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_NETD_BPF_PROG_KVER_RANGE(<span class="string">"cgroupskb/egress/stats$4_19"</span>, AID_ROOT, AID_SYSTEM,</span><br><span class="line">bpf_cgroup_egress_4_19, KVER(<span class="number">4</span>, <span class="number">19</span>, <span class="number">0</span>), KVER_INF)</span><br><span class="line">(struct __sk_buff* skb) &#123;</span><br><span class="line"><span class="keyword">return</span> bpf_traffic_account(skb, EGRESS, TRACE_OFF, KVER(<span class="number">4</span>, <span class="number">19</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_NETD_BPF_PROG_KVER_RANGE(<span class="string">"cgroupskb/egress/stats$4_14"</span>, AID_ROOT, AID_SYSTEM,</span><br><span class="line">bpf_cgroup_egress_4_14, KVER_NONE, KVER(<span class="number">4</span>, <span class="number">19</span>, <span class="number">0</span>))</span><br><span class="line">(struct __sk_buff* skb) &#123;</span><br><span class="line"><span class="keyword">return</span> bpf_traffic_account(skb, EGRESS, TRACE_OFF, KVER_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  均会调到 bpf_traffic_account</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bpf_traffic_account</span><span class="params">(struct __sk_buff* skb, <span class="keyword">bool</span> egress,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">bool</span> enable_tracing,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> sock_uid = bpf_get_socket_uid(skb);</span><br><span class="line"><span class="keyword">uint64_t</span> cookie = bpf_get_socket_cookie(skb);</span><br><span class="line">. . .</span><br><span class="line"><span class="keyword">int</span> match = bpf_owner_match(skb, sock_uid, egress, kver);</span><br><span class="line">. . .</span><br><span class="line"><span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里设定了skb的处理规则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DROP_IF_SET is set of rules that DROP if rule is globally enabled, and per-uid bit is set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DROP_IF_SET (STANDBY_MATCH | OEM_DENY_1_MATCH | OEM_DENY_2_MATCH | OEM_DENY_3_MATCH)</span></span><br><span class="line"><span class="comment">// DROP_IF_UNSET is set of rules that should DROP if globally enabled, and per-uid bit is NOT set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DROP_IF_UNSET (DOZABLE_MATCH | POWERSAVE_MATCH | RESTRICTED_MATCH | LOW_POWER_STANDBY_MATCH)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bpf_owner_match</span><span class="params">(struct __sk_buff* skb, <span class="keyword">uint32_t</span> uid,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">bool</span> egress, <span class="keyword">const</span> <span class="keyword">unsigned</span> kver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_system_uid(uid)) <span class="keyword">return</span> PASS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skip_owner_match(skb, egress, kver)) <span class="keyword">return</span> PASS;</span><br><span class="line"></span><br><span class="line">BpfConfig enabledRules = getConfig(UID_RULES_CONFIGURATION_KEY);</span><br><span class="line"></span><br><span class="line">UidOwnerValue* uidEntry = bpf_uid_owner_map_lookup_elem(&amp;uid);</span><br><span class="line"><span class="keyword">uint32_t</span> uidRules = uidEntry ? uidEntry-&gt;rule : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> allowed_iif = uidEntry ? uidEntry-&gt;iif : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning: funky bit-wise arithmetic: in parallel, for all DROP_IF_SET/UNSET rules</span></span><br><span class="line"><span class="comment">// check whether the rules are globally enabled, and if so whether the rules are</span></span><br><span class="line"><span class="comment">// set/unset for the specific uid.  DROP if that is the case for ANY of the rules.</span></span><br><span class="line"><span class="comment">// We achieve this by masking out only the bits/rules we're interested in checking,</span></span><br><span class="line"><span class="comment">// and negating (via bit-wise xor) the bits/rules that should drop if unset.</span></span><br><span class="line"><span class="keyword">if</span> (enabledRules &amp; (DROP_IF_SET | DROP_IF_UNSET) &amp; (uidRules ^ DROP_IF_UNSET)) <span class="keyword">return</span> DROP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!egress &amp;&amp; skb-&gt;ifindex != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (uidRules &amp; IIF_MATCH) &#123;</span><br><span class="line"><span class="keyword">if</span> (allowed_iif &amp;&amp; skb-&gt;ifindex != allowed_iif) &#123;</span><br><span class="line"><span class="comment">// Drops packets not coming from lo nor the allowed interface</span></span><br><span class="line"><span class="comment">// allowed interface=0 is a wildcard and does not drop packets</span></span><br><span class="line"><span class="keyword">return</span> DROP_UNLESS_DNS;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (uidRules &amp; LOCKDOWN_VPN_MATCH) &#123;</span><br><span class="line"><span class="comment">// Drops packets not coming from lo and rule does not have IIF_MATCH but has</span></span><br><span class="line"><span class="comment">// LOCKDOWN_VPN_MATCH</span></span><br><span class="line"><span class="keyword">return</span> DROP_UNLESS_DNS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  根据预设的规则来决定该socket包的处理方式，是BPF_ALLOW还是DROP，分别对应该socket包的流转方式，比如BPF_ALLOW代表允许该socket包按照预设流程继续流转（唤醒客户端进程，传递socket包给应用程序解析），DROP即代表抛弃该socket包，停止流转。</p><p>  以上是eBPF在tcp包上的应用，udp的包处理方式类似，就是在kernel中协议栈那里调用的接口不同。</p><p>  以上就是android基于eBPF来实现doze下网络限制的基本原理。基于android实现的netd，我们还可扩展很多其他功能。比如我们期望能过滤指定应用的数据，而将其他应用的数据全部给拦截下来，这个在上层实现可能比较困难，但是基于eBPF实现就非常简单。可以通过将指定应用的uid写入map，在netd拦截到skb时去读取map来校验是否匹配，从而选择对应的处理方式。将超白名单中的所有即时通讯应用都纳入冻结管控，清除超级白名单，而应用收到网络消息的时候也能触发解冻流程，避免消息数据延迟和丢失，又能降低功耗。</p><p>  流量过滤也是类似原理，大家有兴趣可以自行研究。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a><br><a href="https://linux.cn/article-9507-1.html" target="_blank" rel="noopener">技术|深入理解 BPF:一个阅读清单</a><br><a href="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">Learn eBPF Tracing: Tutorial and Examples</a><br><a href="https://www.ferrisellis.com/content/ebpf_syscall_and_maps/" target="_blank" rel="noopener">FerrisEllis.com</a><br><a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">GitHub - iovisor/bcc: BCC - Tools for BPF-based Linux IO analysis, networking, monitoring, and more</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> eBPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Input 调试与优化</title>
      <link href="/2023/10/27/Android-inputTuning-and-Optimizing/"/>
      <url>/2023/10/27/Android-inputTuning-and-Optimizing/</url>
      
        <content type="html"><![CDATA[<p>Android input系统负责处理与管理用户输入， 是用户交互体验的中枢，涉及从上到下各个领域。当遇到一些复杂的 Input 相关性能问题时，如何进行精准的 Debug 定位呢？本篇旨在介绍android Input的工作流程及debug手段，并借助perfetto工具，分享一些 Android Input Debug 与优化的实践和相应的优化方案。</p><h1 id="一-Android-input-常用debug-手段"><a href="#一-Android-input-常用debug-手段" class="headerlink" title="一. Android input 常用debug 手段"></a>一. Android input 常用debug 手段</h1><h2 id="1-1-底层"><a href="#1-1-底层" class="headerlink" title="1.1 底层"></a>1.1 底层</h2><ul><li><p>“<strong>adb shell getevent</strong>“ 命令可以获取Android kernel层上报到/dev/input/目录下的原始数据, 确定驱动层是否能正常的生成数据。</p></li><li><p>“<strong>adb shell input keyevent</strong> key-value” 可以模拟进行按键的点击，将点击事件直接通过InputDispatcher的injectInputEvent方法发送到Native层，若这边有问题表示InputDispatcher的拦截和分发存在问题。</p></li></ul><h2 id="1-2-上层"><a href="#1-2-上层" class="headerlink" title="1.2 上层"></a>1.2 上层</h2><ul><li><p>“<strong>adb shell dumpsys input</strong>“ 可以输出一些input系统运行时的一些信息，比如关键字RecentQueue，记录了10条最近的Input事件信息。还有诸如PendingEvent，InboundQueue，Windows，Connections等信息。</p></li><li><p>“<strong>adb shell setprop sys.inputlog.enabled true</strong>“ 打开native 层log。去确认是否有底层是否是事件上报？native 层是否drop 了事件？ 等等怀疑点。如果有需要， 也可打开以下log开关：</p></li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/inputflinger/reader/Macros.cpp </span></span><br><span class="line">DEBUG_RAW_EVENTS  </span><br><span class="line">DEBUG_VIRTUAL_KEYS DEBUG_POINTERS DEBUG_POINTER_ASSIGNMENT </span><br><span class="line">DEBUG_GESTURES DEBUG_VIBRATOR DEBUG_STYLUS_FUSION </span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</span></span><br><span class="line">DEBUG_INPUT_READER_POLICY </span><br><span class="line">DEBUG_INPUT_DISPATCHER_POLICY</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/native/services/inputflinger/dispatcher/inputDispatcher.cpp</span></span><br><span class="line">DEBUG_FOCUS</span><br><span class="line">DEBUG_INJECTION</span><br></pre></td></tr></table></figure><ul><li>开启ViewRootImpl/View/ViewGroup中input event的处理过程的log开关。 去确认以下怀疑点：Input 事件传递到了哪个window？ 有没有被正确的view处理？有没有被drop?等等。</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/WindowManagerDebugConfig.java  </span></span><br><span class="line">DEBUG_INPUT = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/view/KeyEvent.java </span></span><br><span class="line">DEBUG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/view/ViewRootImpl.java </span></span><br><span class="line">DEBUG_INPUT_RESIZE = <span class="keyword">true</span>;</span><br><span class="line">DEBUG_INPUT_STAGES = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/view/ViewDebug.java</span></span><br><span class="line">DEBUG_POSITIONING = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>以上都需要动态或者静态的打开Log 开关，通过log 来分析定位。但是对于一些偶现复杂的问题， log就会很大，分析起来很困难。</p><p>因此本篇推荐使用perfetto trace来分析定位复杂的android Input 问题，主要基于以下优点：</p><ol><li><p>抓取方便，相对于log对系统性能影响很小；</p></li><li><p>相对于Log 更直观，分析起来更容易。</p></li><li><p>Perfetto 抓取的信息更全面，定位更精准。</p></li></ol><h1 id="二-Android-input-传递流程"><a href="#二-Android-input-传递流程" class="headerlink" title="二. Android input 传递流程"></a>二. Android input 传递流程</h1><p>当用户进行触摸、按键等操作时，硬件会产生相应的事件，这些事件经过内核的输入子系统处理后，会被传递给 Android 系统的 Input 系统。然后再由 Input 系统将事件分发给对应的应用程序处理。在这个过程中，会涉及到事件的传递、分发、处理等多个环节，任何一个环节有问题，都会引入bug或性能问题。</p><h2 id="2-1-Android-input-传递流程"><a href="#2-1-Android-input-传递流程" class="headerlink" title="2.1 Android input 传递流程"></a>2.1 Android input 传递流程</h2><p>Android input 事件的整体传递流程见下图。</p><p><img src="whiteboard_exported_image.jpg" alt=""></p><h2 id="2-2-perfetto-trace-上-input-工作流"><a href="#2-2-perfetto-trace-上-input-工作流" class="headerlink" title="2.2 perfetto trace 上 input 工作流"></a>2.2 perfetto trace 上 input 工作流</h2><p>perfetto trace 包含的信息很丰富，怎么在浩如烟海的信息中寻找input的关键脉络呢？ 如下图：</p><p><img src="perfetto_trace.PNG" alt=""></p><p>按上图中序号，具体流程如下：</p><ol><li><p>底层产生一个Input事件，通过中断通知cpu,cpu 响应中断并通知驱动去处理，kernel 往/dev/input/event** 写数据。</p></li><li><p>InputReader 调用EventHub的 getEvents() 方法接收底层事件，把从/dev/input/event** 中读取的raw event (struct input_event) 转成 android event (keymap/layout) ，然后交给 InputDispatcher 进行事件分发。</p></li><li><p>InputDispatcher 拿到 InputReader 获取的事件之后，对事件进行包装和分发。</p></li><li><p>InputDispatcher 执行 notifyKey 的时候，会将 Input 事件封装后放到 InboundQueue 也就是“iq”队列中，后续 InputDispatcher 循环处理 Input 事件的时候，就是从 InboundQueue 取出事件然后做处理。</p></li><li><p>InputDispatcher 找到target window后，将事件放入对应的target window OutboundQueue也就是“oq”队列中等待通过SocketPair双工信道发送到Target window。这里的 OutboundQueue 指的是要被 App 拿去处理的事件队列，每一个 App(Connection) 都对应有一个 OutboundQueue ，事件会先进入 InboundQueue ，然后被 InputDIspatcher 派发到各个 App 的 OutboundQueue。</p></li><li><p>InputDispatcher把事件发送给具体的Target window后，会将事件从outboundQueue 中取出来放到WaitQueue也就是“wq”中，等待目标应用处理事件完成。并开启倒计时，如果超时，就会上报应用ANR异常事件。当分发出去的事件被处理完成，InputManagerService 就会从应用中得到一个回复，这里面会通过JNI通知InputDispatcher事件处理完成，此时就会移除 WaitQueue 中的事件，以免报ANR异常，从perfetto中看就是对应 App 的 WaitQueue 值减少了1。如果app主线程发生卡顿，那么 Input 事件没有及时被消耗，WaitQueue 这里就会看到堆积。</p></li><li><p>当input触控事件传递到App进程后，先通过enqueueInputEvent函数放入“aq”本地待处理队列中。</p></li><li><p>应用的UI线程在deliverInputEvent的流程中进行input事件的具体分发与处理。</p></li></ol><p>下面是跟踪 InboundQueue， OutBoundQueue ，WaitQueue的源码，可以据此查询调用的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::traceInboundQueueLengthLocked</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">   <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">       ATRACE_INT(<span class="string">"iq"</span>, mInboundQueue.<span class="built_in">size</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::traceOutboundQueueLength</span><span class="params">(<span class="keyword">const</span> Connection&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="keyword">char</span> counterName[<span class="number">40</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(counterName, <span class="keyword">sizeof</span>(counterName), <span class="string">"oq:%s"</span>, connection.getWindowName().c_str());</span><br><span class="line">        ATRACE_INT(counterName, connection.outboundQueue.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::traceWaitQueueLength</span><span class="params">(<span class="keyword">const</span> Connection&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="keyword">char</span> counterName[<span class="number">40</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(counterName, <span class="keyword">sizeof</span>(counterName), <span class="string">"wq:%s"</span>,  connection.getWindowName().c_str());</span><br><span class="line">        ATRACE_INT(counterName, connection.waitQueue.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-Android-input-debug与优化实践"><a href="#三-Android-input-debug与优化实践" class="headerlink" title="三. Android input debug与优化实践"></a>三. Android input debug与优化实践</h1><h2 id="3-1-input关键线程调度优化"><a href="#3-1-input关键线程调度优化" class="headerlink" title="3.1 input关键线程调度优化"></a>3.1 input关键线程调度优化</h2><p>在某游戏界面滑动卡顿，偶现不跟手。app 侧在trace 上发现应用DeliverInputEvent 有时候没收到（见下图），app侧怀疑是TP报点异常。</p><p><img src="DeliverInputEvent.png" alt=""></p><p>这个input 事件到底是底层没上报，还是中间传递卡住了呢？只需要弄清楚在input 链路上到底是卡在哪里，也就明白了问题所在。在trace上查看整个input链路，发现有两点异常（如下图）。1，InputReader 由于长时间runnable 没有及时去读取底层的事件；2，InputDispatcher 由于长时间runnable 没有及时的将事件分发出去。在input 链路中任何一步处理不及时，都会导致最终的响应不及时。</p><p><img src="InputReader&amp;InputDispatcher.png" alt=""></p><p>在游戏场景下，Tp报点率比较高，对InputReader 和InputDisaptcher 等线程的调度及时性要求比较高，修改相关线程的调度策略后，测试实测改善很大，perfetto trace 截图如下。</p><p><img src="InputReader&amp;InputDispatcher1.png" alt=""></p><h2 id="3-2-减少帧的上屏时间"><a href="#3-2-减少帧的上屏时间" class="headerlink" title="3.2 减少帧的上屏时间"></a>3.2 减少帧的上屏时间</h2><p>在触控操作中，有时会发现应用程序提交当前帧的时间刚好错过了一个VSync周期，就得等待下一个VSync周期的到来，中间这段时间是闲置的。如下图。</p><p><img src="perfetto_trace_VSync.PNG" alt=""></p><p>尝试这么优化：当应用提交当前帧给SurfaceFlinger的时间减去上一次SurfaceFlinger唤醒的时间超过了1个VSync周期，小于3/2个周期时，直接通知SurfaceFlinger进行Message处理，最优时候可以节约出1帧时间。无论对于响应时间还是帧率的稳定性，效果都有提升。优化后trace 截图如下：</p><p><img src="perfetto_trace_VSync1.PNG" alt=""></p><h2 id="3-3-点击桌面图标响应时间优化"><a href="#3-3-点击桌面图标响应时间优化" class="headerlink" title="3.3 点击桌面图标响应时间优化"></a>3.3 点击桌面图标响应时间优化</h2><p>在桌面点击图标启动应用，响应时间较对比机差。最初抓log 分析没发现问题点。借助强大的perfetto抓取 trace，我们发现点击之后，应用没有立即执行点击事件，等了几帧之后才执行。如下图。原来android为了UI界面的一致性与连贯性，将点击事件发送到消息队列中，待其他视觉状态更新之后才执行点击操作。</p><p><img src="perfetto_trace_Timeline.PNG" alt=""></p><p>尝试修改成立即执行点击事件后，最优有2~3帧的收益，如下图。当然这是非通用改法，需要对side effect做bug fix。</p><p><img src="perfetto_trace_Timeline1.PNG" alt=""></p><h3 id="3-4-其他"><a href="#3-4-其他" class="headerlink" title="3.4 其他"></a>3.4 其他</h3><ul><li><p>Tp 固件优化，减少Tp 休眠时间， 提高采样率，当然这会带来功耗的增加， 需要针对场景来做动态的改变。</p></li><li><p>提高屏幕刷新率。</p></li><li><p>改善控件的响应，提高感知触控的敏感性。包括：修改滑动控件的阀值、调低摩擦力系数和样条滑动持续时间等参数，以及调整view的触摸区域等等。</p></li><li><p>其他。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸解锁带来的安卓系统崩溃之谜！</title>
      <link href="/2023/07/07/Face-recognition-block-analysis/"/>
      <url>/2023/07/07/Face-recognition-block-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h2><p>用户反馈开启人脸解锁后，偶现密码解锁、指纹解锁、人脸解锁均无法使用，系统卡死随后出现安卓重启。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><strong>问题分析</strong></h2><h3 id="SWT之初步释疑"><a href="#SWT之初步释疑" class="headerlink" title="SWT之初步释疑"></a><strong>SWT之初步释疑</strong></h3><p>查看android SWT(Software Watchdog Timeout)日志，发现android.ui线程卡死。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject: Blocked in <span class="keyword">handler</span> <span class="keyword">on</span> ui <span class="keyword">thread</span> (android.ui)</span><br></pre></td></tr></table></figure></p><p>查看android.ui堆栈，可以看到该线程一直在等锁，锁id为0x05158af1。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"android.ui"</span> prio=<span class="number">5</span> tid=<span class="number">12</span> Blocked</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=<span class="number">1</span> ucsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0</span>x17f405e8 self=<span class="number">0</span>xb400007df01a8800</span><br><span class="line">  | sysTid=<span class="number">2904</span> nice=-<span class="number">2</span> cgrp=top-app sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0</span>x7de7bbbcb0</span><br><span class="line">  | state=S schedstat=( <span class="number">8623914505397</span> <span class="number">6889640642861</span> <span class="number">50368108</span> ) utm=<span class="number">519874</span> stm=<span class="number">342516</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0</span>x7de7ab8000-<span class="number">0</span>x7de7aba000 stackSize=<span class="number">1039</span>KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at <span class="keyword">com</span>.android.server.locksettings.LockSettingsService.getCredentialTypeInternal(LockSettingsService.jav<span class="variable">a:1341</span>)</span><br><span class="line">  - waiting <span class="keyword">to</span> lock <span class="symbol">&lt;0x05158af1&gt;</span> (<span class="keyword">a</span> <span class="keyword">com</span>.android.server.locksettings.SyntheticPasswordManager) held by thread <span class="number">178</span></span><br><span class="line">  at <span class="keyword">com</span>.android.server.locksettings.LockSettingsService.getCredentialType(LockSettingsService.jav<span class="variable">a:1328</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.internal.widget.LockPatternUtils$<span class="number">1</span>.apply(LockPatternUtils.jav<span class="variable">a:946</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.internal.widget.LockPatternUtils$<span class="number">1</span>.apply(LockPatternUtils.jav<span class="variable">a:942</span>)</span><br><span class="line">  at android.app.PropertyInvalidatedCache.recompute(PropertyInvalidatedCache.jav<span class="variable">a:754</span>)</span><br><span class="line">  at android.app.PropertyInvalidatedCache.query(PropertyInvalidatedCache.jav<span class="variable">a:971</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.internal.widget.LockPatternUtils.getCredentialTypeForUser(LockPatternUtils.jav<span class="variable">a:985</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.internal.widget.LockPatternUtils.getKeyguardStoredPasswordQuality(LockPatternUtils.jav<span class="variable">a:819</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.<span class="keyword">view</span>.FlymeConfirmPasswordView.getPasswordType(FlymeConfirmPasswordView.jav<span class="variable">a:238</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.<span class="keyword">view</span>.FlymeConfirmPasswordView.refreshViews(FlymeConfirmPasswordView.jav<span class="variable">a:118</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.<span class="keyword">view</span>.FlymeConfirmPasswordView.initViews(FlymeConfirmPasswordView.jav<span class="variable">a:114</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.<span class="keyword">view</span>.FlymeConfirmPasswordView.<span class="symbol">&lt;init&gt;</span>(FlymeConfirmPasswordView.jav<span class="variable">a:81</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.<span class="keyword">view</span>.FlymeConfirmPasswordView.<span class="symbol">&lt;init&gt;</span>(FlymeConfirmPasswordView.jav<span class="variable">a:75</span>)</span><br><span class="line">  at java.lang.reflect.Constructor.newInstance0(Native method)</span><br><span class="line">  at java.lang.reflect.Constructor.newInstance(Constructor.jav<span class="variable">a:343</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.createView(LayoutInflater.jav<span class="variable">a:858</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.createViewFromTag(LayoutInflater.jav<span class="variable">a:1010</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.createViewFromTag(LayoutInflater.jav<span class="variable">a:965</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.rInflate(LayoutInflater.jav<span class="variable">a:1127</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.rInflateChildren(LayoutInflater.jav<span class="variable">a:1088</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.rInflate(LayoutInflater.jav<span class="variable">a:1130</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.rInflateChildren(LayoutInflater.jav<span class="variable">a:1088</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.inflate(LayoutInflater.jav<span class="variable">a:686</span>)</span><br><span class="line">  - locked <span class="symbol">&lt;0x0f6a962a&gt;</span> (<span class="keyword">a</span> java.lang.Object[])</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.inflate(LayoutInflater.jav<span class="variable">a:538</span>)</span><br><span class="line">  at android.<span class="keyword">view</span>.LayoutInflater.inflate(LayoutInflater.jav<span class="variable">a:485</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.internal.policy.PhoneWindow.setContentView(PhoneWindow.jav<span class="variable">a:474</span>)</span><br><span class="line">  at android.app.Dialog.setContentView(Dialog.jav<span class="variable">a:597</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.MzGlobalActions$MzGlobalActionsDialog.onCreate(MzGlobalActions.jav<span class="variable">a:326</span>)</span><br><span class="line">  at android.app.Dialog.dispatchOnCreate(Dialog.jav<span class="variable">a:436</span>)</span><br><span class="line">  at android.app.Dialog.show(Dialog.jav<span class="variable">a:325</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.MzGlobalActions$MzGlobalActionsDialog.show(MzGlobalActions.jav<span class="variable">a:824</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.MzGlobalActions.showGlobalActionsDialog(MzGlobalActions.jav<span class="variable">a:177</span>)</span><br><span class="line">  at <span class="keyword">com</span>.flyme.server.policy.MzGlobalActions.showGlobalActionsDialog(MzGlobalActions.jav<span class="variable">a:134</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.server.policy.PhoneWindowManager.mzShowGlobalActionsInternal(PhoneWindowManager.jav<span class="variable">a:6358</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.server.policy.PhoneWindowManager.showGlobalActionsInternal(PhoneWindowManager.jav<span class="variable">a:1641</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.server.policy.PhoneWindowManager$PolicyHandler.handleMessage(PhoneWindowManager.jav<span class="variable">a:676</span>)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.jav<span class="variable">a:106</span>)</span><br><span class="line">  at android.os.Looper.loopOnce(Looper.jav<span class="variable">a:201</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.jav<span class="variable">a:288</span>)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.jav<span class="variable">a:67</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.server.ServiceThread.run(ServiceThread.jav<span class="variable">a:44</span>)</span><br><span class="line">  at <span class="keyword">com</span>.android.server.UiThread.run(UiThread.jav<span class="variable">a:45</span>)</span><br></pre></td></tr></table></figure></p><p>在SWT日志中查找上述锁id，可以找到如下线程持锁未释放。<br>从堆栈上来看，locksettings在进行verifyChallenge调用时，binder对端没有返回。<br>locksettings的对端是gatekeeperd。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"binder:2869_1C"</span> prio=<span class="number">5</span> tid=<span class="number">178</span> Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=<span class="number">1</span> ucsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x1821f850</span> self=<span class="number">0xb400007dc0652800</span></span><br><span class="line">  | sysTid=<span class="number">18660</span> nice=<span class="number">0</span> cgrp=foreground sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7dc0fdbcb0</span></span><br><span class="line">  | state=S schedstat=( <span class="number">2488346381691</span> <span class="number">2190821996172</span> <span class="number">10125980</span> ) utm=<span class="number">144692</span> stm=<span class="number">104142</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7dc0ee4000</span><span class="number">-0x7dc0ee6000</span> stackSize=<span class="number">991</span>KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: #<span class="number">00</span> pc <span class="number">00000000000e06f</span>c  /apex/com.android.runtime/lib64/bionic/libc.so (__ioctl+<span class="number">12</span>) (BuildId: c7a69636ad70437896f8f6cfecde9001)</span><br><span class="line">  native: #<span class="number">01</span> pc <span class="number">000000000009757</span>c  /apex/com.android.runtime/lib64/bionic/libc.so (ioctl+<span class="number">160</span>) (BuildId: c7a69636ad70437896f8f6cfecde9001)</span><br><span class="line">  native: #<span class="number">02</span> pc <span class="number">000000000005</span>c2a0  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(<span class="built_in">bool</span>)+<span class="number">284</span>) (BuildId: b5f24c77eb4cb8038980e4e1f81dcfc0)</span><br><span class="line">  native: #<span class="number">03</span> pc <span class="number">000000000005</span>d4fc  /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, <span class="built_in">int</span>*)+<span class="number">76</span>) (BuildId: b5f24c77eb4cb8038980e4e1f81dcfc0)</span><br><span class="line">  native: #<span class="number">04</span> pc <span class="number">000000000005</span>d238  /system/lib64/libbinder.so (android::IPCThreadState::transact(<span class="built_in">int</span>, unsigned <span class="built_in">int</span>, android::Parcel <span class="keyword">const</span>&amp;, android::Parcel*, unsigned <span class="built_in">int</span>)+<span class="number">224</span>) (BuildId: b5f24c77eb4cb8038980e4e1f81dcfc0)</span><br><span class="line">  native: #<span class="number">05</span> pc <span class="number">0000000000054</span>a44  /system/lib64/libbinder.so (android::BpBinder::transact(unsigned <span class="built_in">int</span>, android::Parcel <span class="keyword">const</span>&amp;, android::Parcel*, unsigned <span class="built_in">int</span>)+<span class="number">192</span>) (BuildId: b5f24c77eb4cb8038980e4e1f81dcfc0)</span><br><span class="line">  native: #<span class="number">06</span> pc <span class="number">0000000000176</span>bf8  /system/lib64/libandroid_runtime.so (android_os_BinderProxy_transact(_JNIEnv*, _jobject*, <span class="built_in">int</span>, _jobject*, _jobject*, <span class="built_in">int</span>)+<span class="number">156</span>) (BuildId: da5ff736bfee156debca012f9a4e67da)</span><br><span class="line">  at android.os.BinderProxy.transactNative(Native method)</span><br><span class="line">  at android.os.BinderProxy.transact(BinderProxy.java:<span class="number">584</span>)</span><br><span class="line">  at android.service.gatekeeper.IGateKeeperService$Stub$Proxy.verifyChallenge(IGateKeeperService.java:<span class="number">349</span>)</span><br><span class="line">  at com.android.server.locksettings.SyntheticPasswordManager.unwrapPasswordBasedSyntheticPassword(SyntheticPasswordManager.java:<span class="number">1091</span>)</span><br><span class="line">  at com.android.server.locksettings.LockSettingsService.spBasedDoVerifyCredential(LockSettingsService.java:<span class="number">2999</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x05158af1</span>&gt; (a com.android.server.locksettings.SyntheticPasswordManager)</span><br><span class="line">  at com.android.server.locksettings.LockSettingsService.doVerifyCredential(LockSettingsService.java:<span class="number">2355</span>)</span><br><span class="line">  at com.android.server.locksettings.LockSettingsService.checkCredential(LockSettingsService.java:<span class="number">2269</span>)</span><br><span class="line">  at com.android.<span class="built_in">int</span>ernal.widget.ILockSettings$Stub.onTransact(ILockSettings.java:<span class="number">649</span>)</span><br><span class="line">  at android.os.Binder.execTransactInternal(Binder.java:<span class="number">1285</span>)</span><br><span class="line">  at android.os.Binder.execTransact(Binder.java:<span class="number">1244</span>)</span><br></pre></td></tr></table></figure></p><p>上述线程所在的进程pid为2869，线程tid为18660。<br>在binderinfo中查找2869:18660，可以看到outgoing事务已经送出，gatekeeperd的pid为2448，tid为2448。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="number">18660</span>: l <span class="number">11</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  outgoing transaction <span class="number">1265277307</span>: <span class="number">0000000000000000</span> <span class="keyword">from</span> <span class="number">2869</span>:<span class="number">18660</span> to <span class="number">2448</span>:<span class="number">2448</span> code <span class="number">3</span> flags <span class="number">30</span> pri <span class="number">0</span>:<span class="number">120</span> r1</span><br></pre></td></tr></table></figure></p><p>在binderinfo中找到gatekeeperd的binder信息，可以看到gatekeeperd已经收到incoming事务。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proc <span class="number">2448</span></span><br><span class="line">context binder</span><br><span class="line">  thread <span class="number">2448</span>: l <span class="number">02</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">    incoming transaction <span class="number">1265277307</span>: <span class="number">0000000000000000</span> <span class="keyword">from</span> <span class="number">2869</span>:<span class="number">18660</span> to <span class="number">2448</span>:<span class="number">2448</span> code <span class="number">3</span> flags <span class="number">30</span> pri <span class="number">0</span>:<span class="number">120</span> r1 node <span class="number">2469</span> size <span class="number">252</span>:<span class="number">0</span> data <span class="number">0000000000000000</span></span><br><span class="line">  node <span class="number">2469</span>: ub40000758600c1a0 cb400007586009188 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">1</span> lw <span class="number">0</span> <span class="keyword">is</span> <span class="number">2</span> iw <span class="number">2</span> tr <span class="number">1</span> proc <span class="number">2869</span> <span class="number">1121</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">2436</span>: desc <span class="number">0</span> node <span class="number">1</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">100653</span>: desc <span class="number">1</span> node <span class="number">15289</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  buffer <span class="number">57317755</span>: <span class="number">0000000000000000</span> size <span class="number">252</span>:<span class="number">0</span>:<span class="number">0</span> active</span><br></pre></td></tr></table></figure></p><p>gatekeeper需要通过gatekeeper HAL(android.hardware.gatekeeper-service-qti)来实现功能。<br>gatekeeper只有一个线程，主线程既负责处理binder请求，也负责发起hwbinder请求，因此gatekeeperd binder请求无返回，说明gatekeeper HAL hwbinder请求无返回。<br>查看gatekeeperd的hwbinder上下文，可以看到outgoing事务已经送出，对端pid为1336，tid为1336。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proc <span class="number">2448</span></span><br><span class="line">context hwbinder</span><br><span class="line">  thread <span class="number">2448</span>: l <span class="number">10</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">    outgoing transaction <span class="number">1265277317</span>: <span class="number">0000000000000000</span> <span class="keyword">from</span> <span class="number">2448</span>:<span class="number">2448</span> to <span class="number">1336</span>:<span class="number">1336</span> code <span class="number">2</span> flags <span class="number">30</span> pri <span class="number">0</span>:<span class="number">120</span> r1</span><br><span class="line">    transaction complete</span><br><span class="line">  thread <span class="number">6226</span>: l <span class="number">12</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">2437</span>: desc <span class="number">0</span> node <span class="number">3</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">2447</span>: desc <span class="number">1</span> node <span class="number">210</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">100646</span>: desc <span class="number">2</span> node <span class="number">1233</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br></pre></td></tr></table></figure></p><p>继续查看gatekeeper HAL的binder信息，可以看到gatekeeper HAL已经收到incoming事务。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proc <span class="number">1336</span></span><br><span class="line">context hwbinder</span><br><span class="line">  thread <span class="number">1336</span>: l <span class="number">02</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">    incoming transaction <span class="number">1265277317</span>: <span class="number">0000000000000000</span> <span class="keyword">from</span> <span class="number">2448</span>:<span class="number">2448</span> to <span class="number">1336</span>:<span class="number">1336</span> code <span class="number">2</span> flags <span class="number">30</span> pri <span class="number">0</span>:<span class="number">120</span> r1 node <span class="number">210</span> size <span class="number">220</span>:<span class="number">32</span> data <span class="number">0000000000000000</span></span><br><span class="line">  node <span class="number">210</span>: ub4000072b120c340 cb4000072b12220a0 pri <span class="number">0</span>:<span class="number">120</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">1</span> lw <span class="number">0</span> <span class="keyword">is</span> <span class="number">2</span> iw <span class="number">2</span> tr <span class="number">1</span> proc <span class="number">2448</span> <span class="number">1122</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">178</span>: desc <span class="number">0</span> node <span class="number">3</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  buffer <span class="number">57317765</span>: <span class="number">0000000000000000</span> size <span class="number">220</span>:<span class="number">32</span>:<span class="number">160</span> active</span><br></pre></td></tr></table></figure></p><p>gatekeeper HAL是基于TEE相关的接口来实现功能的，因此需要查看该进程在用户空间的堆栈，分析hwbinder无返回原因。<br>比较遗憾的是，SWT日志中并没有关于gatekeeper HAL在用户空间的堆栈，但从psinfo日志也可以看到，gatekeeper HAL处理hwbinder的线程处于D状态。<br>Linux进程D状态(TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。<br>线程在某个时刻处于D状态并不能说明该线程就是异常的，但如果长时间处于D状态，那么很可能就是有问题的。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system        <span class="number">1336</span>  <span class="number">1336</span>     <span class="number">1</span> <span class="number">2243616</span>   <span class="number">3572</span> process_invoke_req  <span class="number">0</span> D <span class="symbol">gatekeeper@</span><span class="number">1.0</span>-</span><br><span class="line">system        <span class="number">1336</span>  <span class="number">1349</span>     <span class="number">1</span> <span class="number">2243616</span>   <span class="number">3572</span> process_accept_req  <span class="number">0</span> S <span class="symbol">gatekeeper@</span><span class="number">1.0</span>-</span><br><span class="line">system        <span class="number">1336</span>  <span class="number">1350</span>     <span class="number">1</span> <span class="number">2243616</span>   <span class="number">3572</span> process_accept_req  <span class="number">0</span> S <span class="symbol">gatekeeper@</span><span class="number">1.0</span>-</span><br><span class="line">system        <span class="number">1336</span>  <span class="number">1351</span>     <span class="number">1</span> <span class="number">2243616</span>   <span class="number">3572</span> process_accept_req  <span class="number">0</span> S <span class="symbol">gatekeeper@</span><span class="number">1.0</span>-</span><br><span class="line">system        <span class="number">1336</span>  <span class="number">1352</span>     <span class="number">1</span> <span class="number">2243616</span>   <span class="number">3572</span> process_accept_req  <span class="number">0</span> S <span class="symbol">gatekeeper@</span><span class="number">1.0</span>-</span><br></pre></td></tr></table></figure></p><p>从sysrq打印所有D状态进程堆栈来看，该线程连续2秒都处于D状态，在gatekeeper HAL的业务上不可能有这么长时间，因此判定此线程异常。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] task:<span class="symbol">gatekeeper@</span><span class="number">1.0</span>- state:D stack:<span class="number">11152</span> pid: <span class="number">1336</span> ppid:     <span class="number">1</span> flags:<span class="number">0x04000008</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">25</span> <span class="number">2023</span>] task:<span class="symbol">gatekeeper@</span><span class="number">1.0</span>- state:D stack:<span class="number">11152</span> pid: <span class="number">1336</span> ppid:     <span class="number">1</span> flags:<span class="number">0x04000008</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">26</span> <span class="number">2023</span>] task:<span class="symbol">gatekeeper@</span><span class="number">1.0</span>- state:D stack:<span class="number">11152</span> pid: <span class="number">1336</span> ppid:     <span class="number">1</span> flags:<span class="number">0x04000008</span></span><br></pre></td></tr></table></figure></p><h3 id="内核态之真凶查找"><a href="#内核态之真凶查找" class="headerlink" title="内核态之真凶查找"></a><strong>内核态之真凶查找</strong></h3><p>通过前面的分析，已知系统发生SWT是由于gatekeeper HAL处理hwbinder的线程陷入内核态且长时间处于D状态。<br>结合sysrq打印所有D状态进程堆栈信息，可以看到该线程在内核中等锁。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] task:<span class="symbol">gatekeeper@</span><span class="number">1.0</span>- state:D stack:<span class="number">11152</span> pid: <span class="number">1336</span> ppid:     <span class="number">1</span> flags:<span class="number">0x04000008</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] Call trace:</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __switch_to+<span class="number">0x240</span>/<span class="number">0x490</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __schedule+<span class="number">0x638</span>/<span class="number">0xacc</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] schedule+<span class="number">0x110</span>/<span class="number">0x204</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] schedule_preempt_disabled+<span class="number">0x2c</span>/<span class="number">0x4c</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __mutex_lock+<span class="number">0x328</span>/<span class="number">0x824</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __mutex_lock_slowpath+<span class="number">0x18</span>/<span class="number">0x28</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] mutex_lock+<span class="number">0x48</span>/<span class="number">0x118</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] process_invoke_req+<span class="number">0x1f0</span>/<span class="number">0x80c</span> [smcinvoke_dlkm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] smcinvoke_ioctl+<span class="number">0x80</span>/<span class="number">0x404</span> [smcinvoke_dlkm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __arm64_sys_ioctl+<span class="number">0x184</span>/<span class="number">0x210</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] invoke_syscall+<span class="number">0x60</span>/<span class="number">0x150</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0_svc_common+<span class="number">0xb8</span>/<span class="number">0xf8</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] do_el0_svc+<span class="number">0x28</span>/<span class="number">0xa0</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0_svc+<span class="number">0x24</span>/<span class="number">0x84</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0t_64_sync_handler+<span class="number">0x88</span>/<span class="number">0xec</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0t_64_sync+<span class="number">0x1b4</span>/<span class="number">0x1b8</span></span><br></pre></td></tr></table></figure></p><p>process_invoke_req函数的地址为0x000000000000818c。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nm</span> <span class="string">smcinvoke_dlkm.ko | grep -w process_invoke_req</span></span><br><span class="line"><span class="attr">000000000000818c</span> <span class="string">t process_invoke_req</span></span><br></pre></td></tr></table></figure></p><p>因此process_invoke_req+0x1f0的地址为0x000000000000837c，对应的代码位置如下。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-addr2line -e smcinvoke_dlkm.ko <span class="number">0x000000000000837c</span></span><br><span class="line">vendor<span class="regexp">/qcom/</span>opensource<span class="regexp">/securemsm-kernel/</span>smcinvoke/smcinvoke.<span class="string">c:</span><span class="number">2320</span></span><br></pre></td></tr></table></figure></p><p>查看代码，发现是smcinvoke驱动中的全局锁g_smcinvoke_lock被持有未释放。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(<span class="name">&amp;g_smcinvoke_lock</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>查看sysrq打印所有CPU堆栈信息，在CPU7上确实有线程持锁未释放。<br>但由于日志缺少足够的信息，因此并无法知道此时运行在CPU7上的进程。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] sysrq: CPU7:</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] Call trace:</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] dump_backtrace.cfi_jt+<span class="number">0x0</span>/<span class="number">0x8</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] showacpu+<span class="number">0xf8</span>/<span class="number">0x1b4</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] flush_smp_call_function_queue+<span class="number">0x1f0</span>/<span class="number">0x3a8</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] do_handle_IPI+<span class="number">0xe0</span>/<span class="number">0x344</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] ipi_handler+<span class="number">0x20</span>/<span class="number">0x34</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] handle_percpu_devid_irq+<span class="number">0xc0</span>/<span class="number">0x374</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] handle_domain_irq+<span class="number">0xd0</span>/<span class="number">0x154</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] gic_handle_irq<span class="number">.33729</span>+<span class="number">0x54</span>/<span class="number">0x2bc</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] call_on_irq_stack+<span class="number">0x40</span>/<span class="number">0x70</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] do_interrupt_handler+<span class="number">0x44</span>/<span class="number">0xa0</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el1_interrupt+<span class="number">0x34</span>/<span class="number">0x64</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el1h_64_irq_handler+<span class="number">0x1c</span>/<span class="number">0x2c</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el1h_64_irq+<span class="number">0x7c</span>/<span class="number">0x80</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __arm_smccc_smc+<span class="number">0x14</span>/<span class="number">0x40</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __scm_smc_call+<span class="number">0x1b8</span>/<span class="number">0x56c</span> [qcom_scm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] qcom_scm_invoke_callback_response+<span class="number">0xa8</span>/<span class="number">0x12c</span> [qcom_scm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] invoke_cmd_handler+<span class="number">0x120</span>/<span class="number">0x254</span> [smcinvoke_dlkm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] prepare_send_scm_msg+<span class="number">0x15c</span>/<span class="number">0x450</span> [smcinvoke_dlkm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] process_invoke_req+<span class="number">0x294</span>/<span class="number">0x80c</span> [smcinvoke_dlkm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] smcinvoke_ioctl+<span class="number">0x80</span>/<span class="number">0x404</span> [smcinvoke_dlkm]</span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] __arm64_sys_ioctl+<span class="number">0x184</span>/<span class="number">0x210</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] invoke_syscall+<span class="number">0x60</span>/<span class="number">0x150</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0_svc_common+<span class="number">0xb8</span>/<span class="number">0xf8</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] do_el0_svc+<span class="number">0x28</span>/<span class="number">0xa0</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0_svc+<span class="number">0x24</span>/<span class="number">0x84</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0t_64_sync_handler+<span class="number">0x88</span>/<span class="number">0xec</span></span><br><span class="line">[Tue May  <span class="number">9</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">24</span> <span class="number">2023</span>] el0t_64_sync+<span class="number">0x1b4</span>/<span class="number">0x1b8</span></span><br></pre></td></tr></table></figure></p><p>考虑到此问题发生的场景与人脸识别有关，且日志也显示人脸识别线程一直处于99%的CPU占用率状态，因此有理由怀疑运行在CPU7上的线程就是人脸识别的线程。<br>FaceAysncQueue线程刚好负责人脸识别TEE的接口调用，因此它的嫌疑最大。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span><span class="number">-11</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">26.491</span>  <span class="number">2869</span> <span class="number">29516</span> E ActivityManager:   <span class="number">99</span>% <span class="number">2589</span>/vendor.xingji.hardware.biometrics.<span class="symbol">face@</span><span class="number">1.0</span>-service: <span class="number">0</span>% user + <span class="number">99</span>% kernel</span><br><span class="line"><span class="number">06</span><span class="number">-11</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">26.491</span>  <span class="number">2869</span> <span class="number">29516</span> E ActivityManager:     <span class="number">99</span>% <span class="number">2639</span>/FaceAysncQueue: <span class="number">0</span>% user + <span class="number">99</span>% kernel</span><br></pre></td></tr></table></figure></p><p>结合TEE人脸识别的日志，可以看到问题发生时，HAL调用人脸识别TA，人脸识别TA一直没有返回。<br>因此，人脸识别就是罪魁祸首。</p><h3 id="kdump之根因定位"><a href="#kdump之根因定位" class="headerlink" title="kdump之根因定位"></a><strong>kdump之根因定位</strong></h3><p>日志的信息比较有限，只能分析到上述的结论，万幸的是，在其他复现问题的机器上抓到了kdump。<br>虽然问题发生在TEE中，但只要有kdump和symbols，那么原理上就可以解析出对应的堆栈，最终解析堆栈如下。<br><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">000</span>|<span class="function"><span class="title">Laplacian</span>(<span class="variable">asm</span>)</span></span><br><span class="line">-<span class="number">001</span>|<span class="function"><span class="title">oem_tee_image_quality_sharpness</span>(<span class="variable">asm</span>)</span></span><br><span class="line">-<span class="number">002</span>|<span class="function"><span class="title">oem_tee_quality</span>(<span class="variable">asm</span>)</span></span><br><span class="line">-<span class="number">003</span>|<span class="function"><span class="title">getFeature</span>()</span></span><br><span class="line">-<span class="number">004</span>|<span class="function"><span class="title">handle_cmd_get_feature</span>()</span></span><br><span class="line">-<span class="number">005</span>|<span class="function"><span class="title">tz_app_cmd_handler</span>()</span></span><br></pre></td></tr></table></figure></p><p>考虑到问题本身不容易复现，算法由供应商提供，添加日志定位问题周期长，因此需要更进一步的手段来定位问题。<br>通过trace32进一步解析，获取通用寄存器，TA加载地址等信息如下。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Register:</span></span><br><span class="line"><span class="string">X0</span> <span class="string">=</span> <span class="number">0x75CF2AC0</span><span class="string">,</span> <span class="string">X1</span> <span class="string">=</span> <span class="number">0x75CF2980</span><span class="string">,</span> <span class="string">X2</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span> <span class="string">X3</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span></span><br><span class="line"><span class="string">X4</span> <span class="string">=</span> <span class="number">0x00015888</span><span class="string">,</span> <span class="string">X5</span> <span class="string">=</span> <span class="number">0x00010910</span><span class="string">,</span> <span class="string">X6</span> <span class="string">=</span> <span class="number">0x00010911</span><span class="string">,</span> <span class="string">X7</span> <span class="string">=</span> <span class="number">0x0000001F</span><span class="string">,</span></span><br><span class="line"><span class="string">X8</span> <span class="string">=</span> <span class="number">0xFFFFFFFE</span><span class="string">,</span> <span class="string">X9</span> <span class="string">=</span> <span class="number">0x00000FED</span><span class="string">,</span> <span class="string">X10</span> <span class="string">=</span> <span class="number">0x75CF2000</span><span class="string">,</span> <span class="string">X11</span> <span class="string">=</span> <span class="number">0x7FFFFFFF</span><span class="string">,</span></span><br><span class="line"><span class="string">X12</span> <span class="string">=</span> <span class="number">0x00001FFF</span><span class="string">,</span> <span class="string">X13</span> <span class="string">=</span> <span class="number">0xFFFFFFFE</span><span class="string">,</span> <span class="string">X14</span> <span class="string">=</span> <span class="number">0x0000000F</span><span class="string">,</span> <span class="string">X15</span> <span class="string">=</span> <span class="number">0x00000010</span><span class="string">,</span></span><br><span class="line"><span class="string">X16</span> <span class="string">=</span> <span class="number">0x00000001</span><span class="string">,</span> <span class="string">X17</span> <span class="string">=</span> <span class="number">0x73656E73</span><span class="string">,</span> <span class="string">X18</span> <span class="string">=</span> <span class="number">0x0000FFFF</span><span class="string">,</span> <span class="string">X19</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span></span><br><span class="line"><span class="string">X20</span> <span class="string">=</span> <span class="number">0x75CF2980</span><span class="string">,</span> <span class="string">X21</span> <span class="string">=</span> <span class="number">0x75CF2980</span><span class="string">,</span> <span class="string">X22</span> <span class="string">=</span> <span class="number">0x75CF2AC0</span><span class="string">,</span> <span class="string">X23</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span></span><br><span class="line"><span class="string">X24</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span> <span class="string">X25</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span> <span class="string">X26</span> <span class="string">=</span> <span class="number">0x75CF2AC0</span><span class="string">,</span> <span class="string">X27</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span></span><br><span class="line"><span class="string">X28</span> <span class="string">=</span> <span class="number">0x00000000</span><span class="string">,</span> <span class="string">X29</span> <span class="string">=</span> <span class="number">0x1F65ED90</span><span class="string">,</span> <span class="string">X30</span> <span class="string">=</span> <span class="number">0x38586CA8</span><span class="string">,</span> <span class="string">ELR</span> <span class="string">=</span> <span class="number">0x385863A8</span><span class="string">,</span></span><br><span class="line"><span class="string">PC</span> <span class="string">=</span> <span class="number">0x385863A8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">VA of stapp loading start:</span> <span class="number">0x38479000</span></span><br><span class="line"><span class="string">Entry</span> <span class="string">of</span> <span class="string">Laplacian</span> <span class="string">:0x38586358</span></span><br></pre></td></tr></table></figure></p><p>问题点虚拟地址为0x385863A8，Laplacian函数虚拟地址为0x38586358。<br>因此，问题点在Laplacian偏移offset=0x385863A8-0x38586358=0x50位置。<br>Laplacian函数链接地址0x107a78，所以问题点的链接地址为0x107a78+0x50=0x107AC8。<br>反汇编显示，0x107AC8地址附近刚好是个循环。</p><p><img src="反汇编.jpg" alt="反汇编"></p><p>循环部分的汇编代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP W11, #0</span><br><span class="line">CSEL W13, WZR, W8 LT</span><br><span class="line">SUB W11, W13, W11</span><br><span class="line">CMP W11, W25</span><br><span class="line">B.CS loc_107AC8</span><br></pre></td></tr></table></figure></p><p>CMP W11, #0，和立即数0做比较。CMP指令的实现SUB指令基本同等，区别是SUB指令需要将结果保存到寄存器，CMP指令丢弃计算结果。CMP指令和SUB指令执行后都会更新CPSR寄存器的NZCV标志位。W11的值是0X7FFFFFFF，也就是0X7FFFFFFF-0x0=0X7FFFFFFF-0x0。结果大于0且没有借位和溢出，所以结果是N=0，Z=0，C=1，V=0。</p><p>CSEL W13, WZR, W8 LT，如果前一条比较指令是LT(小于)情况下(即N!=V)，则W13=WZR，否则W13=W8。前面的CMP指令执行后N==V，W8=0xFFFFFFFE，所以结果是W13=0xFFFFFFFE。</p><p>SUB W11, W13, W11，W11=W13-W11，W11=0x7FFFFFFF，所以结果是W11=0xFFFFFFFE-0x7FFFFFFF=0x7FFFFFFF。</p><p>CMP W11, W25，和W25的值做比较。W11=0x7FFFFFFF，W25=0x00000000，所以结果是N=0，Z=0，C=1，V=0。</p><p>B.CS loc_107AC8，如果CPSR寄存器的C标志位置位，则跳转到地址0x107AC8，继续循环。上面的结果是C标志位置位的，所以循环继续，形成死循环。</p><p>上面这段汇编代码是一个循环，跳出循环的条件是W11小于W25。W11只有两个值，要么是1，要么是W8-1。W8的值为W25*2-2。当W25为0或1的时候，循环就会无法跳出。当W25的值大于1时，第一轮循环就会跳出不再继续。而W25是函数传入的第三个参数，这个值刚好等于0。</p><p>从函数的命名来看，这应该是一个拉普拉斯变换的实现，函数有四个参数。猜测第一个参数是变换前的数据，第二个参数是变换后的数据，第三个和第四个参数是宽度和高度。</p><p><img src="laplace_transfromation.jpg" alt="laplace_transfromation"></p><p>从供应商获取函数签名，确实如上面的猜测一样。<br><img src="Laplacian.png" alt="Laplacian"></p><p>也就是说，这里面存在两个问题。一是没有进行边界检查，导致代码存在死循环的可能。二是如果逻辑走到这个函数，这里的宽度是不能为0的。在宽度为0的时候，oem_tee_image_quality_sharpness不应该调用Laplacian函数。</p><p>从日志来看，出现问题时应该是在没有检测到人脸或者从没有检测到人脸过渡到检测到人脸(即出现问题时算法刚好判断出有人脸)的环境下。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">face: tz_app_cmd_handler(<span class="number">674</span>):enter handler <span class="number">0x65373170</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">702</span>):req size:<span class="number">40</span>, rsp size:<span class="number">48</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">711</span>):TZ App cmd handler, cmd_id = <span class="number">3</span> </span><br><span class="line">face: getFeature(<span class="number">1222</span>):[ TIME-COUNTER ] oem_tee_image_create , use time <span class="number">0</span> ms </span><br><span class="line">face: getFeature(<span class="number">1224</span>):***** image detect start ***** </span><br><span class="line">face: getFeature(<span class="number">1227</span>):begine oem_tee_detect </span><br><span class="line">face: oem_tee_detect(<span class="number">1848</span>):detect no face.</span><br><span class="line">face: getFeature(<span class="number">1233</span>):oem_tee_detect failed: <span class="number">1</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">1140</span>):<span class="keyword">get</span> image feature failed </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">1193</span>):exec cmd <span class="number">3.</span> <span class="number">11</span>ms </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">674</span>):enter handler <span class="number">0x65373170</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">702</span>):req size:<span class="number">40</span>, rsp size:<span class="number">48</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">711</span>):TZ App cmd handler, cmd_id = <span class="number">3</span> </span><br><span class="line">face: getFeature(<span class="number">1222</span>):[ TIME-COUNTER ] oem_tee_image_create , use time <span class="number">1</span> ms </span><br><span class="line">face: getFeature(<span class="number">1224</span>):***** image detect start ***** </span><br><span class="line">face: getFeature(<span class="number">1227</span>):begine oem_tee_detect </span><br><span class="line">face: oem_tee_detect(<span class="number">1848</span>):detect no face.</span><br><span class="line">face: getFeature(<span class="number">1233</span>):oem_tee_detect failed: <span class="number">1</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">1140</span>):<span class="keyword">get</span> image feature failed </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">1193</span>):exec cmd <span class="number">3.</span> <span class="number">11</span>ms </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">674</span>):enter handler <span class="number">0x65373170</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">702</span>):req size:<span class="number">40</span>, rsp size:<span class="number">48</span> </span><br><span class="line">face: tz_app_cmd_handler(<span class="number">711</span>):TZ App cmd handler, cmd_id = <span class="number">3</span> </span><br><span class="line">face: getFeature(<span class="number">1222</span>):[ TIME-COUNTER ] oem_tee_image_create , use time <span class="number">0</span> md</span><br></pre></td></tr></table></figure><p>代码的逻辑是oem_tee_image_create-&gt;oem_tee_detect-&gt;oem_tee_quality。<br>结合问题堆栈来看，oem_tee_detect返回的结果是检测到人脸。<br>因此，压测手法可以为抬手进行人脸识别，模拟人脸从无到有的过程。</p><p>以上仅仅只是分析，需要有办法对这个问题进行复现和修复验证，上述压测手法不一定能很快复现到问题。<br>可以考虑使用问题出现时的人脸数据进行重现，看问题能否稳定复现。由于人脸识别没有做数据保存，因此只能在kdump中查找数据。</p><p>人脸识别REE与TEE通信时，会从dmabuf申请一片内存作为共享内存。因此使用crash工具加载kdump，通过vm命令找到人脸识别HAL进程打开的dmabuf地址，最后通过rd命令导出数据。<br>根据代码知道，人脸录入时这片buffer大小为0x55000，人脸识别时这片buffer大小为0x71000。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; ps | grep <span class="symbol">face@</span><span class="number">1.0</span></span><br><span class="line">     <span class="number">2606</span>       <span class="number">1</span>   <span class="number">2</span>  ffffff88795d6940  IN   <span class="number">0.3</span>  <span class="number">2474768</span>   <span class="number">107460</span>  <span class="symbol">face@</span><span class="number">1.0</span>-servic</span><br><span class="line">     <span class="number">2688</span>       <span class="number">1</span>   <span class="number">7</span>  ffffff88823c0040  IN   <span class="number">0.3</span>  <span class="number">2474768</span>   <span class="number">107460</span>  <span class="symbol">face@</span><span class="number">1.0</span>-servic</span><br><span class="line">     <span class="number">2690</span>       <span class="number">1</span>   <span class="number">0</span>  ffffff88823c2a40  IN   <span class="number">0.3</span>  <span class="number">2474768</span>   <span class="number">107460</span>  <span class="symbol">face@</span><span class="number">1.0</span>-servic</span><br><span class="line">     <span class="number">2693</span>       <span class="number">1</span>   <span class="number">5</span>  ffffff88823c6940  IN   <span class="number">0.3</span>  <span class="number">2474768</span>   <span class="number">107460</span>  <span class="symbol">face@</span><span class="number">1.0</span>-servic</span><br><span class="line">     <span class="number">2695</span>       <span class="number">1</span>   <span class="number">2</span>  ffffff887b385440  IN   <span class="number">0.3</span>  <span class="number">2474768</span>   <span class="number">107460</span>  <span class="symbol">face@</span><span class="number">1.0</span>-servic</span><br><span class="line">crash&gt; <span class="keyword">set</span> <span class="number">2606</span></span><br><span class="line">    PID: <span class="number">2606</span></span><br><span class="line">COMMAND: <span class="string">"face@1.0-servic"</span></span><br><span class="line">   TASK: ffffff88795d6940  [THREAD_INFO: ffffff88795d6940]</span><br><span class="line">    CPU: <span class="number">2</span></span><br><span class="line">  STATE: TASK_INTERRUPTIBLE </span><br><span class="line">crash&gt; vm | grep -w dmabuf</span><br><span class="line">ffffff804466ac68 <span class="number">74</span>dce73000 <span class="number">74</span>dcee4000 <span class="number">40444f</span>b dmabuf</span><br><span class="line">ffffff8884b38f90 <span class="number">7563736000</span> <span class="number">7563737000</span> <span class="number">40444f</span>b dmabuf</span><br><span class="line">crash&gt; rd -r dmabuf.bin ffffff804466ac68 <span class="number">0x71000</span></span><br><span class="line"><span class="number">462848</span> bytes copied <span class="keyword">from</span> <span class="number">0xffffff804466ac68</span> to dmabuf.bin</span><br></pre></td></tr></table></figure><p>导出的数据为nv21 rawdata格式，需要将数据转为jpeg。从实际dump出来的数据来看，并不符合预期。<br>通过做实验，为这片共享内存传入指定数据，再dump出来，发现正常情况下，传入的数据与dump出来的数据也不一致。<br>因此目前并无法通过dump dmabuf来拿到数据，具体原因有待调查。</p><p><img src="dump_dmabuf_data.jpeg" alt="dump_dmabuf_data"></p><p>既然无法从dmabuf dump出正确的数据，那就尝试传入特定数据，直接从kdump的二进制文件特定偏移位置找到数据。<br>实验发现，在A项目上可以在DDRCS0_0.BIN的0x65300000位置(使用binwalk进行二进制查找上述特定数据)dump出正确的人脸数据，但是在出现问题的B项目上，得到的数据不符合预期。<br>而B项目由于某些原因，没法做实验找到偏移的位置，因此只能采取其他办法。</p><p>人脸识别使用的图片数据为nv21，实验中发现，nv21格式具有比较明显的数据特征。</p><p><img src="dump_dmabuf_nv21.png" alt="dump_dmabuf_nv21"></p><p><img src="dump_dmabuf_nv21_1.png" alt="dump_dmabuf_nv21_1"></p><p><img src="dump_dmabuf_nv21_2.png" alt="dump_dmabuf_nv21_2"></p><p>因此尝试使用如下命令进行特征查找。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xxd</span> <span class="selector-tag">DDRCS0_0</span><span class="selector-class">.BIN</span> &gt; <span class="selector-tag">tee</span> <span class="selector-tag">xxd</span><span class="selector-class">.log</span></span><br><span class="line"><span class="selector-tag">grep</span> <span class="selector-tag">-nr</span> "\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>\<span class="selector-class">.w</span>" <span class="selector-tag">xxd</span><span class="selector-class">.log</span></span><br></pre></td></tr></table></figure><p>查找出来的特征不算太多。</p><p><img src="dump_dmabuf_nv21_3.png" alt="dump_dmabuf_nv21_3"></p><p>使用ghex打开DDRCS0_0.BIN，在上述可能的特征前后进行查看，定位到一处比较可疑的内存地址，偏移为0x78400000，物理地址为0x78400000+0x80000000。将数据dump出来后导入手机进行复现，确认问题是可以稳定复现的。</p><p><img src="dump_dmabuf_nv21_4.png" alt="dump_dmabuf_nv21_4"></p><p>查看导出的数据，可以看到图片中并没有人脸，但算法误判存在人脸特征，导致逻辑走到oem_tee_quality。</p><p><img src="face_picture.jpeg" alt="face_picture"></p><p>Laplacian陷入死循环的原因是因为width参数为0，但根据供应商的描述，width参数的值是通过oem_tee_quality传递进去的。从再次复现打日志打印来看，oem_tee_quality传递的宽度为640，因此只能怀疑在oem_tee_quality或者oem_tee_image_quality_sharpness函数内部，有异常逻辑会导致传入Laplacian的width为0。</p><p>最后的解决方案是供应商在更新算法库的同时，为Laplacian加入边界检查逻辑，提升代码健壮性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>NZCV，<a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/NZCV--Condition-Flags" target="_blank" rel="noopener">https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/NZCV--Condition-Flags</a></li><li>Conditional，<a href="https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference/Conditional-execution" target="_blank" rel="noopener">https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference/Conditional-execution</a></li><li>CMP，<a href="https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/CMP--immediate---Compare--immediate---an-alias-of-SUBS--immediate--" target="_blank" rel="noopener">https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/CMP--immediate---Compare--immediate---an-alias-of-SUBS--immediate--</a></li><li>CSEL，<a href="https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/CSEL--Conditional-Select-" target="_blank" rel="noopener">https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/CSEL--Conditional-Select-</a></li><li>B.cond，<a href="https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/B-cond--Branch-conditionally-" target="_blank" rel="noopener">https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/B-cond--Branch-conditionally-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 调试与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Stability </tag>
            
            <tag> Trustzone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Verified Boot 2.0</title>
      <link href="/2023/07/04/Android-R-AVB2-0/"/>
      <url>/2023/07/04/Android-R-AVB2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Verified-Boot-2-0流程"><a href="#Android-Verified-Boot-2-0流程" class="headerlink" title="Android Verified Boot 2.0流程"></a>Android Verified Boot 2.0流程</h1><p>Android Verified Boot(AVB)的作用是校验各个镜像，确保各个镜像没有被篡改过的。如果镜像被篡改过，设备将会报启动异常。</p><p>概览：</p><ul><li><p>设备上电最早启动pbl(primary bootloader)，进行secboot(secure boot)工作，secboot主要工作是校验bootloader的合法性，校验没问题才启动bootloader。</p></li><li><p>bootloader 需要校验下一启动阶段需要用到的镜像，如boot.img, dtbo.img 等镜像，这里就开始Android Verified Boot(AVB)，校验没问题才启动到kernel。</p></li><li><p>到kernel 和 init 阶段则开始新一轮校验，如system.img vendor.img 等镜像，校验过了之后才对分区进行挂载。</p></li></ul><p>说白了，每一个启动阶段，用到什么就校验什么。确保分区读出来的内容，都是没有被篡改过。</p><p><img src="./all-verify.png" alt="all-verify"></p><h2 id="Secboot-boot"><a href="#Secboot-boot" class="headerlink" title="Secboot boot"></a>Secboot boot</h2><p>secboot: bootloader 可信的根本。</p><p>secboot的工作原理：每一个SoC只能写一次根证书，叫root of trust。</p><p>可以简单理解 root of trust 的用途是校验bootloader是否被篡改。</p><p>secure boot 校验流程可以总结下图。</p><p><img src="./secure-boot.png" alt="secure-boot.drawio"></p><h2 id="Bootloader-AVB-Android-Verified-Boot-2-0"><a href="#Bootloader-AVB-Android-Verified-Boot-2-0" class="headerlink" title="Bootloader AVB(Android Verified Boot 2.0)"></a>Bootloader AVB(Android Verified Boot 2.0)</h2><h3 id="bootloader需要校验什么？"><a href="#bootloader需要校验什么？" class="headerlink" title="bootloader需要校验什么？"></a>bootloader需要校验什么？</h3><p>在bootloader中，需要校验分区的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Library/avb/VerifiedBoot.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> CHAR8 *avb_verify_partition_name[] = &#123;</span><br><span class="line">     <span class="string">"boot"</span>,</span><br><span class="line">     <span class="string">"dtbo"</span>,</span><br><span class="line">     <span class="string">"vbmeta"</span>,</span><br><span class="line">     <span class="string">"recovery"</span>,</span><br><span class="line">     <span class="string">"vendor_boot"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的变量可以知道，在bootloader中，可能需要校验上面的5个镜像。</p><p>为什么说是可能？因为最终的校验是需要和vbmeta镜像来决定的。</p><p>通过avbtool工具，解析vbmeta镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avbtool info_image --image vbmeta.img &gt; vbmeta.img.info</span><br></pre></td></tr></table></figure><p>vbmeta.img.info 内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Minimum libavb version:   1.0</span><br><span class="line">Header Block:             256 bytes</span><br><span class="line">Authentication Block:     576 bytes</span><br><span class="line">Auxiliary Block:          4032 bytes</span><br><span class="line">Public key (sha1):        2e22ae4a46cf9db9c24ab74cee91fa005ccb30e4</span><br><span class="line">Algorithm:                SHA256_RSA4096</span><br><span class="line">Rollback Index:           0</span><br><span class="line">Flags:                    0</span><br><span class="line">Release String:           'avbtool 1.1.0'</span><br><span class="line">Descriptors:</span><br><span class="line">    Chain Partition descriptor:</span><br><span class="line">      Partition Name:          vbmeta_system</span><br><span class="line">      Rollback Index Location: 2</span><br><span class="line">      Public key (sha1):       fc92d9cba0628858d846fb9a18a7af72b05d7dc8</span><br><span class="line">    ...</span><br><span class="line">    Hash descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        boot</span><br><span class="line">      Salt:                  e691366c1c43ee5e23b342d65555ad8cfbadf77118dceb77e240c8e7d3e63ea6</span><br><span class="line">      Digest:                239648eb41f5a491c7c4d6b51b52a533bd9da98ba8800f58a0957f7341dd1686</span><br><span class="line">      Flags:                 0</span><br><span class="line">    Hash descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        dtbo</span><br><span class="line">      Salt:                  d445a36d8154a774589dd51c49029ee388ecaac28212c8c6899f45dc5a51dbcf</span><br><span class="line">      Digest:                cac0bd59091464292bc83d6f1193afb1520c12a3849f2673ad3160bb951acf6d</span><br><span class="line">      Flags:                 0</span><br><span class="line">    Hash descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        vendor_boot</span><br><span class="line">      Salt:                  5f7b7c3592142d4f3645d7e675fb7865915e52e8b361ba330fccf00aeb1c4028</span><br><span class="line">      Digest:                cf153ab9df9a5c34024417ea2b0b4dfd716d01ba9cd2d5bcf964fe7e25cdd802</span><br><span class="line">      Flags:                 0</span><br><span class="line">    Hashtree descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        odm</span><br><span class="line">      Salt:                  b6e1f57ae6939659355e83ad7fa57feb6b5eb15a3d16b96752f43cdc14918708</span><br><span class="line">      Root Digest:           da99875b16661e72eec81d05d58dffdf09fe228d</span><br><span class="line">      Flags:                 0</span><br><span class="line">    Hashtree descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        vendor</span><br><span class="line">      Salt:                  b6e1f57ae6939659355e83ad7fa57feb6b5eb15a3d16b96752f43cdc14918708</span><br><span class="line">      Root Digest:           336bd4885da274ae0de38b32b899f7b6169e676f</span><br><span class="line">      Flags:                 0</span><br></pre></td></tr></table></figure><p>通过<code>vbmeta.img.info</code>以及<code>avb_verify_partition_name</code>数组组成集合知道</p><p>bootloader中需要校验 <code>vbmeta、boot 、dtbo、vendor_boot</code>四个镜像，这4个镜像也是下一个启动阶段需要用到的。</p><p>如下图，蓝色代表bootloader需要校验的镜像。</p><p><img src="./bootload-avb.png" alt="bootload-avb"></p><h3 id="UEFI-bootloader-AVB2-0代码校验流程"><a href="#UEFI-bootloader-AVB2-0代码校验流程" class="headerlink" title="UEFI(bootloader) AVB2.0代码校验流程"></a>UEFI(bootloader) AVB2.0代码校验流程</h3><p>简单的校验流程图：</p><p><img src="./boot_avb.png" alt="boot_avb"></p><p>核心函数<code>load_and_verify_vbmeta</code>校验<code>vbmeta</code>，确保vbmeta是可信的。如何做到可信？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AvbSlotVerifyResult <span class="title">load_and_verify_vbmeta</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Check if the image is properly signed and get the public key used</span></span><br><span class="line"><span class="comment">   * to sign the image.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取vbmeta的pk_data(public key) 和 pk_len，为 OEMPublicKey 校验进行准备</span></span><br><span class="line">  vbmeta_ret =</span><br><span class="line">     avb_vbmeta_image_verify(vbmeta_buf, vbmeta_num_read, &amp;pk_data, &amp;pk_len);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// ops-&gt;validate_vbmeta_public_key 该函数最终</span></span><br><span class="line">   <span class="comment">// 与 OEMPublicKey.h 文件的 OEMPublicKey 进行校验比对</span></span><br><span class="line">   <span class="comment">// 而 OEMPublicKey 是硬编码直接写在代码里面。</span></span><br><span class="line">   io_ret = ops-&gt;validate_vbmeta_public_key(ops,</span><br><span class="line">                                         pk_data,</span><br><span class="line">                                         pk_len,</span><br><span class="line">                                         pk_metadata,</span><br><span class="line">                                         pk_metadata_len,</span><br><span class="line">                                         &amp;key_is_trusted);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 获取vbmeta中，需要校验的镜像信息，高通888平台上，涉及到 boot dtbo vendor_boot 三个镜像</span></span><br><span class="line">   descriptors =</span><br><span class="line">      avb_descriptor_get_all(vbmeta_buf, vbmeta_num_read, &amp;num_descriptors);</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">// vbmeta中的 （boot dtbo vendor_boot）descriptors 轮询进行 hash（Digest）比对校验</span></span><br><span class="line">   <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; num_descriptors; n++) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取 vbmeta中的 （boot dtbo vendor_boot）descriptors 信息</span></span><br><span class="line">    <span class="keyword">if</span> (!avb_descriptor_validate_and_byteswap(descriptors[n], &amp;desc)) &#123;</span><br><span class="line">      avb_errorv(full_partition_name, <span class="string">": Descriptor is invalid.\n"</span>, <span class="literal">NULL</span>);</span><br><span class="line">      ret = AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">switch</span> (desc.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> AVB_DESCRIPTOR_TAG_HASH: &#123;</span><br><span class="line">        AvbSlotVerifyResult sub_ret;</span><br><span class="line">        <span class="comment">// 对 vbmeta中的 （boot dtbo vendor_boot）Digest 和 镜像boot,dtbo,vendor_boot的Digest 进行比较</span></span><br><span class="line">        <span class="comment">// 两个 Digest 的值比较相同，则AVB校验通过</span></span><br><span class="line">        sub_ret = load_and_verify_hash_partition(ops,</span><br><span class="line">                                                 requested_partitions,</span><br><span class="line">                                                 ab_suffix,</span><br><span class="line">                                                 allow_verification_error,</span><br><span class="line">                                                 descriptors[n],</span><br><span class="line">                                                 slot_data);</span><br><span class="line">        <span class="keyword">if</span> (sub_ret != AVB_SLOT_VERIFY_RESULT_OK) &#123;</span><br><span class="line">          ret = sub_ret;</span><br><span class="line">          <span class="keyword">if</span> (!allow_verification_error || !result_should_continue(ret)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以boot镜像为例，对<code>load_and_verify_hash_partition</code>函数说明</p><p>1、获取vbmeta中需要检验boot镜像的信息（salt 和 digest），命名为<code>salt1</code>和 <code>digest1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!avb_hash_descriptor_validate_and_byteswap(</span><br><span class="line">          (<span class="keyword">const</span> AvbHashDescriptor*)descriptor, &amp;hash_desc)) &#123;  <span class="comment">//descriptor 是vbmeta中获取的</span></span><br><span class="line">    ret = AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  desc_partition_name =</span><br><span class="line">      ((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)descriptor) + <span class="keyword">sizeof</span>(AvbHashDescriptor); <span class="comment">// 需要校验的镜像 boot</span></span><br><span class="line">  desc_salt = desc_partition_name + hash_desc.partition_name_len; <span class="comment">// salt1 值</span></span><br><span class="line">  desc_digest = desc_salt + hash_desc.salt_len; <span class="comment">// digest1 值</span></span><br></pre></td></tr></table></figure><p>2、获取boot分区的<code>image_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io_ret = ops-&gt;read_from_partition(</span><br><span class="line">      ops, part_name, <span class="number">0</span> <span class="comment">/* offset */</span>, image_size, image_buf, &amp;part_num_read); <span class="comment">//part_name是boot</span></span><br></pre></td></tr></table></figure><p>3、通过分区<code>image_buf</code> 和<code>salt1</code>计算出boot分区的 <code>digest2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avb_sha256_init(&amp;sha256_ctx);</span><br><span class="line">    avb_sha256_update(&amp;sha256_ctx, desc_salt, hash_desc.salt_len);</span><br><span class="line">    avb_sha256_update(&amp;sha256_ctx, image_buf, hash_desc.image_size);</span><br><span class="line">    digest = avb_sha256_final(&amp;sha256_ctx); <span class="comment">// digest2的值</span></span><br></pre></td></tr></table></figure><p>4、最后对比 <code>digest1</code>和 <code>digest2</code>的值是否相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avb_safe_memcmp(digest, desc_digest, digest_len) != <span class="number">0</span>) &#123;</span><br><span class="line">    avb_errorv(part_name,</span><br><span class="line">               <span class="string">": Hash of data does not match digest in descriptor.\n"</span>,</span><br><span class="line">               <span class="literal">NULL</span>);</span><br><span class="line">    ret = AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    avb_debugv (part_name, <span class="string">": success: Image verification completed\n"</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = AVB_SLOT_VERIFY_RESULT_OK;</span><br></pre></td></tr></table></figure><p>从第3和4点看出，如果<strong>你篡改一下boot.img的一个比特位，都导致boot.img计算出来的digest值不对。</strong></p><p>而如果要篡改vbmeta.img，这个也不可能，因为vbmeta.img在编译时，根据私钥与各个校验镜像（boot.img, dto.img …）计算hash才生成的vbmeta.img。</p><h2 id="kernel-init-AVB-2-0"><a href="#kernel-init-AVB-2-0" class="headerlink" title="kernel/init AVB 2.0"></a>kernel/init AVB 2.0</h2><p>init阶段的avb校验，可以通过dts和fstab确定需要校验的镜像。</p><ul><li>dts</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">compatible = <span class="string">"android,firmware"</span>;</span><br><span class="line">vbmeta &#123;</span><br><span class="line">compatible = <span class="string">"android,vbmeta"</span>;</span><br><span class="line">parts = <span class="string">"vbmeta,boot,system,vendor,dtbo"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fstab &#123;</span><br><span class="line">compatible = <span class="string">"android,fstab"</span>;</span><br><span class="line">vendor &#123;</span><br><span class="line">compatible = <span class="string">"android,vendor"</span>;</span><br><span class="line">dev = <span class="string">"/dev/block/platform/soc/1d84000.ufshc/by-name/vendor"</span>;</span><br><span class="line">type = <span class="string">"ext4"</span>;</span><br><span class="line">mnt_flags = <span class="string">"ro,barrier=1,discard"</span>;</span><br><span class="line">fsmgr_flags = <span class="string">"wait,slotselect,avb"</span>;</span><br><span class="line">status = <span class="string">"ok"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dts中的 <code>compatible = &quot;android,fstab&quot;;</code>目的是告诉<code>init</code>进程，vendor分区需要早点挂载。</p><p>其中 <code>fsmgr_flags = &quot;... avb&quot;</code> 告诉<code>init</code>进程，vendor分区需要avb校验。</p><p>但在888高通平台上采用动态分区的策略，无法找到vendor实体分区镜像，估计这一步是没有生效的。</p><ul><li>fstab.qcom</li></ul><p>我们只需要关注fstab中的<code>avb=</code>挂载参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system      /system  ext4    ro,barrier=1,discard    wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkey</span><br><span class="line">system_ext  /system_ext   ext4    ro,barrier=1,discard         wait,slotselect,avb=vbmeta_system,logical,first_stage_mount</span><br><span class="line">product     /product      ext4    ro,barrier=1,discard         wait,slotselect,avb=vbmeta_system,logical,first_stage_mount</span><br><span class="line">vendor      /vendor       ext4    ro,barrier=1,discard         wait,slotselect,avb,logical,first_stage_mount</span><br><span class="line">odm         /odm          ext4    ro,barrier=1,discard         wait,slotselect,avb,logical,first_stage_mount</span><br></pre></td></tr></table></figure><p>其中 <code>avb=vbmeta_system</code>涉及的<code>system、system_ext、product</code>三个镜像需要跟vbmeta_system镜像进行校验。</p><p>而<code>avb</code>没有<code>vbmeta_system</code>参数的，则跟vbmeta镜像进行校验，可以参考上面解析的vbmeta.img.info。</p><p>解析vbmeta_system镜像以求证<code>avb=vbmeta_system</code>涉及的三个分区:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avbtool info_image --image vbmeta_system.img &gt; vbmeta_system.img.info</span><br></pre></td></tr></table></figure><p>vbmeta_system.img.info内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Minimum libavb version:   <span class="number">1.0</span></span><br><span class="line">Header Block:             <span class="number">256</span> bytes</span><br><span class="line">Authentication Block:     <span class="number">320</span> bytes</span><br><span class="line">Auxiliary Block:          <span class="number">2368</span> bytes</span><br><span class="line"><span class="function">Public <span class="title">key</span> <span class="params">(sha1)</span>:        fc92d9cba0628858d846fb9a18a7af72b05d7dc8</span></span><br><span class="line"><span class="function">Algorithm:                SHA256_RSA2048</span></span><br><span class="line"><span class="function">Rollback Index:           1598918400</span></span><br><span class="line"><span class="function">Flags:                    0</span></span><br><span class="line">Release String:           'avbtool 1.1.0'</span><br><span class="line">Descriptors:</span><br><span class="line">    ...</span><br><span class="line">    Hashtree descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        product</span><br><span class="line">      Salt:                  b6e1f57ae6939659355e83ad7fa57feb6b5eb15a3d16b96752f43cdc14918708</span><br><span class="line">      Root Digest:           <span class="number">8747</span>dcab121c9cf740b106dc4b5545d685ee148f</span><br><span class="line">      Flags:                 <span class="number">0</span></span><br><span class="line">    Hashtree descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        system</span><br><span class="line">      Salt:                  b6e1f57ae6939659355e83ad7fa57feb6b5eb15a3d16b96752f43cdc14918708</span><br><span class="line">      Root Digest:           <span class="number">489</span>a406f49dd15c6c4ab3f86ae8c490837602f81</span><br><span class="line">      Flags:                 <span class="number">0</span></span><br><span class="line">    Hashtree descriptor:</span><br><span class="line">    ...</span><br><span class="line">      Partition Name:        system_ext</span><br><span class="line">      Salt:                  b6e1f57ae6939659355e83ad7fa57feb6b5eb15a3d16b96752f43cdc14918708</span><br><span class="line">      Root Digest:           <span class="number">3</span>eabb06d98d7e4639fbca3fd21806ef36332f1d3</span><br><span class="line">      Flags:                 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到vbmeta_system.img.info中包含<code>product system system_ext</code>三个镜像校验信息。</p><p>前面提到，高通888平台采用动态分区，没有vendor，system等镜像的实体分区，fstab该如何挂载这些镜像呢？</p><p>答案是通过<code>logical</code>挂载参数，告诉init进程，该分区是逻辑分区（虚拟分区），从super这一实体分区中划分出来。</p><ul><li>init 阶段 AVB 校验以下镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbmeta_system.img  vbmeta.img vendor.img product.img odm.img system_ext.img system.img</span><br></pre></td></tr></table></figure><p><img src="./init-avb.png" alt="init-avb"></p><p>如果校验失败，日志会报<code>dm-verity device corrupted</code>重启进入fastboot模式。</p><p>校验失败还要继续启动，则需要<code>disable-verity</code>关闭init阶段AVB。</p><h3 id="关闭init阶段AVB"><a href="#关闭init阶段AVB" class="headerlink" title="关闭init阶段AVB"></a>关闭init阶段AVB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastboot --<span class="built_in">disable</span>-verification flash vbmeta vbmeta.img</span><br><span class="line">fastboot --<span class="built_in">disable</span>-verity flash vbmeta vbmeta.img</span><br><span class="line">adb <span class="built_in">disable</span>-verity</span><br></pre></td></tr></table></figure><p>以上三个命令，本质上都是修改vbmeta对应的一个数据位，对应标志位说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Flags for the vbmeta image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED: If this flag is set,</span></span><br><span class="line"><span class="comment"> * hashtree image verification will be disabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED: If this flag is set,</span></span><br><span class="line"><span class="comment"> * verification will be disabled and descriptors will not be parsed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">  AVB_VBMETA_IMAGE_FLAGS_VERIFICATION_DISABLED = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">&#125; AvbVBMetaImageFlags;</span><br></pre></td></tr></table></figure><p><code>disable-verification</code>和<code>disable-verity</code>看着有差异，但是在源码上看到有意思的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/fs_mgr/libfs_avb/fs_avb.cpp</span></span><br><span class="line"><span class="function">AvbHashtreeResult <span class="title">AvbHandle::SetUpAvbHashtree</span><span class="params">(FstabEntry* fstab_entry, <span class="keyword">bool</span> wait_for_verity_dev)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// kHashtreeDisabled 和 kVerificationDisabled 分别对应 disable-verity 和 disable-verification</span></span><br><span class="line">    <span class="keyword">if</span> (status_ == AvbHandleStatus::kHashtreeDisabled ||</span><br><span class="line">        status_ == AvbHandleStatus::kVerificationDisabled) &#123;</span><br><span class="line">        LINFO &lt;&lt; <span class="string">"AVB HASHTREE disabled on: "</span> &lt;&lt; fstab_entry-&gt;mount_point;</span><br><span class="line">        <span class="keyword">return</span> AvbHashtreeResult::kDisabled;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/core/init/first_stage_mount.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FirstStageMountVBootV2::SetUpDmVerity</span><span class="params">(FstabEntry* fstab_entry)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// kHashtreeDisabled 和 kVerificationDisabled 分别对应 disable-verity 和 disable-verification</span></span><br><span class="line">    <span class="keyword">if</span> (avb_handle_-&gt;status() == AvbHandleStatus::kHashtreeDisabled ||</span><br><span class="line">    avb_handle_-&gt;status() == AvbHandleStatus::kVerificationDisabled) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Top-level vbmeta is disabled, skip Hashtree setup for </span></span><br><span class="line"><span class="string">               &lt;&lt; fstab_entry-&gt;mount_point;</span></span><br><span class="line"><span class="string">    return true;  // Returns true to mount the partition directly.</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    switch (hashtree_result) &#123;</span></span><br><span class="line"><span class="string">            case AvbHashtreeResult::kDisabled: // 与SetUpAvbHashtree函数的返回值是一样的</span></span><br><span class="line"><span class="string">            return true;  // Returns true to mount the partition.</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>因此，从这里看，无论是<code>disable-verification</code>还是<code>disable-verity</code>最终都是殊途同归。</p><h3 id="浅谈device-mapper-verity-dm-verity"><a href="#浅谈device-mapper-verity-dm-verity" class="headerlink" title="浅谈device-mapper-verity(dm-verity)"></a>浅谈device-mapper-verity(dm-verity)</h3><p>启动到init之后，system vendor 之类的镜像都是几个G的文件大小。如果真要整个镜像进行hash校验，对启动速度将会有极大的影响。</p><p>因此，才有了dm-verity这一策略。遵守上面介绍的，用到什么就校验什么的思路，来简单说一下dm-verity的工作原理。</p><p><img src="./dm-verity.png" alt="dm-verity"></p><p>图片来源：<a href="https://source.android.com/security/verifiedboot/dm-verity" target="_blank" rel="noopener">https://source.android.com/security/verifiedboot/dm-verity</a></p><p>在编译阶段，首先会对系统镜像（比如system.img、vendor.img）按照每4k大小计算对应hash，将这些hash信息存起来，形成上面图中的layer 0层，紧接着会对 layer 0 层同样按照每4k大小计算hash，并将这层的hash信息存起来，形成layer 1层，以此类推，直至最后的hash信息存放在一个4k大小的块中(未填满使用0填充)，这里边存储的hash信息称为 root hash。</p><p>在运行阶段，对于镜像里的文件进行访问时，操作对应所在块设备的存储区域时，会计算当前存储块(按4k大小)的hash值，然后会跟存储在哈希树上对应块的hash值进行比较，如果匹配不上，则认为当前该文件在底层存储被篡改或是损坏了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Google Android Verified Boot 2.0: <a href="https://android.googlesource.com/platform/external/avb/+/master/README.md" target="_blank" rel="noopener">https://android.googlesource.com/platform/external/avb/+/master/README.md</a></li><li>Google dm-verity: <a href="https://source.android.com/docs/security/features/verifiedboot/dm-verity" target="_blank" rel="noopener">https://source.android.com/docs/security/features/verifiedboot/dm-verity</a></li><li>内核工匠 dm-verity原理剖析：<a href="https://blog.csdn.net/feelabclihu/article/details/120232172" target="_blank" rel="noopener">https://blog.csdn.net/feelabclihu/article/details/120232172</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bootloader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVB </tag>
            
            <tag> Security </tag>
            
            <tag> Safe </tag>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Binder</title>
      <link href="/2019/01/01//android-binder.html/"/>
      <url>/2019/01/01//android-binder.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1、binder原理"><a href="#1、binder原理" class="headerlink" title="1、binder原理"></a>1、binder原理</h1><p>纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？<br>不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。</p><p>我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进程间通讯呢？要素有三个：</p><ul><li>函数指针；</li><li>函数参数；</li><li>函数返回值；</li></ul><p>binder通讯的本质实际上非常简单，就是client、server双方在共享内存的基础上封装成自定义api函数，并无神奇之处。我们看看他是怎么和IPC三要素对应上的：</p><h2 id="1-1、IPC函数指针"><a href="#1-1、IPC函数指针" class="headerlink" title="1.1、IPC函数指针"></a>1.1、IPC函数指针</h2><p>binder的service_server可以向service_client提供service服务，但反过来不行。所以binder service其实是单向的，只有service_server端才能提供service函数，且函数只能在service_server端运行。</p><p>大部分情况下：<strong>service_server端提供的一组IPC服务本地函数</strong>，就是<strong>binder对象</strong>。</p><p>例如，mediaserver注册的一系列service中的一个”media.player”：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/frameworks/</span>av<span class="regexp">/media/</span>mediaserver/main_mediaserver.<span class="string">cpp:</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">    MediaPlayerService:</span>:instantiate();</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="regexp">/frameworks/</span>av<span class="regexp">/media/</span>libmediaplayerservice/MediaPlayerService.<span class="string">cpp:</span></span><br><span class="line"><span class="keyword">void</span> <span class="string">MediaPlayerService:</span>:instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service_server提供了一组可以在server本地运行的函数，即<strong>binder对象</strong>。如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/libmedia/<span class="type">IMediaPlayerService</span>.cpp:</span><br><span class="line"><span class="title">status_t</span> <span class="type">BnMediaPlayerService</span>::onTransact(</span><br><span class="line">    uint32_t code, const <span class="type">Parcel</span>&amp; <span class="class"><span class="keyword">data</span>, <span class="type">Parcel</span>* reply, uint32_t flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayerClient</span>&gt; client =</span><br><span class="line">                interface_cast&lt;<span class="type">IMediaPlayerClient</span>&gt;(<span class="class"><span class="keyword">data</span>.readStrongBinder());</span></span><br><span class="line">            audio_session_t audioSessionId = (audio_session_t) <span class="class"><span class="keyword">data</span>.readInt32();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayer</span>&gt; player = create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(player));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE_MEDIA_RECORDER</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            const <span class="type">String16</span> opPackageName = <span class="class"><span class="keyword">data</span>.readString16();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaRecorder</span>&gt; recorder = createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(recorder));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在service_client端可以通过<strong>handle</strong>来引用这个<strong>binder对象</strong>，还封装了一系列与之对应的函数来组织数据。但是这些函数实际上是通讯用的，函数的实际功能并不能在client本地执行：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/libmedia/<span class="type">IMediaPlayerService</span>.cpp:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">BpMediaPlayerService</span>: public <span class="type">BpInterface</span>&lt;<span class="type">IMediaPlayerService</span>&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    virtual sp&lt;<span class="type">IMediaPlayer</span>&gt; create(</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">sp</span>&lt;<span class="type">IMediaPlayerClient</span>&gt;&amp; <span class="title">client</span>, <span class="title">audio_session_t</span> <span class="title">audioSessionId</span>) &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IMediaPlayerService</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeStrongBinder(<span class="type">IInterface</span>::<span class="title">asBinder</span>(<span class="title">client</span>));</span></span><br><span class="line"><span class="class">        data.writeInt32(<span class="title">audioSessionId</span>);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        remote()-&gt;transact(<span class="type">CREATE</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return interface_cast&lt;<span class="type">IMediaPlayer</span>&gt;(<span class="title">reply</span>.<span class="title">readStrongBinder</span>());</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    virtual sp&lt;<span class="type">IMediaRecorder</span>&gt; createMediaRecorder(<span class="title">const</span> <span class="type">String16</span> &amp;<span class="title">opPackageName</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IMediaPlayerService</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeString16(<span class="title">opPackageName</span>);</span></span><br><span class="line"><span class="class">        remote()-&gt;transact(<span class="type">CREATE_MEDIA_RECORDER</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return interface_cast&lt;<span class="type">IMediaRecorder</span>&gt;(<span class="title">reply</span>.<span class="title">readStrongBinder</span>());</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure><p>所以理解<strong>binder对象</strong>和<strong>handle</strong>是非常关键的。service_server端需要在本地执行函数，所以执行时函数调用的3要素(函数、参数、返回值)都必须是本地的，所以它必须拥有一组函数的<strong>binder对象</strong>；service_client端不需要在本地执行，所以它没有函数集的<strong>binder对象</strong>，它只有函数集的远端引用<strong>handle</strong>。</p><p>binder通讯的3个主角：service_mannager、service_server、service_client。在各种场景下，分别的<strong>binder对象</strong>和<strong>handle</strong>关系如下：</p><table border="1"><caption> binder object_handle </caption><tr><th style="width: 200px;">场景</th><th style="width: 400px;">client</th><th style="width: 400px;">server</th></tr><tr><td> service_manage初始化 </td><td>service_manager:<br/><br/>本地的binder对象为svcmgr_handler()函数集；<br/>通过ioctl BINDER_SET_CONTEXT_MGR命令把该binder对象注册成全局handle0；<br/></td><td>binder device：<br/><br/>创建handle0引用，指向service_manager</td></tr><tr><td> service_server的addService </td><td>service_server:<br/><br/>target handle：handle0<br/>data：binder对象为一组本地service函数集；<br/></td><td>service_manager：<br/><br/>binder驱动会创建对该binder对象的引用handle<br/>通过SVC_MGR_ADD_SERVICE命令把该handle加入到service_manage的handle链表中；<br/></td></tr><tr><td> service_client的get_service </td><td>service_client:<br/><br/>target handle：handle0<br/>data：service name。整个过程中没有binder对象的参与。<br/>向service_manager获取service_server的service函数的handle；<br/></td><td>service_manage：<br/><br/>SVC_MGR_GET_SERVICE命令，通过service的name在service_manage的handle链表中查找对应的handle，并且把handle返回给service_client；<br/>这样对于service_server的binder对象，service_client和service_manage都持有它的handle了；</td></tr><tr><td> service_client调用service </td><td>service_client:<br/><br/>target handle：serive handle0。上一步获取的handle。<br/>data：调用参数。调用参数中也可能包含handle/binder对象。(看server端的处理)<br/></td><td>service_server：<br/><br/>驱动把target handle翻译成本地binder对象，调用对象提供的本地函数。<br/>对于data中可能包含的含handle/binder对象的处理：<br/>1、如果包含的handle是本进程binder的引用，把它翻译成本地binder，在本地可以运行；<br/>2、如果包含的handle不是本进程binder的引用，只能给它创建一份新的引用handle。这个handle也不能在server进程中运行，只能向其他service_server请求服务；<br/>3、不可能包含binder对象，因为client进程的binder对象在service_server进程中无法运行；<br/></td></tr></table><p>衍生出的原则如下：</p><ul><li>service_server类的进程只有<strong>binder对象</strong>，没有<strong>handle</strong>(除了handle0)，因为它所有操作都必须本地执行，引用远程对象毫无意义；</li><li>service_client类的进程只有<strong>handle</strong>，没有<strong>binder对象</strong>，因为它需要远程执行service不需要本地执行；</li><li>service_mannager进程同时有<strong>binder对象</strong>和<strong>handle</strong>，它本地<strong>binder对象</strong>的作用就是操作所有其他进程的<strong>handle</strong>；</li></ul><h2 id="1-2、IPC函数参数"><a href="#1-2、IPC函数参数" class="headerlink" title="1.2、IPC函数参数"></a>1.2、IPC函数参数</h2><p>如上一节描述，service_client可以通过名字向service_manage查询得到handle。这个handle就相当于远程的函数集指针。<br>但是对于一个函数调用，我们除了需要函数指针，还需要传递参数。  </p><p>binder使用parcel方式来打包函数参数和返回值。parcel可以用来传递几种类型的数据：</p><ul><li>普通类型的少量数据；</li><li>binder对象/handle(struct flat_binder_object);</li><li>fd(struct binder_fd_object)；</li></ul><p>下面详细描述每种情况的parcel包格式和承载的内容。</p><ul><li>1、普通类型的少量数据：</li></ul><p>这种普通类型(int/long/string…)的少量数据存储最为简单，存入时按照一定的顺序存入，取出时按照数据的排列格式取出即可。</p><ul><li>2、<strong>binder对象</strong>/<strong>handle</strong>(struct flat_binder_object)：</li></ul><p>这一类型数据的parcel包格式如下： </p><p><img src="binder_parcel_binder_object_format.png" alt="binder_parcel_binder_object_format"></p><p>可以看到这种类型的parcel包中包含了两种数据：data0/data1/…是普通类型数据；binder_obj0/binder_obj1/…是binder对象，binder_obj0 offset/binder_obj1 offset/…指出了了binder对象在parcel包中的偏移；</p><p>binder对象和handle共用结构体struct flat_binder_object。</p><p>上一节说过<strong>binder对象</strong>其实就是一组函数的指针，但是一个指针只需要一个long类型就可以标识了，为什么还需要用一个结构体struct flat_binder_object来传递。我理解下来主要的思想如下：使用binder都是面向对象语言c++/java，它们把函数组也要实例化成一个对象，一个对象只有被引用时才不会被回收，远程引用也需要让本地引用加1。</p><p>一组service函数，对本地进程来说就是binder，对其他需要使用的进程来说需要远程引用，就是handle，是一对多的关系。关系图如下：</p><p><img src="binder_binderobj_and_handle.png" alt="binder_binderobj_and_handle"></p><p>binder object是service_server的一个“local binder object”，service_manager和service_client创建了多个远程引用“remote handle”。</p><p>这个其实就是binder的核心思想，binder花费了大量的代码在维护这个关系上面：</p><ul><li>[x] service_server进程在驱动中创建了binder_node节点来保存<strong>binder对象</strong>，把本进程所有的binder_node都挂载在一颗红黑树proc-&gt;nodes上；</li><li>[x] service_manager和service_client每个新进程对这个<strong>binder对象</strong>引用，就创建一个新的binder_ref，它的值就是<strong>handle</strong>，并回指向binder_node。并且把本进程对其他service_server的引用都挂载到两颗红黑树proc-&gt;refs_by_node/proc-&gt;refs_by_desc上。并且远程引用会增加service_server进程关于<strong>binder对象</strong>的引用计数；</li></ul><p>binder驱动负责建立起<strong>binder对象</strong>和<strong>handle</strong>之间的映射关系，创建上述的数据结构，并负责翻译：</p><ul><li>[x] service_server把本地<strong>binder对象</strong>向service_manager注册。会在service_manager进程本地建立起binder_node，驱动会在service_manager进程中建立起对应的binder_ref引用，那么service_manager进程能看到的其实就是本进程对service_server<strong>binder对象</strong>的一个引用，并不能看到<strong>binder对象</strong>原始值；</li><li>[x] service_client根据名字向service_manager查询service。service_manager会返回本进程的handle，在内核中该handle会转换成<strong>binder对象</strong>binder_node。因为service_client不是service的本地进程，所以service_client不能得到<strong>binder对象</strong>，它只能得到引用<strong>handle</strong>。所以再针对service的<strong>binder对象</strong>创建一份service_client进程的本地引用；</li><li><p>[x] service_client调用远程service_server的service。内核判断handle引用是service_server的本地对象，就把handle转换成service_server的<strong>binder对象</strong>；</p></li><li><p>3、fd(struct binder_fd_object)：</p></li></ul><p>parcel还能传输文件句柄fd，此时的包格式如下：</p><p><img src="binder_parcel_fd_object_format.png" alt="binder_parcel_fd_object_format"></p><p>传输fd的意义何在呢？当binder的两个进程间需要传输大量的数据。例如：图像声音数据、或者是一个对象。可以在匿名共享内存(Ashmem)中创建一块区域，源进程会得到一个相应的fd，再把这个fd使用binder传递给目的进程，就可以共享数据了。</p><p>需要特别说明的是对象的传递，在同一个进程内进行函数调用的话，参数对象通常是使用引用的方式传递的。但是如果是跨进程的调用，是没有办法引用的，只有把整个对象复制过去。这种操作叫做对象的序列化，java称为Serializable，android有优化的实现Parcelable。注意对象序列化的Parcelable和binder的parcel数据封装不是一回事，尽管他们原理上很相似。binder并没有提供对象Parcelable的接口，如果我们要跨进程传输对象，只能把对象序列化(Parcelable)到匿名共享内存中，再把对应fd通过binder传输给目的进程。</p><p><img src="binder_fdobject_translate.png" alt="binder_fdobject_translate"></p><p>binder驱动在检测到传输的是fd，会在新的进程中分配一个新的fd，并指向原来的file结构，这样fd就被跨进程duplicate了。两个进程使用各自的fd对匿名共享内存区域进行mmap映射，就能访问相同的内存区域了。</p><h2 id="1-3、IPC函数返回值"><a href="#1-3、IPC函数返回值" class="headerlink" title="1.3、IPC函数返回值"></a>1.3、IPC函数返回值</h2><p>函数返回值也是使用和函数参数一样的parcel结构来封装数据的。就不再重复叙述。</p><p>上面提到的原则需要再次强调，在一次service_client和service_server之间的通讯，在传递参数和返回值时都要遵循的准则：service_client只会有<strong>handle</strong>，service_server只会有<strong>binder对象</strong>。</p><h2 id="1-4、binder内存"><a href="#1-4、binder内存" class="headerlink" title="1.4、binder内存"></a>1.4、binder内存</h2><p>前面说过binder通讯的本质就是在共享内存上加上一层api，我们来看看他是怎么管理共享内存的。</p><p><img src="binder_alloc_buffer.png" alt="binder_alloc_buffer"></p><p>我们可以看到：</p><ul><li>binder驱动给每个进程分配最多4M的buffer空间，这段空间在内核通过binder_proc-&gt;alloc红黑树来管理，同时通过mmap映射到进程用户空间；</li><li>和所有的进程通讯机制类似，这段空间相当于进程的接收邮箱inbox，其他进程发过来的消息会从其他进程用户空间复制存放到这里；</li><li>因为是mmap的所有本进程的用户空间访问免除了一次拷贝；</li><li>另外因为进程支持多个线程，所以多个线程会共享本进程的binder buffer；</li></ul><p><img src="binder_alloc_buffer_transaction.png" alt="binder_alloc_buffer_transaction"></p><p>我们看一下process 0、process n进程和process 1进程进行binder通讯时的buffer使用情况：</p><ul><li>首先会在process 1进程的inbox(binder buffer)空间中分配buffer；</li><li>binder驱动把process 0、process n进程用户空间的消息拷贝到process 1进程的inbox内核buffer中；</li><li>因为mmap，process 1进程的用户空间也可以看见这些消息了；</li></ul><h1 id="2、binder驱动"><a href="#2、binder驱动" class="headerlink" title="2、binder驱动"></a>2、binder驱动</h1><p>驱动是整个binder通讯的核心，java和native都是对其的封装。<br>因为binder驱动代码比较繁杂，看代码比较不好理解。结合第一章讲的基础知识和binder通讯具体场景，我们使用图来分析每一个典型场景下binder驱动内的变化。</p><h2 id="2-1、service-manager的初始化"><a href="#2-1、service-manager的初始化" class="headerlink" title="2.1、service_manager的初始化"></a>2.1、service_manager的初始化</h2><p><img src="binder_action_servicemanager_init.png" alt="binder_action_servicemanager_init"></p><p>通过上图我们可以看到具体过程：</p><ul><li>1、binder驱动为service_manager进程创建一个新的binder_node结构，赋值：.ptr=0、.cookie=0、.proc=当前proc；</li><li>2、把这个binder_node新节点加入到当前进程的proc-&gt;nodes红黑树中；</li><li>3、把binder_device的全局handle 0指针binder_device-&gt;context.binder_context_mgr_node指向新创建的binder_node；这样其他人通过handle 0指针就能找到对应binder_node，进一步找到service_manager是哪一个进程；</li></ul><p>service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。初始化过程为：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">main</span>() -&gt; <span class="title">binder_open</span>()、<span class="title">binder_become_context_manager</span>()</span></span><br></pre></td></tr></table></figure><h2 id="2-2、service-server的addService"><a href="#2-2、service-server的addService" class="headerlink" title="2.2、service_server的addService"></a>2.2、service_server的addService</h2><p><img src="binder_action_serviceserver_addservice.png" alt="binder_action_serviceserver_addservice"></p><p>通过上图我们可以看到，在service_server向service_manager注册service的时候，在驱动中的具体流程如下：</p><ul><li>1、因为是向service_manager注册，所以target handle固定=0。通过binder_device-&gt;context找到handle 0对应的binder_node，也就找到了对应的binder_proc，找到了对应的service_manager进程；</li><li>2、在service_manager进程中分配binder buffer，把service_server传递过来的parcel数据全部复制进去；</li><li>3、翻译parcel数据中的binder对象，把binder翻译成handle；</li><li>4、可以看到service_manager进程的handle就是对service_server进程binder的一个引用。把handle加入到service_manager进程的handle缓存红黑树中；</li><li>5、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_manager进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li></ul><p>service_manager的读取响应和reply动作就不去具体分析了，因为都非常的清晰。service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。service_manager在svcmgr_handler()函数中响应service_server的SVC_MGR_ADD_SERVICE请求，最终调用do_add_service()把handle和对应的service name加到svclist链表中：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main<span class="function"><span class="params">()</span> -&gt;</span> binder_loop<span class="function"><span class="params">()</span> -&gt;</span> binder_parse<span class="function"><span class="params">()</span> -&gt;</span> svcmgr_handler<span class="function"><span class="params">()</span> -&gt;</span> do_add_service()</span><br></pre></td></tr></table></figure><h2 id="2-3、service-client的get-service"><a href="#2-3、service-client的get-service" class="headerlink" title="2.3、service_client的get service"></a>2.3、service_client的get service</h2><p><img src="binder_action_serviceclient_getservice_send.png" alt="binder_action_serviceclient_getservice_send"></p><p>如上图service_client向service_manager发送get service请求的数据比较简单：</p><ul><li>1、根据handle 0找到service_manager进程；</li><li>2、在service_manager进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li><li>3、parcel的内容中没有binder或者handle，不需要翻译；</li><li>4、把parcel数据和其他信息打包成binder_transaction结构，并挂载到proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li></ul><p><img src="binder_action_serviceclient_getservice_reply.png" alt="binder_action_serviceclient_getservice_reply"></p><p>上图是service_manager给service_client回复信息的过程：</p><ul><li>1、service_manager根据service name在本地svclist链表中找到对应的handle，它把handle打包进parcel并reply给service_client；</li><li>2、根据service_manager所在线程thread-&gt;transaction_stack字段中保存的binder_transaction结构，从.from字段可以找到service_client所在的线程(binder_thread)和进程(binder_proc)；</li><li>3、在service_client进程中分配binder buffer，把service_manager传递过来的parcel数据全部复制进去；</li><li>4、翻译parcel中打包的handle结构，判断handle指向的binder_node进程不是service_client进程，所以新建service_client进程中对binder_node新的引用。新创建handle并加入到service_client进程的handle缓存红黑树中；</li><li>5、这样service_client就从service_manager中获取到了service_server binder对应的引用handle；</li><li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li></ul><h2 id="2-4、service-client调用service"><a href="#2-4、service-client调用service" class="headerlink" title="2.4、service_client调用service"></a>2.4、service_client调用service</h2><p><img src="binder_action_serviceclient_callservice.png" alt="binder_action_serviceclient_callservice"></p><p>上图是service_client调用service_server的service的过程：</p><ul><li>1、service_client的target handle为上一步向service_manager查询得到的handle，根据handle能找到对应binder_node，进一步找到service_server所在进程；</li><li>2、在service_server进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li><li>3、parcel中打包了函数参数，如果包含handle对象，需要进行翻译；不可能包含binder对象，因为service_client进程的binder对象在service_server进程中无法运行；</li><li>4、如果parcel中包含的handle指向的binder_noe和service_server是同一进程，把它翻译成本地binder，在本地可以运行；</li><li>5、如果parcel中包含的handle指向的binder_noe和service_server不是同一进程，那只能在service_server进程中给它创建一份新的引用handle。这个handle也不能在service_server进程中运行，只能向其他service_server请求服务；</li><li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li></ul><h2 id="2-5、Scatter-gather模式"><a href="#2-5、Scatter-gather模式" class="headerlink" title="2.5、Scatter-gather模式"></a>2.5、Scatter-gather模式</h2><p>在Android O中binder增加了一种性能改进模式Scatter-gather，这是因为binder在传输IPC参数数据时，因为传输的量不大，binder实际上做了3次拷贝：</p><p><img src="binder_transcation_3_copy.png" alt="binder_transcation_3_copy"></p><p>Scatter-gather把3次copy优化成1次：</p><p><img src="binder_transcation_Scatter-gather_1_copy.png" alt="binder_transcation_Scatter-gather_1_copy"></p><p>具体的代码可以看驱动对BINDER_TYPE_PTR类型数据的处理：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">case BINDER_TYPE_PTR: &#123;</span><br><span class="line">struct binder_buffer_object *bp =</span><br><span class="line">to_binder_buffer_object(hdr);</span><br><span class="line">size_t buf_left = sg_buf_end - sg_bufp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bp-&gt;length &gt; buf_left) &#123;</span><br><span class="line">binder_user_error(<span class="string">"%d:%d got transaction with too large buffer\n"</span>,</span><br><span class="line">  <span class="keyword">proc</span>-&gt;pid,<span class="title"> thread-&gt;pid);</span></span><br><span class="line"><span class="title"></span><span class="title">return_error</span> =<span class="title"> BR_FAILED_REPLY;</span></span><br><span class="line"><span class="title"></span><span class="title">return_error_param</span> = -EINVAL;</span><br><span class="line"><span class="title">return_error_line</span> =<span class="title"> __LINE__;</span></span><br><span class="line"><span class="title"></span><span class="title">goto</span> err_bad_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">if</span> (copy_from_user(sg_bufp,</span><br><span class="line">   (const<span class="title"> void</span> __user *)(uintptr_t)</span><br><span class="line"><span class="title">   bp-&gt;buffer,</span> bp-&gt;length)) &#123;</span><br><span class="line">binder_user_error(<span class="string">"%d:%d got transaction with invalid offsets ptr\n"</span>,</span><br><span class="line">  <span class="keyword">proc</span>-&gt;pid,<span class="title"> thread-&gt;pid);</span></span><br><span class="line"><span class="title"></span><span class="title">return_error_param</span> = -EFAULT;</span><br><span class="line"><span class="title">return_error</span> =<span class="title"> BR_FAILED_REPLY;</span></span><br><span class="line"><span class="title"></span><span class="title">return_error_line</span> =<span class="title"> __LINE__;</span></span><br><span class="line"><span class="title"></span><span class="title">goto</span> err_copy_data_failed;</span><br><span class="line">&#125;</span><br><span class="line">/*<span class="title"> Fixup</span> buffer<span class="title"> pointer</span> to<span class="title"> target</span> <span class="keyword">proc</span><span class="title"> address</span> space */</span><br><span class="line"><span class="title">bp-&gt;buffer</span> = (uintptr_t)sg_bufp +</span><br><span class="line"><span class="title">binder_alloc_get_user_buffer_offset(</span></span><br><span class="line"><span class="title"></span>&amp;target_proc-&gt;alloc);</span><br><span class="line"><span class="title">sg_bufp</span> +=<span class="title"> ALIGN(bp-&gt;length,</span> sizeof(u64));</span><br><span class="line"></span><br><span class="line"><span class="title">ret</span> =<span class="title"> binder_fixup_parent(t,</span> thread,<span class="title"> bp,</span> off_start,</span><br><span class="line"><span class="title">  offp</span> -<span class="title"> off_start,</span></span><br><span class="line"><span class="title"></span><span class="title">  last_fixup_obj,</span></span><br><span class="line"><span class="title"></span><span class="title">  last_fixup_min_off);</span></span><br><span class="line"><span class="title"></span>if (ret &lt; 0) &#123;</span><br><span class="line">return_error = BR_FAILED_REPLY;</span><br><span class="line">return_error_param = ret;</span><br><span class="line">return_error_line = __LINE__;</span><br><span class="line">goto err_translate_failed;</span><br><span class="line">&#125;</span><br><span class="line">last_fixup_obj = bp;</span><br><span class="line">last_fixup_min_off = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="2-6、多个binder-context"><a href="#2-6、多个binder-context" class="headerlink" title="2.6、多个binder context"></a>2.6、多个binder context</h2><p>Android O以后创建了3个misc设备，对应3个domain(contexts)，相互独立：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># ls /dev/*binder</span></span><br><span class="line"><span class="regexp">/dev/</span>binder <span class="regexp">/dev/</span>hwbinder <span class="regexp">/dev/</span>vndbinder</span><br></pre></td></tr></table></figure><p>因为在Android O以后HIDL也启用了binder通信，使用binder通信的进程越来越多，为了便于管理并且相互隔离，Android把binder划分成了3个domain(contexts)：</p><div class="table-container"><table><thead><tr><th>IPC Domain</th><th>Description</th></tr></thead><tbody><tr><td>/dev/binder</td><td>IPC between framework/app processes with AIDL interfaces</td></tr><tr><td>/dev/hwbinder</td><td>IPC between framework/vendor processes with HIDL interfacesIPC between vendor processes with HIDL interfaces</td></tr><tr><td>/dev/vndbinder</td><td>IPC between vendor/vendor processes with AIDL Interfaces</td></tr></tbody></table></div><h2 id="2-7、调试接口"><a href="#2-7、调试接口" class="headerlink" title="2.7、调试接口"></a>2.7、调试接口</h2><p>binder驱动创建了很多调试接口，可以方便的debug binder通讯的过程。</p><p>1、”/d/binder/state”</p><p>全局情况：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># more /d/binder/state</span><br><span class="line">binder state:</span><br><span class="line">dead nodes:</span><br><span class="line">  node <span class="number">392820</span>: u0000007b50bf75a0 c0000007b2b4d5b80 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">3021</span></span><br><span class="line">  node <span class="number">176573</span>: u0000007b50bf72c0 c0000007b4515a600 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">5571</span></span><br><span class="line">  node <span class="number">56178</span>: u0000007b50a8dfa0 c0000007b50bc31c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">3135</span></span><br><span class="line">  node <span class="number">47334</span>: u0000007b47f0df40 c0000007b47f077c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">1458</span></span><br><span class="line">  node <span class="number">342153</span>: u0000007b47f0d480 c0000007b451bf8c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">5571</span></span><br><span class="line">  node <span class="number">50574</span>: u0000007b451ffa20 c0000007b3519e5c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">1458</span></span><br><span class="line">  node <span class="number">49594</span>: u0000007b451ff940 c0000007b3507f480 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">2859</span></span><br></pre></td></tr></table></figure><p>2、”/d/binder/stats”</p><p>全局统计：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># more /d/binder/stats</span></span><br><span class="line"><span class="attr">binder stats:</span></span><br><span class="line"><span class="attr">BC_TRANSACTION:</span> <span class="number">226132</span></span><br><span class="line"><span class="attr">BC_REPLY:</span> <span class="number">201918</span></span><br><span class="line"><span class="attr">BC_FREE_BUFFER:</span> <span class="number">633493</span></span><br><span class="line"><span class="attr">BC_INCREFS:</span> <span class="number">9234</span></span><br><span class="line"><span class="attr">BC_ACQUIRE:</span> <span class="number">9415</span></span><br><span class="line"><span class="attr">BC_RELEASE:</span> <span class="number">6040</span></span><br><span class="line"><span class="attr">BC_DECREFS:</span> <span class="number">6014</span></span><br><span class="line"><span class="attr">BC_INCREFS_DONE:</span> <span class="number">5551</span></span><br><span class="line"><span class="attr">BC_ACQUIRE_DONE:</span> <span class="number">5552</span></span><br><span class="line"><span class="attr">BC_REGISTER_LOOPER:</span> <span class="number">355</span></span><br><span class="line"><span class="attr">BC_ENTER_LOOPER:</span> <span class="number">229</span></span><br><span class="line"><span class="attr">BC_REQUEST_DEATH_NOTIFICATION:</span> <span class="number">2908</span></span><br><span class="line"><span class="attr">BC_CLEAR_DEATH_NOTIFICATION:</span> <span class="number">2146</span></span><br><span class="line"><span class="attr">BC_DEAD_BINDER_DONE:</span> <span class="number">225</span></span><br><span class="line"><span class="attr">BC_TRANSACTION_SG:</span> <span class="number">118790</span></span><br><span class="line"><span class="attr">BC_REPLY_SG:</span> <span class="number">86885</span></span><br><span class="line"><span class="attr">BR_TRANSACTION:</span> <span class="number">344921</span></span><br><span class="line"><span class="attr">BR_REPLY:</span> <span class="number">288803</span></span><br><span class="line"><span class="attr">BR_TRANSACTION_COMPLETE:</span> <span class="number">633725</span></span><br><span class="line"><span class="attr">BR_INCREFS:</span> <span class="number">5559</span></span><br><span class="line"><span class="attr">BR_ACQUIRE:</span> <span class="number">5560</span></span><br><span class="line"><span class="attr">BR_RELEASE:</span> <span class="number">3436</span></span><br><span class="line"><span class="attr">BR_DECREFS:</span> <span class="number">3435</span></span><br><span class="line"><span class="attr">BR_SPAWN_LOOPER:</span> <span class="number">357</span></span><br><span class="line"><span class="attr">BR_DEAD_BINDER:</span> <span class="number">226</span></span><br><span class="line"><span class="attr">BR_CLEAR_DEATH_NOTIFICATION_DONE:</span> <span class="number">2146</span></span><br><span class="line"><span class="attr">proc:</span> <span class="string">active</span> <span class="number">163</span> <span class="string">total</span> <span class="number">232</span></span><br><span class="line"><span class="attr">thread:</span> <span class="string">active</span> <span class="number">852</span> <span class="string">total</span> <span class="number">3214</span></span><br><span class="line"><span class="attr">node:</span> <span class="string">active</span> <span class="number">1610</span> <span class="string">total</span> <span class="number">5564</span></span><br><span class="line"><span class="attr">ref:</span> <span class="string">active</span> <span class="number">2557</span> <span class="string">total</span> <span class="number">9384</span></span><br><span class="line"><span class="attr">death:</span> <span class="string">active</span> <span class="number">746</span> <span class="string">total</span> <span class="number">2908</span></span><br><span class="line"><span class="attr">transaction:</span> <span class="string">active</span> <span class="number">1</span> <span class="string">total</span> <span class="number">633725</span></span><br><span class="line"><span class="attr">transaction_complete:</span> <span class="string">active</span> <span class="number">0</span> <span class="string">total</span> <span class="number">633725</span></span><br><span class="line"><span class="string">proc</span> <span class="number">10578</span></span><br><span class="line"><span class="string">context</span> <span class="string">binder</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">requested threads:</span> <span class="number">0</span><span class="string">+2/15</span></span><br><span class="line">  <span class="string">ready</span> <span class="string">threads</span> <span class="number">3</span></span><br><span class="line">  <span class="string">free</span> <span class="string">async</span> <span class="string">space</span> <span class="number">520192</span></span><br><span class="line">  <span class="attr">nodes:</span> <span class="number">41</span></span><br></pre></td></tr></table></figure><p>3、”/d/binder/proc/xxx”</p><p>具体进程的情况：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cat /d/binder/proc/<span class="number">1037</span></span><br><span class="line">binder proc state:</span><br><span class="line">proc <span class="number">1037</span></span><br><span class="line">context binder</span><br><span class="line">  thread <span class="number">1037</span>: l <span class="number">12</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  thread <span class="number">1094</span>: l <span class="number">00</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  thread <span class="number">1096</span>: l <span class="number">12</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  node <span class="number">2758</span>: u0000006fe9c10000 c0000006fe9c0d008 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">704</span></span><br><span class="line">  node <span class="number">1192</span>: u0000006fea02f620 c0000006fea029868 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">549</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">1190</span>: desc <span class="number">0</span> node <span class="number">2</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">1204</span>: desc <span class="number">1</span> node <span class="number">170</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">249105</span>: desc <span class="number">2</span> node <span class="number">5946</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  buffer <span class="number">249107</span>: <span class="number">0000000000000000</span> size <span class="number">3600</span>:<span class="number">0</span>:<span class="number">0</span> delivered</span><br></pre></td></tr></table></figure><h1 id="3、service-manager实现"><a href="#3、service-manager实现" class="headerlink" title="3、service manager实现"></a>3、service manager实现</h1><p>service_manager逻辑很清晰，代码也不多，主要流程在上节中已经描述就不再详细分析。<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a></p><h1 id="4、native实现"><a href="#4、native实现" class="headerlink" title="4、native实现"></a>4、native实现</h1><p>整个native层binder的实现还是以mediaserver为例来说明。</p><h2 id="4-1、process-thread"><a href="#4-1、process-thread" class="headerlink" title="4.1、process/thread"></a>4.1、process/thread</h2><p><img src="binder_native_process_thread.png" alt="binder_native_process_thread"></p><p>上图已经把native层binder通讯最重要的部分都画出来了，理解了这张图native的实现基本理解了大半：</p><ul><li>[x] binder在server接收端会创建多个线程，在发送端不会创建专门的线程直接在发送者的线程中；</li><li><p>[x] binder在server端的通用对象是BBinder，在client端的通用引用对象是BpBinder。具体service的server端和client端的实现，只要继承这两个类就行了；</p></li><li><p>1、ProcessState类</p></li></ul><p>因为binder buffer是一个进程一份的，所以不论是client还是server进程，都只会创建一个binder fd，进行一次mmap映射。binder fd、mmap公共资源在本进程内的多个线程间共享。native使用了一个ProcessState类来管理这些进程公共资源。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; proc(<span class="name">ProcessState</span>:<span class="symbol">:self</span>())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* (1) 创建新的ProcessState对象 */</span></span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(<span class="string">"/dev/binder"</span>);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    <span class="comment">/* (1.1) open binder节点"/dev/binder"，获得文件句柄 */</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        <span class="comment">/* (1.2) 根据fd映射1M的mmap空间 */</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            ALOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* (1.1.1) open节点的具体操作 */</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          ALOGE(<span class="string">"Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d"</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* (1.1.2) 设置默认最大接收线程数为15 */</span></span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"Opening '%s' failed: %s\n"</span>, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、IPCThreadState类</li></ul><p>native binder对线程也进行了封装。  </p><ul><li>2.1、对于server端来说，native binder创建一个线程池，可以多个接收线程来响应和运行service服务。例如</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ps -eT | grep Binder</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">1180</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_1</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">1886</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_2</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">1887</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_3</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">2489</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_4</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">5497</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_5</span><br><span class="line">media         <span class="number">1034</span>  <span class="number">1130</span>     <span class="number">1</span> <span class="number">2140724</span>  <span class="number">10968</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1034</span>_1</span><br><span class="line">media         <span class="number">1034</span>  <span class="number">8000</span>     <span class="number">1</span> <span class="number">2140724</span>  <span class="number">10968</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1034</span>_2</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self<span class="literal">()</span>-&gt;start<span class="constructor">ThreadPool()</span>;</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::start<span class="constructor">ThreadPool()</span></span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex <span class="constructor">_l(<span class="params">mLock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">        spawn<span class="constructor">PooledThread(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::spawn<span class="constructor">PooledThread(<span class="params">bool</span> <span class="params">isMain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = make<span class="constructor">BinderThreadName()</span>;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, <span class="params">name</span>.<span class="params">string</span>()</span>);</span><br><span class="line">        <span class="comment">/* (1)新创建一个PoolThread对象 </span></span><br><span class="line"><span class="comment">            main的意思就是它是一个接收主线程，它不会动态的退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="constructor">PoolThread(<span class="params">isMain</span>)</span>;</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>PoolThread类继承了Thread类，并且实现了线程主循环函数：threadLoop()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PoolThread</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function">        : <span class="title">mIsMain</span><span class="params">(isMain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* (1.1) 线程主循环，进一步调用 */</span></span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>↓<br>创建IPCThreadState对象<br>frameworks/native/libs/binder/IPCThreadState.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">/* (1.1.1) 创建一个本地线程的IPCThreadState对象 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gShutdown) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line">        <span class="keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(<span class="string">"IPCThreadState::self() unable to create TLS key, expect a crash: %s\n"</span>,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">    mRealCallingPid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// @&#125;</span></span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>最后进入IPCThreadState类的线程主循环函数joinThreadPool()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(<span class="built_in">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n"</span>, (void*)pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123;</span><br><span class="line">            ALOGE(<span class="string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></span><br><span class="line">        <span class="comment">// needed and it is not the main process thread.</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d\n"</span>,</span><br><span class="line">        (void*)pthread_self(), getpid(), result);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.2.1) 和binder驱动交互：</span></span><br><span class="line"><span class="comment">        把mOut中的数据发送给binder驱动</span></span><br><span class="line"><span class="comment">        把接收驱动中的数据到mIn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        size_t IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; sizeof(int32_t)) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (1.1.2.2) 读出接收数据中的cmd */</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></span><br><span class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1.1.2.3) 执行cmd */</span></span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs != <span class="number">0</span>) &#123;</span><br><span class="line">            int64_t starvationTimeMs = uptimeMillis() - mProcess-&gt;mStarvationStartTimeMs;</span><br><span class="line">            <span class="keyword">if</span> (starvationTimeMs &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"binder thread pool (%zu threads) starved for %"</span> PRId64 <span class="string">" ms"</span>,</span><br><span class="line">                      mProcess-&gt;mMaxThreads, starvationTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>我们只需要关注其中BR_TRANSACTION命令的处理：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            Parcel <span class="built_in">buffer</span>;</span><br><span class="line">            <span class="built_in">buffer</span>.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> origPid = mCallingPid;</span><br><span class="line">            <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span>  origPidCopy = mRealCallingPid;</span><br><span class="line">            <span class="comment">// @&#125;</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uid_t</span> origUid = mCallingUid;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> origStrictModePolicy = mStrictModePolicy;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> origTransactionBinderFlags = mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid = tr.sender_pid;</span><br><span class="line">            <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">            mRealCallingPid = tr.sender_pid;</span><br><span class="line">            <span class="comment">// @&#125;</span></span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags = tr.flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);</span></span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">"BR_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self()</span><br><span class="line">                    &lt;&lt; <span class="string">" / obj "</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">" / code "</span></span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; <span class="built_in">buffer</span></span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">                    &lt;&lt; <span class="string">"Data addr = "</span></span><br><span class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>)</span><br><span class="line">                    &lt;&lt; <span class="string">", offsets addr="</span></span><br><span class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to</span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    <span class="comment">/* (1.1.2.3.1) 如果target是一个合法的本地对象， </span></span><br><span class="line"><span class="comment">                        把tr.cookie转换成BBinder对象，并调用BBinder-&gt;transact()来处理数据</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, <span class="built_in">buffer</span>,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, <span class="built_in">buffer</span>, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",</span></span><br><span class="line">            <span class="comment">//     mCallingPid, origPid, origUid);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid = origPid;</span><br><span class="line">            <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">            mRealCallingPid = origPidCopy;</span><br><span class="line">            <span class="comment">// @&#125;</span></span><br><span class="line">            mCallingUid = origUid;</span><br><span class="line">            mStrictModePolicy = origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags = origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">"BC_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / obj "</span></span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>BBinder是一个标准的通用binder对象，它的transact()函数会被具体的service子类重写，所以会调用到具体子类的transact()函数中<br>frameworks/native/libs/binder/Binder.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> <span class="comment">/*flags*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">            reply-&gt;writeString16(getInterfaceDescriptor());</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>BnMediaPlayerService是负责具体实现的子类，最后会调用进BnMediaPlayerService类的onTransact()函数中：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">status_t</span> <span class="type">BnMediaPlayerService</span>::onTransact(</span><br><span class="line">    uint32_t code, const <span class="type">Parcel</span>&amp; <span class="class"><span class="keyword">data</span>, <span class="type">Parcel</span>* reply, uint32_t flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayerClient</span>&gt; client =</span><br><span class="line">                interface_cast&lt;<span class="type">IMediaPlayerClient</span>&gt;(<span class="class"><span class="keyword">data</span>.readStrongBinder());</span></span><br><span class="line">            audio_session_t audioSessionId = (audio_session_t) <span class="class"><span class="keyword">data</span>.readInt32();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayer</span>&gt; player = create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(player));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE_MEDIA_RECORDER</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            const <span class="type">String16</span> opPackageName = <span class="class"><span class="keyword">data</span>.readString16();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaRecorder</span>&gt; recorder = createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(recorder));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return <span class="type">BBinder</span>::onTransact(code, <span class="class"><span class="keyword">data</span>, reply, flags);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.2、对于client端来说是发送数据，native binder不会对其创建新的线程，但是IPCThreadState类也为client端的发送提供了封装。</li></ul><p>client端通用的binder远端代理类为BpBinder，它的发送数据到binder驱动的函数为transact()：<br>frameworks/native/libs/binder/BpBinder.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>最后调用到IPCThreadState类的相关方法：<br>frameworks/native/libs/binder/IPCThreadState.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span></span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (1) 把数据写入mOut */</span></span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (2) 使用mOut、mIn和binder驱动进行通讯 */</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (2.1) 和binder驱动通讯 */</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2、manager-proxy"><a href="#4-2、manager-proxy" class="headerlink" title="4.2、manager proxy"></a>4.2、manager proxy</h2><p>service_client service_server和service_manager通讯时，都是处于client角色，所以只能操作service_manager的代理对象。我们看一下具体的代理对象是怎么创建起来的。</p><p>server在注册service服务时，都需要获取到默认manager代理：  </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager<span class="function"><span class="params">()</span>-&gt;</span>addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/IServiceManager.cpp：  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; <span class="built_in">defaultServiceManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="built_in">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex <span class="built_in">_l</span>(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="built_in">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* (1) 创建BpBinder对象，并在此基础上创建它的子类BpServiceManager对象 */</span></span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="built_in">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="built_in">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>|→<br>frameworks/native/libs/binder/ProcessState.cpp</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* (1.1) 为service_manager创建handle=0的BpBinder对象 */</span></span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 */</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Special case for context manager...</span></span><br><span class="line">                <span class="comment">// The context manager is the only object for which we create</span></span><br><span class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></span><br><span class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></span><br><span class="line">                <span class="comment">// is registered before we create the first local reference</span></span><br><span class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></span><br><span class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></span><br><span class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></span><br><span class="line">                <span class="comment">// provide a reference to the context manager, but the</span></span><br><span class="line">                <span class="comment">// driver API does not return status.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></span><br><span class="line">                <span class="comment">// dies while this code runs.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> add a driver API to wait for context manager, or</span></span><br><span class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></span><br><span class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></span><br><span class="line">                <span class="comment">// proper reference counting.</span></span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="keyword">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (1.1.2) 给新handle新创建一个对应BpBinder对象 */</span></span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>|→<br>在创建完标准BpBinder对象以后，使用了一个模板函数interface_cast<IServiceManager>()把子类对象也给创建了。interface_cast()的定义在</p><p>frameworks/native/libs/binder/include/binder/IInterface.h:</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename <span class="class"><span class="keyword">INTERFACE</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;<span class="class"><span class="keyword">INTERFACE</span>&gt; <span class="title">interface_cast</span>(<span class="title">const</span> <span class="title">sp</span>&lt;<span class="title">IBinder</span>&gt;&amp; <span class="title">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">INTERFACE</span>::<span class="title">asInterface</span>(<span class="title">obj</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface_cast<IServiceManager>()扩展为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IServiceManager&gt; interface<span class="constructor">_cast(<span class="params">const</span> <span class="params">sp</span>&lt;IBinder&gt;&amp; <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return IServiceManager::<span class="keyword">as</span><span class="constructor">Interface(<span class="params">obj</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frameworks/native/libs/binder/include/binder/IInterface.h:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16</span> I<span class="comment">##INTERFACE::descriptor(NAME);           \</span></span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16&amp;</span>                                          \</span><br><span class="line">            I<span class="comment">##INTERFACE::getInterfaceDescriptor() const &#123;              \</span></span><br><span class="line">        <span class="keyword">return</span> I<span class="comment">##INTERFACE::descriptor;                                \</span></span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;I</span><span class="comment">##INTERFACE&gt; I##INTERFACE::asInterface(              \</span></span><br><span class="line">            const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;</span><span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:IBinder&gt;&amp;</span> obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;I</span><span class="comment">##INTERFACE&gt; intr;                               \</span></span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;I<span class="comment">##INTERFACE*&gt;(                          \</span></span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I<span class="comment">##INTERFACE::descriptor).get());               \</span></span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new Bp<span class="comment">##INTERFACE(obj);                          \</span></span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I<span class="comment">##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span></span><br><span class="line">    I<span class="comment">##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span></span><br></pre></td></tr></table></figure><p>frameworks/native/libs/binder/IServiceManager.cpp:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(<span class="name">ServiceManager</span>, <span class="string">"android.os.IServiceManager"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>扩展为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define IMPLEMENT_META_INTERFACE(ServiceManager, "android.os.IServiceManager")                       \</span></span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16</span> IServiceManager::descriptor(<span class="string">"android.os.IServiceManager"</span>);           \</span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16&amp;</span>                                          \</span><br><span class="line">            IServiceManager::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        <span class="keyword">return</span> IServiceManager::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;IServiceManager&gt;</span> IServiceManager::asInterface(              \</span><br><span class="line">            const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;</span><span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:IBinder&gt;&amp;</span> obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;IServiceManager&gt;</span> intr;                               \</span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;IServiceManager*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IServiceManager::descriptor).get());               \</span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new BpServiceManager(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;                                    \</span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure><p>所以defaultServiceManager()最后得到了一个BpServiceManager对象，利用它的::addService()方法来注册service。<br>frameworks/native/libs/binder/IServiceManager.cpp：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">BpServiceManager</span> : public <span class="type">BpInterface</span>&lt;<span class="type">IServiceManager</span>&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    explicit <span class="type">BpServiceManager</span>(<span class="title">const</span> <span class="title">sp</span>&lt;<span class="type">IBinder</span>&gt;&amp; <span class="title">impl</span>)</span></span><br><span class="line"><span class="class">        : <span class="type">BpInterface</span>&lt;<span class="type">IServiceManager</span>&gt;(<span class="title">impl</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    virtual status_t addService(<span class="title">const</span> <span class="type">String16</span>&amp; <span class="title">name</span>, <span class="title">const</span> <span class="title">sp</span>&lt;<span class="type">IBinder</span>&gt;&amp; <span class="title">service</span>,</span></span><br><span class="line"><span class="class">            <span class="title">bool</span> <span class="title">allowIsolated</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IServiceManager</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeString16(<span class="title">name</span>);</span></span><br><span class="line"><span class="class">        data.writeStrongBinder(<span class="title">service</span>);</span></span><br><span class="line"><span class="class">        data.writeInt32(<span class="title">allowIsolated</span> ? 1 : 0);</span></span><br><span class="line"><span class="class">        status_t err = remote()-&gt;transact(<span class="type">ADD_SERVICE_TRANSACTION</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return err == <span class="type">NO_ERROR</span> ? reply.readExceptionCode() : err;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    virtual sp&lt;<span class="type">IBinder</span>&gt; checkService( <span class="title">const</span> <span class="type">String16</span>&amp; <span class="title">name</span>) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IServiceManager</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeString16(<span class="title">name</span>);</span></span><br><span class="line"><span class="class">        remote()-&gt;transact(<span class="type">CHECK_SERVICE_TRANSACTION</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return reply.readStrongBinder();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br></pre></td></tr></table></figure><p>remote()-&gt;transact()会调用到BpBinder的transact()函数，最后IPCThreadState的transact()函数。<br>frameworks/native/libs/binder/BpBinder.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用老罗的一张图总结，service_manager类之间复杂的关系：</p><p><img src="binder_class_manager.jpg" alt="binder_class_manager"></p><h2 id="4-3、server"><a href="#4-3、server" class="headerlink" title="4.3、server"></a>4.3、server</h2><p>有了manager的代理对象以后，server就可以注册服务并且创建binder rx服务线程了。</p><p>frameworks/av/media/mediaserver/main_mediaserver.cpp:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager<span class="function"><span class="params">()</span>-&gt;</span>addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的细节在上面几节都已经描述过了，还是借用老罗的一张图总结service_server类之间复杂的关系：</p><p><img src="binder_class_server.jpg" alt="binder_class_server"></p><h2 id="4-4、client-proxy"><a href="#4-4、client-proxy" class="headerlink" title="4.4、client proxy"></a>4.4、client proxy</h2><p>service_client也是创建代理对象，和manager代理非常相似。我们也来具体分析一下。<br>frameworks/av/media/libmedia/IMediaDeathNotifier.cpp:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMediaDeathNotifier::get<span class="constructor">MediaPlayerService()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">"getMediaPlayerService"</span>)</span>;</span><br><span class="line">    Mutex::Autolock <span class="constructor">_l(<span class="params">sServiceLock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (sMediaPlayerService<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* (1) 创建manager代理对象 */</span></span><br><span class="line">        sp&lt;IServiceManager&gt; sm = default<span class="constructor">ServiceManager()</span>;</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* (2) 使用manager代理获取到service的handle, </span></span><br><span class="line"><span class="comment">                并根据handle创建一个BpBinder对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            binder = sm-&gt;get<span class="constructor">Service(String16(<span class="string">"media.player"</span>)</span>);</span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="constructor">ALOGW(<span class="string">"Media player service not published, waiting..."</span>)</span>;</span><br><span class="line">            usleep(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">            sDeathNotifier = <span class="keyword">new</span> <span class="constructor">DeathNotifier()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;link<span class="constructor">ToDeath(<span class="params">sDeathNotifier</span>)</span>;</span><br><span class="line">        <span class="comment">/* (3) 根据BpBinder对象，使用interface_cast&lt;IMediaPlayerService&gt;()函数创建一个BpMediaPlayerService对象 */</span></span><br><span class="line">        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">ALOGE_IF(<span class="params">sMediaPlayerService</span> <span class="operator">==</span> 0, <span class="string">"no media player service!?"</span>)</span>;</span><br><span class="line">    return sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了BpMediaPlayerService对象，即MediaPlayerService的远端代理，就可以调用远端service服务了。<br>frameworks/wilhelm/src/android/android_LocAVPlayer.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocAVPlayer::onPrepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SL_LOGD(<span class="string">"LocAVPlayer::onPrepare()"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* (4.1) 获取到MediaPlayerService的远端代理 */</span></span><br><span class="line">    <span class="function">sp&lt;IMediaPlayerService&gt; <span class="title">mediaPlayerService</span><span class="params">(getMediaPlayerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mediaPlayerService != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mDataLocatorType) &#123;</span><br><span class="line">        <span class="keyword">case</span> kDataLocatorUri:</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* (4.2) 调用远端service服务 */</span></span><br><span class="line">            mPlayer = mediaPlayerService-&gt;create(mPlayerClient <span class="comment">/*IMediaPlayerClient*/</span>,</span><br><span class="line">                    mPlaybackParams.sessionId);</span><br></pre></td></tr></table></figure><p>其中通过sm-&gt;getService(String16(“media.player”))返回BpBinder的过程如下：<br>frameworks/native/libs/binder/IServiceManager.cpp:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; get<span class="constructor">Service(<span class="params">const</span> String16&amp; <span class="params">name</span>)</span> const&#123;&#125;</span><br><span class="line">↓</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; check<span class="constructor">Service( <span class="params">const</span> String16&amp; <span class="params">name</span>)</span> const</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.write<span class="constructor">InterfaceToken(IServiceManager::<span class="params">getInterfaceDescriptor</span>()</span>);</span><br><span class="line">        data.write<span class="constructor">String16(<span class="params">name</span>)</span>;</span><br><span class="line">        <span class="comment">/* (2.1) 向远程manager查询handle */</span></span><br><span class="line">        remote<span class="literal">()</span>-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return reply.read<span class="constructor">StrongBinder()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/Parcel.cpp</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Parcel::readStrongBinder</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    <span class="comment">// Note that a lot of code in Android reads binders by hand with this</span></span><br><span class="line">    <span class="comment">// method, and that code has historically been ok with getting nullptr</span></span><br><span class="line">    <span class="comment">// back (while ignoring error codes).</span></span><br><span class="line">    readNullableStrongBinder(&amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, val);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">unflatten_binder</span><span class="params">(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                <span class="comment">/* (2.1.1) 根据handle创建BpBinder */</span></span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;<span class="built_in">get</span>()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>然后就来到了创建manager代理对象同样的位置：<br>frameworks/native/libs/binder/ProcessState.cpp:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 */</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Special case for context manager...</span></span><br><span class="line">                <span class="comment">// The context manager is the only object for which we create</span></span><br><span class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></span><br><span class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></span><br><span class="line">                <span class="comment">// is registered before we create the first local reference</span></span><br><span class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></span><br><span class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></span><br><span class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></span><br><span class="line">                <span class="comment">// provide a reference to the context manager, but the</span></span><br><span class="line">                <span class="comment">// driver API does not return status.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></span><br><span class="line">                <span class="comment">// dies while this code runs.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> add a driver API to wait for context manager, or</span></span><br><span class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></span><br><span class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></span><br><span class="line">                <span class="comment">// proper reference counting.</span></span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="keyword">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (2.1.1.2) 给新handle新创建一个对应BpBinder对象 */</span></span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据BpBinder对象，使用interface_cast<IMediaPlayerService>()函数创建一个BpMediaPlayerService对象的过程如下：</p><p>interface_cast<IMediaPlayerService>()扩展为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IMediaPlayerService&gt; interface<span class="constructor">_cast(<span class="params">const</span> <span class="params">sp</span>&lt;IBinder&gt;&amp; <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return IMediaPlayerService::<span class="keyword">as</span><span class="constructor">Interface(<span class="params">obj</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IMediaPlayerService定义在：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(<span class="name">MediaPlayerService</span>, <span class="string">"android.media.IMediaPlayerService"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>展开为：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define IMPLEMENT_META_INTERFACE(MediaPlayerService, "android.os.IServiceManager")                       \</span></span><br><span class="line">    <span class="keyword">const</span> ::android::String16 IMediaPlayerService::descriptor(<span class="string">"android.os.IServiceManager"</span>);           <span class="string">\</span></span><br><span class="line">    <span class="keyword">const</span> ::android::String16&amp;                                          <span class="string">\</span></span><br><span class="line">            IMediaPlayerService::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> IMediaPlayerService::descriptor;                                <span class="string">\</span></span><br><span class="line">    &#125;                                                                   <span class="string">\</span></span><br><span class="line">    ::android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(              <span class="string">\</span></span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               <span class="string">\</span></span><br><span class="line">    &#123;                                                                   <span class="string">\</span></span><br><span class="line">        ::android::sp&lt;IMediaPlayerService&gt; intr;                               <span class="string">\</span></span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              <span class="string">\</span></span><br><span class="line">            intr = static_cast&lt;IMediaPlayerService*&gt;(                          <span class="string">\</span></span><br><span class="line">                obj-&gt;queryLocalInterface(                               <span class="string">\</span></span><br><span class="line">                        IMediaPlayerService::descriptor).get());               <span class="string">\</span></span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         <span class="string">\</span></span><br><span class="line">                <span class="comment">/* (3.1) 根据BpBinder对象，创建一个BpMediaPlayerService对象 */</span></span><br><span class="line">                intr = <span class="keyword">new</span> BpMediaPlayerService(obj);                          <span class="string">\</span></span><br><span class="line">            &#125;                                                           <span class="string">\</span></span><br><span class="line">        &#125;                                                               <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> intr;                                                    <span class="string">\</span></span><br><span class="line">    &#125;                                                                   <span class="string">\</span></span><br><span class="line">    IMediaPlayerService::IMediaPlayerService() &#123; &#125;                                    <span class="string">\</span></span><br><span class="line">    IMediaPlayerService::~IMediaPlayerService() &#123; &#125;                                   <span class="string">\</span></span><br></pre></td></tr></table></figure><p>BpMediaPlayerService的定义为：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">BpMediaPlayerService: <span class="symbol">public</span></span> <span class="symbol">BpInterface</span>&lt;<span class="symbol">IMediaPlayerService</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> BpMediaPlayerService(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IMediaPlayerService&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaMetadataRetriever&gt; createMetadataRetriever()</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(CREATE_METADATA_RETRIEVER, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>erface_cast&lt;IMediaMetadataRetriever&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是借用老罗的一张图总结service_client类之间复杂的关系：</p><p><img src="binder_class_client.jpg" alt="binder_class_client"></p><h2 id="4-5、service-thread管理"><a href="#4-5、service-thread管理" class="headerlink" title="4.5、service thread管理"></a>4.5、service thread管理</h2><p>binder service初始会启动2个main线程来提供服务，在等待service服务过多的情况下会动态的增加binder线程的数量，但是目前没有实现动态减少binder线程可能觉得cache着更好。</p><p>service一般默认最大考验开启15个线程，这个数值也可以通过ioctl的BINDER_SET_MAX_THREADS命令来修改。</p><p>动态增加binder线程的动作是binder驱动完成的，因为驱动可以看到service进程整个的阻塞情况。</p><p>具体驱动代码binder.c：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *<span class="keyword">proc</span>,</span><br><span class="line"><span class="title">      struct</span> binder_thread *thread,</span><br><span class="line"><span class="title">      binder_uintptr_t</span> binder_buffer,<span class="title"> size_t</span> size,</span><br><span class="line"><span class="title">      binder_size_t</span> *consumed,<span class="title"> int</span> non_block)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">proc</span>-&gt;requested_threads == 0 &amp;&amp;</span><br><span class="line"><span class="title">    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads)</span> &amp;&amp;</span><br><span class="line"><span class="title">    proc-&gt;requested_threads_started</span> &lt;<span class="title"> proc-&gt;max_threads</span> &amp;&amp;</span><br><span class="line">    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line"><span class="title">     BINDER_LOOPER_STATE_ENTERED))</span> /*<span class="title"> the</span> user-space<span class="title"> code</span> fails<span class="title"> to</span> */</span><br><span class="line">     /*spawn<span class="title"> a</span> new<span class="title"> thread</span> if<span class="title"> we</span> leave<span class="title"> this</span> out */) &#123;</span><br><span class="line"><span class="keyword">proc</span>-&gt;requested_threads++;</span><br><span class="line"><span class="title">binder_inner_proc_unlock(proc);</span></span><br><span class="line"><span class="title"></span><span class="title">binder_debug(BINDER_DEBUG_THREADS,</span></span><br><span class="line"><span class="title"></span>     "%d:%d<span class="title"> BR_SPAWN_LOOPER\n",</span></span><br><span class="line"><span class="title"></span><span class="title">     proc-&gt;pid,</span> thread-&gt;pid);</span><br><span class="line"></span><br><span class="line">/* (1) 判断阻塞的情况下发送BR_SPAWN_LOOPER命令，通知native增加接收线程 */</span><br><span class="line"><span class="title">if</span> (put_user(BR_SPAWN_LOOPER, (uint32_t<span class="title"> __user</span> *)buffer))</span><br><span class="line"><span class="title">return</span> -EFAULT;</span><br><span class="line"><span class="title">binder_stat_br(proc,</span> thread,<span class="title"> BR_SPAWN_LOOPER);</span></span><br><span class="line"><span class="title"></span>&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frameworks/native/libs/binder/IPCThreadState.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::spawn<span class="constructor">PooledThread(<span class="params">bool</span> <span class="params">isMain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = make<span class="constructor">BinderThreadName()</span>;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, <span class="params">name</span>.<span class="params">string</span>()</span>);</span><br><span class="line">        <span class="comment">/* (1.1) 创建新的binder接收线程 */</span></span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="constructor">PoolThread(<span class="params">isMain</span>)</span>;</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6、死亡通知-DeathRecipient"><a href="#4-6、死亡通知-DeathRecipient" class="headerlink" title="4.6、死亡通知(DeathRecipient)"></a>4.6、死亡通知(DeathRecipient)</h2><p>可以使用BC_REQUEST_DEATH_NOTIFICATION注册死亡通知，在server端正常或者异常死亡的情况下都能收到通知。</p><p>在server端进程正常或者异常退出时，会关闭进程所有打开的文件句柄：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span><span class="constructor">_exit()</span></span><br><span class="line">↓</span><br><span class="line">exit<span class="constructor">_files()</span></span><br><span class="line">↓</span><br><span class="line">put<span class="constructor">_files_struct()</span></span><br><span class="line">↓</span><br><span class="line">static <span class="keyword">struct</span> fdtable *close<span class="constructor">_files(<span class="params">struct</span> <span class="params">files_struct</span> <span class="operator">*</span> <span class="params">files</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It is safe to dereference the fd table without RCU or</span></span><br><span class="line"><span class="comment"> * -&gt;file_lock because this is the last reference to the</span></span><br><span class="line"><span class="comment"> * files structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> fdtable *fdt = rcu<span class="constructor">_dereference_raw(<span class="params">files</span>-&gt;<span class="params">fdt</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">unsigned long set;</span><br><span class="line">i = j<span class="operator"> * </span>BITS_PER_LONG;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= fdt-&gt;max_fds)</span><br><span class="line">break;</span><br><span class="line">set = fdt-&gt;open_fds<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line"><span class="keyword">while</span> (set) &#123;</span><br><span class="line"><span class="keyword">if</span> (set &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">struct</span> file<span class="operator"> * </span>file = xchg(&amp;fdt-&gt;fd<span class="literal">[<span class="identifier">i</span>]</span>, NULL);</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">filp<span class="constructor">_close(<span class="params">file</span>, <span class="params">files</span>)</span>;</span><br><span class="line">cond<span class="constructor">_resched_rcu_qs()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">set &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return fdt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到binder fd的release函数，调用到死亡通知的回调:</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int binder_release(struct inode *nodp, struct <span class="keyword">file</span> *filp)</span><br><span class="line">&#123;</span><br><span class="line">struct binder_proc *<span class="keyword">proc</span> =<span class="title"> filp-&gt;private_data;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title"></span>debugfs_remove(<span class="keyword">proc</span>-&gt;debugfs_entry);</span><br><span class="line"><span class="title">binder_defer_work(proc,</span> BINDER_DEFERRED_RELEASE);</span><br><span class="line"></span><br><span class="line"><span class="title">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">static<span class="title"> void</span></span><br><span class="line"><span class="title">binder_defer_work(struct</span> binder_proc *<span class="keyword">proc</span>,<span class="title"> enum</span> binder_deferred_state<span class="title"> defer)</span></span><br><span class="line"><span class="title"></span>&#123;</span><br><span class="line">mutex_lock(&amp;binder_deferred_lock);</span><br><span class="line"><span class="keyword">proc</span>-&gt;deferred_work |=<span class="title"> defer;</span></span><br><span class="line"><span class="title"></span>if (hlist_unhashed(&amp;<span class="keyword">proc</span>-&gt;deferred_work_node)) &#123;</span><br><span class="line">hlist_add_head(&amp;<span class="keyword">proc</span>-&gt;deferred_work_node,</span><br><span class="line">&amp;binder_deferred_list);</span><br><span class="line"><span class="title">schedule_work(&amp;binder_deferred_work);</span></span><br><span class="line"><span class="title"></span>&#125;</span><br><span class="line"><span class="title">mutex_unlock(&amp;binder_deferred_lock);</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="5、java实现"><a href="#5、java实现" class="headerlink" title="5、java实现"></a>5、java实现</h1><p>略</p><h1 id="6、AIDL-Android-Interface-Definition-Language"><a href="#6、AIDL-Android-Interface-Definition-Language" class="headerlink" title="6、AIDL(Android Interface Definition Language)"></a>6、AIDL(Android Interface Definition Language)</h1><p>略</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://blog.csdn.net/Luoshengyang/article/details/6629298" target="_blank" rel="noopener">1、Android系统进程间通信（IPC）机制 罗升阳</a><br><a href="http://light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%80%85%5BParcel%5D/" target="_blank" rel="noopener">2、Android Binder 分析</a><br><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">3、Android Bander设计与实现</a><br><a href="https://blog.csdn.net/chenying126/article/details/78989413#_Toc503017553" target="_blank" rel="noopener">4、Binder实现原理分析</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="noopener">5、一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a>  </p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel 空间加载用户空间fw实现原理</title>
      <link href="/2018/11/22//implementation-of-loading-fw-from-userspace.html/"/>
      <url>/2018/11/22//implementation-of-loading-fw-from-userspace.html/</url>
      
        <content type="html"><![CDATA[<p>随着手机外围器件的集成度和复杂度越来越高, 单纯的设置相关寄存器已经无法使得器件可以正常的工作. 在一般情况下，需要将一个特定的fw下载到器件中, 确保器件可以正常稳定的运行, 比如：camera ois，camera actuator， TP等等. 一般情况下, 有以下三种方案:</p><ul><li>直接将fw data转化为特定的数组，编码在驱动代码中.</li><li>将fw data烧录到一个分区中，需要的时候从分区中load进来.</li><li>将fw打包到某个镜像中，如vendor，system等等，需要的时候从用户空间中load到kernel空间中.</li></ul><p>对于方案1, 直接将其硬编码在驱动代码中, 会造成kernel镜像size变大, 有可能造成镜像超限, 导致kernel启动失败; 并且调试也不方便, 每次修改fw都需要重新编译内核.</p><p>对于方案2, 需要实现预留好空间, 某些时候可能无法满足; 并且一般重新烧录fw, 一般机器需要进入特定的模式, 不利于在线调试.</p><p>对于方案3,  能够有效的避免前两种方案的不足, 在驱动中应用比较广泛, 也是本文叙述的主题.</p><p>下文主要从编程步骤出发, 通过调用的接口来具体分析其中实现的机制.</p><h3 id="一-编程步骤"><a href="#一-编程步骤" class="headerlink" title="一 编程步骤"></a>一 编程步骤</h3><p>linux内核为方案3提供了完整的解决方案, 驱动开发起来也相当的方便, 具体的步骤如下:</p><ol><li>在编译的时候, 将fw打包到具体镜像中. 对于android系统，可以将fw放在/etc/firmware, /vendor/firmware, /firmware/image这几个目录. 当上层服务ueventd接收到kernel上报的请求fw的uevent事件, 会依次搜索这几个目录, 查找对应名称的fw, 并通过节点data传递给kernel.</li><li>由于内核已经封装好了接口, 驱动代码比较简单, 具体如下:</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;linux/firmware.h&gt;</span></span><br><span class="line"> <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">xxx_func() &#123;</span><br><span class="line">const struct<span class="built_in"> firmware </span><span class="number">*f</span><span class="attribute">w</span>=<span class="literal">NULL</span>;`</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">request_firmware(&amp;fw, fw_name, dev);</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">release_firmware();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上面的步骤可知, 内核已经把接口封装的相当简洁, 使用简单的接口就可以完成load 用户空间的fw任务. 当然kernel还为我们提供了其他类型接口, 主要是提供了一些其他的特性, 满足特定条件下load 用户空间的fw. 例如, 如果在原子上下文load fw，则只能用request_firmware_nowait()接口, 该接口不会导致进程睡眠. 但是所有的这些接口, 其工作原理是一样, 因此下文将以request_firmware()为入口分析load用户空间fw的原理.</p><h3 id="二-实现原理分析"><a href="#二-实现原理分析" class="headerlink" title="二 实现原理分析"></a>二 实现原理分析</h3><h4 id="2-1-相关结构体介绍"><a href="#2-1-相关结构体介绍" class="headerlink" title="2.1 相关结构体介绍"></a>2.1 相关结构体介绍</h4><p>理解代码最好的入口是熟悉代码使用的数据结构, 理解了代码使用的数据结构, 就基本上可以对代码的实现原理有一个初步的认识. 所以下面熟悉一下相关的数据结构.</p><ul><li>firmware 结构体</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">路径:include/linux/firmware.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">firmware</span> &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">const</span> u8 *data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* firmware loader private fields */</span></span><br><span class="line">        <span class="keyword">void</span> *priv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体主要用于向驱动导出load 到内核的fw信息, 成员含义如下:<br>size: firmware 数据的大小.<br>data: firmware数据.<br>pages: 指向fw data存储的物理页面.<br>priv: 私有数据指针.</p><ul><li>builtin_fw 结构体</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">路径:include/linux/firmware.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">builtin_fw</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构主要用于描述编译到内核builtin_fw段的fw, 成员含义如下:<br>name: firmware 数据的名称.<br>data: 指向firmware数据的指针.<br>size: firmware的大小.</p><ul><li>firmware_buf结构体</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/base/firmware_class.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">firmware_buf</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">completion</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">firmware_cache</span> *<span class="title">fwc</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> status;</span><br><span class="line">        <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FW_LOADER_USER_HELPER</span></span><br><span class="line">        <span class="keyword">bool</span> is_paged_buf;</span><br><span class="line">        <span class="keyword">bool</span> need_uevent;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nr_pages;</span><br><span class="line">        <span class="keyword">int</span> page_array_size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pending_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *fw_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体主要用于存储fw data,以及一些控制状态等等. 部分重要的成员解释如下:<br>completion: 完成量,用于在load fw完成时, 唤醒等待的进程.<br>fwc: 指向全局的fw_cache, 该结构保存了已经load 的fw的相关信息.<br>status: 保存当前的状态.<br>data: 指向保存fw data的kernel虚拟地址.<br>size: fw 的大小.<br>pages: 指向存储fw data的物理页.<br>page_array_size: 分配的物理页的数目.<br>fw_id: fw 的名称.</p><h4 id="2-2-实现原理分析"><a href="#2-2-实现原理分析" class="headerlink" title="2.2 实现原理分析"></a>2.2 实现原理分析</h4><p>request_firmware()和request_firmware_nowait()等接口都是_request_firmware()的一个前端, 仅仅只是传进的参数不一样而已, 因此基于分析request_firmware()的实现来探讨其实现原理, request_firmware()如下:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/<span class="keyword">base</span>/firmware_class.c</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">request_firmware(<span class="keyword">const</span> <span class="keyword">struct</span> firmware **firmware_p, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line"> <span class="keyword">struct</span> device *device)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Need to pin this module until return */</span></span><br><span class="line">__module_get(THIS_MODULE);</span><br><span class="line">ret = _request_firmware(firmware_p, name, device, NULL, <span class="number">0</span>,</span><br><span class="line">FW_OPT_UEVENT | FW_OPT_FALLBACK);</span><br><span class="line">module_put(THIS_MODULE);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看_request_firmware()函数的实现:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/base/firmware_class.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_request_firmware(<span class="keyword">const</span> struct firmware **firmware_p, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                  struct device *device, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span><br><span class="line">                  <span class="keyword">unsigned</span> <span class="keyword">int</span> opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        ret = _request_firmware_prepare(&amp;fw, name, device, buf, <span class="built_in">size</span>,</span><br><span class="line">                                        opt_flags);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) <span class="comment">/* error or already assigned */</span></span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">         ret = fw_get_filesystem_firmware(device, fw-&gt;priv);</span><br><span class="line">         <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!(opt_flags &amp; FW_OPT_NO_WARN))</span><br><span class="line">                         dev_dbg(device,</span><br><span class="line">                                  <span class="string">"Firmware %s was not found in kernel paths. rc:%d\n"</span>,</span><br><span class="line">                                  name, ret);</span><br><span class="line">                 <span class="keyword">if</span> (opt_flags &amp; FW_OPT_USERHELPER) &#123;</span><br><span class="line">                         dev_err(device, <span class="string">"[%s]Falling back to user helper\n"</span>, __func__);</span><br><span class="line">                         ret = fw_load_from_user_helper(fw, name, device,</span><br><span class="line">                                                        opt_flags, timeout);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line">        ret = assign_firmware_buf(fw, device, opt_flags);</span><br><span class="line">......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在该函数中，会依次从4个地方尝试load 相应的fw, 具体如下:</p><ul><li>从内核中相应的段中查找是否有符合要求的firmware.</li><li>从cache中查找是否有上次load相应的还没有换出firmware.</li><li>直接利用内核中文件接口中读取相应的firmware.</li><li>利用uevent接口load相应的firmware.</li></ul><p>其中, 对于第1种和第2种情况是在_request_firmware_prepare()函数中完成的; 第3种情况是在_request_firmware_prepare()函数中完成的; 第4种情况是在fw_load_from_user_helper()函数中完成的.</p><p>对于第1种情况, 其具体的实现在fw_get_builtin_firmware()函数中, 原理是通过遍历builtin_fw段的firmware, 并比较firmware的name是否相同, 如果相同, 表示匹配上,则将firmware的size和data赋值给驱动传过来的firmware结构体指针, request_firmware就完成load firmware功能, 具体如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">路径:drivers/base/firmware_class.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_request_firmware_prepare(struct firmware **firmware_p, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                          struct device *device, <span class="keyword">void</span> *dbuf, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span><br><span class="line">                          <span class="keyword">unsigned</span> <span class="keyword">int</span> opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">.......</span><br><span class="line">        *firmware_p = firmware = kzalloc(<span class="keyword">sizeof</span>(*firmware), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!firmware) &#123;</span><br><span class="line">                dev_err(device, <span class="string">"%s: kmalloc(struct firmware) failed\n"</span>,</span><br><span class="line">                        __func__);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fw_get_builtin_firmware(firmware, name, dbuf, <span class="built_in">size</span>)) &#123;</span><br><span class="line">                dev_dbg(device, <span class="string">"using built-in %s\n"</span>, name);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* assigned */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">路径:drivers/base/firmware_class.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">fw_get_builtin_firmware</span><span class="params">(struct firmware *fw, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">builtin_fw</span> *<span class="title">b_fw</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, b_fw-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">                        fw-&gt;<span class="built_in">size</span> = b_fw-&gt;<span class="built_in">size</span>;</span><br><span class="line">                        fw-&gt;data = b_fw-&gt;data;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (buf &amp;&amp; fw-&gt;<span class="built_in">size</span> &lt;= <span class="built_in">size</span>)</span><br><span class="line">                                <span class="built_in">memcpy</span>(buf, fw-&gt;data, fw-&gt;<span class="built_in">size</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第2种情况, 其具体的实现在fw_lookup_and_allocate_buf()函数中, 匹配原理和第1种情况相同, 只不过查找实在全局变量fw_cache的链表上查找. fw_cache的 head链表上保存了以前load过的fw的信息,比如name, data, size等等. 其中在函数sync_cached_firmware_buf()中主要检查fw是否已经load到内核空间, 如果没有, 则等待; 否在就调用fw_set_page_data(), 将fw相关的信息赋值到驱动的firmware结构体指针, 具体如下:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">路径:drivers/<span class="keyword">base</span>/firmware_class.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_request_firmware_prepare(<span class="keyword">struct</span> firmware **firmware_p, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                          <span class="keyword">struct</span> device *device, <span class="keyword">void</span> *dbuf, size_t size,</span><br><span class="line">                          unsigned <span class="keyword">int</span> opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">        ret = fw_lookup_and_allocate_buf(name, &amp;fw_cache, &amp;buf, dbuf, size,</span><br><span class="line">                                        opt_flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * bind with 'buf' now to avoid warning in failure path</span></span><br><span class="line"><span class="comment">         * of requesting firmware.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        firmware-&gt;priv = buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = sync_cached_firmware_buf(buf);</span><br><span class="line">                <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                        fw_set_page_data(buf, firmware);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* assigned */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">路径:drivers/<span class="keyword">base</span>/firmware_class.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fw_lookup_and_allocate_buf</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *fw_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">struct</span> firmware_cache *fwc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">struct</span> firmware_buf **buf, <span class="keyword">void</span> *dbuf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      size_t size, unsigned <span class="keyword">int</span> opt_flags</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> firmware_buf *tmp;</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;fwc-&gt;<span class="keyword">lock</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(opt_flags &amp; FW_OPT_NOCACHE)) &#123;</span><br><span class="line">                tmp = __fw_lookup_buf(fw_name);</span><br><span class="line">                <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                        kref_get(&amp;tmp-&gt;<span class="keyword">ref</span>);</span><br><span class="line">                        spin_unlock(&amp;fwc-&gt;<span class="keyword">lock</span>);</span><br><span class="line">                        *buf = tmp;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第3种情况, 依据内核预先定义好的路径fw_path调用内核文件读写接口kernel_read_file_from_path load入相应的fw, 在fw_finish_direct_load()函数中做了一些load fw后的清理工作,比如设置完成标志等等.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">路径:drivers/base/firmware_class.c</span><br><span class="line"><span class="keyword">static</span> int</span><br><span class="line">fw_get_filesystem_firmware(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *device, <span class="class"><span class="keyword">struct</span> <span class="title">firmware_buf</span></span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(fw_path); i++) &#123;</span><br><span class="line">                <span class="comment">/* skip the unset customized path */</span></span><br><span class="line">                <span class="keyword">if</span> (!fw_path[i][<span class="number">0</span>])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                len = snprintf(path, PATH_MAX, <span class="string">"%s/%s"</span>,</span><br><span class="line">                               fw_path[i], buf-&gt;fw_id);</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= PATH_MAX) &#123;</span><br><span class="line">                        rc = -ENAMETOOLONG;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 buf-&gt;size = <span class="number">0</span>;</span><br><span class="line">                 rc = kernel_read_file_from_path(path, &amp;buf-&gt;data, &amp;size, msize,</span><br><span class="line">                                                 id);</span><br><span class="line">                 <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (rc == -ENOENT)</span><br><span class="line">                                 dev_dbg(device, <span class="string">"loading %s failed with error %d\n"</span>,</span><br><span class="line">                                          path, rc);</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                                 dev_warn(device, <span class="string">"loading %s failed with error %d\n"</span>,</span><br><span class="line">                                          path, rc);</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dev_dbg(device, <span class="string">"direct-loading %s\n"</span>, buf-&gt;fw_id);</span><br><span class="line">                 buf-&gt;size = size;</span><br><span class="line">                 fw_finish_direct_load(device, buf);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>fw_path具体的定义如下, 其中fw_path_para主要用于用户传递定制的路径.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> fw_path[] = &#123;</span><br><span class="line">        fw_path_para,</span><br><span class="line">        <span class="string">"/data/vendor/vibrator"</span>,</span><br><span class="line">        <span class="string">"/lib/firmware/updates/"</span> UTS_RELEASE,</span><br><span class="line">        <span class="string">"/lib/firmware/updates"</span>,</span><br><span class="line">        <span class="string">"/lib/firmware/"</span> UTS_RELEASE,</span><br><span class="line">        <span class="string">"/lib/firmware"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当在前三种情况下无法找到对应的fw时,就会进入第4种情况进行查找, 其工作在函数为fw_load_from_user_helper()种实现, 具体如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int fw_load_from_user_helper(<span class="class"><span class="keyword">struct</span> <span class="title">firmware</span></span> *firmware,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="built_in">char</span> *name, <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *device,</span><br><span class="line">                                    unsigned int opt_flags, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">firmware_priv</span></span> *fw_priv;</span><br><span class="line"></span><br><span class="line">        fw_priv = fw_create_instance(firmware, name, device, opt_flags);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(fw_priv))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(fw_priv);</span><br><span class="line"></span><br><span class="line">        fw_priv-&gt;buf = firmware-&gt;<span class="keyword">priv</span>;</span><br><span class="line">        <span class="keyword">return</span> _request_firmware_load(fw_priv, opt_flags, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数 fw_create_instance() 主要进行了一些设备的初始化工作, 如设备所属的class, groups等等. 具体如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static struct firmware_priv *</span><br><span class="line">fw_create_instance(struct<span class="built_in"> firmware </span><span class="number">*f</span>irmware, const char <span class="number">*f</span>w_name,</span><br><span class="line">                   struct device <span class="number">*de</span>vice, unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">        struct firmware_priv <span class="number">*f</span>w_priv;</span><br><span class="line">        struct device <span class="number">*f</span>_dev;</span><br><span class="line"></span><br><span class="line">        fw_priv = kzalloc(sizeof(<span class="number">*f</span>w_priv), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!fw_priv) &#123;</span><br><span class="line">                fw_priv = ERR_PTR(-ENOMEM);</span><br><span class="line">                goto exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw_priv-&gt;nowait = !!(opt_flags &amp; FW_OPT_NOWAIT);</span><br><span class="line">        fw_priv-&gt;fw = firmware;</span><br><span class="line">        f_dev = &amp;fw_priv-&gt;dev;</span><br><span class="line"></span><br><span class="line">        device_initialize(f_dev);</span><br><span class="line">        dev_set_name(f_dev, <span class="string">"%s"</span>, fw_name);</span><br><span class="line">        f_dev-&gt;parent = device;</span><br><span class="line">        f_dev-&gt;class = &amp;firmware_class;</span><br><span class="line">        f_dev-&gt;groups = fw_dev_attr_groups;</span><br><span class="line">exit:</span><br><span class="line">        return fw_priv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中重点看一下 fw_dev_attr_groups属性集合, 由linux 设备驱动框架原理,当该设备加入到系统中时,会在该设备下生成两个节点data和loading, 后面讲到这两个节点的用处.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/base/firmware_class.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">fw_dev_attr_groups</span>[] = &#123;</span></span><br><span class="line">        &amp;fw_dev_attr_group,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">fw_dev_attr_group</span> = &#123;</span></span><br><span class="line">        .attrs = fw_dev_attrs,</span><br><span class="line">        .bin_attrs = fw_dev_bin_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> *<span class="title">fw_dev_bin_attrs</span>[] = &#123;</span></span><br><span class="line">        &amp;firmware_attr_data,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">fw_dev_attrs</span>[] = &#123;</span></span><br><span class="line">        &amp;dev_attr_loading.attr,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">firmware_attr_data</span> = &#123;</span></span><br><span class="line">        .attr = &#123; .name = <span class="string">"data"</span>, .mode = <span class="number">0644</span> &#125;,</span><br><span class="line">        .<span class="built_in">size</span> = <span class="number">0</span>,</span><br><span class="line">        .<span class="built_in">read</span> = firmware_data_read,</span><br><span class="line">        .<span class="built_in">write</span> = firmware_data_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(loading, <span class="number">0644</span>, firmware_loading_show, firmware_loading_store)</span></span>;</span><br></pre></td></tr></table></figure><p>在_request_firmware_load()函数中, 首先调用device_add()函数将设备注册到系统中, 接着调用kobject_uevent()函数向用户空间上报uevent事件, 最后调用wait_for_completion_killable_timeout()函数等待load fw完成.<br>loading节点写函数如下:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/base/firmware_class.c</span><br><span class="line"> static ssize_t firmware_loading_store(struct device *dev,</span><br><span class="line">                                       struct device_attribute *attr,</span><br><span class="line">                                       const char *buf, size_t count)</span><br><span class="line"> &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">         switch (loading) &#123;</span><br><span class="line">         case <span class="number">1</span>:</span><br><span class="line">                 <span class="comment">/* discarding any previous partial load */</span></span><br><span class="line">                 <span class="function"><span class="title">if</span> (!test_bit(FW_STATUS_DONE, &amp;fw_buf-&gt;</span>status)) &#123;</span><br><span class="line">                         <span class="function"><span class="title">for</span> (i = 0; i &lt; fw_buf-&gt;</span>nr_pages; i++)</span><br><span class="line">                                 __<span class="function"><span class="title">free_page</span>(fw_buf-&gt;</span>pages[i]);</span><br><span class="line">                         <span class="function"><span class="title">vfree</span>(fw_buf-&gt;</span>pages);</span><br><span class="line">                         <span class="function"><span class="title">fw_buf</span>-&gt;</span>pages = NULL;</span><br><span class="line">                         <span class="function"><span class="title">fw_buf</span>-&gt;</span>page_array_size = <span class="number">0</span>;</span><br><span class="line">                         <span class="function"><span class="title">fw_buf</span>-&gt;</span>nr_pages = <span class="number">0</span>;</span><br><span class="line">                         <span class="function"><span class="title">set_bit</span>(FW_STATUS_LOADING, &amp;fw_buf-&gt;</span>status);</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">         case <span class="number">0</span>:</span><br><span class="line">                 <span class="function"><span class="title">if</span> (test_bit(FW_STATUS_LOADING, &amp;fw_buf-&gt;</span>status)) &#123;</span><br><span class="line">                         int rc;</span><br><span class="line"></span><br><span class="line">                         <span class="function"><span class="title">set_bit</span>(FW_STATUS_DONE, &amp;fw_buf-&gt;</span>status);</span><br><span class="line">                         <span class="function"><span class="title">clear_bit</span>(FW_STATUS_LOADING, &amp;fw_buf-&gt;</span>status);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">                         rc = fw_map_pages_buf(fw_buf);</span><br><span class="line">......</span><br><span class="line">                         <span class="function"><span class="title">complete_all</span>(&amp;fw_buf-&gt;</span>completion);</span><br><span class="line">                         break;</span><br><span class="line">                 &#125;</span><br><span class="line">......</span><br><span class="line">         &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序将fw写入到data节点时,  如果buf-&gt;data已经映射到kernel虚拟地址空间,则调用firmware_rw_buf()直接将fw data copy到buf-&gt;data中; 如果buf-&gt;data为NULL, 则首先调用fw_realloc_buf()函数, 分配物理页, 然后调用firmware_rw()函数将fw data 拷贝到分配的物理页中.<br>data节点写函数如下:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/base/firmware_class.c</span><br><span class="line">static ssize_t firmware_data_write(struct <span class="keyword">file</span> *filp, struct kobject *kobj,</span><br><span class="line">                                   struct bin_attribute *bin_attr,</span><br><span class="line">                                   <span class="built_in">char</span> *buffer, loff_t offset, size_t <span class="built_in">count</span>)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf-&gt;<span class="keyword">data</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (offset + <span class="built_in">count</span> &gt; buf-&gt;allocated_size) &#123;</span><br><span class="line">                        retval = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                firmware_rw_buf(buf, buffer, offset, <span class="built_in">count</span>, false);</span><br><span class="line">                retval = <span class="built_in">count</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retval = fw_realloc_buffer(fw_priv, offset + <span class="built_in">count</span>);</span><br><span class="line">                <span class="keyword">if</span> (retval)</span><br><span class="line">                        <span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">                retval = <span class="built_in">count</span>;</span><br><span class="line">                firmware_rw(buf, buffer, offset, <span class="built_in">count</span>, false);</span><br><span class="line">        &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序向该节点写入1时, 如果status的状态不是FW_STATUS_DONE, 则进行一些初始化工作, 为后续load fw做准备工作,  并将status状态设备为FW_STATUS_LOADING.</p><p>当应用程序向该节点写入0时, 设置status的状态为FW_STATUS_DONE, 并调用fw_map_pages_buf函数将保存fw data的pages映射到kernel虚拟地址空间, 变为内核可操作的数据. 然后调用complete_all 唤醒等待的进程. 进程唤醒后,会执行assign_firmware_buf()函数, 将保存在firmware_buf结构中fw信息赋值给request_firmware()的第一个参数, 从而完成fw 的load工作.</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">路径:driver/base/firmware_class.c</span><br><span class="line">static int assign_firmware_buf(struct firmware *fw, struct device *device,</span><br><span class="line">                               unsigned int opt_flags)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/* pass the pages buffer to driver at the last minute */</span></span><br><span class="line">        fw_set_page_data(buf, fw);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">static void fw_set_page_data(struct firmware_buf *buf, struct firmware *fw)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="title">fw</span>-&gt;</span>priv = buf;</span><br><span class="line">#ifdef CONFIG_FW_LOADER_USER_HELPER</span><br><span class="line">        <span class="function"><span class="title">fw</span>-&gt;</span><span class="function"><span class="title">pages</span> = buf-&gt;</span>pages;</span><br><span class="line">#endif</span><br><span class="line">        <span class="function"><span class="title">fw</span>-&gt;</span><span class="function"><span class="title">size</span> = buf-&gt;</span>size;</span><br><span class="line">        <span class="function"><span class="title">fw</span>-&gt;</span><span class="function"><span class="title">data</span> = buf-&gt;</span><span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">        pr_debug(<span class="string">"%s: fw-%s buf=%p data=%p size=%u\n"</span>,</span><br><span class="line">                 __<span class="function"><span class="title">func__</span>, buf-&gt;</span><span class="function"><span class="title">fw_id</span>, buf, buf-&gt;</span><span class="keyword">data</span>,</span><br><span class="line">                 (<span class="function"><span class="title">unsigned</span> int)buf-&gt;</span>size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-结束语"><a href="#三-结束语" class="headerlink" title="三 结束语"></a>三 结束语</h3><p>本文以request_firmware()为入口详细探讨了内核load fw的实现原理, 以期大家对这个模块有一个全面的认识. 欢迎大家批评指正, 谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firmware </tag>
            
            <tag> uevent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android FBE</title>
      <link href="/2018/07/11//android-p-fbe.html/"/>
      <url>/2018/07/11//android-p-fbe.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-FBE"><a href="#Android-FBE" class="headerlink" title="Android FBE"></a>Android FBE</h2><h3 id="1-FBE-简介"><a href="#1-FBE-简介" class="headerlink" title="1. FBE 简介"></a>1. FBE 简介</h3><ul><li>名称: FBE, File-Based Encryption,基于文件的加密</li><li>凭据加密 (CE) 存储空间：这是默认存储位置，只有在用户解锁设备后才可用。设备加密 (DE) 存储空间：在直接启动模式期间以及用户解锁设备后均可用。</li><li>开启 FBE 方式,在相关的 fstab 文件中添加相关的代码:</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/bootdevice/by-name/userdata                  /data              ext4    noatime,nosuid,nodev,<span class="attribute">barrier</span>=1,noauto_da_alloc,discard wait,check,resize,*<span class="number">*f</span><span class="attribute">ileencryption</span>=aes-256-xts**,quota</span><br></pre></td></tr></table></figure><ul><li>一些概念性内容这里不再赘述，如有需要自行阅读 <a href="https://source.android.com/security/encryption/file-based" target="_blank" rel="noopener">Goole FBE</a></li></ul><h3 id="2-FBE-流程分析"><a href="#2-FBE-流程分析" class="headerlink" title="2. FBE 流程分析"></a>2. FBE 流程分析</h3><h4 id="2-1-开机过程中-加密前的准备"><a href="#2-1-开机过程中-加密前的准备" class="headerlink" title="2.1 开机过程中,加密前的准备"></a>2.1 开机过程中,加密前的准备</h4><ul><li>init.rc 中加入相关的代码,用于根据 fstab 文件中进行相关的挂载操作</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="title">fs</span></span><br><span class="line">    <span class="built_in">wait</span> /dev/block/bootdevice</span><br><span class="line">    <span class="built_in">write</span> /proc/sys/vm/swappiness <span class="number">100</span></span><br><span class="line">    mount_all fstab.qcom</span><br></pre></td></tr></table></figure><ul><li>看完 init.rc 中,当然是查看 init 进程中如何解析 init.rc ,代码在 <code>system/core/init/builtins.cpp</code> 中:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> BuiltinFunctionMap::Map&amp; <span class="title">BuiltinFunctionMap::map</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">1</span>,     kMax, do_mount_all&#125;&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mount_all</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*mount_fstab 会 fork 出一个子进程调用 fs_mgr_read_fstab 以及 fs_mgr_mount_all 函数,前一个函数用于读取 fstab 文件,后者用于 mount,之后重点分析 fs_mgr_mount_all函数*/</span></span><br><span class="line">    <span class="keyword">int</span> ret =  mount_fstab(fstabfile, mount_mode);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (queue_event) &#123;</span><br><span class="line">        <span class="comment">/* queue_fs_event will queue event based on mount_fstab return code</span></span><br><span class="line"><span class="comment">         * and return processed return code*/</span></span><br><span class="line">        ret = queue_fs_event(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在来看一下 fs_mgr_mount_all 函数,代码路径在<code>system/core/fs_mgr/fs_mgr.cpp</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fs_mgr_mount_all</span><span class="params">(struct fstab *fstab, <span class="keyword">int</span> mount_mode)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> encryptable = FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fstab-&gt;num_entries; i++) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">int</span> last_idx_inspected;</span><br><span class="line">        <span class="keyword">int</span> top_idx = i;</span><br><span class="line"></span><br><span class="line">        mret = mount_with_alternatives(fstab, i, &amp;last_idx_inspected, &amp;attempted_idx);</span><br><span class="line">        i = last_idx_inspected;</span><br><span class="line">        mount_errno = errno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Deal with encryptability. */</span></span><br><span class="line">        <span class="keyword">if</span> (!mret) &#123;</span><br><span class="line">            <span class="keyword">int</span> status = handle_encryptable(&amp;fstab-&gt;recs[attempted_idx]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status == FS_MGR_MNTALL_FAIL) &#123;</span><br><span class="line">                <span class="comment">/* Fatal error - no point continuing */</span></span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">                    <span class="comment">// Log and continue</span></span><br><span class="line">                    LERROR &lt;&lt; <span class="string">"Only one encryptable/encrypted partition supported"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//结果赋值给 encryptable</span></span><br><span class="line">                encryptable = status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Success!  Go get the next one */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        ......</span><br><span class="line">    <span class="comment">/*此处返回给父进程,即 queue_fs_event 接收返回值进行之后的处理*/</span></span><br><span class="line">    <span class="keyword">if</span> (error_count) &#123;</span><br><span class="line">        <span class="keyword">return</span> FS_MGR_MNTALL_FAIL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encryptable;</span><br><span class="line">    &#125;</span><br><span class="line">- [ ] &#125;</span><br></pre></td></tr></table></figure><ul><li>先来看一下 queue_fs_event 函数,它会根据 mount_fstab 的返回值结果进行不同的操作,而 mount_fstab 会返回 FS_MGR_MNTALL_DEV_FILE_ENCRYPTED 给 queue_fs_event，然后调用 e4crypt_install_keyring 函数用于安装 e4crypt keyring，这个用于存放文件加密的 key，之后设置相关的属性，然后触发 nonencrypted 这个 trigger 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_fs_event</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = code;</span><br><span class="line">    <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION) &#123;</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"encrypt"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) &#123;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"encrypted"</span>);</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"block"</span>);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"defaultcrypto"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) &#123;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"unencrypted"</span>);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"nonencrypted"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"unsupported"</span>);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"nonencrypted"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_RECOVERY) &#123;</span><br><span class="line">        <span class="comment">/* Setup a wipe via recovery, and reboot into recovery */</span></span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"fs_mgr_mount_all suggested recovery, so wiping data via recovery."</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; options = &#123;<span class="string">"--wipe_data"</span>, <span class="string">"--reason=fs_mgr_mount_all"</span> &#125;;</span><br><span class="line">        reboot_into_recovery(options);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* If reboot worked, there is no return. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_FILE_ENCRYPTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_install_keyring()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"encrypted"</span>);</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Although encrypted, we have device key, so we do not need to</span></span><br><span class="line">        <span class="comment">// do anything different from the nonencrypted case.</span></span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"nonencrypted"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_IS_METADATA_ENCRYPTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_install_keyring()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.state"</span>, <span class="string">"encrypted"</span>);</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// defaultcrypto detects file/block encryption. init flow is same for each.</span></span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"defaultcrypto"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_METADATA_ENCRYPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_install_keyring()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        property_set(<span class="string">"ro.crypto.type"</span>, <span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// encrypt detects file/block encryption. init flow is same for each.</span></span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(<span class="string">"encrypt"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"fs_mgr_mount_all returned unexpected error "</span> &lt;&lt; code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else ... &lt; 0: error */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之前如果有了解过全盘加密的同学应该会很熟悉,全盘加密会返回 FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION ,然后触发一个 trigger ,最后在 init.rc 中执行 vdc 进程,最后启动 vold 进行全盘加密操作.那现在我们来看一下 FBE 中的 nonencrypted 这个 trigger 中做了什么操作,没看到有触发 vold 的操作啊,那文件加密是什么时候做的呢?不着急,我们继续往下看.</li></ul><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    <span class="keyword">class</span><span class="number">_</span>start main</span><br><span class="line">    <span class="keyword">class</span><span class="number">_</span>start <span class="keyword">late</span><span class="number">_</span>start</span><br></pre></td></tr></table></figure><ul><li>我们知道,正常系统起来后,init 的执行顺序为 <code>early-init</code>,<code>init</code>,<code>late-init</code>.既然我们一下子无法知道 FBE 中 vold 是在什么时候执行的,那就只能一步步跟 init.rc,看下能否发现一些端倪,功夫不负有心人,终于在 init.rc 中发现了一点可能和 FBE 相关的东西. <strong>installkey /data</strong> 这个看着有点像.</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">on</span> post-fs-<span class="class"><span class="keyword">data</span></span></span><br><span class="line">    # <span class="type">We</span> chown/chmod /<span class="class"><span class="keyword">data</span> again so because mount is run as root + defaults</span></span><br><span class="line">    chown system system /<span class="class"><span class="keyword">data</span></span></span><br><span class="line">    chmod <span class="number">0771</span> /<span class="class"><span class="keyword">data</span></span></span><br><span class="line">    # <span class="type">We</span> restorecon /<span class="class"><span class="keyword">data</span> in case the userdata partition has been reset.</span></span><br><span class="line">    restorecon /<span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br><span class="line">    # <span class="type">Make</span> sure we have the device encryption key.</span><br><span class="line">    start vold</span><br><span class="line">    installkey /<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure><ul><li>类似 mount 的处理流程, installkey /data 最后会调用<code>system/core/init/builtins.cpp</code> 中的 do_installkey 函数,do_installkey 首先判断是否为文件加密方式,如果是文件加密方式,则会执行 vdc 命令,到这里终于开始进入加密流程过程了.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_installkey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_crypto()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> unencrypted_dir = args[<span class="number">1</span>] + e4crypt_unencrypted_folder;</span><br><span class="line">    <span class="keyword">if</span> (do_installkeys_ensure_dir_exists(unencrypted_dir.c_str())) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to create "</span> &lt;&lt; unencrypted_dir;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; exec_args = &#123;<span class="string">"exec"</span>, <span class="string">"/system/bin/vdc"</span>, <span class="string">"--wait"</span>, <span class="string">"cryptfs"</span>,</span><br><span class="line">                                          <span class="string">"enablefilecrypto"</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> do_exec(exec_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-FBE-加密处理流程"><a href="#2-2-FBE-加密处理流程" class="headerlink" title="2.2 FBE 加密处理流程"></a>2.2 FBE 加密处理流程</h4><ul><li>先看一下 vdc 代码中的处理流程,在 <code>system/vold/vdc.cpp</code>, 通过 local socket 实现了 vdc 通知 vold 进行之后的操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">........</span><br><span class="line"><span class="keyword">while</span> ((sock = socket_local_client(sockname,</span><br><span class="line">                             ANDROID_SOCKET_NAMESPACE_RESERVED,</span><br><span class="line">                             SOCK_STREAM)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_socket) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Error connecting to "</span> &lt;&lt; sockname;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"monitor"</span>)) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(do_monitor(sock, <span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exit</span>(do_cmd(sock, argc, argv));</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(write(sock, cmd.c_str(), cmd.length() + <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to write command"</span>;</span><br><span class="line">    <span class="keyword">return</span> errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码在 system/vold/CryptCommandListener.cpp,通过之前的命令执行到 e4crypt_initialize_global_de 函数,到这里终于进入了文件加密的核心部分了,该函数会生成 /data/unencrypted/key.unencrypted key用来设置/data下除了<code>directories_to_exclude</code> (system/extras/ext4_utils/ext4_crypt_init_extensions.cpp 中定义)目录的当前所有目录的policy,(更准确的说,用的是 /data/unencrypted/ref ,该文件是是key 的引用(),key 其实是存入到密钥环(keyring)当中去的 ).其实 FBE 下有三种类型的 key 用于整个 Android 系统,那这里只是生成的一把 key,之后的 key 是在哪里生成的呢?</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_initialize_global_de</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"e4crypt_initialize_global_de"</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (s_global_de_initialized) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Already initialized"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *contents_mode;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filenames_mode;</span><br><span class="line">    cryptfs_get_file_encryption_modes(&amp;contents_mode, &amp;filenames_mode);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> modestring = <span class="built_in">std</span>::<span class="built_in">string</span>(contents_mode) + <span class="string">":"</span> + filenames_mode;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mode_filename = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"/data"</span>) + e4crypt_key_mode;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::WriteStringToFile(modestring, mode_filename)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Cannot save type"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> device_key_ref;</span><br><span class="line">    <span class="comment">//生成 /data/unencrypted/key这个文件夹  key 是怎样生成的 ,首先会读取 /dev/urandom 节点生成一个随机数，再通过 keymaster key 进行签名操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同时会生成 /data/uncrypt/key/version(版本信息)  /data/uncrypt/key/encrypt_key(之前通过/dev/urandom 生成的 key 再通过 keymaster key 加密过的 key)</span></span><br><span class="line">    <span class="keyword">if</span> (!android::vold::retrieveAndInstallKey(<span class="literal">true</span>,</span><br><span class="line">        device_key_path, device_key_temp, &amp;device_key_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ref_filename = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"/data"</span>) + e4crypt_key_ref;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::WriteStringToFile(device_key_ref, ref_filename)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Cannot save key reference to:"</span> &lt;&lt; ref_filename;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Wrote system DE key reference to:"</span> &lt;&lt; ref_filename;</span><br><span class="line">                </span><br><span class="line">    s_global_de_initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生成了 uncryptkey 之后, 分析 init.rc 看看之后做了什么操作,看了大部分都是 mkdir 操作啊.</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start bootcharting as soon as possible after the data partition is</span></span><br><span class="line"><span class="comment"># mounted to collect more data.</span></span><br><span class="line">mkdir /data/bootchart 0755 shell shell</span><br><span class="line">bootchart start</span><br><span class="line"></span><br><span class="line"><span class="comment"># Avoid predictable entropy pool. Carry over entropy from previous boot.</span></span><br><span class="line">copy /data/system/entropy.dat /dev/urandom</span><br><span class="line"></span><br><span class="line"><span class="comment"># create basic filesystem structure</span></span><br><span class="line">mkdir /data/misc 01771<span class="built_in"> system </span>misc</span><br><span class="line">mkdir /data/misc/recovery 0770<span class="built_in"> system </span>log</span><br></pre></td></tr></table></figure><ul><li>也类似 mount_all ,mkdir 最终调用了 init/builtins.cpp 中的 do_mkdir 函数,关注 e4crypt_set_directory_policy 函数实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//判断是否未文件加密方式,是则执行之后的流程</span></span><br><span class="line">    <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e4crypt_set_directory_policy(args[<span class="number">1</span>].c_str())) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; options = &#123;</span><br><span class="line">                <span class="string">"--prompt_and_wipe_data"</span>,</span><br><span class="line">                <span class="string">"--reason=set_policy_failed:"</span>s + args[<span class="number">1</span>]&#125;;</span><br><span class="line">            reboot_into_recovery(options);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置相关目录的加密 policy,使用的 policy 便是上面生成的 /data/unencrypted/ref (ref 是 key 经过填充后 再经过 sha512 算法得到的东西). directories_to_exclude 指定的相关目录不会被加密,因为该部分相关的子目录需要加密 (加密 key 使用之后生成的 CE/DE)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">e4crypt_set_directory_policy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dir || <span class="built_in">strncmp</span>(dir, <span class="string">"/data/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special-case /data/media/obb per b/64566063</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dir, <span class="string">"/data/media/obb"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Try to set policy on this directory, but if it is non-empty this may fail.</span></span><br><span class="line">        set_system_de_policy_on(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set policy on first level /data directories</span></span><br><span class="line">    <span class="comment">// To make this less restrictive, consider using a policy file.</span></span><br><span class="line">    <span class="comment">// However this is overkill for as long as the policy is simply</span></span><br><span class="line">    <span class="comment">// to apply a global policy to all /data folders created via makedir</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(dir + <span class="number">6</span>, <span class="string">'/'</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Special case various directories that must not be encrypted,</span></span><br><span class="line">    <span class="comment">// often because their subdirectories must be encrypted.</span></span><br><span class="line">    <span class="comment">// This isn't a nice way to do this, see b/26641735</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; directories_to_exclude = &#123;</span><br><span class="line">        <span class="string">"lost+found"</span>,</span><br><span class="line">        <span class="string">"system_ce"</span>, <span class="string">"system_de"</span>,</span><br><span class="line">        <span class="string">"misc_ce"</span>, <span class="string">"misc_de"</span>,</span><br><span class="line">        <span class="string">"media"</span>,</span><br><span class="line">        <span class="string">"data"</span>, <span class="string">"user"</span>, <span class="string">"user_de"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> prefix = <span class="string">"/data/"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d: directories_to_exclude) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((prefix + d) == dir) &#123;</span><br><span class="line">            LOG(INFO) &lt;&lt; <span class="string">"Not setting policy on "</span> &lt;&lt; dir;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set_system_de_policy_on(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e4crypt_policy_set 先填充了 eep 这个结构体,相关的加密 key 与加密方式都是通过这个结构体进行进一步操作的.最后通过 ioctl 实现相关目录的 key policy ,kernel 部分这里就不去深究了,相关代码位置在 kernel/fs/crypto/ 中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">e4crypt_policy_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *directory, <span class="keyword">const</span> <span class="keyword">char</span> *policy,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> policy_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> contents_encryption_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> filenames_encryption_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy_length != EXT4_KEY_DESCRIPTOR_SIZE) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Policy wrong length: "</span> &lt;&lt; policy_length;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = open(directory, O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to open directory "</span> &lt;&lt; directory;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//填充 eep</span></span><br><span class="line">    ext4_encryption_policy eep;</span><br><span class="line">    eep.version = <span class="number">0</span>;</span><br><span class="line">    eep.contents_encryption_mode = contents_encryption_mode;</span><br><span class="line">    eep.filenames_encryption_mode = filenames_encryption_mode;</span><br><span class="line">    eep.flags = e4crypt_get_policy_flags(filenames_encryption_mode);</span><br><span class="line">    <span class="built_in">memcpy</span>(eep.master_key_descriptor, policy, EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">    <span class="comment">//ioctl 实现最后的加密操作</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, EXT4_IOC_SET_ENCRYPTION_POLICY, &amp;eep)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to set encryption policy for "</span> &lt;&lt; directory;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> policy_hex[EXT4_KEY_DESCRIPTOR_SIZE_HEX];</span><br><span class="line">    policy_to_hex(policy, policy_hex);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Policy for "</span> &lt;&lt; directory &lt;&lt; <span class="string">" set to "</span> &lt;&lt; policy_hex;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面已经分析了 uncryptkey 加密操作. 那么文章开头说的 CE/DE 又是在哪做的操作呢? 继续分析 init.rc,发现在 init.rc 中,在 post-fs-data 中创建了一些必要的文件后,是时候为用户0创建相应的key 了 , <code>init_user0</code> 就是做了这个操作,类似之前的 do_installkey 操作, init_user0 最终会调用了 vold 下的 e4crypt_init_user0 函数,该函数会生成 /data/misc/vold/user_keys 目录下的相关文件.注:DE key 加密相关的存储空间就是在这个阶段实现的 CE 加密相关的存储空间还未生成</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_init_user0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"e4crypt_init_user0"</span>;</span><br><span class="line">    <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_key_dir, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_key_dir + <span class="string">"/ce"</span>, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_key_dir + <span class="string">"/de"</span>, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!android::vold::pathExists(get_de_key_path(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">//第一次系统起来, de/ce key 未创建,所以会走这,创建 DE/CE key 的过程都是在这个函数里面做的,类似 uncrypted key 的生成流程,</span></span><br><span class="line">        <span class="comment">// 也会通过调用 randomKey 函数生成随机 key ,storeKeyAtomically 函数生成 keymaster key ,</span></span><br><span class="line">        <span class="comment">//最后调用 installKey 将 key 加入到 密钥环(keyring)中</span></span><br><span class="line">            <span class="keyword">if</span> (!create_and_install_user_keys(<span class="number">0</span>, <span class="literal">false</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> switch to loading only DE_0 here once framework makes</span></span><br><span class="line">        <span class="comment">// explicit calls to install DE keys for secondary users</span></span><br><span class="line">        <span class="comment">// 加密之后，第一次系统起来直接走这，load key 然后用 keymaster key进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (!load_all_de_keys()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We can only safely prepare DE storage here, since CE keys are probably</span></span><br><span class="line">    <span class="comment">// entangled with user credentials.  The framework will always prepare CE</span></span><br><span class="line">    <span class="comment">// storage once CE keys are installed.</span></span><br><span class="line">    <span class="comment">//开始准备 DE 存储空间,e4crypt_prepare_user_storage 先是准备了相关的 DE 目录,之后查找相关用户id 的 key ,最后调用 ensure_policy 用户设置相关目录的加密策略</span></span><br><span class="line">    <span class="keyword">if</span> (!e4crypt_prepare_user_storage(<span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>, FLAG_STORAGE_DE)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Failed to prepare user 0 storage"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a non-FBE device that recently left an emulated mode,</span></span><br><span class="line">    <span class="comment">// restore user data directories to known-good state.</span></span><br><span class="line">    <span class="keyword">if</span> (!e4crypt_is_native() &amp;&amp; !e4crypt_is_emulated()) &#123;</span><br><span class="line">        e4crypt_unlock_user_key(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"!"</span>, <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着上面的 ensure_policy 函数,通过 cryptfs_get_file_encryption_modes 函数,根据 fstab 文件获取了 FBE 加密方式(contents_mode,filenames_mode),最后通过 e4crypt_policy_ensure 函数设置相关目录的 policy</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">e4crypt_policy_ensure</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *directory, <span class="keyword">const</span> <span class="keyword">char</span> *policy,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">size_t</span> policy_length,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span> *contents_encryption_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span> *filenames_encryption_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> contents_mode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> filenames_mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">"software"</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">"aes-256-xts"</span>)) &#123;</span><br><span class="line">        contents_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">"ice"</span>)) &#123;</span><br><span class="line">        contents_mode = EXT4_ENCRYPTION_MODE_PRIVATE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Invalid file contents encryption mode: "</span></span><br><span class="line">                   &lt;&lt; contents_encryption_mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filenames_encryption_mode, <span class="string">"aes-256-cts"</span>)) &#123;</span><br><span class="line">        filenames_mode = EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filenames_encryption_mode, <span class="string">"aes-256-heh"</span>)) &#123;</span><br><span class="line">        filenames_mode = EXT4_ENCRYPTION_MODE_AES_256_HEH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Invalid file names encryption mode: "</span></span><br><span class="line">                   &lt;&lt; filenames_encryption_mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> is_empty;</span><br><span class="line">    <span class="keyword">if</span> (!is_dir_empty(directory, &amp;is_empty)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_empty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e4crypt_policy_set(directory, policy, policy_length,</span><br><span class="line">                                contents_mode, filenames_mode)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e4crypt_policy_check(directory, policy, policy_length,</span><br><span class="line">                                  contents_mode, filenames_mode)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么 CE 空间是在什么时候准备好的？其实那部分代码是在 framework 里面做的。framework 相关代码在 <code>frameworks/base/services/core/java/com/android/server/StorageManagerService.java</code>，调用了 unlockUserKey 函数，该部分代码还是很简单的，主要就是通过 <code>mCryptConnector.execute(&quot;cryptfs&quot;, &quot;unlock_user_key&quot;, userId, serialNumber,encodeBytes(token), encodeBytes(secret));</code>通知 vold 需要去生成 key 了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockUserKey</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> serialNumber, <span class="keyword">byte</span>[] token, <span class="keyword">byte</span>[] secret)</span> </span>&#123;</span><br><span class="line">    enforcePermission(android.Manifest.permission.STORAGE_INTERNAL);</span><br><span class="line">    waitForReady();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">        <span class="comment">// When a user has secure lock screen, require secret to actually unlock.</span></span><br><span class="line">        <span class="comment">// This check is mostly in place for emulation mode.</span></span><br><span class="line">        <span class="keyword">if</span> (mLockPatternUtils.isSecure(userId) &amp;&amp; ArrayUtils.isEmpty(secret)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Secret required to unlock secure user "</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCryptConnector.execute(<span class="string">"cryptfs"</span>, <span class="string">"unlock_user_key"</span>, userId, serialNumber,</span><br><span class="line">                    encodeBytes(token), encodeBytes(secret));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLocalUnlockedUsers = ArrayUtils.appendInt(mLocalUnlockedUsers, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">        String propertyName = <span class="string">"sys.user."</span> + userId + <span class="string">".ce_available"</span>;</span><br><span class="line">        Slog.d(TAG, <span class="string">"Setting property: "</span> + propertyName + <span class="string">"=true"</span>);</span><br><span class="line">        SystemProperties.set(propertyName, <span class="string">"true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 system/vold/Ext4Crypt.cpp 中的 <code>e4crypt_unlock_user_key</code> 函数进行解密操作，第一次系统起来的时候，因为用户没有设置密码，所以此时的 key 是没有用 auth 进行签名的，s_ce_key_raw_refs 会直接返回，即此时的 key 是已经解密过的 key 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> rename to 'install' for consistency, and take flags to know which keys to install</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_unlock_user_key</span><span class="params">(<span class="keyword">userid_t</span> user_id, <span class="keyword">int</span> serial, <span class="keyword">const</span> <span class="keyword">char</span>* token_hex,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">char</span>* secret_hex)</span> </span>&#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"e4crypt_unlock_user_key "</span> &lt;&lt; user_id &lt;&lt; <span class="string">" serial="</span> &lt;&lt; serial</span><br><span class="line">               &lt;&lt; <span class="string">" token_present="</span> &lt;&lt; (<span class="built_in">strcmp</span>(token_hex, <span class="string">"!"</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_ce_key_raw_refs.count(user_id) != <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(WARNING) &lt;&lt; <span class="string">"Tried to unlock already-unlocked key for user "</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> token, secret;</span><br><span class="line">        <span class="keyword">if</span> (!parse_hex(token_hex, &amp;token)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!parse_hex(secret_hex, &amp;secret)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        android::<span class="function">vold::KeyAuthentication <span class="title">auth</span><span class="params">(token, secret)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!read_and_install_user_ce_key(user_id, auth)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Couldn't read key for "</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When in emulation mode, we just use chmod. However, we also</span></span><br><span class="line">        <span class="comment">// unlock directories when not in emulation mode, to bring devices</span></span><br><span class="line">        <span class="comment">// back into a known-good state.</span></span><br><span class="line">        <span class="keyword">if</span> (!emulated_unlock(android::vold::BuildDataSystemCePath(user_id), <span class="number">0771</span>) ||</span><br><span class="line">            !emulated_unlock(android::vold::BuildDataMiscCePath(user_id), <span class="number">01771</span>) ||</span><br><span class="line">            !emulated_unlock(android::vold::BuildDataMediaCePath(<span class="literal">nullptr</span>, user_id), <span class="number">0770</span>) ||</span><br><span class="line">            !emulated_unlock(android::vold::BuildDataUserCePath(<span class="literal">nullptr</span>, user_id), <span class="number">0771</span>)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to unlock user "</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之后调用 prepareUserStorage 用于设置 ce 空间相关的 policy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareUserStorage</span><span class="params">(String volumeUuid, <span class="keyword">int</span> userId, <span class="keyword">int</span> serialNumber, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    enforcePermission(android.Manifest.permission.STORAGE_INTERNAL);</span><br><span class="line">    waitForReady();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCryptConnector.execute(<span class="string">"cryptfs"</span>, <span class="string">"prepare_user_storage"</span>, escapeNull(volumeUuid),</span><br><span class="line">                userId, serialNumber, flags);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类似 DE 空间的加密流程 CE 空间也会调用 e4crypt_prepare_user_storage 进行设置目录的 policy ，这样子，加密空间就全部准备好了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">e4crypt_prepare_user_storage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* volume_uuid, <span class="keyword">userid_t</span> user_id, <span class="keyword">int</span> serial,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"e4crypt_prepare_user_storage for volume "</span> &lt;&lt; escape_null(volume_uuid)</span><br><span class="line">               &lt;&lt; <span class="string">", user "</span> &lt;&lt; user_id &lt;&lt; <span class="string">", serial "</span> &lt;&lt; serial &lt;&lt; <span class="string">", flags "</span> &lt;&lt; flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FLAG_STORAGE_DE) &#123;</span><br><span class="line">        <span class="comment">// DE_sys key</span></span><br><span class="line">        <span class="keyword">auto</span> system_legacy_path = android::vold::BuildDataSystemLegacyPath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_legacy_path = android::vold::BuildDataMiscLegacyPath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> profiles_de_path = android::vold::BuildDataProfilesDePath(user_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DE_n key</span></span><br><span class="line">        <span class="keyword">auto</span> system_de_path = android::vold::BuildDataSystemDePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_de_path = android::vold::BuildDataMiscDePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> user_de_path = android::vold::BuildDataUserDePath(volume_uuid, user_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(system_legacy_path, <span class="number">0700</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MANAGE_MISC_DIRS</span></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(misc_legacy_path, <span class="number">0750</span>, multiuser_get_uid(user_id, AID_SYSTEM),</span><br><span class="line">                multiuser_get_uid(user_id, AID_EVERYBODY))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(profiles_de_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(system_de_path, <span class="number">0770</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(misc_de_path, <span class="number">01771</span>, AID_SYSTEM, AID_MISC)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_de_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> de_raw_ref;</span><br><span class="line">            <span class="keyword">if</span> (!lookup_key_ref(s_de_key_raw_refs, user_id, &amp;de_raw_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(de_raw_ref, system_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(de_raw_ref, misc_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(de_raw_ref, user_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FLAG_STORAGE_CE) &#123;</span><br><span class="line">        <span class="comment">// CE_n key</span></span><br><span class="line">        <span class="keyword">auto</span> system_ce_path = android::vold::BuildDataSystemCePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_ce_path = android::vold::BuildDataMiscCePath(user_id);</span><br><span class="line">        <span class="keyword">auto</span> media_ce_path = android::vold::BuildDataMediaCePath(volume_uuid, user_id);</span><br><span class="line">        <span class="keyword">auto</span> user_ce_path = android::vold::BuildDataUserCePath(volume_uuid, user_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(system_ce_path, <span class="number">0770</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(misc_ce_path, <span class="number">01771</span>, AID_SYSTEM, AID_MISC)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(media_ce_path, <span class="number">0770</span>, AID_MEDIA_RW, AID_MEDIA_RW)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_dir(user_ce_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e4crypt_is_native()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> ce_raw_ref;</span><br><span class="line">            <span class="keyword">if</span> (!lookup_key_ref(s_ce_key_raw_refs, user_id, &amp;ce_raw_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, system_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, misc_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, media_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ensure_policy(ce_raw_ref, user_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Now that credentials have been installed, we can run restorecon</span></span><br><span class="line">            <span class="comment">// over these paths</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> these paths need to be kept in sync with libselinux</span></span><br><span class="line">            android::vold::RestoreconRecursive(system_ce_path);</span><br><span class="line">            android::vold::RestoreconRecursive(misc_ce_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-锁屏密码与-FBE-key-的关系"><a href="#2-3-锁屏密码与-FBE-key-的关系" class="headerlink" title="2.3 锁屏密码与 FBE key 的关系"></a>2.3 锁屏密码与 FBE key 的关系</h4><p>开始前，先说说加密思想。Android FBE 中会通过密码文件生成一个 auth ，用这个 auth 再对 key 进行签名。这样子，用户在没有输入正确密码时，是无法进行解密 CE 空间的。那按照这样子，用户在不输入密码的时候岂不是用不了这些内存位置。其实，根据 auth 对 key 的签名，只针对了 CE 空间的 key 进行签名，所以系统在正常起来时，DE 空间其实已经解密完成了，现在就来看下用户在设置密码后，vold 做了哪些处理吧。</p><ul><li><p>用户设置完成密码后，vold 进程首先会调用 e4crypt_add_user_key_auth 用于生成新的 CE key，一个疑惑，在设置密码完成后，会调用两次该函数，第一次会生成一个未经过 auth 签名的 key，之后会再次生成一个经过 auth 签名的 key，不知这样的意图为何？</p></li><li><p>e4crypt_fixate_newest_user_key_auth 主要是将用户设置密码后生成的 auth 签名过 key 给重命名成之前的 key 名称</p></li><li><p>secdiscard 主要用于删除旧的 key 文件</p></li></ul><h4 id="2-4-FBE-解密"><a href="#2-4-FBE-解密" class="headerlink" title="2.4 FBE 解密"></a>2.4 FBE 解密</h4><p>这里说的解密的意思理解成读取可能会比较好理解. Android 的加密思想是如果是未经过授权的读取操作都是无法进行访问的.其实 FBE 解密流程和系统第一次起来时 set policy 的流程几乎是一样的。不同的是，在调用 ensure_policy 时，会对目录检测是否为空，如果是空，则进行 set policy 操作，而如果为非空，则进行 check_policy 操作，所以对 /data 的解密操作都在这个 check_policy ，当校验成功后，kernel 会自动对 /data 进行解密操作。如果要实现对 /data 的解密，最难的倒不是 vold 中解密流程的移植，反倒是 framework 中根据 password 生成的 auth 的提取，因为此时的 key 是使用了 auth 进行签名的 key 了，如何把加密的 key 给解出来倒成了开发的难点。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>分析到最后，其实 FBE 的加密思想并不复杂，相对于 Android 之前的全盘加密，整个流程加密思想几乎是相同的。但无疑文件加密是更为人性化的，用户无需在输入密码就可进行一些基础操作。文中可能还有些不足以及 kernel 部分详细的加密操作都未详谈，欢迎各位指正补充。</p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FBE </tag>
            
            <tag> 文件级加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Time</title>
      <link href="/2018/07/11//linux-time.html/"/>
      <url>/2018/07/11//linux-time.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Linux时钟框架"><a href="#1、Linux时钟框架" class="headerlink" title="1、Linux时钟框架"></a>1、Linux时钟框架</h2><p><img src="linux_time_profile.png" alt="image"><sup><a href="#fn_DroidPhoneo" id="reffn_DroidPhoneo">DroidPhoneo</a></sup></p><p>上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。</p><p>1、定时Timer</p><ul><li>这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对应的是SPI（Shared Peripheral Interrupt，即多个cpu共享同一个中断。</li><li>这类timer一般是32bit宽度count，最重要的它会频繁的溢出并产生timer到期中断。</li><li>这类timer服务于tick timer(低精度)或者hrtimer(高精度)。</li><li>低精度模式，local timer工作在PERIODIC模式。即timer以tick时间(1/HZ)周期性的产生中断。在tick timer中处理任务调度tick、低精度timer、其他时间更新和统计profile。在这种模式下，所有利用时间的进行的运算，精度都是以tick(1/HZ)为单位的，精度较低。比如HZ=1000，那么tick=1ms。</li><li>高精度模式，local timer工作在ONESHOT模式。即系统可以支持hrtimer(high resolution)高精度timer，精度为local timer的计数clk达到ns级别。这种情况下把tick timer也转换成一种hrtimer。</li></ul><p>2、时间戳Timer</p><ul><li>这类timer一个系统多个cpu共享一个，称为global timer。</li><li>这类timer一般是32bit/64bit宽度count，一般不会溢出产生中断，系统实时的去读取count的值来计算当前的时间戳。</li><li>这类timer服务于clocksource/timekeeper。</li></ul><blockquote><p>本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”</p></blockquote><h3 id="1-1、Exynos-MCT-Multi-Core-Timer"><a href="#1-1、Exynos-MCT-Multi-Core-Timer" class="headerlink" title="1.1、Exynos MCT(Multi-Core Timer)"></a>1.1、Exynos MCT(Multi-Core Timer)</h3><p>我们以samsung exynos架构为例来说明linux对timer的使用。</p><p><img src="exynos_timer.png" alt="image"></p><p>从上图可以看到，exynos有1个64bit global timer用来做时间戳timer，有8个31bit localtimer用来做定时timer，每个cpu拥有一个localtimer。</p><p><img src="exynos_mct_initflow.png" alt="image"></p><p>上图是exynos driver的初始化流程，mct_init_dt()中包含了主要的初始化流程：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __init mct<span class="constructor">_init_dt(<span class="params">struct</span> <span class="params">device_node</span> <span class="operator">*</span><span class="params">np</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">int_type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">exynos4<span class="constructor">_timer_resources(<span class="params">np</span>, <span class="params">of_iomap</span>(<span class="params">np</span>, 0)</span>); <span class="comment">//(1)初始化localtimer，并将其注册成clockevent</span></span><br><span class="line">exynos4<span class="constructor">_clocksource_init()</span>; <span class="comment">//(2)初始化globaltimer，并将其注册成clocksource</span></span><br><span class="line">exynos4<span class="constructor">_clockevent_init()</span>; <span class="comment">//(3)将globaltimer的comparator 0注册成一个clockevent，一般不会使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面结合clocksource和clockevent的子系统的解析，再来详细描述exynos系统的具体实现。</p><h2 id="2、clocksource-amp-timekeeper"><a href="#2、clocksource-amp-timekeeper" class="headerlink" title="2、clocksource &amp; timekeeper"></a>2、clocksource &amp; timekeeper</h2><p><img src="clocksource_timekeeper.png" alt="image"></p><p>上图描述的是clocksource和timekeeper的关系：</p><ul><li>一个global timer对应注册一个clocksource。</li><li>一个系统中可以有多个clocksource，timekeeper选择精度最高的那个来使用。</li><li>用户使用timekeeper提供的接口来获取系统的时间戳。</li><li>为了避免无人主动获取时间clocksource定时器的溢出，timekeeper需要定期的去获取clocksource的值来更新系统时间，一般是在tick处理中更新。</li></ul><h3 id="2-1、clocksource"><a href="#2-1、clocksource" class="headerlink" title="2.1、clocksource"></a>2.1、clocksource</h3><p>下面来看一看clocksource的定义：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct clocksource <span class="attr">mct_frc</span> = &#123;</span><br><span class="line">.<span class="attr">name</span>= <span class="string">"mct-frc"</span>,</span><br><span class="line"><span class="comment">/* (1) .rating = 精度，数值越大越好，</span></span><br><span class="line"><span class="comment">       select_best会选择精度最大的clocksource给timekeeper使用 */</span></span><br><span class="line">.<span class="attr">rating</span>= <span class="number">400</span>,  </span><br><span class="line"><span class="comment">/* (2) .read = 读取clocksource的timer当前计数 */</span></span><br><span class="line">.<span class="attr">read</span>= exynos4_frc_read,</span><br><span class="line"><span class="comment">/* (3) .mask = timer的位宽 */</span></span><br><span class="line">.<span class="attr">mask</span>= CLOCKSOURCE_MASK(<span class="number">32</span>),</span><br><span class="line">.<span class="attr">flags</span>= CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">.<span class="attr">resume</span>= exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看一下clocksource的注册过程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动global timer</span></span><br><span class="line">exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册timer_delay</span></span><br><span class="line">exynos4_delay_timer.read_current_timer = &amp;exynos4_read_current_timer;</span><br><span class="line">exynos4_delay_timer.freq = clk_rate;</span><br><span class="line">register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) 注册clocksource</span></span><br><span class="line"><span class="keyword">if</span> (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">panic(<span class="string">"%s: can't register clocksource\n"</span>, mct_frc.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册sched_clock</span></span><br><span class="line">sched_clock_register(exynos4_read_sched_clock, <span class="number">32</span>, clk_rate);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="keyword">static</span> inline int clocksource_register_hz(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *cs, <span class="built_in">u32</span> hz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __clocksource_register_scale(cs, <span class="number">1</span>, hz);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">int __clocksource_register_scale(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *cs, <span class="built_in">u32</span> scale, <span class="built_in">u32</span> freq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize mult/shift and max_idle_ns */</span></span><br><span class="line"><span class="comment">/* (1.1) 根据timer的频率freq，计算cs-&gt;mult、cs-&gt;shift</span></span><br><span class="line"><span class="comment">    这两个字段是用来把timer的计数转换成实际时间单位ns</span></span><br><span class="line"><span class="comment">    ns = (count * cs-&gt;mult) &gt;&gt; cs-&gt;shift */</span></span><br><span class="line">__clocksource_update_freq_scale(cs, scale, freq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add clocksource to the clocksource list */</span></span><br><span class="line">mutex_lock(&amp;clocksource_mutex);</span><br><span class="line"><span class="comment">/* (1.2) 将新的clocksource加入全局链表 */</span></span><br><span class="line">clocksource_enqueue(cs);</span><br><span class="line">clocksource_enqueue_watchdog(cs);</span><br><span class="line"><span class="comment">/* (1.3) 从全局链表中重新选择一个best</span></span><br><span class="line"><span class="comment">    clocksource给timekeeper使用 */</span></span><br><span class="line">clocksource_select();</span><br><span class="line">clocksource_select_watchdog(<span class="literal">false</span>);</span><br><span class="line">mutex_unlock(&amp;clocksource_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">void __clocksource_update_freq_scale(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *cs, <span class="built_in">u32</span> scale, <span class="built_in">u32</span> freq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">u64</span> sec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default clocksources are *special* and self-define their mult/shift.</span></span><br><span class="line"><span class="comment"> * But, you're not special, so you should specify a freq value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (freq) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calc the maximum number of seconds which we can run before</span></span><br><span class="line"><span class="comment"> * wrapping around. For clocksources which have a mask &gt; 32-bit</span></span><br><span class="line"><span class="comment"> * we need to limit the max sleep time to have a good</span></span><br><span class="line"><span class="comment"> * conversion precision. 10 minutes is still a reasonable</span></span><br><span class="line"><span class="comment"> * amount. That results in a shift value of 24 for a</span></span><br><span class="line"><span class="comment"> * clocksource with mask &gt;= 40-bit and f &gt;= 4GHz. That maps to</span></span><br><span class="line"><span class="comment"> * ~ 0.06ppm granularity for NTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (1.1.1) 计算timer计数器到溢出，</span></span><br><span class="line"><span class="comment">    最大能计数多少秒 = sec */</span></span><br><span class="line">sec = cs-&gt;mask;</span><br><span class="line">do_div(sec, freq);</span><br><span class="line">do_div(sec, scale);</span><br><span class="line"><span class="keyword">if</span> (!sec)</span><br><span class="line">sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sec &gt; <span class="number">600</span> &amp;&amp; cs-&gt;mask &gt; UINT_MAX)</span><br><span class="line">sec = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1.1.2) 根据1s内的频率数freq，和1s内的ns数NSEC_PER_SEC</span></span><br><span class="line"><span class="comment">            计算freq和ns之间的转换公式：</span></span><br><span class="line"><span class="comment">            ns = (freq * cs-&gt;mult) &gt;&gt; cs-&gt;shift </span></span><br><span class="line"><span class="comment">            目的是把mult和shift算到最大值，最大可能的保留精度 */</span></span><br><span class="line">clocks_calc_mult_shift(&amp;cs-&gt;mult, &amp;cs-&gt;shift, freq,</span><br><span class="line">       NSEC_PER_SEC / scale, sec * scale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure clocksources that have large 'mult' values don't overflow</span></span><br><span class="line"><span class="comment"> * when adjusted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cs-&gt;maxadj = clocksource_max_adjustment(cs);</span><br><span class="line"><span class="keyword">while</span> (freq &amp;&amp; ((cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult)</span><br><span class="line">|| (cs-&gt;mult - cs-&gt;maxadj &gt; cs-&gt;mult))) &#123;</span><br><span class="line">cs-&gt;mult &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">cs-&gt;shift--;</span><br><span class="line">cs-&gt;maxadj = clocksource_max_adjustment(cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only warn for *special* clocksources that self-define</span></span><br><span class="line"><span class="comment"> * their mult/shift values and don't specify a freq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ONCE(cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult,</span><br><span class="line"><span class="string">"timekeeping: Clocksource %s might overflow on 11%% adjustment\n"</span>,</span><br><span class="line">cs-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.3) 根据mult和shift的值，计算最大能进入idle的时间max_idle_ns</span></span><br><span class="line"><span class="comment">        才能保证idle时timer不会溢出*/</span></span><br><span class="line">clocksource_update_max_deferment(cs);</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n"</span>,</span><br><span class="line">cs-&gt;name, cs-&gt;mask, cs-&gt;max_cycles, cs-&gt;max_idle_ns);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line"><span class="keyword">static</span> void clocksource_select(void)</span><br><span class="line">&#123;</span><br><span class="line">__clocksource_select(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> void __clocksource_select(<span class="built_in">bool</span> skipcur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">bool</span> oneshot = tick_oneshot_mode_active();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *best, *cs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the best suitable clocksource */</span></span><br><span class="line"><span class="comment">/* (1.3.1) 选择best clocksource */</span></span><br><span class="line">best = clocksource_find_best(oneshot, skipcur);</span><br><span class="line"><span class="keyword">if</span> (!best)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for the override clocksource. */</span></span><br><span class="line">list_for_each_entry(cs, &amp;clocksource_list, list) &#123;</span><br><span class="line"><span class="keyword">if</span> (skipcur &amp;&amp; cs == curr_clocksource)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (strcmp(cs-&gt;name, override_name) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check to make sure we don't switch to a non-highres</span></span><br><span class="line"><span class="comment"> * capable clocksource if the tick code is in oneshot</span></span><br><span class="line"><span class="comment"> * mode (highres or nohz)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(cs-&gt;flags &amp; CLOCK_SOURCE_VALID_FOR_HRES) &amp;&amp; oneshot) &#123;</span><br><span class="line"><span class="comment">/* Override clocksource cannot be used. */</span></span><br><span class="line">pr_warn(<span class="string">"Override clocksource %s is not HRT compatible - cannot switch while in HRT/NOHZ mode\n"</span>,</span><br><span class="line">cs-&gt;name);</span><br><span class="line">override_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">/* Override clocksource can be used. */</span></span><br><span class="line">best = cs;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.3.2) 通知timekeeper更新clocksource，tick-sched更新 */</span></span><br><span class="line"><span class="keyword">if</span> (curr_clocksource != best &amp;&amp; !timekeeping_notify(best)) &#123;</span><br><span class="line">pr_info(<span class="string">"Switched to clocksource %s\n"</span>, best-&gt;name);</span><br><span class="line">curr_clocksource = best;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">||||→</span><br><span class="line">int timekeeping_notify(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *clock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;tk_core.timekeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tk-&gt;tkr_mono.clock == clock)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">stop_machine(change_clocksource, clock, NULL);</span><br><span class="line">tick_clock_notify();</span><br><span class="line"><span class="keyword">return</span> tk-&gt;tkr_mono.clock == clock ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1、exynos4-clocksource-init"><a href="#2-1-1、exynos4-clocksource-init" class="headerlink" title="2.1.1、exynos4_clocksource_init()"></a>2.1.1、exynos4_clocksource_init()</h4><p>exynos将global timer注册成clocksource，虽然global timer拥有64bit的位宽，但是注册的时候把其当成32bit的clocksource注册。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static u32 notrace exynos4<span class="constructor">_read_count_32(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return readl<span class="constructor">_relaxed(<span class="params">reg_base</span> + EXYNOS4_MCT_G_CNT_L)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static cycle_t exynos4<span class="constructor">_frc_read(<span class="params">struct</span> <span class="params">clocksource</span> <span class="operator">*</span><span class="params">cs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return exynos4<span class="constructor">_read_count_32()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">struct</span> clocksource mct_frc = &#123;</span><br><span class="line">.name= <span class="string">"mct-frc"</span>,</span><br><span class="line">.rating= <span class="number">400</span>,</span><br><span class="line">.read= exynos4_frc_read,</span><br><span class="line">.mask= <span class="constructor">CLOCKSOURCE_MASK(32)</span>,</span><br><span class="line">.flags= CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">.resume= exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __init exynos4<span class="constructor">_clocksource_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">exynos4<span class="constructor">_mct_frc_start()</span>;</span><br><span class="line"></span><br><span class="line">exynos4_delay_timer.read_current_timer = &amp;exynos4_read_current_timer;</span><br><span class="line">exynos4_delay_timer.freq = clk_rate;</span><br><span class="line">register<span class="constructor">_current_timer_delay(&amp;<span class="params">exynos4_delay_timer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) exynos将global timer注册成clocksource */</span></span><br><span class="line"><span class="keyword">if</span> (clocksource<span class="constructor">_register_hz(&amp;<span class="params">mct_frc</span>, <span class="params">clk_rate</span>)</span>)</span><br><span class="line">panic(<span class="string">"%s: can't register clocksource\n"</span>, mct_frc.name);</span><br><span class="line"></span><br><span class="line">sched<span class="constructor">_clock_register(<span class="params">exynos4_read_sched_clock</span>, 32, <span class="params">clk_rate</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、timekeeper"><a href="#2-2、timekeeper" class="headerlink" title="2.2、timekeeper"></a>2.2、timekeeper</h3><p>timerkeeper提供了几种时间：xtime、monotonic time、raw monotonic time、boot time。</p><ul><li><strong>xtime</strong> 即是wall time，和RTC时间一样可以表示当前的时刻，它的起始时间是公元0世纪0秒，精度大于RTC时间；</li><li><strong>monotonic time</strong> 从系统开机后到现在的累计时间，不过不计算系统休眠的时间；</li><li><strong>raw monotonic time</strong> 和monotonic time含义一样，不过更纯粹，不会受到NTP时间调整的影响；</li><li><strong>boot time</strong> 在monotonic time的基础上加上了系统休眠的时间，它代表着系统上电后的总时间。</li></ul><div class="table-container"><table><thead><tr><th>时间种类</th><th>精度（统计单位）</th><th>访问速度</th><th>累计休眠时间</th><th>受NTP调整的影响</th><th>获取函数</th></tr></thead><tbody><tr><td>RTC</td><td>低</td><td>慢</td><td>Yes</td><td>Yes</td></tr><tr><td>xtime</td><td>高</td><td>快</td><td>Yes</td><td>Yes</td><td>do_gettimeofday()、ktime_get_real_ts()、ktime_get_real()</td></tr><tr><td>monotonic</td><td>高</td><td>快</td><td>No</td><td>Yes</td><td>ktime_get()、ktime_get_ts64()</td></tr><tr><td>raw monotonic</td><td>高</td><td>快</td><td>No</td><td>No</td><td>ktime_get_raw()、getrawmonotonic64()</td></tr><tr><td>boot time</td><td>高</td><td>快</td><td>Yes</td><td>Yes</td><td>ktime_get_boottime()</td></tr></tbody></table></div><h4 id="2-2-1、timekeeper的定义"><a href="#2-2-1、timekeeper的定义" class="headerlink" title="2.2.1、timekeeper的定义"></a>2.2.1、timekeeper的定义</h4><p>虽然clocksource定时器只有一个，但是timekeeper提供了xtime、monotonic time、raw time、boot time等几种时间，所以timekeeper结构体中定义了多个变量来记住这些差值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>struct timekeeper - Structure holding internal timekeeping values.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@tkr<span class="emphasis">_mono:The readout base structure for CLOCK_</span>MONOTONIC</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@tkr<span class="emphasis">_raw:The readout base structure for CLOCK_</span>MONOTONIC_RAW</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@xtime<span class="emphasis">_sec:Current CLOCK_</span>REALTIME time in seconds</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ktime<span class="emphasis">_sec:Current CLOCK_</span>MONOTONIC time in seconds</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@wall<span class="emphasis">_to_</span>monotonic:CLOCK<span class="emphasis">_REALTIME to CLOCK_</span>MONOTONIC offset</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@offs_real:Offset clock monotonic -&gt; clock realtime</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@offs_boot:Offset clock monotonic -&gt; clock boottime</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@offs_tai:Offset clock monotonic -&gt; clock tai</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@tai_offset:The current UTC to TAI offset in seconds</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@clock<span class="emphasis">_was_</span>set_seq:The sequence number of clock was set events</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@next<span class="emphasis">_leap_</span>ktime:CLOCK_MONOTONIC time value of </span>a<span class="markdown"> pending leap-second</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@raw_time:Monotonic raw base time in timespec64 format</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@cycle_interval:Number of clock cycles in one NTP interval</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@xtime_interval:Number of clock shifted nano seconds in one NTP</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span>interval.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@xtime_remainder:Shifted nano seconds left over when rounding</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span>@cycle_interval</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@raw_interval:Raw nano seconds accumulated per NTP interval.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ntp_error:Difference between accumulated time and NTP time in ntp</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span>shifted nano seconds.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ntp<span class="emphasis">_error_</span>shift:Shift conversion between clock shifted nano seconds and</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span>ntp shifted nano seconds.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@last<span class="emphasis">_warning:Warning ratelimiter (DEBUG_</span>TIMEKEEPING)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@underflow<span class="emphasis">_seen:Underflow warning flag (DEBUG_</span>TIMEKEEPING)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@overflow<span class="emphasis">_seen:Overflow warning flag (DEBUG_</span>TIMEKEEPING)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Note: For timespec(64) based interfaces wall<span class="emphasis">_to_</span>monotonic is what</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>we need to add to xtime (or xtime corrected for sub jiffie times)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>to get to monotonic time.  Monotonic is pegged at zero at system</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>boot time, </span>so<span class="markdown"> wall<span class="emphasis">_to_</span>monotonic </span>will<span class="markdown"> be negative, however, we </span>will</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>ALWAYS keep </span>the<span class="markdown"> tv_nsec part positive </span>so<span class="markdown"> we can use </span>the<span class="markdown"> usual</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>normalization.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>wall<span class="emphasis">_to_</span>monotonic is moved after resume from suspend for </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>monotonic time not to jump. We need to add total<span class="emphasis">_sleep_</span>time to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>wall<span class="emphasis">_to_</span>monotonic to get </span>the<span class="markdown"> real boot based time offset.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>wall<span class="emphasis">_to_</span>monotonic is no longer </span>the<span class="markdown"> boot time, getboottime must be</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>used instead.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">struct timekeeper &#123;</span><br><span class="line">struct tk_read_basetkr_mono;   </span><br><span class="line">                <span class="comment">// tkr_mono.xtime_nsec：xtime/monotonic time 的ns</span></span><br><span class="line">                <span class="comment">// tkr_mono.base：monotonic time的base部分</span></span><br><span class="line">struct tk_read_basetkr_raw;</span><br><span class="line">                <span class="comment">// tkr_mono.base：raw time的base部分</span></span><br><span class="line">u64xtime_sec;              <span class="comment">// xtime的sec</span></span><br><span class="line">unsigned longktime_sec;      <span class="comment">// monotonic time 的整sec</span></span><br><span class="line">struct timespec64wall_to_monotonic;  <span class="comment">// xtime + wall_to_monotonic = monotonic time</span></span><br><span class="line">ktime_toffs_real;  <span class="comment">//  monotonic time + offs_real = xtime，</span></span><br><span class="line">                                <span class="comment">// 和wall_to_monotonic是相反的值</span></span><br><span class="line">ktime_toffs_boot;  <span class="comment">//  monotonic time + offs_boot = boot time</span></span><br><span class="line">ktime_toffs_tai;</span><br><span class="line">s32tai_offset;</span><br><span class="line">unsigned <span class="built_in">int</span>clock_was_set_seq;</span><br><span class="line">ktime_tnext_leap_ktime;</span><br><span class="line">struct timespec64raw_time;   <span class="comment">// raw time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following members are for timekeeping internal use */</span></span><br><span class="line">cycle_tcycle_interval;</span><br><span class="line">u64xtime_interval;</span><br><span class="line">s64xtime_remainder;</span><br><span class="line">u32raw_interval;</span><br><span class="line"><span class="comment">/* The ntp_tick_length() value currently being used.</span></span><br><span class="line"><span class="comment"> * This cached copy ensures we consistently apply the tick</span></span><br><span class="line"><span class="comment"> * length for an entire tick, as ntp_tick_length may change</span></span><br><span class="line"><span class="comment"> * mid-tick, and we don't want to apply that new value to</span></span><br><span class="line"><span class="comment"> * the tick in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64ntp_tick;</span><br><span class="line"><span class="comment">/* Difference between accumulated time and NTP time in ntp</span></span><br><span class="line"><span class="comment"> * shifted nano seconds. */</span></span><br><span class="line">s64ntp_error;</span><br><span class="line">u32ntp_error_shift;</span><br><span class="line">u32ntp_err_mult;</span><br><span class="line">#ifdef CONFIG_DEBUG_TIMEKEEPING</span><br><span class="line">longlast_warning;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These simple flag variables are managed</span></span><br><span class="line"><span class="comment"> * without locks, which is racy, but they are</span></span><br><span class="line"><span class="comment"> * ok since we don't really care about being</span></span><br><span class="line"><span class="comment"> * super precise about how many events were</span></span><br><span class="line"><span class="comment"> * seen, just that a problem was observed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">int</span>underflow_seen;</span><br><span class="line"><span class="built_in">int</span>overflow_seen;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-2、timekeeper的初始化"><a href="#2-2-2、timekeeper的初始化" class="headerlink" title="2.2.2、timekeeper的初始化"></a>2.2.2、timekeeper的初始化</h4><p>timekeeper在初始化的过程中，读取当前的RTC值和clocksource的值，来初始化xtime、monotonic time、raw time、boot time，以及各种offset。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void __init timekeeping_init(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper <span class="comment">*tk = &amp;tk_core.timekeeper;</span></span><br><span class="line">struct clocksource <span class="comment">*clock;</span></span><br><span class="line">unsigned long flags;</span><br><span class="line">struct timespec64 now, boot, tmp;</span><br><span class="line"></span><br><span class="line">read_persistent_clock64(<span class="variable">&amp;now</span>);</span><br><span class="line"><span class="meta">if</span> (!timespec64_valid_strict(<span class="variable">&amp;now</span>)) &#123;</span><br><span class="line">pr_wa<span class="meta">rn(</span><span class="string">"WARNING: Persistent clock returned invalid value!\n"</span></span><br><span class="line"><span class="string">"         Check your CMOS/BIOS settings.\n"</span>);</span><br><span class="line">now.tv_sec = 0;</span><br><span class="line">now.tv_nsec = 0;</span><br><span class="line">&#125; <span class="meta">else</span> <span class="meta">if</span> (now.tv_sec || now.tv_nsec)</span><br><span class="line">persistent_clock_exists = true;</span><br><span class="line"></span><br><span class="line">read_boot_clock64(<span class="variable">&amp;boot</span>);</span><br><span class="line"><span class="meta">if</span> (!timespec64_valid_strict(<span class="variable">&amp;boot</span>)) &#123;</span><br><span class="line">pr_wa<span class="meta">rn(</span><span class="string">"WARNING: Boot clock returned invalid value!\n"</span></span><br><span class="line"><span class="string">"         Check your CMOS/BIOS settings.\n"</span>);</span><br><span class="line">boot.tv_sec = 0;</span><br><span class="line">boot.tv_nsec = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(<span class="variable">&amp;timekeeper_lock</span>, flags);</span><br><span class="line">write_seqcount_beg<span class="meta">in(</span><span class="variable">&amp;tk_core.</span>seq);</span><br><span class="line">ntp_init();</span><br><span class="line"></span><br><span class="line">clock = clocksource_default_clock();</span><br><span class="line"><span class="meta">if</span> (clock-&gt;enable)</span><br><span class="line">clock-&gt;enable(clock);</span><br><span class="line">tk_setup_internals(tk, clock);</span><br><span class="line"></span><br><span class="line">tk_set_<span class="meta">xtime(</span>tk, <span class="variable">&amp;now</span>);</span><br><span class="line">tk-&gt;raw_time.tv_sec = 0;</span><br><span class="line">tk-&gt;raw_time.tv_nsec = 0;</span><br><span class="line"><span class="meta">if</span> (boot.tv_sec == 0 <span class="variable">&amp;&amp;</span> boot.tv_nsec == 0)</span><br><span class="line">boot = tk_<span class="meta">xtime(</span>tk);</span><br><span class="line"></span><br><span class="line">set_normalized_timespec64(<span class="variable">&amp;tmp</span>, -boot.tv_sec, -boot.tv_nsec);</span><br><span class="line">tk_set_wall_to_mono(tk, tmp);</span><br><span class="line"></span><br><span class="line">timekeeping_u<span class="meta">pdate(</span>tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">write_seqcount_end(<span class="variable">&amp;tk_core.</span>seq);</span><br><span class="line">raw_spin_unlock_irqrestore(<span class="variable">&amp;timekeeper_lock</span>, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timekeeper原理上的初始化是在timekeeping_init()函数中完成的，但是read_persistent_clock64()、read_boot_clock64()都是空函数，所以实际上的初始化是另外的路径：rtc_hctosys() -&gt; do_settimeofday64()，rtc初始化的时候重新配置timekeeper。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">rtc_hctosys</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err = -ENODEV;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">tv64</span> = &#123;</span></span><br><span class="line">.tv_nsec = NSEC_PER_SEC &gt;&gt; <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> = <span class="title">rtc_class_open</span>(<span class="title">CONFIG_RTC_HCTOSYS_DEVICE</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pr_info(<span class="string">"unable to open rtc device (%s)\n"</span>,</span><br><span class="line">CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line"><span class="keyword">goto</span> err_open;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 读取当前的rtc时间 */</span></span><br><span class="line">err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">dev_err(rtc-&gt;dev.parent,</span><br><span class="line"><span class="string">"hctosys: unable to read the hardware clock\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> err_read;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tv64.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">tv64.tv_nsec = tm.tm_cnt * (<span class="number">1000000000</span> / <span class="number">32768</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* (2) 根据rtc时间配置xtime */</span></span><br><span class="line">err = do_settimeofday64(&amp;tv64);</span><br><span class="line"></span><br><span class="line">dev_info(rtc-&gt;dev.parent,</span><br><span class="line"><span class="string">"setting system clock to "</span></span><br><span class="line"><span class="string">"%d-%02d-%02d %02d:%02d:%02d UTC (%lld)\n"</span>,</span><br><span class="line">tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday,</span><br><span class="line">tm.tm_hour, tm.tm_min, tm.tm_sec,</span><br><span class="line">(<span class="keyword">long</span> <span class="keyword">long</span>) tv64.tv_sec);</span><br><span class="line"></span><br><span class="line">err_read:</span><br><span class="line">rtc_class_close(rtc);</span><br><span class="line"></span><br><span class="line">err_open:</span><br><span class="line">rtc_hctosys_ret = err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_settimeofday64</span><span class="params">(<span class="keyword">const</span> struct timespec64 *ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> = &amp;<span class="title">tk_core</span>.<span class="title">timekeeper</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts_delta</span>, <span class="title">xt</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!timespec64_valid_strict(ts))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 读取当前的xtime，计算rtc time和xtime之间的差值  */</span></span><br><span class="line">xt = tk_xtime(tk);</span><br><span class="line">ts_delta.tv_sec = ts-&gt;tv_sec - xt.tv_sec;</span><br><span class="line">ts_delta.tv_nsec = ts-&gt;tv_nsec - xt.tv_nsec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (timespec64_compare(&amp;tk-&gt;wall_to_monotonic, &amp;ts_delta) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2) 将差值追加到offset；tk-&gt;wall_to_monotonic、tk-&gt;offs_real */</span></span><br><span class="line">tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, ts_delta));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.3) 更新xtime */</span></span><br><span class="line">tk_set_xtime(tk, ts);</span><br><span class="line">out:</span><br><span class="line">timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signal hrtimers about time change */</span></span><br><span class="line">clock_was_set();</span><br><span class="line">notify_time_update();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3、timekeeper的update"><a href="#2-2-3、timekeeper的update" class="headerlink" title="2.2.3、timekeeper的update"></a>2.2.3、timekeeper的update</h4><p>clocksource定时器的值要定时的读出来，并且把增量加到timekeeper中，不然clocksource定时器会溢出。这个定时更新的时间一般是1 tick，调用的函数是update_wall_time()：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">void update_wall_time(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *real_tk = &amp;tk_core.timekeeper;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;shadow_timekeeper;</span><br><span class="line">cycle_t offset;</span><br><span class="line">int shift = <span class="number">0</span>, maxshift;</span><br><span class="line">unsigned int clock_set = <span class="number">0</span>;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure we're fully resumed: */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(timekeeping_suspended))</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span><br><span class="line">offset = real_tk-&gt;cycle_interval;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* (1) 获取clocksource和上一次update之间的offset */</span></span><br><span class="line">offset = clocksource_delta(tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock),</span><br><span class="line">   tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if there's really nothing to do */</span></span><br><span class="line"><span class="keyword">if</span> (offset &lt; real_tk-&gt;cycle_interval)</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do some additional sanity checking */</span></span><br><span class="line">timekeeping_check_update(real_tk, offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * With NO_HZ we may have to accumulate many cycle_intervals</span></span><br><span class="line"><span class="comment"> * (think "ticks") worth of time at once. To do this efficiently,</span></span><br><span class="line"><span class="comment"> * we calculate the largest doubling multiple of cycle_intervals</span></span><br><span class="line"><span class="comment"> * that is smaller than the offset.  We then accumulate that</span></span><br><span class="line"><span class="comment"> * chunk in one go, and then try to consume the next smaller</span></span><br><span class="line"><span class="comment"> * doubled multiple.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">shift = ilog2(offset) - ilog2(tk-&gt;cycle_interval);</span><br><span class="line">shift = max(<span class="number">0</span>, shift);</span><br><span class="line"><span class="comment">/* Bound shift to one less than what overflows tick_length */</span></span><br><span class="line">maxshift = (<span class="number">64</span> - (ilog2(ntp_tick_length())+<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">shift = min(shift, maxshift);</span><br><span class="line"><span class="comment">/* (2) 如果offset的值是多个cycle_interval，</span></span><br><span class="line"><span class="comment">    不要一次update，使用2的n次方cycle_interval的方式逐个update。</span></span><br><span class="line"><span class="comment">    tk-&gt;cycle_interval的值在tk_setup_internals()时被赋值，默认为1 tick */</span></span><br><span class="line"><span class="keyword">while</span> (offset &gt;= tk-&gt;cycle_interval) &#123;</span><br><span class="line">    <span class="comment">/* (3) 将offset更新到timekeeper中 */</span></span><br><span class="line">offset = logarithmic_accumulation(tk, offset, shift,</span><br><span class="line">&amp;clock_set);</span><br><span class="line"><span class="keyword">if</span> (offset &lt; tk-&gt;cycle_interval&lt;&lt;shift)</span><br><span class="line">shift--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* correct the clock when NTP error is too big */</span></span><br><span class="line">timekeeping_adjust(tk, offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * XXX This can be killed once everyone converts</span></span><br><span class="line"><span class="comment"> * to the new update_vsyscall.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old_vsyscall_fixup(tk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finally, make sure that after the rounding</span></span><br><span class="line"><span class="comment"> * xtime_nsec isn't larger than NSEC_PER_SEC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clock_set |= accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update the real timekeeper.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We could avoid this memcpy by switching pointers, but that</span></span><br><span class="line"><span class="comment"> * requires changes to all other timekeeper usage sites as</span></span><br><span class="line"><span class="comment"> * well, i.e. move the timekeeper pointer getter into the</span></span><br><span class="line"><span class="comment"> * spinlocked/seqcount protected sections. And we trade this</span></span><br><span class="line"><span class="comment"> * memcpy under the tk_core.seq against one before we start</span></span><br><span class="line"><span class="comment"> * updating.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (4)  */</span></span><br><span class="line">timekeeping_update(tk, clock_set);</span><br><span class="line">memcpy(real_tk, tk, sizeof(*tk));</span><br><span class="line"><span class="comment">/* The memcpy must come last. Do not put anything here! */</span></span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">out:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"><span class="keyword">if</span> (clock_set)</span><br><span class="line"><span class="comment">/* Have to call _delayed version, since in irq context*/</span></span><br><span class="line">clock_was_set_delayed();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="keyword">static</span> cycle_t logarithmic_accumulation(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk, cycle_t offset,</span><br><span class="line"><span class="built_in">u32</span> shift,</span><br><span class="line">unsigned int *clock_set)</span><br><span class="line">&#123;</span><br><span class="line">cycle_t interval = tk-&gt;cycle_interval &lt;&lt; shift;</span><br><span class="line"><span class="built_in">u64</span> raw_nsecs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the offset is smaller than a shifted interval, do nothing */</span></span><br><span class="line"><span class="keyword">if</span> (offset &lt; interval)</span><br><span class="line"><span class="keyword">return</span> offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Accumulate one shifted interval */</span></span><br><span class="line">offset -= interval;</span><br><span class="line"><span class="comment">/* (3.1) 更新cycle_last */</span></span><br><span class="line">tk-&gt;tkr_mono.cycle_last += interval;</span><br><span class="line">tk-&gt;tkr_raw.cycle_last  += interval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (3.2) 更新xtime：</span></span><br><span class="line"><span class="comment">        tk-&gt;tkr_mono.xtime_nsec</span></span><br><span class="line"><span class="comment">        tk-&gt;xtime_sec   */</span></span><br><span class="line">tk-&gt;tkr_mono.xtime_nsec += tk-&gt;xtime_interval &lt;&lt; shift;</span><br><span class="line">*clock_set |= accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Accumulate raw time */</span></span><br><span class="line"><span class="comment">/* (3.3) 更新raw time：</span></span><br><span class="line"><span class="comment">   tk-&gt;raw_time.tv_nsec</span></span><br><span class="line"><span class="comment">   tk-&gt;raw_time.tv_sec */</span></span><br><span class="line">raw_nsecs = (<span class="built_in">u64</span>)tk-&gt;raw_interval &lt;&lt; shift;</span><br><span class="line">raw_nsecs += tk-&gt;raw_time.tv_nsec;</span><br><span class="line"><span class="keyword">if</span> (raw_nsecs &gt;= NSEC_PER_SEC) &#123;</span><br><span class="line"><span class="built_in">u64</span> raw_secs = raw_nsecs;</span><br><span class="line">raw_nsecs = do_div(raw_secs, NSEC_PER_SEC);</span><br><span class="line">tk-&gt;raw_time.tv_sec += raw_secs;</span><br><span class="line">&#125;</span><br><span class="line">tk-&gt;raw_time.tv_nsec = raw_nsecs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Accumulate error between NTP and clock interval */</span></span><br><span class="line">tk-&gt;ntp_error += tk-&gt;ntp_tick &lt;&lt; shift;</span><br><span class="line">tk-&gt;ntp_error -= (tk-&gt;xtime_interval + tk-&gt;xtime_remainder) &lt;&lt;</span><br><span class="line">(tk-&gt;ntp_error_shift + shift);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="keyword">static</span> void timekeeping_update(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk, unsigned int action)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (action &amp; TK_CLEAR_NTP) &#123;</span><br><span class="line">tk-&gt;ntp_error = <span class="number">0</span>;</span><br><span class="line">ntp_clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tk_update_leap_state(tk);</span><br><span class="line"><span class="comment">/* (4.1) update monotonic time */</span></span><br><span class="line">tk_update_ktime_data(tk);</span><br><span class="line"></span><br><span class="line">update_vsyscall(tk);</span><br><span class="line">update_pvclock_gtod(tk, action &amp; TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">update_fast_timekeeper(&amp;tk-&gt;tkr_mono, &amp;tk_fast_mono);</span><br><span class="line">update_fast_timekeeper(&amp;tk-&gt;tkr_raw,  &amp;tk_fast_raw);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (action &amp; TK_CLOCK_WAS_SET)</span><br><span class="line">tk-&gt;clock_was_set_seq++;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The mirroring of the data to the shadow-timekeeper needs</span></span><br><span class="line"><span class="comment"> * to happen last here to ensure we don't over-write the</span></span><br><span class="line"><span class="comment"> * timekeeper structure on the next update with stale data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (action &amp; TK_MIRROR)</span><br><span class="line">memcpy(&amp;shadow_timekeeper, &amp;tk_core.timekeeper,</span><br><span class="line">       sizeof(tk_core.timekeeper));</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line"><span class="keyword">static</span> inline void tk_update_ktime_data(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">u64</span> seconds;</span><br><span class="line"><span class="built_in">u32</span> nsec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The xtime based monotonic readout is:</span></span><br><span class="line"><span class="comment"> *nsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();</span></span><br><span class="line"><span class="comment"> * The ktime based monotonic readout is:</span></span><br><span class="line"><span class="comment"> *nsec = base_mono + now();</span></span><br><span class="line"><span class="comment"> * ==&gt; base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (4.1.1) update tk-&gt;tkr_mono.base的值，</span></span><br><span class="line"><span class="comment">   = tk-&gt;xtime_sec +  tk-&gt;wall_to_monotonic,</span></span><br><span class="line"><span class="comment">   tk-&gt;tkr_mono.xtime_nsec 没有计算到base中 */</span></span><br><span class="line">seconds = (<span class="built_in">u64</span>)(tk-&gt;xtime_sec + tk-&gt;wall_to_monotonic.tv_sec);</span><br><span class="line">nsec = (<span class="built_in">u32</span>) tk-&gt;wall_to_monotonic.tv_nsec;</span><br><span class="line">tk-&gt;tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update the monotonic raw base */</span></span><br><span class="line"><span class="comment">/* (4.1.2) update tk-&gt;tkr_raw.base的值，</span></span><br><span class="line"><span class="comment">   直接转换tk-&gt;raw_time */</span></span><br><span class="line">tk-&gt;tkr_raw.base = timespec64_to_ktime(tk-&gt;raw_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The sum of the nanoseconds portions of xtime and</span></span><br><span class="line"><span class="comment"> * wall_to_monotonic can be greater/equal one second. Take</span></span><br><span class="line"><span class="comment"> * this into account before updating tk-&gt;ktime_sec.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (4.1.3) update tk-&gt;ktime_sec的值</span></span><br><span class="line"><span class="comment">nsec += (u32)(tk-&gt;tkr_mono.xtime_nsec &gt;&gt; tk-&gt;tkr_mono.shift);</span></span><br><span class="line"><span class="comment">if (nsec &gt;= NSEC_PER_SEC)</span></span><br><span class="line"><span class="comment">seconds++;</span></span><br><span class="line"><span class="comment">tk-&gt;ktime_sec = seconds;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-4、timekeeper的获取"><a href="#2-2-4、timekeeper的获取" class="headerlink" title="2.2.4、timekeeper的获取"></a>2.2.4、timekeeper的获取</h4><ul><li><strong>xtime/wall time 的获取:</strong></li></ul><p>do_gettimeofday()、ktime_get_real_ts()最后调用的getnstimeofday64() -&gt; __getnstimeofday64()获取到xtime：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">int __getnstimeofday64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">unsigned long seq;</span><br><span class="line">s64 nsecs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) sec直接从变量tk-&gt;xtime_sec获取到，</span></span><br><span class="line"><span class="comment">            即上一tick更新的值 */</span></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">tv_sec</span> = tk-&gt;</span>xtime_sec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span></span><br><span class="line"><span class="comment">    delta是距离上一次tick更新的差值 */</span></span><br><span class="line"><span class="function"><span class="title">nsecs</span> = timekeeping_get_ns(&amp;tk-&gt;</span>tkr_mono);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>tv_nsec = <span class="number">0</span>;</span><br><span class="line">timespec64_add_ns(ts, nsecs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not bail out early, in case there were callers still using</span></span><br><span class="line"><span class="comment"> * the value, even in the face of the WARN_ON.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(timekeeping_suspended))</span><br><span class="line">return -EAGAIN;</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">cycle_t delta;</span><br><span class="line">s64 nsec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 获取距离上一次tick更新，timer的delta值  */</span></span><br><span class="line">delta = timekeeping_get_delta(tkr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2) delta加上上一次的nsec tkr-&gt;xtime_nsec，</span></span><br><span class="line"><span class="comment">        即为最新的ns值 */</span></span><br><span class="line"><span class="function"><span class="title">nsec</span> = (delta * tkr-&gt;</span><span class="function"><span class="title">mult</span> + tkr-&gt;</span><span class="function"><span class="title">xtime_nsec</span>) &gt;&gt; tkr-&gt;</span>shift;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If arch requires, add in get_arch_timeoffset() */</span></span><br><span class="line">return nsec + arch_gettimeoffset();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline cycle_t timekeeping_get_delta(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">cycle_t now, last, mask, max, delta;</span><br><span class="line">unsigned int seq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since we're called holding a seqlock, the data may shift</span></span><br><span class="line"><span class="comment"> * under us while we're doing the calculation. This can cause</span></span><br><span class="line"><span class="comment"> * false positives, since we'd note a problem but throw the</span></span><br><span class="line"><span class="comment"> * results away. So nest another seqlock here to atomically</span></span><br><span class="line"><span class="comment"> * grab the points we are checking with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"><span class="comment">/* (2.1.1) 使用read函数读取当前timer的计数 */</span></span><br><span class="line"><span class="function"><span class="title">now</span> = tkr-&gt;</span><span class="function"><span class="title">read</span>(tkr-&gt;</span>clock);</span><br><span class="line"><span class="function"><span class="title">last</span> = tkr-&gt;</span>cycle_last;</span><br><span class="line"><span class="function"><span class="title">mask</span> = tkr-&gt;</span>mask;</span><br><span class="line"><span class="function"><span class="title">max</span> = tkr-&gt;</span><span class="function"><span class="title">clock</span>-&gt;</span>max_cycles;</span><br><span class="line">&#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1.2) 使用公式：(now - last) &amp; mask，</span></span><br><span class="line"><span class="comment">        计算delta值 */</span></span><br><span class="line">delta = clocksource_delta(now, last, mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try to catch underflows by checking if we are seeing small</span></span><br><span class="line"><span class="comment"> * mask-relative negative values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely((~delta &amp; mask) &lt; (mask &gt;&gt; <span class="number">3</span>))) &#123;</span><br><span class="line"><span class="function"><span class="title">tk</span>-&gt;</span>underflow_seen = <span class="number">1</span>;</span><br><span class="line">delta = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cap delta value to the max_cycles values to avoid mult overflows */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(delta &gt; max)) &#123;</span><br><span class="line"><span class="function"><span class="title">tk</span>-&gt;</span>overflow_seen = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">delta</span> = tkr-&gt;</span><span class="function"><span class="title">clock</span>-&gt;</span>max_cycles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ktime_get_real()使用monotonic time再加上差值timekeeper.offs_real的方法来获取xtime：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime<span class="constructor">_get_real(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return ktime<span class="constructor">_get_with_offset(TK_OFFS_REAL)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static ktime<span class="constructor">_t</span> <span class="operator">*</span>offsets[<span class="constructor">TK_OFFS_MAX</span>] = &#123;</span></span><br><span class="line"><span class="pattern-match">[<span class="constructor">TK_OFFS_REAL</span>]= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_real</span>,</span></span><br><span class="line"><span class="pattern-match">[<span class="constructor">TK_OFFS_BOOT</span>]= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_boot</span>,</span></span><br><span class="line"><span class="pattern-match">[<span class="constructor">TK_OFFS_TAI</span>]= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_tai</span>,</span></span><br><span class="line"><span class="pattern-match">&#125;;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">ktime<span class="constructor">_t</span> ktime<span class="constructor">_get_with_offset(<span class="params">enum</span> <span class="params">tk_offsets</span> <span class="params">offs</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">struct</span> timekeeper <span class="operator">*</span>tk = &amp;tk<span class="constructor">_core</span>.timekeeper;</span></span><br><span class="line"><span class="pattern-match">unsigned <span class="built_in">int</span> seq;</span></span><br><span class="line"><span class="pattern-match">ktime<span class="constructor">_t</span> base, <span class="operator">*</span>offset = offsets[offs];</span></span><br><span class="line"><span class="pattern-match">s64 nsecs;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="constructor">WARN_ON(<span class="params">timekeeping_suspended</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="pattern-match">seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> (1) monotonic time = tk-&gt;tkr<span class="constructor">_mono</span>.base，</span></span><br><span class="line"><span class="pattern-match">   offset = timekeeper.offs<span class="constructor">_real</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">base = ktime<span class="constructor">_add(<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>.<span class="params">base</span>, <span class="operator">*</span><span class="params">offset</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> (2) nsec需要更新最新的值：tk-&gt;tkr<span class="constructor">_mono</span>.xtime<span class="constructor">_nsec</span> + delta</span></span><br><span class="line"><span class="pattern-match">    delta是距离上一次tick更新的差值 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>monotonic time 的获取；</strong></li></ul><p>ktime_get()直接获取monotonic time：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime<span class="constructor">_get(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">unsigned <span class="built_in">int</span> seq;</span><br><span class="line">ktime_t base;</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line"><span class="constructor">WARN_ON(<span class="params">timekeeping_suspended</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span><br><span class="line"><span class="comment">/* (1) monotonic time = tk-&gt;tkr_mono.base */</span></span><br><span class="line">base = tk-&gt;tkr_mono.base;</span><br><span class="line"><span class="comment">/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span></span><br><span class="line"><span class="comment">    delta是距离上一次tick更新的差值 */</span></span><br><span class="line">nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ktime_get_ts64()通过xtime加上差值tk-&gt;wall_to_monotonic的方法来获取monotonic time：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ktime_get_ts64(<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> *ts)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;tk_core.timekeeper;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> tomono;</span><br><span class="line">s64 nsec;</span><br><span class="line">unsigned int seq;</span><br><span class="line"></span><br><span class="line">WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"><span class="comment">/* (1) 获取xtime */</span></span><br><span class="line">ts-&gt;tv_sec = tk-&gt;xtime_sec;</span><br><span class="line">nsec = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"><span class="comment">/* (2) 加上xtime和monotonic之间的差值tk-&gt;wall_to_monotonic */</span></span><br><span class="line">tomono = tk-&gt;wall_to_monotonic;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">ts-&gt;tv_sec += tomono.tv_sec;</span><br><span class="line">ts-&gt;tv_nsec = <span class="number">0</span>;</span><br><span class="line">timespec64_add_ns(ts, nsec + tomono.tv_nsec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>raw monotonic time 的获取；</strong></li></ul><p>ktime_get_raw()通过tk-&gt;tkr_raw.base获取raw monotonic time：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime<span class="constructor">_get_raw(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">unsigned <span class="built_in">int</span> seq;</span><br><span class="line">ktime_t base;</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span><br><span class="line"><span class="comment">/* (1) raw monotonic time = tk-&gt;tkr_raw.base */</span></span><br><span class="line">base = tk-&gt;tkr_raw.base;</span><br><span class="line"><span class="comment">/* (2) nsec需要更新最新的值：tk-&gt;tkr_raw.xtime_nsec + delta</span></span><br><span class="line"><span class="comment">    delta是距离上一次tick更新的差值 */</span></span><br><span class="line">nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_raw</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getrawmonotonic64()通过tk-&gt;raw_time获取raw monotonic time：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void getrawmonotonic64(<span class="keyword">struct</span> timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line"><span class="keyword">struct</span> timespec64 ts64;</span><br><span class="line">unsigned long seq;</span><br><span class="line">s64 nsecs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span><br><span class="line">nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_raw</span>)</span>;</span><br><span class="line">ts64 = tk-&gt;raw_time;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">timespec64<span class="constructor">_add_ns(&amp;<span class="params">ts64</span>, <span class="params">nsecs</span>)</span>;</span><br><span class="line">*ts = ts64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>boot time 的获取；</strong></li></ul><p>ktime_get_boottime()使用monotonic time再加上差值timekeeper.offs_boot的方法来获取boot time：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime<span class="constructor">_get_boottime(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return ktime<span class="constructor">_get_with_offset(TK_OFFS_BOOT)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static ktime<span class="constructor">_t</span> <span class="operator">*</span>offsets[<span class="constructor">TK_OFFS_MAX</span>] = &#123;</span></span><br><span class="line"><span class="pattern-match">[<span class="constructor">TK_OFFS_REAL</span>]= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_real</span>,</span></span><br><span class="line"><span class="pattern-match">[<span class="constructor">TK_OFFS_BOOT</span>]= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_boot</span>,</span></span><br><span class="line"><span class="pattern-match">[<span class="constructor">TK_OFFS_TAI</span>]= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_tai</span>,</span></span><br><span class="line"><span class="pattern-match">&#125;;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">ktime<span class="constructor">_t</span> ktime<span class="constructor">_get_with_offset(<span class="params">enum</span> <span class="params">tk_offsets</span> <span class="params">offs</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">struct</span> timekeeper <span class="operator">*</span>tk = &amp;tk<span class="constructor">_core</span>.timekeeper;</span></span><br><span class="line"><span class="pattern-match">unsigned <span class="built_in">int</span> seq;</span></span><br><span class="line"><span class="pattern-match">ktime<span class="constructor">_t</span> base, <span class="operator">*</span>offset = offsets[offs];</span></span><br><span class="line"><span class="pattern-match">s64 nsecs;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="constructor">WARN_ON(<span class="params">timekeeping_suspended</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="pattern-match">seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> (1) monotonic time = tk-&gt;tkr<span class="constructor">_mono</span>.base，</span></span><br><span class="line"><span class="pattern-match">   offset = timekeeper.offs<span class="constructor">_boot</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">base = ktime<span class="constructor">_add(<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>.<span class="params">base</span>, <span class="operator">*</span><span class="params">offset</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> (2) nsec需要更新最新的值：tk-&gt;tkr<span class="constructor">_mono</span>.xtime<span class="constructor">_nsec</span> + delta</span></span><br><span class="line"><span class="pattern-match">    delta是距离上一次tick更新的差值 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5、timekeeper-suspend"><a href="#2-2-5、timekeeper-suspend" class="headerlink" title="2.2.5、timekeeper suspend"></a>2.2.5、timekeeper suspend</h4><p>系统在进入suspend以后，clocksource不会再工作，这部分时间会计入xtime和boot time，但是不会计入monotonic time。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timekeeping_resume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> = &amp;<span class="title">tk_core</span>.<span class="title">timekeeper</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span> *<span class="title">clock</span> = <span class="title">tk</span>-&gt;<span class="title">tkr_mono</span>.<span class="title">clock</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts_new</span>, <span class="title">ts_delta</span>;</span></span><br><span class="line"><span class="keyword">cycle_t</span> cycle_now, cycle_delta;</span><br><span class="line"></span><br><span class="line">sleeptime_injected = <span class="literal">false</span>;</span><br><span class="line">read_persistent_clock64(&amp;ts_new);</span><br><span class="line"></span><br><span class="line">clockevents_resume();</span><br><span class="line">clocksource_resume();</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After system resumes, we need to calculate the suspended time and</span></span><br><span class="line"><span class="comment"> * compensate it for the OS time. There are 3 sources that could be</span></span><br><span class="line"><span class="comment"> * used: Nonstop clocksource during suspend, persistent clock and rtc</span></span><br><span class="line"><span class="comment"> * device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * One specific platform may have 1 or 2 or all of them, and the</span></span><br><span class="line"><span class="comment"> * preference will be:</span></span><br><span class="line"><span class="comment"> *suspend-nonstop clocksource -&gt; persistent clock -&gt; rtc</span></span><br><span class="line"><span class="comment"> * The less preferred source will only be tried if there is no better</span></span><br><span class="line"><span class="comment"> * usable source. The rtc part is handled separately in rtc core code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cycle_now = tk-&gt;tkr_mono.<span class="built_in">read</span>(clock);</span><br><span class="line"><span class="keyword">if</span> ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;</span><br><span class="line">cycle_now &gt; tk-&gt;tkr_mono.cycle_last) &#123;</span><br><span class="line">u64 num, <span class="built_in">max</span> = ULLONG_MAX;</span><br><span class="line">u32 mult = clock-&gt;mult;</span><br><span class="line">u32 shift = clock-&gt;shift;</span><br><span class="line">s64 nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cycle_delta = clocksource_delta(cycle_now, tk-&gt;tkr_mono.cycle_last,</span><br><span class="line">tk-&gt;tkr_mono.mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * "cycle_delta * mutl" may cause 64 bits overflow, if the</span></span><br><span class="line"><span class="comment"> * suspended time is too long. In that case we need do the</span></span><br><span class="line"><span class="comment"> * 64 bits math carefully</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_div(<span class="built_in">max</span>, mult);</span><br><span class="line"><span class="keyword">if</span> (cycle_delta &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">num = div64_u64(cycle_delta, <span class="built_in">max</span>);</span><br><span class="line">nsec = (((u64) <span class="built_in">max</span> * mult) &gt;&gt; shift) * num;</span><br><span class="line">cycle_delta -= num * <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line">nsec += ((u64) cycle_delta * mult) &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">ts_delta = ns_to_timespec64(nsec);</span><br><span class="line">sleeptime_injected = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timespec64_compare(&amp;ts_new, &amp;timekeeping_suspend_time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);</span><br><span class="line">sleeptime_injected = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sleeptime_injected)</span><br><span class="line">__timekeeping_inject_sleeptime(tk, &amp;ts_delta);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Re-base the last cycle value */</span></span><br><span class="line">tk-&gt;tkr_mono.cycle_last = cycle_now;</span><br><span class="line">tk-&gt;tkr_raw.cycle_last  = cycle_now;</span><br><span class="line"></span><br><span class="line">tk-&gt;ntp_error = <span class="number">0</span>;</span><br><span class="line">timekeeping_suspended = <span class="number">0</span>;</span><br><span class="line">timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">touch_softlockup_watchdog();</span><br><span class="line"></span><br><span class="line">tick_resume();</span><br><span class="line">hrtimers_resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timekeeping_suspend</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> = &amp;<span class="title">tk_core</span>.<span class="title">timekeeper</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span><span class="title">delta</span>, <span class="title">delta_delta</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span><span class="title">old_delta</span>;</span></span><br><span class="line"></span><br><span class="line">read_persistent_clock64(&amp;timekeeping_suspend_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On some systems the persistent_clock can not be detected at</span></span><br><span class="line"><span class="comment"> * timekeeping_init by its return value, so if we see a valid</span></span><br><span class="line"><span class="comment"> * value returned, update the persistent_clock_exists flag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)</span><br><span class="line">persistent_clock_exists = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">timekeeping_forward_now(tk);</span><br><span class="line">timekeeping_suspended = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (persistent_clock_exists) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To avoid drift caused by repeated suspend/resumes,</span></span><br><span class="line"><span class="comment"> * which each can add ~1 second drift error,</span></span><br><span class="line"><span class="comment"> * try to compensate so the difference in system time</span></span><br><span class="line"><span class="comment"> * and persistent_clock time stays close to constant.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">delta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);</span><br><span class="line">delta_delta = timespec64_sub(delta, old_delta);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(delta_delta.tv_sec) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if delta_delta is too large, assume time correction</span></span><br><span class="line"><span class="comment"> * has occurred and set old_delta to the current delta.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old_delta = delta;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Otherwise try to adjust old_system to compensate */</span></span><br><span class="line">timekeeping_suspend_time =</span><br><span class="line">timespec64_add(timekeeping_suspend_time, delta_delta);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timekeeping_update(tk, TK_MIRROR);</span><br><span class="line">halt_fast_timekeeper(tk);</span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">tick_suspend();</span><br><span class="line">clocksource_suspend();</span><br><span class="line">clockevents_suspend();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sysfs resume/suspend bits for timekeeping */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">syscore_ops</span> <span class="title">timekeeping_syscore_ops</span> = &#123;</span></span><br><span class="line">.resume= timekeeping_resume,</span><br><span class="line">.suspend= timekeeping_suspend,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和初始化一样的原因，理论上timekeeper的操作在timekeeping_resume()、timekeeping_suspend()，但是实际上在rtc的操作中执行rtc_suspend()、rtc_resume()。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int rtc_suspend(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span></span>*rtc = to_rtc_device(dev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span></span>tm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span>delta, delta_delta;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (timekeeping_rtc_skipsuspend())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* snapshot the current RTC and system time at suspend*/</span></span><br><span class="line"><span class="comment">/* (1.1) 读取suspend时候的rtc时间 */</span></span><br><span class="line">err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s:  fail to read rtc time\n"</span>, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.2) 读取当前xtime */</span></span><br><span class="line">getnstimeofday64(&amp;old_system);</span><br><span class="line">old_rtc.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">old_rtc.tv_nsec = tm.tm_cnt*(<span class="number">1000000000</span>/<span class="number">32768</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To avoid drift caused by repeated suspend/resumes,</span></span><br><span class="line"><span class="comment"> * which each can add ~1 second drift error,</span></span><br><span class="line"><span class="comment"> * try to compensate so the difference in system time</span></span><br><span class="line"><span class="comment"> * and rtc time stays close to constant.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (1.3) 如果rtc时间和xtime有偏差，尝试纠正xtime */</span></span><br><span class="line">delta = timespec64_sub(old_system, old_rtc);</span><br><span class="line">delta_delta = timespec64_sub(delta, old_delta);</span><br><span class="line"><span class="keyword">if</span> (delta_delta.tv_sec &lt; -<span class="number">2</span> || delta_delta.tv_sec &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if delta_delta is too large, assume time correction</span></span><br><span class="line"><span class="comment"> * has occured and set old_delta to the current delta.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old_delta = delta;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Otherwise try to adjust old_system to compensate */</span></span><br><span class="line">old_system = timespec64_sub(old_system, delta_delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int rtc_resume(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span></span>*rtc = to_rtc_device(dev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span></span>tm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span>new_system, new_rtc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span>sleep_time;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (timekeeping_rtc_skipresume())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">rtc_hctosys_ret = -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* snapshot the current rtc and system time at resume */</span></span><br><span class="line"><span class="comment">/* (2.1) 读取resume后的rtc时间和xtime */</span></span><br><span class="line">getnstimeofday64(&amp;new_system);</span><br><span class="line">err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s:  fail to read rtc time\n"</span>, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_rtc.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">new_rtc.tv_nsec = tm.tm_cnt*(<span class="number">1000000000</span>/<span class="number">32768</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_rtc.tv_sec &lt; old_rtc.tv_sec) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s:  time travel!\n"</span>, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* calculate the RTC time delta (sleep time)*/</span></span><br><span class="line"><span class="comment">/* (2.2) 计算suspend和resume之间rtc的差值 */</span></span><br><span class="line">sleep_time = timespec64_sub(new_rtc, old_rtc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since these RTC suspend/resume handlers are not called</span></span><br><span class="line"><span class="comment"> * at the very end of suspend or the start of resume,</span></span><br><span class="line"><span class="comment"> * some run-time may pass on either sides of the sleep time</span></span><br><span class="line"><span class="comment"> * so subtract kernel run-time between rtc_suspend to rtc_resume</span></span><br><span class="line"><span class="comment"> * to keep things accurate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.3) 使用上一步的差值，再减去，suspend和resume之间xtime的差值</span></span><br><span class="line"><span class="comment">        得到实际的sleep时间*/</span></span><br><span class="line">sleep_time = timespec64_sub(sleep_time,</span><br><span class="line">timespec64_sub(new_system, old_system));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sleep_time.tv_sec &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* (2.4) 将计算得到的sleep时间，加入到timekeeper中 */</span></span><br><span class="line">timekeeping_inject_sleeptime64(&amp;sleep_time);</span><br><span class="line">rtc_hctosys_ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void timekeeping_inject_sleeptime64(<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> *delta)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;tk_core.timekeeper;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">__timekeeping_inject_sleeptime(tk, delta);</span><br><span class="line"></span><br><span class="line">timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signal hrtimers about time change */</span></span><br><span class="line">clock_was_set();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line"><span class="keyword">static</span> void __timekeeping_inject_sleeptime(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk,</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> *delta)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!timespec64_valid_strict(delta)) &#123;</span><br><span class="line">printk_deferred(KERN_WARNING</span><br><span class="line"><span class="string">"__timekeeping_inject_sleeptime: Invalid "</span></span><br><span class="line"><span class="string">"sleep delta value!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* (2.4.1) 更新xtime */</span></span><br><span class="line">tk_xtime_add(tk, delta);</span><br><span class="line"><span class="comment">/* (2.4.2) 更新tk-&gt;wall_to_monotonic、tk-&gt;offs_real */</span></span><br><span class="line">tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, *delta));</span><br><span class="line"><span class="comment">/* (2.4.3) 更新tk-&gt;offs_boot */</span></span><br><span class="line">tk_update_sleep_time(tk, timespec64_to_ktime(*delta));</span><br><span class="line">tk_debug_account_sleep_time(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、clock-event"><a href="#3、clock-event" class="headerlink" title="3、clock_event"></a>3、clock_event</h2><p><img src="clockevent.png" alt="image"></p><p>clock_event其实就是对local timer的使用，每个cpu对应一个本地local timer。global timer启动后不需要主动做任何事情，只需要等待timekepper的读取就可以了。而local timer需要触发中断，它的主要价值就体现在定时中断处理了，中断的时间可以是固定的(period mode)也或者是不固定的(oneshot mode)。</p><h3 id="3-1、clock-event的注册"><a href="#3-1、clock-event的注册" class="headerlink" title="3.1、clock_event的注册"></a>3.1、clock_event的注册</h3><h4 id="3-1-1、exynos-clock-event的注册"><a href="#3-1-1、exynos-clock-event的注册" class="headerlink" title="3.1.1、exynos clock_event的注册"></a>3.1.1、exynos clock_event的注册</h4><p>exynos clock_event的注册分为两部分：</p><ul><li>第一部分：localtimer中断的注册：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">exynos4_timer_resources</span><span class="params">(struct device_node *np, <span class="keyword">void</span> __iomem *base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err, cpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mct_clock_event_device</span> *<span class="title">mevt</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">percpu_mct_tick</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">mct_clk</span>, *<span class="title">tick_clk</span>;</span></span><br><span class="line"></span><br><span class="line">tick_clk = np ? of_clk_get_by_name(np, <span class="string">"fin_pll"</span>) :</span><br><span class="line">clk_get(<span class="literal">NULL</span>, <span class="string">"fin_pll"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tick_clk))</span><br><span class="line">panic(<span class="string">"%s: unable to determine tick clock rate\n"</span>, __func__);</span><br><span class="line">clk_rate = clk_get_rate(tick_clk);</span><br><span class="line"></span><br><span class="line">mct_clk = np ? of_clk_get_by_name(np, <span class="string">"mct"</span>) : clk_get(<span class="literal">NULL</span>, <span class="string">"mct"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(mct_clk))</span><br><span class="line">panic(<span class="string">"%s: unable to retrieve mct clock instance\n"</span>, __func__);</span><br><span class="line">clk_prepare_enable(mct_clk);</span><br><span class="line"></span><br><span class="line">reg_base = base;</span><br><span class="line"><span class="keyword">if</span> (!reg_base)</span><br><span class="line">panic(<span class="string">"%s: unable to ioremap mct address space\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mct_int_type == MCT_INT_PPI) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) 大部分的localtimer是PPI模式，</span></span><br><span class="line"><span class="comment">            注册中断处理函数：exynos4_mct_tick_isr() */</span></span><br><span class="line">err = request_percpu_irq(mct_irqs[MCT_L0_IRQ],</span><br><span class="line"> exynos4_mct_tick_isr, <span class="string">"MCT"</span>,</span><br><span class="line"> &amp;percpu_mct_tick);</span><br><span class="line">WARN(err, <span class="string">"MCT: can't request IRQ %d (%d)\n"</span>,</span><br><span class="line">     mct_irqs[MCT_L0_IRQ], err);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="keyword">int</span> mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mct_clock_event_device</span> *<span class="title">pcpu_mevt</span> =</span></span><br><span class="line"><span class="class"><span class="title">per_cpu_ptr</span>(&amp;<span class="title">percpu_mct_tick</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">pcpu_mevt-&gt;evt.irq = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span><br><span class="line"><span class="keyword">if</span> (request_irq(mct_irq,</span><br><span class="line">exynos4_mct_tick_isr,</span><br><span class="line">IRQF_TIMER | IRQF_NOBALANCING,</span><br><span class="line">pcpu_mevt-&gt;name, pcpu_mevt)) &#123;</span><br><span class="line">pr_err(<span class="string">"exynos-mct: cannot register IRQ (cpu%d)\n"</span>,</span><br><span class="line">cpu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pcpu_mevt-&gt;evt.irq = mct_irq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 注册cpu hotplug的notifier，</span></span><br><span class="line"><span class="comment">        在其他cpu up时调用exynos4_local_timer_setup()注册clock_event */</span></span><br><span class="line">err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Immediately configure the timer on the boot CPU */</span></span><br><span class="line"><span class="comment">/* (3) 注册本cpu的clock_event */</span></span><br><span class="line">exynos4_local_timer_setup(mevt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">out_irq:</span><br><span class="line">free_percpu_irq(mct_irqs[MCT_L0_IRQ], &amp;percpu_mct_tick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">exynos4_mct_tick_isr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mct_clock_event_device</span> *<span class="title">mevt</span> = <span class="title">dev_id</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">evt</span> = &amp;<span class="title">mevt</span>-&gt;<span class="title">evt</span>;</span></span><br><span class="line"></span><br><span class="line">exynos4_mct_tick_clear(mevt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (4) localtimer中断处理函数是固定的也是非常简单的，</span></span><br><span class="line"><span class="comment">        调用本cpu clock_event_device的handler函数：evt-&gt;event_handler(evt) */</span></span><br><span class="line">evt-&gt;event_handler(evt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二部分：clock_event_device注册：</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int exynos4_local_timer_setup(struct mct_clock_event_device *mevt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="title">struct</span> clock_event_device *evt = &amp;mevt-&gt;</span>evt;</span><br><span class="line">unsigned int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mevt</span>-&gt;</span>base = EXYNOS4_MCT_L_BASE(cpu);</span><br><span class="line"><span class="function"><span class="title">snprintf</span>(mevt-&gt;</span><span class="function"><span class="title">name</span>, sizeof(mevt-&gt;</span><span class="keyword">name</span>), <span class="string">"mct_tick%d"</span>, cpu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 初始化clock_event_device */</span></span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span><span class="function"><span class="title">name</span> = mevt-&gt;</span><span class="keyword">name</span>;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>cpumask = cpumask_of(cpu);         <span class="comment">// 本clock_event_device只服务于一个cpu</span></span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>set_next_event = exynos4_tick_set_next_event;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>set_state_periodic = set_state_periodic;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>set_state_shutdown = set_state_shutdown;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>set_state_oneshot = set_state_shutdown;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>tick_resume = set_state_shutdown;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;</span><br><span class="line"><span class="function"><span class="title">evt</span>-&gt;</span>rating = <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">exynos4_mct_write</span>(TICK_BASE_CNT, mevt-&gt;</span>base + MCT_L_TCNTB_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mct_int_type == MCT_INT_SPI) &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (evt-&gt;</span>irq == -<span class="number">1</span>)</span><br><span class="line">return -EIO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">irq_force_affinity</span>(evt-&gt;</span>irq, cpumask_of(cpu));</span><br><span class="line"><span class="function"><span class="title">enable_irq</span>(evt-&gt;</span>irq);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">enable_percpu_irq(mct_irqs[MCT_L0_IRQ], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* (2) 配置并注册clockevent */</span></span><br><span class="line">clockevents_config_and_register(evt, clk_rate / (TICK_BASE_CNT + <span class="number">1</span>),</span><br><span class="line"><span class="number">0</span>xf, <span class="number">0</span>x7fffffff);</span><br><span class="line"></span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2、clock-event-device的注册"><a href="#3-1-2、clock-event-device的注册" class="headerlink" title="3.1.2、clock_event_device的注册"></a>3.1.2、clock_event_device的注册</h4><p>我们来分析一下clock_event_device的注册过程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">void clockevents_config_and_register(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *dev,</span><br><span class="line">     <span class="built_in">u32</span> freq, unsigned long min_delta,</span><br><span class="line">     unsigned long max_delta)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;min_delta_ticks = min_delta;   <span class="comment">// localtimer可配置的最小定时值</span></span><br><span class="line">dev-&gt;max_delta_ticks = max_delta;   <span class="comment">// localtimer可配置的最大定时值，</span></span><br><span class="line">                                    <span class="comment">// 比如exynos是31bit的localtimer，最大值就是0x7fffffff</span></span><br><span class="line"><span class="comment">/* (1) 根据localtimer的freq，计算clock_event_device对应的mult、shift，</span></span><br><span class="line"><span class="comment">    mult、shift的作用是用来做ns到localtimer cycle之间的转换，</span></span><br><span class="line"><span class="comment">    与之相反的是，在clocksource中mult、shift用来转换localtimer cycle到ns */</span></span><br><span class="line">clockevents_config(dev, freq);</span><br><span class="line"><span class="comment">/* (2) 继续注册clock_event_device */</span></span><br><span class="line">clockevents_register_device(dev);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_config(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *dev, <span class="built_in">u32</span> freq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">u64</span> sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1) 如果不支持oneshot模式，只是period模式，</span></span><br><span class="line"><span class="comment">        定时周期是固定的，不需要动态计算ns到cycle的转换 */</span></span><br><span class="line"><span class="keyword">if</span> (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the maximum number of seconds we can sleep. Limit</span></span><br><span class="line"><span class="comment"> * to 10 minutes for hardware which can program more than</span></span><br><span class="line"><span class="comment"> * 32bit ticks so we still get reasonable conversion values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sec = dev-&gt;max_delta_ticks;</span><br><span class="line">do_div(sec, freq);</span><br><span class="line"><span class="keyword">if</span> (!sec)</span><br><span class="line">sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sec &gt; <span class="number">600</span> &amp;&amp; dev-&gt;max_delta_ticks &gt; UINT_MAX)</span><br><span class="line">sec = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.2) 根据localtimer的freq，计算clock_event_device对应的mult、shift */</span></span><br><span class="line">clockevents_calc_mult_shift(dev, freq, sec);</span><br><span class="line"><span class="comment">/* (1.3) 转换min、max的cycle到ns */</span></span><br><span class="line">dev-&gt;min_delta_ns = cev_delta2ns(dev-&gt;min_delta_ticks, dev, <span class="literal">false</span>);</span><br><span class="line">dev-&gt;max_delta_ns = cev_delta2ns(dev-&gt;max_delta_ticks, dev, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_register_device(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize state to DETACHED */</span></span><br><span class="line">clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;cpumask) &#123;</span><br><span class="line">WARN_ON(num_possible_cpus() &gt; <span class="number">1</span>);</span><br><span class="line">dev-&gt;cpumask = cpumask_of(smp_processor_id());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;clockevents_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 将clock_event_device加入到全局链表clockevent_devices中 */</span></span><br><span class="line">list_add(&amp;dev-&gt;list, &amp;clockevent_devices);</span><br><span class="line"><span class="comment">/* (2.2) 继续尝试向本cpu的tick_device中注册clock_event_device */</span></span><br><span class="line">tick_check_new_device(dev);</span><br><span class="line">clockevents_notify_released();</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">void tick_check_new_device(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *newdev)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *curdev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span></span> *td;</span><br><span class="line">int cpu;</span><br><span class="line"></span><br><span class="line">cpu = smp_processor_id();</span><br><span class="line">td = &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class="line">curdev = td-&gt;evtdev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cpu local device ? */</span></span><br><span class="line"><span class="comment">/* (2.2.1) 新的clock_event_device是否支持本cpu？  */</span></span><br><span class="line"><span class="keyword">if</span> (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class="line">goto out_bc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Preference decision */</span></span><br><span class="line"><span class="comment">/* (2.2.2) 新的clock_event_device是否比当前clock_event_device更适合？</span></span><br><span class="line"><span class="comment">   1.如果curdev已经是oneshot模式，而newdev不支持oneshot，则切换</span></span><br><span class="line"><span class="comment">   2.newdev的精度要大于curdev，精度 = dev-&gt;rating */</span></span><br><span class="line"><span class="keyword">if</span> (!tick_check_preferred(curdev, newdev))</span><br><span class="line">goto out_bc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(newdev-&gt;owner))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Replace the eventually existing device by the new</span></span><br><span class="line"><span class="comment"> * device. If the current device is the broadcast device, do</span></span><br><span class="line"><span class="comment"> * not give it back to the clockevents layer !</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (tick_is_broadcast_device(curdev)) &#123;</span><br><span class="line">clockevents_shutdown(curdev);</span><br><span class="line">curdev = NULL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* (2.2.3) 关闭curdev、newdev */</span></span><br><span class="line">clockevents_exchange_device(curdev, newdev);</span><br><span class="line"><span class="comment">/* (2.2.4) 继续clock_event_device注册 */</span></span><br><span class="line">tick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class="line"><span class="keyword">if</span> (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class="line">tick_oneshot_notify();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">out_bc:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Can the new device be used as a broadcast device ?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.2.5) 如果newdev不适合注册成本cpu的td-&gt;evtdev,</span></span><br><span class="line"><span class="comment">    尝试将其注册成broadcast clockevent */</span></span><br><span class="line">tick_install_broadcast_device(newdev);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line"><span class="keyword">static</span> void tick_setup_device(<span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span></span> *td,</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *newdev, int cpu,</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span></span> *cpumask)</span><br><span class="line">&#123;</span><br><span class="line">ktime_t next_event;</span><br><span class="line">void (*handler)(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *) = NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * First device setup ?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!td-&gt;evtdev) &#123;</span><br><span class="line">    <span class="comment">/* (2.2.4.1) 如果是tick_do_timer_cpu没有被设置，且没有使能tick_nohz_full_cpu</span></span><br><span class="line"><span class="comment">        把tick_do_timer_cpu设置成本cpu，</span></span><br><span class="line"><span class="comment">        tick_do_timer_cpu负责在tick中update jiffies、update_wall_time  */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If no cpu took the do_timer update, assign it to</span></span><br><span class="line"><span class="comment"> * this cpu:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) &#123;</span><br><span class="line"><span class="keyword">if</span> (!tick_nohz_full_cpu(cpu))</span><br><span class="line">tick_do_timer_cpu = cpu;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class="line">tick_next_period = ktime_get();</span><br><span class="line">tick_period = ktime_set(<span class="number">0</span>, NSEC_PER_SEC / HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Startup in periodic mode first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.2.4.2) 如果tick_device是第一次设置clock_event_device,</span></span><br><span class="line"><span class="comment">    把tick_device设置成period模式 */</span></span><br><span class="line">td-&gt;mode = TICKDEV_MODE_PERIODIC;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* (2.2.4.3) 如果tick_device不是第一次设置clock_event_device,</span></span><br><span class="line"><span class="comment">    备份原clock_event_deviced的event_handler和next_event */</span></span><br><span class="line">handler = td-&gt;evtdev-&gt;event_handler;</span><br><span class="line">next_event = td-&gt;evtdev-&gt;next_event;</span><br><span class="line">td-&gt;evtdev-&gt;event_handler = clockevents_handle_noop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.4.4) 更新tick_device-&gt;evtdev到new clock_event_deviced  */</span></span><br><span class="line">td-&gt;evtdev = newdev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the device is not per cpu, pin the interrupt to the</span></span><br><span class="line"><span class="comment"> * current cpu:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!cpumask_equal(newdev-&gt;cpumask, cpumask))</span><br><span class="line">irq_set_affinity(newdev-&gt;irq, cpumask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When global broadcasting is active, check if the current</span></span><br><span class="line"><span class="comment"> * device is registered as a placeholder for broadcast mode.</span></span><br><span class="line"><span class="comment"> * This allows us to handle this x86 misfeature in a generic</span></span><br><span class="line"><span class="comment"> * way. This function also returns !=0 when we keep the</span></span><br><span class="line"><span class="comment"> * current active broadcast state for this CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.2.4.5) 如果全局的brodcast clockevent服务已经启动，</span></span><br><span class="line"><span class="comment">    本cpu的clockevent注册需要向brodcas服务，</span></span><br><span class="line"><span class="comment">    这是为了解决x86的一个失误(misfeature)，其他架构不需要？ */</span></span><br><span class="line"><span class="keyword">if</span> (tick_device_uses_broadcast(newdev, cpu))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.4.6) 根据td-&gt;mode安装clock_event_deviced的event_handler,并启动 */</span></span><br><span class="line"><span class="keyword">if</span> (td-&gt;mode == TICKDEV_MODE_PERIODIC)</span><br><span class="line">    <span class="comment">/* (2.2.4.7) period模式 */</span></span><br><span class="line">tick_setup_periodic(newdev, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* (2.2.4.8) oneshot模式 */</span></span><br><span class="line">tick_setup_oneshot(newdev, handler, next_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、tick-device的period-mode"><a href="#3-2、tick-device的period-mode" class="headerlink" title="3.2、tick_device的period mode"></a>3.2、tick_device的period mode</h3><p>接上节，在cpu第一次注册clock_event_deviced的时候，td-&gt;mode默认被设置成period模式。event_handler会被初始化成tick_handle_periodic：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void tick<span class="constructor">_setup_periodic(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">int</span> <span class="params">broadcast</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* (1) 设置period模式下的event_handler */</span></span><br><span class="line">tick<span class="constructor">_set_periodic_handler(<span class="params">dev</span>, <span class="params">broadcast</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Broadcast setup ? */</span></span><br><span class="line"><span class="keyword">if</span> (!tick<span class="constructor">_device_is_functional(<span class="params">dev</span>)</span>)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 如果dev支持period模式，则硬件上启动period模式:</span></span><br><span class="line"><span class="comment">        tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span></span><br><span class="line"><span class="comment">        clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_PERIODIC */</span></span><br><span class="line"><span class="keyword">if</span> ((dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC) &amp;&amp;</span><br><span class="line">    !tick<span class="constructor">_broadcast_oneshot_active()</span>) &#123;</span><br><span class="line">clockevents<span class="constructor">_switch_state(<span class="params">dev</span>, CLOCK_EVT_STATE_PERIODIC)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">unsigned long seq;</span><br><span class="line">ktime_t next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read<span class="constructor">_seqbegin(&amp;<span class="params">jiffies_lock</span>)</span>;</span><br><span class="line">next = tick_next_period;</span><br><span class="line">&#125; <span class="keyword">while</span> (read<span class="constructor">_seqretry(&amp;<span class="params">jiffies_lock</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (3) 如果dev不支持period模式只支持oneshot模式，则硬件上启动one shot模式，</span></span><br><span class="line"><span class="comment">            使用oneshot模式来模拟period模式：</span></span><br><span class="line"><span class="comment">            tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span></span><br><span class="line"><span class="comment">            clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_ONESHOT */</span></span><br><span class="line">clockevents<span class="constructor">_switch_state(<span class="params">dev</span>, CLOCK_EVT_STATE_ONESHOT)</span>;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!clockevents<span class="constructor">_program_event(<span class="params">dev</span>, <span class="params">next</span>, <span class="params">false</span>)</span>)</span><br><span class="line">return;</span><br><span class="line">next = ktime<span class="constructor">_add(<span class="params">next</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">void tick<span class="constructor">_set_periodic_handler(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">int</span> <span class="params">broadcast</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (!broadcast)</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.1) 设置period模式下的event<span class="constructor">_handler</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">dev-&gt;event<span class="constructor">_handler</span> = tick<span class="constructor">_handle_periodic</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">dev-&gt;event<span class="constructor">_handler</span> = tick<span class="constructor">_handle_periodic_broadcast</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>仔细分析一下tick_handle_periodic：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void tick<span class="constructor">_handle_periodic(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> cpu = smp<span class="constructor">_processor_id()</span>;</span><br><span class="line">ktime_t next = dev-&gt;next_event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 周期性的tick任务 */</span></span><br><span class="line">tick<span class="constructor">_periodic(<span class="params">cpu</span>)</span>;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_HIGH_RES_TIMERS)<span class="operator"> || </span>defined(CONFIG_NO_HZ_COMMON)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The cpu might have transitioned to HIGHRES or NOHZ mode via</span></span><br><span class="line"><span class="comment"> * update_process_times() -&gt; run_local_timers() -&gt;</span></span><br><span class="line"><span class="comment"> * hrtimer_run_queues().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;event_handler != tick_handle_periodic)</span><br><span class="line">return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!clockevent<span class="constructor">_state_oneshot(<span class="params">dev</span>)</span>)</span><br><span class="line">return;</span><br><span class="line"><span class="comment">/* (2) 如果tick_device是period mode，而clockevent是oneshot模式,</span></span><br><span class="line"><span class="comment">    编程oneshot模式clockevent在下一周期触发：</span></span><br><span class="line"><span class="comment">        tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span></span><br><span class="line"><span class="comment">        clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_ONESHOT */</span></span><br><span class="line">for (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the next period for devices, which do not have</span></span><br><span class="line"><span class="comment"> * periodic mode:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next = ktime<span class="constructor">_add(<span class="params">next</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!clockevents<span class="constructor">_program_event(<span class="params">dev</span>, <span class="params">next</span>, <span class="params">false</span>)</span>)</span><br><span class="line">return;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Have to be careful here. If we're in oneshot mode,</span></span><br><span class="line"><span class="comment"> * before we call tick_periodic() in a loop, we need</span></span><br><span class="line"><span class="comment"> * to be sure we're using a real hardware clocksource.</span></span><br><span class="line"><span class="comment"> * Otherwise we could get trapped in an infinite</span></span><br><span class="line"><span class="comment"> * loop, as the tick_periodic() increments jiffies,</span></span><br><span class="line"><span class="comment"> * which then will increment time, possibly causing</span></span><br><span class="line"><span class="comment"> * the loop to trigger again and again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (timekeeping<span class="constructor">_valid_for_hres()</span>)</span><br><span class="line">tick<span class="constructor">_periodic(<span class="params">cpu</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static void tick<span class="constructor">_periodic(<span class="params">int</span> <span class="params">cpu</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.1) 如果本cpu是tick<span class="constructor">_do_timer_cpu</span>，更新全局时间戳类型的任务，</span></span><br><span class="line"><span class="pattern-match">        包括update jiffies、update<span class="constructor">_wall_time</span>  <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (tick<span class="constructor">_do_timer_cpu</span> <span class="operator">==</span> cpu) &#123;</span></span><br><span class="line"><span class="pattern-match">write<span class="constructor">_seqlock(&amp;<span class="params">jiffies_lock</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> <span class="constructor">Keep</span> track <span class="keyword">of</span> the next tick event <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">tick<span class="constructor">_next_period</span> = ktime<span class="constructor">_add(<span class="params">tick_next_period</span>, <span class="params">tick_period</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">*</span> (1.1.1) 更新jiffies <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">do</span><span class="constructor">_timer(1)</span>;</span></span><br><span class="line"><span class="pattern-match">write<span class="constructor">_sequnlock(&amp;<span class="params">jiffies_lock</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> (1.1.2) 读取clocksource来更新timekeeper <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">update<span class="constructor">_wall_time()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.2) 运行软件timer(run<span class="constructor">_local_timers()</span>)和运行调度tick任务(scheduler<span class="constructor">_tick()</span>) <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">update<span class="constructor">_process_times(<span class="params">user_mode</span>(<span class="params">get_irq_regs</span>()</span>));</span></span><br><span class="line"><span class="pattern-match">profile<span class="constructor">_tick(CPU_PROFILING)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-3、运行Mode"><a href="#3-3、运行Mode" class="headerlink" title="3.3、运行Mode"></a>3.3、运行Mode</h3><p>关于mode，有几个结构涉及到：tick_device、clock_event_device、tick_sched、hrtimer_cpu_base、。组合起来有以下几种情况：</p><p><img src="clockevent_mode.png" alt="image"></p><p>其实归结起来就3种mode：NOHZ_MODE_INACTIVE、NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。下面来逐个解析一下。</p><h4 id="3-3-1、NOHZ-MODE-INACTIVE"><a href="#3-3-1、NOHZ-MODE-INACTIVE" class="headerlink" title="3.3.1、NOHZ_MODE_INACTIVE"></a>3.3.1、NOHZ_MODE_INACTIVE</h4><p>NOHZ_MODE_INACTIVE就是系统初始化时的状态：“td=period模式, dev=period/oneshot模式, hrtimer=low res, noHz=dis”。</p><p><img src="clockevent_NOHZ_MODE_INACTIVE.png" alt="image"></p><p>NOHZ_MODE_INACTIVE模式：</p><ul><li>tick_device工作在period模式，HW local timer工作在period/oneshot模式；</li><li>noHZ没有使能，进入idle会被tick timer中断打断；</li><li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li></ul><h4 id="3-3-2、NOHZ-MODE-LOWRES"><a href="#3-3-2、NOHZ-MODE-LOWRES" class="headerlink" title="3.3.2、NOHZ_MODE_LOWRES"></a>3.3.2、NOHZ_MODE_LOWRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，但是hrtimer高精度不能使能，即进入NOHZ_MODE_LOWRES模式：“td=period模式, dev=oneshot模式, hrtimer=low res, noHz=en”。</p><p><img src="clockevent_NOHZ_MODE_LOWRES.png" alt="image"></p><p>NOHZ_MODE_LOWRES模式：</p><ul><li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li><li>noHZ使能，进入idle不会被tick timer中断打断；</li><li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li></ul><p>为了支持noHZ，tick_device必须切换成oneshot模式，在进入idle时停掉tick timer(tick_nohz_idle_enter() -&gt;　__tick_nohz_idle_enter() -&gt; tick_nohz_stop_sched_tick())，在离开idle时恢复tick timer(tick_nohz_idle_exit() -&gt; tick_nohz_restart_sched_tick())，这样idle过程就不会被tick中断。就实现了noHZ模式(tickless)。</p><p>NOHZ_MODE_LOWRES模式下，没有进入idle时tick_device还是以固定周期工作的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void tick<span class="constructor">_nohz_handler(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> pt_regs *regs = get<span class="constructor">_irq_regs()</span>;</span><br><span class="line">ktime_t now = ktime<span class="constructor">_get()</span>;</span><br><span class="line"></span><br><span class="line">dev-&gt;next_event.tv64 = KTIME_MAX;</span><br><span class="line"></span><br><span class="line">tick<span class="constructor">_sched_do_timer(<span class="params">now</span>)</span>;</span><br><span class="line">tick<span class="constructor">_sched_handle(<span class="params">ts</span>, <span class="params">regs</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* No need to reprogram if we are running tickless  */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(ts-&gt;tick_stopped))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) HW local timer还是以固定周期发生中断 */</span></span><br><span class="line">hrtimer<span class="constructor">_forward(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, <span class="params">now</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line">tick<span class="constructor">_program_event(<span class="params">hrtimer_get_expires</span>(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>)</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3、NOHZ-MODE-HIGHRES"><a href="#3-3-3、NOHZ-MODE-HIGHRES" class="headerlink" title="3.3.3、NOHZ_MODE_HIGHRES"></a>3.3.3、NOHZ_MODE_HIGHRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，hrtimer高精度可以使能，即进入NOHZ_MODE_HIGHRES模式：“td=period模式, dev=oneshot模式, hrtimer=high res, noHz=en”。</p><p><img src="clockevent_NOHZ_MODE_HIGHRES.png" alt="image"></p><p>NOHZ_MODE_HIGHRES：</p><ul><li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li><li>noHZ使能，进入idle不会被tick timer中断打断；</li><li>hrtimer工作在高精度模式，和硬件定时器(HWlocal timer)的精度一样，远大于低精度定时器tick精度；</li></ul><p>为了支持hrtimer的高精度模式，hrtimer必须直接使用tick_device的oneshot模式，而常规的tick timer转换成hrtimer的一个子timer。</p><p><img src="ftrace_NOHZ_MODE_HIGHRES.png" alt="image"></p><p>上图是NOHZ_MODE_HIGHRES模式下，用ftrace抓取HW timer硬件中断和tick任务的执行情况：</p><ul><li>tick任务是以固定周期4ms固定执行的；</li><li>遇到tick任务超过4ms的间隔，这时就是进入了idle状态，且发生了noHZ(tickless)；</li><li>硬件timer中断的发生周期是不固定的，是和hrtimer绑定的；</li><li>发生tick的时候肯定发生了timer硬中断，因为tick是其中一个hrtimer；</li></ul><h4 id="3-3-4、Mode切换"><a href="#3-3-4、Mode切换" class="headerlink" title="3.3.4、Mode切换"></a>3.3.4、Mode切换</h4><p>系统初始状态工作在NOHZ_MODE_INACTIVE模式时，会动态检测是否可以进入更高级别的模式NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。这个检测工作是在这个路径中做的：tick_device工作在period模式：tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer<span class="constructor">_run_queues(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> hrtimer_cpu_base *cpu_base = this<span class="constructor">_cpu_ptr(&amp;<span class="params">hrtimer_bases</span>)</span>;</span><br><span class="line">ktime_t now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (3) 如果hrtimer已经切换到高精度模式，</span></span><br><span class="line"><span class="comment">        则不会从run_local_timers()低精度定时器路径来运行hrtimer */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="constructor">__hrtimer_hres_active(<span class="params">cpu_base</span>)</span>)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This _is_ ugly: We have to check periodically, whether we</span></span><br><span class="line"><span class="comment"> * can switch to highres and / or nohz mode. The clocksource</span></span><br><span class="line"><span class="comment"> * switch happens with xtime_lock held. Notification from</span></span><br><span class="line"><span class="comment"> * there only sets the check bit in the tick_oneshot code,</span></span><br><span class="line"><span class="comment"> * otherwise we might deadlock vs. xtime_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* (1) 如果hrtimer没有使能、noHZ使能，</span></span><br><span class="line"><span class="comment">    则调用：tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz()，</span></span><br><span class="line"><span class="comment">    切换到NOHZ_MODE_LOWRES模式 */</span></span><br><span class="line"><span class="keyword">if</span> (tick<span class="constructor">_check_oneshot_change(!<span class="params">hrtimer_is_hres_enabled</span>()</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 如果hrtimer使能、noHZ使能，</span></span><br><span class="line"><span class="comment">        则调用：hrtimer_switch_to_hres()，</span></span><br><span class="line"><span class="comment">        切换到NOHZ_MODE_HIGHRES模式 */</span></span><br><span class="line">hrtimer<span class="constructor">_switch_to_hres()</span>;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw<span class="constructor">_spin_lock(&amp;<span class="params">cpu_base</span>-&gt;<span class="params">lock</span>)</span>;</span><br><span class="line">now = hrtimer<span class="constructor">_update_base(<span class="params">cpu_base</span>)</span>;</span><br><span class="line"><span class="comment">/* (4) 低精度hrtimer的运行函数 */</span></span><br><span class="line"><span class="constructor">__hrtimer_run_queues(<span class="params">cpu_base</span>, <span class="params">now</span>)</span>;</span><br><span class="line">raw<span class="constructor">_spin_unlock(&amp;<span class="params">cpu_base</span>-&gt;<span class="params">lock</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、noHZ"><a href="#4、noHZ" class="headerlink" title="4、noHZ"></a>4、noHZ</h2><p>系统在NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES两种模式下支持noHZ。noHZ是一个功耗优化的feature，在系统负载比较轻的时候没有任务需要调度cpu会进入idle状态，但是系统的tick任务(update_process_times())默认会以固定周期执行，这种固定周期会打断idle状态让系统恢复成正常耗电状态。</p><p>tick任务这种不管有没有任务都是固定周期运行的特性是需要改进的，noHZ就是为了解决这一问题而产生的：如果在idle状态的过程中tick任务没有到期需要处理的低精度timer和高精度timer，tick任务可以继续保持睡眠，直到真正有timer到期。</p><p>idle进程的主要执行序列如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void cpu<span class="constructor">_idle_loop(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) 进入idle前,noHZ的处理 */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!need<span class="constructor">_resched()</span>) &#123;</span><br><span class="line">check<span class="constructor">_pgt_cache()</span>;</span><br><span class="line">rmb<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (2) cpu hotplug之cpu_down()的处理 */</span></span><br><span class="line"><span class="keyword">if</span> (cpu<span class="constructor">_is_offline(<span class="params">smp_processor_id</span>()</span>)) &#123;</span><br><span class="line"></span><br><span class="line">arch<span class="constructor">_cpu_idle_dead()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local<span class="constructor">_irq_disable()</span>;</span><br><span class="line">arch<span class="constructor">_cpu_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (3) cpu idle的进入 */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_idle_force_poll<span class="operator"> || </span>tick<span class="constructor">_check_broadcast_expired()</span>)</span><br><span class="line">cpu<span class="constructor">_idle_poll()</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cpuidle<span class="constructor">_idle_call()</span>;</span><br><span class="line"></span><br><span class="line">arch<span class="constructor">_cpu_idle_exit()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (4) 退出idle后,noHZ的处理 */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_exit()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其中的关键在tick_nohz_idle_enter()/tick_nohz_idle_exit()函数。</p><h3 id="4-1、tick-nohz-idle-enter-exit"><a href="#4-1、tick-nohz-idle-enter-exit" class="headerlink" title="4.1、tick_nohz_idle_enter/exit()"></a>4.1、tick_nohz_idle_enter/exit()</h3><p>tick_nohz_idle_enter()的解析：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>inidle = <span class="number">1</span>;</span><br><span class="line">__tick_nohz_idle_enter(ts);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class="line">&#123;</span><br><span class="line">ktime_t now, expires;</span><br><span class="line">int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">now = tick_nohz_start_idle(ts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 判断当前能否stop tick任务 */</span></span><br><span class="line"><span class="keyword">if</span> (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class="line"><span class="function"><span class="title">int</span> was_stopped = ts-&gt;</span>tick_stopped;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>idle_calls++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (2) 尝试stop tick任务 */</span></span><br><span class="line">expires = tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class="line"><span class="keyword">if</span> (expires.tv64 &gt; <span class="number">0</span>LL) &#123;</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>idle_sleeps++;</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>idle_expires = expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (!was_stopped &amp;&amp; ts-&gt;</span>tick_stopped)</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">idle_jiffies</span> = ts-&gt;</span>last_jiffies;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span><br><span class="line"> ktime_t now, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">struct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);</span><br><span class="line">u64 basemono, next_tick, next_tmr, next_rcu, delta, expires;</span><br><span class="line">unsigned long seq, basejiff;</span><br><span class="line">ktime_ttick;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read jiffies and the time when jiffies were updated last */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">seq = read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">basemono = last_jiffies_update.tv64;</span><br><span class="line">basejiff = jiffies;</span><br><span class="line">&#125; <span class="keyword">while</span> (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>last_jiffies = basejiff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span><br><span class="line">    arch_needs_cpu() || irq_work_needs_cpu()) &#123;</span><br><span class="line">next_tick = basemono + TICK_NSEC;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the next pending timer. If high resolution</span></span><br><span class="line"><span class="comment"> * timers are enabled this only takes the timer wheel</span></span><br><span class="line"><span class="comment"> * timers into account. If high resolution timers are</span></span><br><span class="line"><span class="comment"> * disabled this also looks at the next expiring</span></span><br><span class="line"><span class="comment"> * hrtimer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.1) 获取下一个timer的到期时间(包括低精度和高精度timer) */</span></span><br><span class="line">next_tmr = get_next_timer_interrupt(basejiff, basemono);</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>next_timer = next_tmr;</span><br><span class="line"><span class="comment">/* Take the next rcu event into account */</span></span><br><span class="line">next_tick = next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the tick is due in the next period, keep it ticking or</span></span><br><span class="line"><span class="comment"> * restart it proper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.2) 如果差距小于一个tick，不需要进入noHZ模式 */</span></span><br><span class="line">delta = next_tick - basemono;</span><br><span class="line"><span class="keyword">if</span> (delta &lt;= (u64)TICK_NSEC) &#123;</span><br><span class="line">tick.tv64 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="title">if</span> (!ts-&gt;</span>tick_stopped)</span><br><span class="line">goto out;</span><br><span class="line"><span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Tick is stopped, but required now. Enforce it */</span></span><br><span class="line">tick_nohz_restart(ts, now);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this cpu is the one which updates jiffies, then give up</span></span><br><span class="line"><span class="comment"> * the assignment and let it be taken by the cpu which runs</span></span><br><span class="line"><span class="comment"> * the tick timer next, which might be this cpu as well. If we</span></span><br><span class="line"><span class="comment"> * don't drop this here the jiffies might be stale and</span></span><br><span class="line"><span class="comment"> * do_timer() never invoked. Keep track of the fact that it</span></span><br><span class="line"><span class="comment"> * was the one which had the do_timer() duty last. If this cpu</span></span><br><span class="line"><span class="comment"> * is the one which had the do_timer() duty last, we limit the</span></span><br><span class="line"><span class="comment"> * sleep time to the timekeeping max_deferement value.</span></span><br><span class="line"><span class="comment"> * Otherwise we can sleep as long as we want.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* (2.3) 根据timekeeper的可能溢出的位宽，得到的idle最大值 */</span></span><br><span class="line">delta = timekeeping_max_deferment();</span><br><span class="line"><span class="keyword">if</span> (cpu == tick_do_timer_cpu) &#123;</span><br><span class="line">tick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>do_timer_last = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tick_do_timer_cpu != TICK_DO_TIMER_NONE) &#123;</span><br><span class="line">delta = KTIME_MAX;</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>do_timer_last = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (!ts-&gt;</span>do_timer_last) &#123;</span><br><span class="line">delta = KTIME_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_FULL</span><br><span class="line"><span class="comment">/* Limit the tick delta to the maximum scheduler deferment */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (!ts-&gt;</span>inidle)</span><br><span class="line">delta = min(delta, scheduler_tick_max_deferment());</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Calculate the next expiry time */</span></span><br><span class="line"><span class="keyword">if</span> (delta &lt; (KTIME_MAX - basemono))</span><br><span class="line">expires = basemono + delta;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">expires = KTIME_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.4) 综合上面条件，得到合理的stop tick的时间 */</span></span><br><span class="line">expires = min_t(u64, expires, next_tick);</span><br><span class="line">tick.tv64 = expires;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip reprogram of event if its not changed */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (ts-&gt;</span><span class="function"><span class="title">tick_stopped</span> &amp;&amp; (expires == dev-&gt;</span>next_event.tv64))</span><br><span class="line">goto out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nohz_stop_sched_tick can be called several times before</span></span><br><span class="line"><span class="comment"> * the nohz_restart_sched_tick is called. This happens when</span></span><br><span class="line"><span class="comment"> * interrupts arrive which do not cause a reschedule. In the</span></span><br><span class="line"><span class="comment"> * first call we save the current tick time, so we can restart</span></span><br><span class="line"><span class="comment"> * the scheduler tick in nohz_restart_sched_tick.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (!ts-&gt;</span>tick_stopped) &#123;</span><br><span class="line">nohz_balance_enter_idle(cpu);</span><br><span class="line">calc_load_enter_idle();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">last_tick</span> = hrtimer_get_expires(&amp;ts-&gt;</span>sched_timer);</span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>tick_stopped = <span class="number">1</span>;</span><br><span class="line">trace_tick_stop(<span class="number">1</span>, <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the expiration time == KTIME_MAX, then we simply stop</span></span><br><span class="line"><span class="comment"> * the tick timer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(expires == KTIME_MAX)) &#123;</span><br><span class="line"><span class="function"><span class="title">if</span> (ts-&gt;</span>nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line"><span class="function"><span class="title">hrtimer_cancel</span>(&amp;ts-&gt;</span>sched_timer);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.5) 实际的stop tick动作：</span></span><br><span class="line"><span class="comment">      将local timer的周期改为大于一个tick的时间，将idle时间延长  */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (ts-&gt;</span>nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line"><span class="function"><span class="title">hrtimer_start</span>(&amp;ts-&gt;</span>sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tick_program_event(tick, <span class="number">1</span>);</span><br><span class="line">out:</span><br><span class="line"><span class="comment">/* Update the estimated sleep length */</span></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">sleep_length</span> = ktime_sub(dev-&gt;</span>next_event, now);</span><br><span class="line">return tick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tick_nohz_idle_exit()的解析：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void tick<span class="constructor">_nohz_idle_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line">ktime_t now;</span><br><span class="line"></span><br><span class="line">local<span class="constructor">_irq_disable()</span>;</span><br><span class="line"></span><br><span class="line"><span class="constructor">WARN_ON_ONCE(!<span class="params">ts</span>-&gt;<span class="params">inidle</span>)</span>;</span><br><span class="line"></span><br><span class="line">ts-&gt;inidle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts-&gt;idle_active<span class="operator"> || </span>ts-&gt;tick_stopped)</span><br><span class="line">now = ktime<span class="constructor">_get()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts-&gt;idle_active)</span><br><span class="line">tick<span class="constructor">_nohz_stop_idle(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts-&gt;tick_stopped) &#123;</span><br><span class="line">    <span class="comment">/* (1) 重启tick任务 */</span></span><br><span class="line">tick<span class="constructor">_nohz_restart_sched_tick(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line">tick<span class="constructor">_nohz_account_idle_ticks(<span class="params">ts</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local<span class="constructor">_irq_enable()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static void tick<span class="constructor">_nohz_restart_sched_tick(<span class="params">struct</span> <span class="params">tick_sched</span> <span class="operator">*</span><span class="params">ts</span>, <span class="params">ktime_t</span> <span class="params">now</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> <span class="constructor">Update</span> jiffies first <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">tick<span class="constructor">_do_update_jiffies64(<span class="params">now</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">update<span class="constructor">_cpu_load_nohz()</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">calc<span class="constructor">_load_exit_idle()</span>;</span></span><br><span class="line"><span class="pattern-match">touch<span class="constructor">_softlockup_watchdog()</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match"> <span class="operator">*</span> <span class="constructor">Cancel</span> the scheduled timer <span class="keyword">and</span> restore the tick</span></span><br><span class="line"><span class="pattern-match"> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">ts-&gt;tick<span class="constructor">_stopped</span>  = 0;</span></span><br><span class="line"><span class="pattern-match">ts-&gt;idle<span class="constructor">_exittime</span> = now;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.1) 重启local timer <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">tick<span class="constructor">_nohz_restart(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">||</span>→</span></span><br><span class="line"><span class="pattern-match">static void tick<span class="constructor">_nohz_restart(<span class="params">struct</span> <span class="params">tick_sched</span> <span class="operator">*</span><span class="params">ts</span>, <span class="params">ktime_t</span> <span class="params">now</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">hrtimer<span class="constructor">_cancel(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">hrtimer<span class="constructor">_set_expires(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, <span class="params">ts</span>-&gt;<span class="params">last_tick</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> <span class="constructor">Forward</span> the time <span class="keyword">to</span> expire <span class="keyword">in</span> the future <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">hrtimer<span class="constructor">_forward(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, <span class="params">now</span>, <span class="params">tick_period</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (ts-&gt;nohz<span class="constructor">_mode</span> <span class="operator">==</span> <span class="constructor">NOHZ_MODE_HIGHRES</span>)</span></span><br><span class="line"><span class="pattern-match">hrtimer<span class="constructor">_start_expires(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, HRTIMER_MODE_ABS_PINNED)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">tick<span class="constructor">_program_event(<span class="params">hrtimer_get_expires</span>(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>)</span>, 1);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-tick-nohz-irq-enter-exit"><a href="#4-2-tick-nohz-irq-enter-exit" class="headerlink" title="4.2 tick_nohz_irq_enter/exit()"></a>4.2 tick_nohz_irq_enter/exit()</h3><p>因为在idle退出执行完本tick需要处理的timer后又需要重新关闭tick，系统设计了tick_nohz_irq_enter()/tick_nohz_irq_exit()来处理这种操作。在本次中断处理完timer后，在tick_nohz_irq_exit()中判断是否重新关闭tick任务。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void cpu<span class="constructor">_idle_loop(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) 关闭tick */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!need<span class="constructor">_resched()</span>) &#123;</span><br><span class="line">check<span class="constructor">_pgt_cache()</span>;</span><br><span class="line">rmb<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (2) cpu hotplug之cpu_down()的处理 */</span></span><br><span class="line"><span class="keyword">if</span> (cpu<span class="constructor">_is_offline(<span class="params">smp_processor_id</span>()</span>)) &#123;</span><br><span class="line"></span><br><span class="line">arch<span class="constructor">_cpu_idle_dead()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (3) 关中断 */</span></span><br><span class="line">local<span class="constructor">_irq_disable()</span>;</span><br><span class="line">arch<span class="constructor">_cpu_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (4) 进入idle，</span></span><br><span class="line"><span class="comment">                cpu进入暂停状态 */</span></span><br><span class="line"><span class="keyword">if</span> (cpu_idle_force_poll<span class="operator"> || </span>tick<span class="constructor">_check_broadcast_expired()</span>)</span><br><span class="line">cpu<span class="constructor">_idle_poll()</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cpuidle<span class="constructor">_idle_call()</span>;</span><br><span class="line">    <span class="comment">/* (5) cpu被local timer中断唤醒退出idle状态，继续执行；</span></span><br><span class="line"><span class="comment">        但是因为irq是disable状态，中断服务程序并不能马上得到执行*/</span></span><br><span class="line"><span class="comment">/* (5.1) 退出idle，并且开中断 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* (6) 中断打开后，被阻塞的local timer中断服务得到执行，到期的软件timer得到执行；*/</span></span><br><span class="line">                    <span class="comment">/* (6.1) 退出中断时调用tick_nohz_irq_exit()，重新计算一个tick可以被stop的值 */</span></span><br><span class="line">            </span><br><span class="line">arch<span class="constructor">_cpu_idle_exit()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (7) 重启tick */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_exit()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tick_nohz_irq_enter()/tick_nohz_irq_exit()的代码解析：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick<span class="constructor">_nohz_irq_enter(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line">ktime_t now;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ts-&gt;idle_active<span class="operator"> &amp;&amp; </span>!ts-&gt;tick_stopped)</span><br><span class="line">return;</span><br><span class="line">now = ktime<span class="constructor">_get()</span>;</span><br><span class="line"><span class="keyword">if</span> (ts-&gt;idle_active)</span><br><span class="line">tick<span class="constructor">_nohz_stop_idle(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* (1) 基本就是空操作 */</span></span><br><span class="line"><span class="keyword">if</span> (ts-&gt;tick_stopped) &#123;</span><br><span class="line">tick<span class="constructor">_nohz_update_jiffies(<span class="params">now</span>)</span>;</span><br><span class="line">tick<span class="constructor">_nohz_kick_tick(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick<span class="constructor">_nohz_irq_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts-&gt;inidle)</span><br><span class="line">    <span class="comment">/* (2) 重新判断stop tick任务 */</span></span><br><span class="line"><span class="constructor">__tick_nohz_idle_enter(<span class="params">ts</span>)</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tick<span class="constructor">_nohz_full_update_tick(<span class="params">ts</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、local-timer时钟被关闭时的处理"><a href="#4-3、local-timer时钟被关闭时的处理" class="headerlink" title="4.3、local timer时钟被关闭时的处理"></a>4.3、local timer时钟被关闭时的处理</h3><p>还有一种情况需要考虑，在系统进入深层次的idle状态时，local timer本身的时钟可能会被关闭。比如MTK平台进入soidle状态时，local timer本身会被停止，这时会用一个GPT timer来替代local timer继续工作。</p><p>核心函数是timer_setting_before_wfi()/timer_setting_after_wfi()：</p><ul><li>timer_setting_before_wfi()在进入idle前被调用，读出local timer的剩余值并配置到GPT timer中；</li><li>timer_setting_after_wfi()在退出idle后被调用，读出GPT timer的值来重新恢复local timer；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_setting_before_wfi</span><span class="params">(<span class="keyword">bool</span> f26m_off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USING_STD_TIMER_OPS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> timer_left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 读出local timer的剩余值 */</span></span><br><span class="line">timer_left = localtimer_get_counter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 根据GPT timer在不同状态下的频率，把剩余值配置到GPT中 */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)timer_left &lt;= <span class="number">0</span>)</span><br><span class="line">gpt_set_cmp(IDLE_GPT, <span class="number">1</span>); <span class="comment">/* Trigger idle_gpt Timeout imediately */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (f26m_off)</span><br><span class="line">gpt_set_cmp(IDLE_GPT, div_u64(timer_left, <span class="number">406.25</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">gpt_set_cmp(IDLE_GPT, timer_left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f26m_off)</span><br><span class="line">gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_RTC, GPT_CLK_DIV_1);</span><br><span class="line"></span><br><span class="line">start_gpt(IDLE_GPT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">gpt_get_cnt(GPT1, &amp;timer_left);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_setting_after_wfi</span><span class="params">(<span class="keyword">bool</span> f26m_off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USING_STD_TIMER_OPS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/* (3) 判断当前退出idle状态是否是因为GPT到期引起的 */</span></span><br><span class="line"><span class="keyword">if</span> (gpt_check_and_ack_irq(IDLE_GPT)) &#123;</span><br><span class="line">    <span class="comment">/* (3.1) 如果GPT时间已经到期，证明local timer也已经到期，</span></span><br><span class="line"><span class="comment">        触发local timer在下一时钟执行 */</span></span><br><span class="line">localtimer_set_next_event(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (f26m_off)</span><br><span class="line">gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* (4) 退出idle是因为GPT以外的中断源唤醒的 */</span></span><br><span class="line"><span class="comment">/* waked up by other wakeup source */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cnt, cmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (4.1) 读出GPT中的剩余到期值，重新配置到local timer中 */</span></span><br><span class="line">idle_gpt_get_cnt(IDLE_GPT, &amp;cnt);</span><br><span class="line">idle_gpt_get_cmp(IDLE_GPT, &amp;cmp);</span><br><span class="line"><span class="keyword">if</span> (unlikely(cmp &lt; cnt)) &#123;</span><br><span class="line">idle_err(<span class="string">"[%s]GPT%d: counter = %10u, compare = %10u\n"</span>,</span><br><span class="line">__func__, IDLE_GPT + <span class="number">1</span>, cnt, cmp);</span><br><span class="line"><span class="comment">/* BUG(); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f26m_off) &#123;</span><br><span class="line">localtimer_set_next_event((cmp - cnt) * <span class="number">1625</span> / <span class="number">4</span>);</span><br><span class="line">gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">localtimer_set_next_event(cmp - cnt);</span><br><span class="line">&#125;</span><br><span class="line">stop_gpt(IDLE_GPT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别说明的是，这种GPT timer全局只有一个，进入soidle的状态时cpu也只有一个在线，所以能正常的工作。</p><h2 id="5、hrtimer"><a href="#5、hrtimer" class="headerlink" title="5、hrtimer"></a>5、hrtimer</h2><h3 id="5-1、hrtimer的组织"><a href="#5-1、hrtimer的组织" class="headerlink" title="5.1、hrtimer的组织"></a>5.1、hrtimer的组织</h3><p>hrtimer的组织相对来说还是比较简单的，每个cpu对应一个hrtimer_cpu_base，每个hrtimer_cpu_base中有4类clock_base代表4种时间类型(HRTIMER_BASE_REALTIME、HRTIMER_BASE_MONOTONIC、HRTIMER_BASE_BOOTTIME、HRTIMER_BASE_TAI)的hrtimer，每个clock_base是以红黑树来组织同一类型的hrtimer的：</p><p><img src="hrtimer.png" alt="image"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">.lock</span> = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases<span class="number">.</span><span class="keyword">lock</span>),</span><br><span class="line"><span class="meta">.seq</span> = SEQCNT_ZERO(hrtimer_bases<span class="number">.</span>seq),</span><br><span class="line"><span class="meta">.clock_base</span> =</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">.index</span> = HRTIMER_BASE_MONOTONIC,</span><br><span class="line"><span class="meta">.clockid</span> = CLOCK_MONOTONIC,</span><br><span class="line"><span class="meta">.get_time</span> = &amp;ktime_get,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">.index</span> = HRTIMER_BASE_REALTIME,</span><br><span class="line"><span class="meta">.clockid</span> = CLOCK_REALTIME,</span><br><span class="line"><span class="meta">.get_time</span> = &amp;ktime_get_real,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">.index</span> = HRTIMER_BASE_BOOTTIME,</span><br><span class="line"><span class="meta">.clockid</span> = CLOCK_BOOTTIME,</span><br><span class="line"><span class="meta">.get_time</span> = &amp;ktime_get_boottime,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">.index</span> = HRTIMER_BASE_TAI,</span><br><span class="line"><span class="meta">.clockid</span> = CLOCK_TAI,</span><br><span class="line"><span class="meta">.get_time</span> = &amp;ktime_get_clocktai,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES"><a href="#5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES" class="headerlink" title="5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)"></a>5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)</h3><p>前面几章已经详细描述了执行路径，在低精度模式下hrtimer的实际精度和低精度定时器是一样的，都是基于tick精度的。他的执行路径如下。</p><p>NOHZ_MODE_INACTIVE模式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tick_handle_periodic</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">tick_periodic</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">update_process_times</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">run_local_timers</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">hrtimer_run_queues</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure><p>NOHZ_MODE_LOWRES模式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tick_nohz_handler</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">tick_sched_handle</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">update_process_times</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">run_local_timers</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">hrtimer_run_queues</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure><h3 id="5-3、高精度模式-NOHZ-MODE-HIGHRES"><a href="#5-3、高精度模式-NOHZ-MODE-HIGHRES" class="headerlink" title="5.3、高精度模式(NOHZ_MODE_HIGHRES)"></a>5.3、高精度模式(NOHZ_MODE_HIGHRES)</h3><p>在高精度模式下hrtimer才能发挥出真正的精度，他的可以精确定时到小于一个tick，精度依赖于硬件local timer。</p><p>NOHZ_MODE_LOWRES模式：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hrtimer_interrupt</span>()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">__hrtimer_run_queues</span>()</span></span><br></pre></td></tr></table></figure><h2 id="6、低精度timer-lowres-timer"><a href="#6、低精度timer-lowres-timer" class="headerlink" title="6、低精度timer(lowres timer)"></a>6、低精度timer(lowres timer)</h2><p>低精度timer在系统中的应用范围更广，若非特别声明是hrtimer其他都是使用低精度timer，类如schedule_timeout()、msleep()。他有以下特点：</p><ul><li>精度低，以tick为单位计时；</li><li>执行上下文，低精度timer执行时是在softirq中，而hrtimer的实际执行是在中断当中。所以低精度的执行精度更小于hrtimer；</li><li>对系统的实时影响小，softirq比irq对系统的实时性影响更小；</li></ul><h3 id="6-1、低精度timer的组织"><a href="#6-1、低精度timer的组织" class="headerlink" title="6.1、低精度timer的组织"></a>6.1、低精度timer的组织</h3><p>低精度timer的组织形式和hrtimer类似，只是timer的链接不是采用红黑树，而是采用tv1 - tv5等一系列的链表。</p><p><img src="lowres_timer.png" alt="image"></p><p>tv1 - tv5中保留着一系列槽位，每个槽位代表一个超时时间，把相同超时时间的低精度timer链接到同一槽位当中。</p><h3 id="6-2、低精度timer的执行路径"><a href="#6-2、低精度timer的执行路径" class="headerlink" title="6.2、低精度timer的执行路径"></a>6.2、低精度timer的执行路径</h3><p>低精度timer的实际执行时在softirq中执行的，在中断中的动作只是简单触发softirq。</p><p>中断中：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tick_handle_periodic</span>()/<span class="title">tick_nohz_handler</span>()/<span class="title">hrtimer_interrupt</span>()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">run_local_timers</span>()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">raise_softirq</span>(<span class="variable">TIMER_SOFTIRQ</span>);</span></span><br></pre></td></tr></table></figure><p>软中断中：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softir<span class="string">q()</span></span><br><span class="line">    ↓</span><br><span class="line">__run_timers()</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_DroidPhoneo"><sup>DroidPhoneo</sup>. <a href="http://blog.csdn.net/DroidPhone/article/category/1263459" target="_blank" rel="noopener">Linux 时间子系统</a><a href="#reffn_DroidPhoneo" title="Jump back to footnote [DroidPhoneo] in the text."> &#8617;</a></blockquote><blockquote id="fn_wowo"><sup>wowo</sup>. <a href="http://www.wowotech.net/timer_subsystem/time_subsystem_index.html" target="_blank" rel="noopener">wowotech time subsystem</a><a href="#reffn_wowo" title="Jump back to footnote [wowo] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hrtimer </tag>
            
            <tag> tickless </tag>
            
            <tag> monotonic time </tag>
            
            <tag> timekeeper </tag>
            
            <tag> clocksource </tag>
            
            <tag> clockevent </tag>
            
            <tag> noHZ </tag>
            
            <tag> lowres timer </tag>
            
            <tag> wall time </tag>
            
            <tag> xtime </tag>
            
            <tag> boottime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Device Tree 详解</title>
      <link href="/2018/03/20//device-tree.html/"/>
      <url>/2018/03/20//device-tree.html/</url>
      
        <content type="html"><![CDATA[<h1 id="1、DTS语法"><a href="#1、DTS语法" class="headerlink" title="1、DTS语法"></a>1、DTS语法</h1><p>对于DeviceTree的来历和用处大部分人都已经非常了解了，DeviceTree发源于PowerPC架构，为了消除代码中冗余的各种device注册代码而产生的，现在已经成为了linux的通用机制。</p><p>DeviceTree的结构非常简单，由两种元素组成：Node(节点)、Property(属性)。下图是一个真实的简单的DeviceTree树形结构图。</p><p><img src="DeviceTree.png" alt="image"></p><ul><li>Node节点。在DTS中使用一对花括号”node-name{}”来定义;</li><li>Property属性。在Node中使用”property-name=value”字符串来定义；</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">/ &#123;</span></span><br><span class="line"><span class="class">model = <span class="string">"mt6799"</span>;</span></span><br><span class="line"><span class="class">compatible = <span class="string">"mediatek,mt6799"</span>;</span></span><br><span class="line"><span class="class">interrupt-parent = <span class="params">&lt;<span class="variable">&amp;gic</span>&gt;</span>;</span></span><br><span class="line"><span class="class">#address-cells = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span></span><br><span class="line"><span class="class">#size-cells = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="comment">/* chosen */</span></span></span><br><span class="line"><span class="class"><span class="class">chosen </span>&#123;</span></span><br><span class="line"><span class="class">bootargs = <span class="string">"console=tty0 console=ttyMT0,921600n1 root=/dev/ram"</span>;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中定义了一个根节点”/“和一个子节点“chosen”，其他的字符串“model = “mt6799”;”、“compatible = “mediatek,mt6799”;”都是property。</p><p>Node、Property的名字和值都是可以自定义的，没有太大限制。但是DeviceTree的标准还是预定义了一些标准的Node和Property，在标准Node和Property之间还定义了一些约束规则。关于这些描述在 <a href="https://www.devicetree.org/" target="_blank" rel="noopener">The DeviceTree Specification</a>官方spec中有详细描述。这里为了方便大家，还是重复做一些搬运。</p><h2 id="1-1、标准Property"><a href="#1-1、标准Property" class="headerlink" title="1.1、标准Property"></a>1.1、标准Property</h2><p>Property的格式为”property-name=value”，其中value的取值类型如下：</p><table border="1"><caption> Property values： </caption><tr><th style="width: 200px;">Value</th><th style="width: 600px;">Description</th></tr><tr><td> &#60;empty&#62; </td><td>Value is empty. Used for conveying true-false information, when the presence ofabsence of the property itself is sufficiently descriptive.<br /><br />Property值为空，用property本身出现或者不出现来表示一个treue/false值。</td></tr><tr><td> &#60;u32&#62; </td><td>A 32-bit integer in big-endian format. Example: the 32-bit value 0x11223344 would be represented in memory as: <br />address 11<br />address+1 22<br />address+2 33<br />address+3 44<br /><br />32bit的值，用大端格式存储。</td></tr><tr><td> &#60;u64&#62; </td><td>Represents a 64-bit integer in big-endian format. Consists of two &#60;u32&#62; values where the first value contains the most significant bits of the integer and the second value contains the least significant bits.<br />Example: the 64-bit value 0x1122334455667788 would be represented as two cells as: <0x11223344 0x55667788>. <br />The value would be represented in memory as:<br />address 11<br />address+1 22<br />address+2 33<br />address+3 44<br />address+4 55<br />address+5 66<br />address+6 77<br />address+7 88<br /><br />64bit的值，用大端格式存储。</td></tr><tr><td> &#60;string&#62; </td><td>Strings are printable and null-terminated. Example: the string “hello” would be represented in memory as:<br />address 68 'h'<br />address+1 65 'e'<br />address+2 6C 'l'<br />address+3 6C 'l'<br />address+4 6F 'o'<br />address+5 00 '\0'<br /><br />字符串。</td></tr><tr><td> &#60;prop-encoded-array&#62; </td><td>Format is specific to the property. See the property definition.<br /><br />混合编码，自定义property的值。</td></tr><tr><td> &#60;phandle&#62; </td><td>A &#60;u32&#62; value. A phandle value is a way to reference another node in the devicetree.<br />Any node that can be referenced defines a phandle property with a unique &#60;u32&#62;value. That number is used for the value of properties with a phandle value type.<br /><br />作为一个句柄指向一个Node，用来引用Node。</td></tr><tr><td> &#60;stringlist&#62; </td><td>A list of &#60;string&#62; values concatenated together.<br />Example: The string list “hello”,”world” would be represented in memory as:<br />address 68 'h'<br />address+1 65 'e'<br />address+2 6C 'l'<br />address+3 6C 'l'<br />address+4 6F 'o'<br />address+5 00 '\0'<br />address+6 77 'w'<br />address+7 6f 'o'<br />address+8 72 'r'<br />address+9 6C 'l'<br />address+10 64 'd'<br />address+11 00 '\0'<br /><br />字符串数组。</td></tr></table><h3 id="1-1-1、compatible"><a href="#1-1-1、compatible" class="headerlink" title="1.1.1、compatible"></a>1.1.1、compatible</h3><ul><li>“compatible”属性通常用来device和driver的适配，推荐的格式为”manufacturer,model”。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">compatible</td></tr><tr><td> Value type: </td><td> &#60;stringlist&#62; </td></tr><tr><td> Description: </td><td>The compatible property value consists of one or more strings that define the specific programming model for the device. This list of strings should be used by a client program for device driver selection. The property value consists of a concatenated list of null terminated strings, from most specific to most general. They allow a device to express its compatibility with a family of similar devices, potentially allowing a single device driver to match against several devices.<br />The recommended format is "manufacturer,model", where manufacturer is a string describing the name of the manufacturer (such as a stock ticker symbol), and model specifies the model number.<br /><br /></td></tr><tr><td> Example: </td><td>compatible = "fsl,mpc8641", "ns16550"; <br /><br />In this example, an operating system would first try to locate a device driver that supported fsl,mpc8641. If a driver was not found, it would then try to locate a driver that supported the more general ns16550 device type.<br /><br />在这个例子中，device首先尝试去适配"fsl,mpc8641"driver，如果失败再去尝试适配"ns16550"driver。</td></tr></table><h3 id="1-1-2、model"><a href="#1-1-2、model" class="headerlink" title="1.1.2、model"></a>1.1.2、model</h3><ul><li>“model”属性只是简单的表示型号，root节点用其来传递值给machine_desc_str。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">model</td></tr><tr><td> Value type: </td><td> &#60;stringlist&#62; </td></tr><tr><td> Description: </td><td>The model property value is a &#60;string&#62; that specifies the manufacturer’s model number of the device.<br />The recommended format is: "manufacturer,model", where manufacturer is a string describing the name of the manufacturer (such as a stock ticker symbol), and model specifies the model number.</td></tr><tr><td> Example: </td><td>model = "fsl,MPC8349EMITX";</td></tr></table><h3 id="1-1-3、phandle"><a href="#1-1-3、phandle" class="headerlink" title="1.1.3、phandle"></a>1.1.3、phandle</h3><ul><li>“phandle”属性通用一个唯一的id来标识一个Node，在property可以使用这个id来引用Node。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">phandle</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The phandle property specifies a numerical identifier for a node that is unique within the devicetree. The phandle property value is used by other nodes that need to refer to the node associated with the property.</td></tr><tr><td> Example: </td><td>See the following devicetree excerpt:<br />pic@10000000 {<br />phandle = <1>;<br />interrupt-controller;<br />};<br /><br />A phandle value of 1 is defined. Another device node could reference the pic node with a phandle value of 1:<br />another-device-node {<br />interrupt-parent = <1>;<br />};<br /><br />Node“pic@10000000”定义了一个phandle属性，这个phandle有唯一id = <1>，在property“interrupt-parent”通过<1>对Node“pic@10000000”进行引用。</td></tr></table><p>在DeviceTree中通过另一种方式进行phandle的定义和引用更加常见：</p><ul><li>定义一个“label：”来引用Node，在编译是系统会自动为node生成一个phandle属性。”cpu0”是一个label，用来引用node”cpu@0”：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cpu0:</span> <span class="class">cpu@0 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a35"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x000</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1248000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用”&amp;”来引用“label”，即是引用phandle。property”cpu”通过”&amp;cpu0”来对node”cpu@0”：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cpu-<span class="class">map </span>&#123;</span><br><span class="line"><span class="class">cluster0 </span>&#123;</span><br><span class="line"><span class="class">core0 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu0</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class">core1 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu1</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core2 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu2</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core3 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu3</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-1-4、-address-cells-、-size-cells"><a href="#1-1-4、-address-cells-、-size-cells" class="headerlink" title="1.1.4、#address-cells 、 #size-cells"></a>1.1.4、#address-cells 、 #size-cells</h3><ul><li>“#address-cells, #size-cells”属性用来定义当前node的子node中”reg”属性的解析格式。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">#address-cells, #size-cells</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The #address-cells and #size-cells properties may be used in any device node that has children in the devicetree hierarchy and describes how child device nodes should be addressed. The #address-cells property defines the number of &#60;u32&#62; cells used to encode the address field in a child node’s reg property. The #size-cells property defines the number of &#60;u32&#62; cells used to encode the size field in a child node’s reg property.<br />The #address-cells and #size-cells properties are not inherited from ancestors in the devicetree. They shall be explicitly defined.<br />A DTSpec-compliant boot program shall supply #address-cells and #size-cells on all nodes that have children.<br />If missing, a client program should assume a default value of 2 for #address-cells, and a value of 1 for #size-cells.<br /></td></tr><tr><td> Example: </td><td>See the following devicetree excerpt:<br />soc {<br />#address-cells = <1>;<br />#size-cells = <1>;<br />&nbsp;&nbsp;&nbsp;&nbsp;serial {<br />&nbsp;&nbsp;&nbsp;&nbsp;compatible = "ns16550";<br />&nbsp;&nbsp;&nbsp;&nbsp;reg = <0x4600 0x100>;<br />&nbsp;&nbsp;&nbsp;&nbsp;clock-frequency = <0>;<br />&nbsp;&nbsp;&nbsp;&nbsp;interrupts = <0xA 0x8>;<br />&nbsp;&nbsp;&nbsp;&nbsp;interrupt-parent = <&ipic>;<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br />};<br /><br />In this example, the #address-cells and #size-cells properties of the soc node are both set to 1. This setting specifies that one cell is required to represent an address and one cell is required to represent the size of nodesthat are children of this node.<br />The serial device reg property necessarily follows this specification set in the parent (soc) node—the address is represented by a single cell (0x4600), and the size is represented by a single cell (0x100).<br /></td></tr></table><p>举例说明：</p><ul><li>1、如果node”soc”中”#address-cells=<1>“、”#size-cells=<1>“，那么子node”serial”中”reg”属性的解析为“addr1 = 0x0, size1 = 0x100, addr2 = 0x0, size2 = 0x200”：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    #size-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    serial &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x100</span> <span class="number">0x0</span> <span class="number">0x200</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、如果node”soc”中”#address-cells=<2>“、”#size-cells=<2>“，那么子node”serial”中”reg”属性的解析为“addr1 = 0x100, size1 = 0x200”：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    #size-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    serial &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x100</span> <span class="number">0x0</span> <span class="number">0x200</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、如果node”soc”中”#address-cells=<2>“、”#size-cells=<0>“，那么子node”serial”中”reg”属性的解析为“addr1 = 0x100, addr2 = 0x200”：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    #size-cells = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">    serial &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x100</span> <span class="number">0x0</span> <span class="number">0x200</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-5、reg"><a href="#1-1-5、reg" class="headerlink" title="1.1.5、reg"></a>1.1.5、reg</h3><ul><li>“reg”属性解析出”address,length”数字，解析格式依据父节点的”#address-cells、#size-cells”定义。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">reg</td></tr><tr><td> Value type: </td><td> &#60;prop-encoded-array&#62; encoded as an arbitrary number of (address, length) pairs. </td></tr><tr><td> Description: </td><td>The reg property describes the address of the device’s resources within the address space defined by its parent bus. Most commonly this means the offsets and lengths of memory-mapped IO register blocks, but may have a different meaning on some bus types. Addresses in the address space defined by the root node are CPU real addresses.<br />The value is a &#60;prop-encoded-array&#62;, composed of an arbitrary number of pairs of address and length, (address length). The number of &#60;u32&#62; cells required to specify the address and length are bus-specific and are specified by the #address-cells and #size-cells properties in the parent of the device node. If the parent node specifies a value of 0 for #size-cells, the length field in the value of reg shall be omitted.<br /></td></tr><tr><td> Example: </td><td>Suppose a device within a system-on-a-chip had two blocks of registers, a 32-byte block at offset 0x3000 in the SOC and a 256-byte block at offset 0xFE00. The reg property would be encoded as follows (assuming #address-cells and #size-cells values of 1):<br /><br />reg = <0x3000 0x20 0xFE00 0x100>;</td></tr></table><h3 id="1-1-6、ranges"><a href="#1-1-6、ranges" class="headerlink" title="1.1.6、ranges"></a>1.1.6、ranges</h3><ul><li>“ranges”属性用来做当前node和父node之间的地址映射，格式为(child-bus-address, parentbus-address, length)。其中child-bus-address的解析长度受当前node的#address-cells属性控制，parentbus-address的解析长度受父node的#address-cells属性控制length的解析长度受当前node的#size-cells属性控制。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">ranges</td></tr><tr><td> Value type: </td><td> &#60;empty&#62; or &#60;prop-encoded-array&#62; encoded as an arbitrary number of (child-bus-address, parentbus-address, length) triplets. </td></tr><tr><td> Description: </td><td>The ranges property provides a means of defining a mapping or translation between the address space of the bus (the child address space) and the address space of the bus node’s parent (the parent address space).<br />The format of the value of the ranges property is an arbitrary number of triplets of (child-bus-address, parentbus-address, length)<br />• The child-bus-address is a physical address within the child bus’ address space. The number of cells to represent the address is bus dependent and can be determined from the #address-cells of this node (the node in which the ranges property appears).<br />• The parent-bus-address is a physical address within the parent bus’ address space. The number of cells to represent the parent address is bus dependent and can be determined from the #address-cells property of the node that defines the parent’s address space.<br />• The length specifies the size of the range in the child’s address space. The number of cells to represent the size can be determined from the #size-cells of this node (the node in which the ranges property appears).<br />If the property is defined with an &#60;empty&#62; value, it specifies that the parent and child address space is identical, and no address translation is required.<br />If the property is not present in a bus node, it is assumed that no mapping exists between children of the node and the parent address space.</td></tr><tr><td> Example: </td><td>Address Translation Example:<br />soc {<br />compatible = "simple-bus";<br />#address-cells = <1>;<br />#size-cells = <1>;<br />ranges = <0x0 0xe0000000 0x00100000>;<br />serial {<br />device_type = "serial";<br />compatible = "ns16550";<br />reg = <0x4600 0x100>;<br />clock-frequency = <0>;<br />interrupts = <0xA 0x8>;<br />interrupt-parent = <&ipic>;<br />};<br />};<br /><br />The soc node specifies a ranges property of<br /><0x0 0xe0000000 0x00100000>;<br /><br />This property value specifies that for an 1024KB range of address space, a child node addressed at physical 0x0 maps to a parent address of physical 0xe0000000. With this mapping, the serial device node can be addressed by a load or store at address 0xe0004600, an offset of 0x4600 (specified in reg) plus the 0xe0000000mapping specified in ranges.</td><br /></tr></table><h3 id="1-1-7、interrupt-property"><a href="#1-1-7、interrupt-property" class="headerlink" title="1.1.7、interrupt property"></a>1.1.7、interrupt property</h3><p>和中断相关的node可以分成3种：</p><ul><li>“Interrupt Generating Devices”，中断发生设备，这种设备可以发生中断。</li><li>“Interrupt Controllers”，中断控制器，处理中断。</li><li>“Interrupt Nexus”，中断联结，路由中断给中断控制器。</li></ul><p><img src="interrupt_tree.png" alt="image"></p><h4 id="1-1-7-1、Interrupt-Generating-Devices-Property"><a href="#1-1-7-1、Interrupt-Generating-Devices-Property" class="headerlink" title="1.1.7.1、Interrupt Generating Devices Property"></a>1.1.7.1、Interrupt Generating Devices Property</h4><ul><li>“interrupts”属性用来定义设备的中断解析，根据其”interrupt-parent”node中定义的“#interrupt-cells”来解析。比如#interrupt-cells=2，那根据2个cells为单位来解析”interrupts”属性。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupts</td></tr><tr><td> Value type: </td><td> &#60;prop-encoded-array&#62; encoded as arbitrary number of interrupt specifiers </td></tr><tr><td> Description: </td><td>The interrupts property of a device node defines the interrupt or interrupts that are generated by the device.<br />The value of the interrupts property consists of an arbitrary number of interrupt specifiers. The format of an interrupt specifier is defined by the binding of the interrupt domain root.<br />interrupts is overridden by the interrupts-extended property and normally only one or the other should be used.<br /></td></tr><tr><td> Example: </td><td>A common definition of an interrupt specifier in an open PIC–compatible interrupt domain consists of two cells; an interrupt number and level/sense information. See the following example, which defines a singleinterrupt specifier, with an interrupt number of 0xA and level/sense encoding of 8.<br /><br />interrupts = <0xA 8>;<br /></td><br /></tr></table><ul><li>“interrupt-parent”属性用来制定当前设备的Interrupt Controllers/Interrupt Nexus，phandle指向对应的node。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupt-parent</td></tr><tr><td> Value type: </td><td> &#60;phandle&#62; </td></tr><tr><td> Description: </td><td>Because the hierarchy of the nodes in the interrupt tree might not match the devicetree, the interrupt-parent property is available to make the definition of an interrupt parent explicit. The value is the phandle to the interrupt parent. If this property is missing from a device, its interrupt parent is assumed to be its devicetree parent.<br /></td></tr></table><h4 id="1-1-7-2、Interrupt-Controllers-Property"><a href="#1-1-7-2、Interrupt-Controllers-Property" class="headerlink" title="1.1.7.2、Interrupt Controllers Property"></a>1.1.7.2、Interrupt Controllers Property</h4><ul><li>“#interrupt-cells”属性用来规定连接到该中断控制器上的设备的”interrupts”属性的解析长度。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">#interrupt-cells</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The #interrupt-cells property defines the number of cells required to encode an interrupt specifier for an interrupt domain.<br /></td></tr></table><ul><li>“interrupt-controller”属性用来声明当前node为中断控制器。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupt-controller</td></tr><tr><td> Value type: </td><td> &#60;empty&#62; </td></tr><tr><td> Description: </td><td>The presence of an interrupt-controller property defines a node as an interrupt controller node.<br /></td></tr></table><h4 id="1-1-7-3、Interrupt-Nexus-Property"><a href="#1-1-7-3、Interrupt-Nexus-Property" class="headerlink" title="1.1.7.3、Interrupt Nexus Property"></a>1.1.7.3、Interrupt Nexus Property</h4><ul><li>“#interrupt-cells”属性用来规定连接到该中断控制器上的设备的”interrupts”属性的解析长度。</li></ul><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">#interrupt-cells</td></tr><tr><td> Value type: </td><td> &#60;u32&#62; </td></tr><tr><td> Description: </td><td>The #interrupt-cells property defines the number of cells required to encode an interrupt specifier for an interrupt domain.<br /></td></tr></table><ul><li>“interrupt-map”属性用来描述interrupt nexus设备对中断的路由。解析格式为5元素序列“child unit address, child interrupt specifier, interrupt-parent, parent unit address, parent interrupt specifier”。</li></ul><p>其中：</p><p>“child unit address”的cells长度由子节点的“#address-cells”指定；<br>“child interrupt specifier”的cells长度由子节点的“#interrupt-cells”指定；<br>“interrupt-parent”phandle指向interrupt controller的引用；<br>“parent unit address”的cells长度由父节点的“#address-cells”指定；<br>“parent interrupt specifier”的cells长度由父节点的“#interrupt-cells”指定；</p><table border="1"><tr><td style="width: 200px;">Property name:</td><td style="width: 600px;">interrupt-map</td></tr><tr><td> Value type: </td><td> &#60;prop-encoded-array&#62; encoded as an arbitrary number of interrupt mapping entries. </td></tr><tr><td> Description: </td><td>An interrupt-map is a property on a nexus node that bridges one interrupt domain with a set of parent interrupt domains and specifies how interrupt specifiers in the child domain are mapped to their respective parentdomains.<br />The interrupt map is a table where each row is a mapping entry consisting of five components: <i>child unit address, child interrupt specifier, interrupt-parent, parent unit address, parent interrupt specifier.</i><br /><b>child unit address</b> The unit address of the child node being mapped. The number of 32-bit cells required to specify this is described by the #address-cells property of the bus node on which the child is located.<br /><b>child interrupt specifier</b> The interrupt specifier of the child node being mapped. The number of 32-bit cells required to specify this component is described by the #interrupt-cells property of this node—the nexus node containing the interrupt-map property.<br /><b>interrupt-parent</b> A single &#60;phandle&#62; value that points to the interrupt parent to which the child domain is being mapped.<br /><b>parent unit address</b> The unit address in the domain of the interrupt parent. The number of 32-bit cells required to specify this address is described by the #address-cells property of the node pointed to by the interrupt-parent field.<br /><b>parent interrupt specifier</b> The interrupt specifier in the parent domain. The number of 32-bit cells required to specify this component is described by the #interrupt-cells property of the node pointed to by the interrupt-parent field.<br />Lookups are performed on the interrupt mapping table by matching a unit-address/interrupt specifier pair against the child components in the interrupt-map. Because some fields in the unit interrupt specifier may not be relevant, a mask is applied before the lookup is done. This mask is defined in the interrupt-map-mask property (see section 2.4.3.2).<br /></td></tr></table><p>举例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    compatible = <span class="string">"simple-bus"</span>;</span><br><span class="line">    #address-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    #size-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    open-pic &#123;</span><br><span class="line">        clock-frequency = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        <span class="built_in">int</span>errupt-controller;</span><br><span class="line">        #address-cells = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        #<span class="built_in">int</span>errupt-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    pci &#123;</span><br><span class="line">        #<span class="built_in">int</span>errupt-cells = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">        #size-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">        #address-cells = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">        <span class="built_in">int</span>errupt-map-mask = &lt;<span class="number">0xf800</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span>&gt;;</span><br><span class="line">        <span class="built_in">int</span>errupt-map = &lt;</span><br><span class="line">        <span class="comment">/* IDSEL 0x11 - PCI slot 1 */</span></span><br><span class="line">        <span class="number">0x8800</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> &amp;open-pic <span class="number">2</span> <span class="number">1</span> <span class="comment">/* INTA */</span></span><br><span class="line">        <span class="number">0x8800</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> &amp;open-pic <span class="number">3</span> <span class="number">1</span> <span class="comment">/* INTB */</span></span><br><span class="line">        <span class="number">0x8800</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> &amp;open-pic <span class="number">4</span> <span class="number">1</span> <span class="comment">/* INTC */</span></span><br><span class="line">        <span class="number">0x8800</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> &amp;open-pic <span class="number">1</span> <span class="number">1</span> <span class="comment">/* INTD */</span></span><br><span class="line">        <span class="comment">/* IDSEL 0x12 - PCI slot 2 */</span></span><br><span class="line">        <span class="number">0x9000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> &amp;open-pic <span class="number">3</span> <span class="number">1</span> <span class="comment">/* INTA */</span></span><br><span class="line">        <span class="number">0x9000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> &amp;open-pic <span class="number">4</span> <span class="number">1</span> <span class="comment">/* INTB */</span></span><br><span class="line">        <span class="number">0x9000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> &amp;open-pic <span class="number">1</span> <span class="number">1</span> <span class="comment">/* INTC */</span></span><br><span class="line">        <span class="number">0x9000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> &amp;open-pic <span class="number">2</span> <span class="number">1</span> <span class="comment">/* INTD */</span></span><br><span class="line">        &gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">•</span> <span class="string">For</span> <span class="string">example,</span> <span class="string">the</span> <span class="string">first</span> <span class="string">row</span> <span class="string">of</span> <span class="string">the</span> <span class="string">interrupt-map</span> <span class="string">table</span> <span class="string">specifies</span> <span class="string">the</span> <span class="string">mapping</span> <span class="string">for</span> <span class="string">INTA</span> <span class="string">of</span> <span class="string">slot</span> <span class="number">1</span><span class="string">.</span> <span class="string">The</span> <span class="string">components</span> <span class="string">of</span> <span class="string">that</span> <span class="string">row</span> <span class="string">are</span> <span class="string">shown</span> <span class="string">here</span></span><br><span class="line">    <span class="attr">child unit address:</span> <span class="number">0x8800</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">child interrupt specifier:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">interrupt parent:</span> <span class="string">&amp;open-pic</span></span><br><span class="line">    <span class="attr">parent unit address:</span> <span class="string">(empty</span> <span class="string">because</span> <span class="comment">#address-cells = &lt;0&gt; in the open-pic node)</span></span><br><span class="line">    <span class="attr">parent interrupt specifier:</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="1-2、标准Node"><a href="#1-2、标准Node" class="headerlink" title="1.2、标准Node"></a>1.2、标准Node</h2><p>Node Name常常由两部分组成“node-name@unit-address”，主要是为了防止Node Name重复冲突：</p><ul><li>“node-name”是node的名字；</li><li>“unit-address”是node中“reg”属性描述的开始地址；</li></ul><p>例如：”msdc@11240000”中node-name=“msdc”，unit-address=“11240000”。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">/ &#123;</span></span><br><span class="line"><span class="class">model = <span class="string">"mt6799"</span>;</span></span><br><span class="line"><span class="class">compatible = <span class="string">"mediatek,mt6799"</span>;</span></span><br><span class="line"><span class="class">interrupt-parent = <span class="params">&lt;<span class="variable">&amp;gic</span>&gt;</span>;</span></span><br><span class="line"><span class="class">#address-cells = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span></span><br><span class="line"><span class="class">#size-cells = <span class="params">&lt;<span class="number">2</span>&gt;</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="symbol">msdc0:</span><span class="class">msdc@11240000 </span>&#123;</span></span><br><span class="line"><span class="class">compatible = <span class="string">"mediatek,msdc"</span>;</span></span><br><span class="line"><span class="class">reg = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x11240000</span> <span class="number">0x0</span> <span class="number">0x10000</span></span></span></span><br><span class="line"><span class="class"><span class="params">       <span class="number">0x0</span> <span class="number">0x10000e84</span> <span class="number">0x0</span> <span class="number">0x2</span>&gt;</span>;    <span class="comment">/* FPGA PWR_GPIO, PWR_GPIO_EO */</span></span></span><br><span class="line"><span class="class">interrupts = <span class="params">&lt;GIC_SPI <span class="number">79</span> IRQ_TYPE_LEVEL_LOW&gt;</span>;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure><p>下面主要介绍一下一些预先定义的标准Node。</p><h3 id="1-2-1、Root-node"><a href="#1-2-1、Root-node" class="headerlink" title="1.2.1、Root node"></a>1.2.1、Root node</h3><p>每个DeviceTree只有一个根节点。根节点需要有以下必备属性：</p><table border="1"><caption>  Root Node Properties </caption><tr><th style="width: 150px;">Property Name</th><th style="width: 100px;">Usage</th><th style="width: 150px;">Value Type</th><th style="width: 600px;">Definition</th></tr><tr><td> #address-cells </td><td> R </td><td> &#60;u32&#62; </td><td> Specifies the number of &#60;u32&#62; cells to represent the address in the reg  property in children of root. </td></tr><tr><td> #size-cells </td><td> R </td><td> &#60;u32&#62; </td><td> Specifies the number of &#60;u32&#62; cells to represent the size in the reg property in children of root. </td></tr><tr><td> model </td><td> R </td><td> &#60;string&#62; </td><td> Specifies a string that uniquely identifies the model of the system board. The recommended format is “manufacturer,model-number”.</td></tr><tr><td> compatible </td><td> R </td><td> &#60;stringlist&#62; </td><td> Specifies a list of platform architectures with which this platform is compatible. This property can be used by operating systems in selectingplatform specific code. The recommended form of the property value is:<br />"manufacturer,model"<br /><br />For example:<br />compatible = "fsl,mpc8572ds"<br /></td></tr></table><h3 id="1-2-2、-aliases-node"><a href="#1-2-2、-aliases-node" class="headerlink" title="1.2.2、/aliases node"></a>1.2.2、/aliases node</h3><p>用来给一些绝对路径定义别名：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    serial<span class="number">0</span> = <span class="string">"/simple-bus@fe000000/serial@llc500"</span>;</span><br><span class="line">    ethernet<span class="number">0</span> = <span class="string">"/simple-bus@fe000000/ethernet@31c000"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-3、-memory-node"><a href="#1-2-3、-memory-node" class="headerlink" title="1.2.3、/memory node"></a>1.2.3、/memory node</h3><p>用来传递内存布局：</p><table border="1"><caption>  /memory Node Properties </caption><tr><th style="width: 150px;">Property Name</th><th style="width: 100px;">Usage</th><th style="width: 150px;">Value Type</th><th style="width: 600px;">Definition</th></tr><tr><td> device_type </td><td> R </td><td> &#60;string&#62; </td><td> Value shall be “memory”</td></tr><tr><td> reg </td><td> R </td><td> &#60;prop-encoded-array&#62; </td><td> Consists of an arbitrary number of address and size pairs that specify the physical address and size of the memory ranges.</td></tr><tr><td> initial-mapped-area </td><td> O </td><td> &#60;prop-encoded-array&#62; </td><td> Specifies the address and size of the Initial Mapped AreaIs a prop-encoded-array consisting of a triplet of (effective address, physical address, size).The effective and physical address shall each be 64-bit (&#60;u64&#62; value), and the size shall be 32-bits (&#60;u32&#62; value).</td></tr></table><p>举例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• RAM: starting<span class="built_in"> address </span>0x0, length 0x80000000 (2GB)</span><br><span class="line">• RAM: starting<span class="built_in"> address </span>0x100000000, length 0x100000000 (4GB)</span><br></pre></td></tr></table></figure></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\ &#123;</span><br><span class="line">    #address-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    #size-cells = &lt;<span class="number">2</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">memory@</span><span class="number">0</span> &#123;</span><br><span class="line">        device_type = <span class="string">"memory"</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x000000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x80000000</span></span><br><span class="line">        <span class="number">0x000000001</span> <span class="number">0x00000000</span> <span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4、-chosen-node"><a href="#1-2-4、-chosen-node" class="headerlink" title="1.2.4、/chosen node"></a>1.2.4、/chosen node</h3><p>其中“bootargs”属性用来传递cmdline参数，“stdout-path”属性用来指定标准输出设备，“stdin-path”属性用来指定标准输入设备。</p><table border="1"><caption>  /chosen Node Properties </caption><tr><th style="width: 150px;">Property Name</th><th style="width: 100px;">Usage</th><th style="width: 150px;">Value Type</th><th style="width: 600px;">Definition</th></tr><tr><td> bootargs </td><td> O </td><td> &#60;string&#62; </td><td> A string that specifies the boot arguments for the client program. The value could potentially be a null string if no boot arguments are required.</td></tr><tr><td> stdout-path </td><td> O </td><td> &#60;string&#62; </td><td> A string that specifies the full path to the node representing the device to be used for boot console output. If the character “:” is present in the value it terminates the path. The value may be an alias. If the stdin-path property isnot specified, stdout-path should be assumed to define the input device.</td></tr><tr><td> stdin-path </td><td> O </td><td> &#60;string&#62; </td><td> A string that specifies the full path to the node representing the device to be used for boot console input. If the character “:” is present in the value it terminates the path. The value may be an alias.</td></tr></table><p>举例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* chosen */</span><br><span class="line">chosen &#123;</span><br><span class="line">bootargs = <span class="string">"console=tty0 console=ttyMT0,921600n1 root=/dev/ram"</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-5、-cpus-node"><a href="#1-2-5、-cpus-node" class="headerlink" title="1.2.5、/cpus node"></a>1.2.5、/cpus node</h3><p>/cpus节点也是必须的，下面举个具体例子：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">cpus </span>&#123;</span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu0:</span> <span class="class">cpu@0 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a35"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x000</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1248000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu1:</span> <span class="class">cpu@001 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a35"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x001</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1248000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu2:</span> <span class="class">cpu@002 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a35"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x002</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1248000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu3:</span> <span class="class">cpu@003 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a35"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x003</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1248000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu4:</span> <span class="class">cpu@100 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a53"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x100</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1378000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu5:</span> <span class="class">cpu@101 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a53"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x101</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1378000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu6:</span> <span class="class">cpu@102 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a53"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x102</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1378000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu7:</span> <span class="class">cpu@103 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a53"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x103</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1378000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu8:</span> <span class="class">cpu@200 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a73"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x200</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1638000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">cpu9:</span> <span class="class">cpu@201 </span>&#123;</span><br><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">compatible = <span class="string">"arm,cortex-a73"</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x201</span>&gt;</span>;</span><br><span class="line">enable-method = <span class="string">"psci"</span>;</span><br><span class="line">cpu-idle-states = <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_MCDI <span class="variable">&amp;</span>LEGACY_SODI <span class="variable">&amp;</span>LEGACY_SODI3 <span class="variable">&amp;</span>LEGACY_DPIDLE&gt;</span>,</span><br><span class="line">  <span class="params">&lt;<span class="variable">&amp;</span>LEGACY_SUSPEND <span class="variable">&amp;</span>MCDI <span class="variable">&amp;</span>SODI <span class="variable">&amp;</span>SODI3 <span class="variable">&amp;</span>DPIDLE <span class="variable">&amp;</span>SUSPEND&gt;</span>;</span><br><span class="line">cpu-release-addr = <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x40000200</span>&gt;</span>;</span><br><span class="line">clock-frequency = <span class="params">&lt;<span class="number">1638000000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpu-<span class="class">map </span>&#123;</span><br><span class="line"><span class="class">cluster0 </span>&#123;</span><br><span class="line"><span class="class">core0 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu0</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class">core1 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu1</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core2 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu2</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core3 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu3</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">cluster1 </span>&#123;</span><br><span class="line"><span class="class">core0 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu4</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core1 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu5</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core2 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu6</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core3 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu7</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">cluster2 </span>&#123;</span><br><span class="line"><span class="class">core0 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu8</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class">core1 </span>&#123;</span><br><span class="line">cpu = <span class="params">&lt;<span class="variable">&amp;cpu9</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">idle-<span class="class">states </span>&#123;</span><br><span class="line">entry-method = <span class="string">"arm,psci"</span>;</span><br><span class="line"></span><br><span class="line"><span class="symbol">LEGACY_MCDI:</span> legacy-<span class="class">mcdi </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x0000001</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">1200</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">LEGACY_SODI:</span> legacy-<span class="class">sodi </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x0000002</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">1200</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">LEGACY_SODI3:</span> legacy-<span class="class">sodi3 </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x0000003</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">1200</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">LEGACY_DPIDLE:</span> legacy-<span class="class">dpidle </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x0000004</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">1200</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">LEGACY_SUSPEND:</span> legacy-<span class="class">suspend </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x0000005</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">1200</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">MCDI:</span> <span class="class">mcdi </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x0010001</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">600</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">1200</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">SODI:</span> <span class="class">sodi </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x1010002</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">800</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">1000</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">2000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">SODI3:</span> <span class="class">sodi3 </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x1010003</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">800</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">1000</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">2000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">DPIDLE:</span> <span class="class">dpidle </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x1010004</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">800</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">1000</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">2000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">SUSPEND:</span> <span class="class">suspend </span>&#123;</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = <span class="params">&lt;<span class="number">0x1010005</span>&gt;</span>;</span><br><span class="line">entry-latency-us = <span class="params">&lt;<span class="number">800</span>&gt;</span>;</span><br><span class="line">exit-latency-us = <span class="params">&lt;<span class="number">1000</span>&gt;</span>;</span><br><span class="line">min-residency-us = <span class="params">&lt;<span class="number">2000</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2、DTB"><a href="#2、DTB" class="headerlink" title="2、DTB"></a>2、DTB</h1><h2 id="2-1、DTB的编译"><a href="#2-1、DTB的编译" class="headerlink" title="2.1、DTB的编译"></a>2.1、DTB的编译</h2><p>DTB(Devicetree Blob)是DTS的二进制文件格式，Kernel使用DTC工具将DTS源文件编译成DTB，bootloader再将DTB文件传递给Kernel解析。</p><p>不遵守标准书写的DTS文件在编译的时候会报错。</p><h2 id="2-2、DTB的文件结构"><a href="#2-2、DTB的文件结构" class="headerlink" title="2.2、DTB的文件结构"></a>2.2、DTB的文件结构</h2><p><img src="dtb_struct.png" alt="image"></p><p>DTB文件的结构如上图所示，主要在3部分：</p><ul><li>struct ftd_header。文件头结构；</li><li>structure block。存放含Node和Property的Value；</li><li>strings block。存放Property的Name；把Property Name单独分为一个区域的原因是，有很多Property Name是重复的，单独一个区域可以使用指针引用，节约空间。</li></ul><p>dtb中的fdt_header的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;</span><br><span class="line">    <span class="keyword">uint32_t</span> totalsize;</span><br><span class="line">    <span class="keyword">uint32_t</span> off_dt_struct;</span><br><span class="line">    <span class="keyword">uint32_t</span> off_dt_strings;</span><br><span class="line">    <span class="keyword">uint32_t</span> off_mem_rsvmap;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_comp_version;</span><br><span class="line">    <span class="keyword">uint32_t</span> boot_cpuid_phys;</span><br><span class="line">    <span class="keyword">uint32_t</span> size_dt_strings;</span><br><span class="line">    <span class="keyword">uint32_t</span> size_dt_struct;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dtb中node header的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_node_header</span> &#123;</span></span><br><span class="line"><span class="keyword">fdt32_t</span> tag;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">0</span>];   <span class="comment">// node name 存放在structure block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dtb中property header的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_property</span> &#123;</span></span><br><span class="line"><span class="keyword">fdt32_t</span> tag;</span><br><span class="line"><span class="keyword">fdt32_t</span> len;</span><br><span class="line"><span class="keyword">fdt32_t</span> nameoff;    <span class="comment">// perperty name存放在strings block</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个文件使用5种token来分割出node和property：</p><ul><li>FDT_BEGIN_NODE (0x00000001)</li><li>FDT_END_NODE (0x00000002)</li><li>FDT_PROP (0x00000003)</li><li>FDT_NOP (0x00000004)</li><li>FDT_END (0x00000009)</li></ul><p>可以使用hex编辑器来查看DTB文件的结构：</p><p><img src="dtb_hex_example.png" alt="image"></p><h2 id="2-3、Bootloader对DTB的传递"><a href="#2-3、Bootloader对DTB的传递" class="headerlink" title="2.3、Bootloader对DTB的传递"></a>2.3、Bootloader对DTB的传递</h2><p>没有仔细去看</p><h1 id="3、Kernel解析"><a href="#3、Kernel解析" class="headerlink" title="3、Kernel解析"></a>3、Kernel解析</h1><h2 id="3-1、DTB解析"><a href="#3-1、DTB解析" class="headerlink" title="3.1、DTB解析"></a>3.1、DTB解析</h2><h3 id="3-1-1-setup-machine-fdt"><a href="#3-1-1-setup-machine-fdt" class="headerlink" title="3.1.1 setup_machine_fdt()"></a>3.1.1 setup_machine_fdt()</h3><p>直接在dtb中解析根节点的一些属性和子节点给系统早期使用。</p><ul><li>解析”/“节点的model”属性给machine_desc赋值；</li><li>解析”/chosen”node中的”bootargs”属性给boot_command_line；</li><li>解析”/“节点的”#size-cells”、”#address-cells”属性；</li><li>解析”/memory”node中的”reg”属性，并将memory区域加入到系统；</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">start_kernel<span class="function"><span class="params">()</span> -&gt;</span> setup_arch<span class="function"><span class="params">()</span> -&gt;</span> setup_machine_fdt():</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static <span class="literal">void</span> __init setup_machine_fdt(phys_addr_t dt_phys)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* (1) 映射dtb内存，到使之可以访问 */</span></span><br><span class="line"><span class="literal">void</span> *dt_virt = fixmap_remap_fdt(dt_phys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 早期扫描device tree中的一些node和property */</span></span><br><span class="line"><span class="keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;</span><br><span class="line">pr_crit(<span class="string">"\n"</span></span><br><span class="line"><span class="string">"Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n"</span></span><br><span class="line"><span class="string">"The dtb must be 8-byte aligned and must not exceed 2 MB in size\n"</span></span><br><span class="line"><span class="string">"\nPlease check your bootloader."</span>,</span><br><span class="line">&amp;dt_phys, dt_virt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">cpu_relax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (3) 使用device tree中root node的"model/compatible"属性给machine_desc赋值 */</span></span><br><span class="line">machine_desc_set(of_flat_dt_get_machine_name());</span><br><span class="line">dump_stack_set_arch_desc(<span class="string">"%s (DT)"</span>, of_flat_dt_get_machine_name());</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">bool __init early_init_dt_scan(<span class="literal">void</span> *params)</span><br><span class="line">&#123;</span><br><span class="line">bool status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1)校验dtb数据 */</span></span><br><span class="line">status = early_init_dt_verify(params);</span><br><span class="line"><span class="keyword">if</span> (!status)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2) */</span></span><br><span class="line">early_init_dt_scan_nodes();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="literal">void</span> __init early_init_dt_scan_nodes(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* (2.2.1) 解析"/chosen"node中的"bootargs"属性 */</span></span><br><span class="line"><span class="comment">/* Retrieve various information from the /chosen node */</span></span><br><span class="line">of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.2) 解析"/"node中的"#size-cells"、"#address-cells"属性 */</span></span><br><span class="line"><span class="comment">/* Initialize &#123;size,address&#125;-cells info */</span></span><br><span class="line">of_scan_flat_dt(early_init_dt_scan_root, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.3) 解析"/memory"node中的"reg"属性，并将memory区域加入到系统 */</span></span><br><span class="line"><span class="comment">/* Setup memory, calling early_init_dt_add_memory_arch */</span></span><br><span class="line">of_scan_flat_dt(early_init_dt_scan_memory, NULL);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">early_init_dt_scan_memory<span class="function"><span class="params">()</span> -&gt;</span> early_init_dt_add_memory_arch<span class="function"><span class="params">()</span> -&gt;</span> memblock_add()</span><br></pre></td></tr></table></figure><h3 id="3-1-2-unflatten-device-tree"><a href="#3-1-2-unflatten-device-tree" class="headerlink" title="3.1.2 unflatten_device_tree()"></a>3.1.2 unflatten_device_tree()</h3><p>将DTB完全解析为内核使用的的device_node、property结构：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; setup_arch() -&gt; unflatten_device_tree():</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">unflatten_device_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* (1) 解析dtb数据到kernel中 */</span></span><br><span class="line">__unflatten_device_tree(initial_boot_params, &amp;of_root,</span><br><span class="line">early_init_dt_alloc_memory_arch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 扫描"/aliases"、"/chosen"节点来进行一些预制值的配置 */</span></span><br><span class="line"><span class="comment">/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */</span></span><br><span class="line">of_alias_scan(early_init_dt_alloc_memory_arch);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __unflatten_device_tree(<span class="keyword">const</span> <span class="keyword">void</span> *blob,</span><br><span class="line">     struct device_node **mynodes,</span><br><span class="line">     <span class="keyword">void</span> * (*dt_alloc)(u64 <span class="built_in">size</span>, u64 align))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">void</span> *mem;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">" -&gt; unflatten_device_tree()\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!blob) &#123;</span><br><span class="line">pr_debug(<span class="string">"No device tree pointer\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"Unflattening device tree:\n"</span>);</span><br><span class="line">pr_debug(<span class="string">"magic: %08x\n"</span>, fdt_magic(blob));</span><br><span class="line">pr_debug(<span class="string">"size: %08x\n"</span>, fdt_totalsize(blob));</span><br><span class="line">pr_debug(<span class="string">"version: %08x\n"</span>, fdt_version(blob));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fdt_check_header(blob)) &#123;</span><br><span class="line">pr_err(<span class="string">"Invalid device tree blob header\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1) 第一遍扫描，计算dtb解析需要的内存空间 */</span></span><br><span class="line"><span class="comment">/* First pass, scan for size */</span></span><br><span class="line">start = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">size</span> = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)unflatten_dt_node(blob, <span class="literal">NULL</span>, &amp;start, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">size</span> = ALIGN(<span class="built_in">size</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"  size is %lx, allocating...\n"</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.2) 分配所需内存 */</span></span><br><span class="line"><span class="comment">/* Allocate memory for the expanded device tree */</span></span><br><span class="line">mem = dt_alloc(<span class="built_in">size</span> + <span class="number">4</span>, __alignof__(struct device_node));</span><br><span class="line"><span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">*(__be32 *)(mem + <span class="built_in">size</span>) = cpu_to_be32(<span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"  unflattening %p...\n"</span>, mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.3)第二遍扫描，在分配的内存中创建device_node、property树形结构来存储dtb的解析 */</span></span><br><span class="line"><span class="comment">/* Second pass, do actual unflattening */</span></span><br><span class="line">start = <span class="number">0</span>;</span><br><span class="line">unflatten_dt_node(blob, mem, &amp;start, <span class="literal">NULL</span>, mynodes, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (be32_to_cpup(mem + <span class="built_in">size</span>) != <span class="number">0xdeadbeef</span>)</span><br><span class="line">pr_warning(<span class="string">"End of tree marker overwritten: %08x\n"</span>,</span><br><span class="line">   be32_to_cpup(mem + <span class="built_in">size</span>));</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">" &lt;- unflatten_device_tree()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">unflatten_dt_node</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *blob,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *mem,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> *poffset,</span></span></span><br><span class="line"><span class="function"><span class="params">struct device_node *dad,</span></span></span><br><span class="line"><span class="function"><span class="params">struct device_node **nodepp,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> fpsize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> dryrun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> __be32 *p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">pp</span>, **<span class="title">prev_pp</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pathp;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> l, allocl;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> depth;</span><br><span class="line"><span class="keyword">int</span> old_depth;</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line"><span class="keyword">int</span> has_name = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> new_format = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.1) 解析node，解析node中的name值 */</span></span><br><span class="line">pathp = fdt_get_name(blob, *poffset, &amp;l);</span><br><span class="line"><span class="keyword">if</span> (!pathp)</span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line"></span><br><span class="line">allocl = ++l;<span class="comment">/* l 为当前路径的长度 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* version 0x10 has a more compact unit name here instead of the full</span></span><br><span class="line"><span class="comment"> * path. we accumulate the full path size using "fpsize", we'll rebuild</span></span><br><span class="line"><span class="comment"> * it later. We detect this because the first character of the name is</span></span><br><span class="line"><span class="comment"> * not '/'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((*pathp) != <span class="string">'/'</span>) &#123;</span><br><span class="line">new_format = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (fpsize == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* root node: special case. fpsize accounts for path</span></span><br><span class="line"><span class="comment"> * plus terminating zero. root node only has '/', so</span></span><br><span class="line"><span class="comment"> * fpsize should be 2, but we want to avoid the first</span></span><br><span class="line"><span class="comment"> * level nodes to have two '/' so we use fpsize 1 here</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fpsize = <span class="number">1</span>;</span><br><span class="line">allocl = <span class="number">2</span>;</span><br><span class="line">l = <span class="number">1</span>;</span><br><span class="line">pathp = <span class="string">""</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* account for '/' and path size minus terminal 0</span></span><br><span class="line"><span class="comment"> * already in 'l'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fpsize += l;<span class="comment">/* 当前full path的长度 = 上一次full path的长度 + 当前node nam的长度 l */</span></span><br><span class="line">allocl = fpsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算解析当前node节点需要的内存大小 = device_node + full path  */</span></span><br><span class="line">np = unflatten_dt_alloc(&amp;mem, <span class="keyword">sizeof</span>(struct device_node) + allocl,</span><br><span class="line">__alignof__(struct device_node));</span><br><span class="line">    <span class="comment">/*  dryrun = true，只进行长度计算</span></span><br><span class="line"><span class="comment">     dryrun = fasle，进行实际的赋值  */</span></span><br><span class="line"><span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line"><span class="keyword">char</span> *fn;</span><br><span class="line">of_node_init(np);</span><br><span class="line">np-&gt;full_name = fn = ((<span class="keyword">char</span> *)np) + <span class="keyword">sizeof</span>(*np); <span class="comment">/* device_node-&gt;full_name，指向device_node结构体的结尾 */</span> </span><br><span class="line"><span class="keyword">if</span> (new_format) &#123;</span><br><span class="line"><span class="comment">/* rebuild full path for new format */</span></span><br><span class="line"><span class="keyword">if</span> (dad &amp;&amp; dad-&gt;parent) &#123;</span><br><span class="line">                 <span class="comment">/* 先拷入上次的full name */</span></span><br><span class="line"><span class="built_in">strcpy</span>(fn, dad-&gt;full_name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strlen</span>(fn) + l + <span class="number">1</span>) != allocl) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s: p: %d, l: %d, a: %d\n"</span>,</span><br><span class="line">pathp, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(fn),</span><br><span class="line">l, allocl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">fn += <span class="built_in">strlen</span>(fn);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">/* 再加上 '/' */</span></span><br><span class="line">*(fn++) = <span class="string">'/'</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 最后加上当前node的name */</span></span><br><span class="line"><span class="built_in">memcpy</span>(fn, pathp, l);</span><br><span class="line"></span><br><span class="line">prev_pp = &amp;np-&gt;properties;</span><br><span class="line">        <span class="comment">/* node和node之间树形结构的创建 */</span></span><br><span class="line"><span class="keyword">if</span> (dad != <span class="literal">NULL</span>) &#123;</span><br><span class="line">np-&gt;parent = dad;</span><br><span class="line">np-&gt;sibling = dad-&gt;child;</span><br><span class="line">dad-&gt;child = np;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.2) 解析node中的property */</span></span><br><span class="line"><span class="comment">/* process properties */</span></span><br><span class="line"><span class="keyword">for</span> (offset = fdt_first_property_offset(blob, *poffset);</span><br><span class="line">     (offset &gt;= <span class="number">0</span>);</span><br><span class="line">     (offset = fdt_next_property_offset(blob, offset))) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pname;</span><br><span class="line">u32 sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 解析一个property：</span></span><br><span class="line"><span class="comment">          p：property中的data</span></span><br><span class="line"><span class="comment">          pname：property的name指针，实际存储位置在dt_strings区域中</span></span><br><span class="line"><span class="comment">         sz：property data的长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">if</span> (!(p = fdt_getprop_by_offset(blob, offset, &amp;pname, &amp;sz))) &#123;</span><br><span class="line">offset = -FDT_ERR_INTERNAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pname == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pr_info(<span class="string">"Can't find property name in list !\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pname, <span class="string">"name"</span>) == <span class="number">0</span>)</span><br><span class="line">has_name = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 计算解析当前property的内存大小 = property */</span></span><br><span class="line">pp = unflatten_dt_alloc(&amp;mem, <span class="keyword">sizeof</span>(struct property),</span><br><span class="line">__alignof__(struct property));</span><br><span class="line">        <span class="comment">/* 实际的property赋值 */</span></span><br><span class="line"><span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line"><span class="comment">/* We accept flattened tree phandles either in</span></span><br><span class="line"><span class="comment"> * ePAPR-style "phandle" properties, or the</span></span><br><span class="line"><span class="comment"> * legacy "linux,phandle" properties.  If both</span></span><br><span class="line"><span class="comment"> * appear and have different values, things</span></span><br><span class="line"><span class="comment"> * will get weird.  Don't do that. */</span></span><br><span class="line">            <span class="comment">/* 如果property为"phandle"，设置父node的device_node-&gt;phandle为当前属性的值 */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(pname, <span class="string">"phandle"</span>) == <span class="number">0</span>) ||</span><br><span class="line">    (<span class="built_in">strcmp</span>(pname, <span class="string">"linux,phandle"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (np-&gt;phandle == <span class="number">0</span>)</span><br><span class="line">np-&gt;phandle = be32_to_cpup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* And we process the "ibm,phandle" property</span></span><br><span class="line"><span class="comment"> * used in pSeries dynamic device tree</span></span><br><span class="line"><span class="comment"> * stuff */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pname, <span class="string">"ibm,phandle"</span>) == <span class="number">0</span>)</span><br><span class="line">np-&gt;phandle = be32_to_cpup(p);</span><br><span class="line">            <span class="comment">/* 给property的其他字段赋值：（DTB的空间没有释放，被property成员指针引用）</span></span><br><span class="line"><span class="comment">            property-&gt;name：指针指向dtb strings blcok区域中的属性name</span></span><br><span class="line"><span class="comment">            property-&gt;length：属性data的长度</span></span><br><span class="line"><span class="comment">            property-&gt;value：指针指向dtb stucture block区域中的属性data</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">pp-&gt;name = (<span class="keyword">char</span> *)pname;</span><br><span class="line">pp-&gt;length = sz;</span><br><span class="line">pp-&gt;value = (__be32 *)p;</span><br><span class="line">*prev_pp = pp;</span><br><span class="line">prev_pp = &amp;pp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* with version 0x10 we may not have the name property, recreate</span></span><br><span class="line"><span class="comment"> * it here from the unit name if absent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!has_name) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = pathp, *ps = pathp, *pa = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*p1) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p1) == <span class="string">'@'</span>)</span><br><span class="line">pa = p1;</span><br><span class="line"><span class="keyword">if</span> ((*p1) == <span class="string">'/'</span>)</span><br><span class="line">ps = p1 + <span class="number">1</span>;</span><br><span class="line">p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pa &lt; ps)</span><br><span class="line">pa = p1;</span><br><span class="line">sz = (pa - ps) + <span class="number">1</span>;</span><br><span class="line">pp = unflatten_dt_alloc(&amp;mem, <span class="keyword">sizeof</span>(struct property) + sz,</span><br><span class="line">__alignof__(struct property));</span><br><span class="line"><span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line">pp-&gt;name = <span class="string">"name"</span>;</span><br><span class="line">pp-&gt;length = sz;</span><br><span class="line">pp-&gt;value = pp + <span class="number">1</span>;</span><br><span class="line">*prev_pp = pp;</span><br><span class="line">prev_pp = &amp;pp-&gt;next;</span><br><span class="line"><span class="built_in">memcpy</span>(pp-&gt;value, ps, sz - <span class="number">1</span>);</span><br><span class="line">((<span class="keyword">char</span> *)pp-&gt;value)[sz - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pr_debug(<span class="string">"fixed up name for %s -&gt; %s\n"</span>, pathp,</span><br><span class="line">(<span class="keyword">char</span> *)pp-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 根据"name"、 "device_type"属性，来给device_node结构中的name、type成员赋值 */</span></span><br><span class="line"><span class="keyword">if</span> (!dryrun) &#123;</span><br><span class="line">*prev_pp = <span class="literal">NULL</span>;</span><br><span class="line">np-&gt;name = of_get_property(np, <span class="string">"name"</span>, <span class="literal">NULL</span>);</span><br><span class="line">np-&gt;type = of_get_property(np, <span class="string">"device_type"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!np-&gt;name)</span><br><span class="line">np-&gt;name = <span class="string">"&lt;NULL&gt;"</span>;</span><br><span class="line"><span class="keyword">if</span> (!np-&gt;type)</span><br><span class="line">np-&gt;type = <span class="string">"&lt;NULL&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.3)如果还有子node的存在，递归解析 */</span></span><br><span class="line">old_depth = depth;</span><br><span class="line">*poffset = fdt_next_node(blob, *poffset, &amp;depth);</span><br><span class="line"><span class="keyword">if</span> (depth &lt; <span class="number">0</span>)</span><br><span class="line">depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*poffset &gt; <span class="number">0</span> &amp;&amp; depth &gt; old_depth)</span><br><span class="line">mem = unflatten_dt_node(blob, mem, poffset, np, <span class="literal">NULL</span>,</span><br><span class="line">fpsize, dryrun);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*poffset &lt; <span class="number">0</span> &amp;&amp; *poffset != -FDT_ERR_NOTFOUND)</span><br><span class="line">pr_err(<span class="string">"unflatten: error %d processing FDT\n"</span>, *poffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reverse the child list. Some drivers assumes node order matches .dts</span></span><br><span class="line"><span class="comment"> * node order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!dryrun &amp;&amp; np-&gt;child) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span> = <span class="title">np</span>-&gt;<span class="title">child</span>;</span></span><br><span class="line">np-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (child) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">next</span> = <span class="title">child</span>-&gt;<span class="title">sibling</span>;</span></span><br><span class="line">child-&gt;sibling = np-&gt;child;</span><br><span class="line">np-&gt;child = child;</span><br><span class="line">child = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nodepp)</span><br><span class="line">*nodepp = np;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2、Device创建"><a href="#3-2、Device创建" class="headerlink" title="3.2、Device创建"></a>3.2、Device创建</h2><h3 id="3-2-1-of-platform-populate"><a href="#3-2-1-of-platform-populate" class="headerlink" title="3.2.1 of_platform_populate()"></a>3.2.1 of_platform_populate()</h3><p>首先root节点下的第1级子节点创建成platform device。</p><ul><li>对root节点下的第1级子节点，如果有”compatible”属性创建对应platform device；</li><li>如果”compatible”属性等于of_default_bus_match_table(“simple-bus”/“simple-mfd”/“arm,amba-bus”)中任意一种，继续对其子节点进行platform device创建。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">start_kernel() -&gt; ... -&gt;do_initcalls() -&gt; arm64_device_init():</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span> of_default_bus_match_table[] = &#123;</span><br><span class="line">&#123; .compatible = <span class="string">"simple-bus"</span>, &#125;,</span><br><span class="line">&#123; .compatible = <span class="string">"simple-mfd"</span>, &#125;,</span><br><span class="line">#ifdef CONFIG_ARM_AMBA</span><br><span class="line">&#123; .compatible = <span class="string">"arm,amba-bus"</span>, &#125;,</span><br><span class="line">#endif <span class="comment">/* CONFIG_ARM_AMBA */</span></span><br><span class="line">&#123;&#125; <span class="comment">/* Empty terminated list */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int __init arm64_device_init(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of_have_populated_dt()) &#123;</span><br><span class="line">of_iommu_init();</span><br><span class="line">of_platform_populate(NULL, of_default_bus_match_table,</span><br><span class="line">     NULL, NULL);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (acpi_disabled) &#123;</span><br><span class="line">pr_crit(<span class="string">"Device tree not populated\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">int of_platform_populate(<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *root,</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span> *matches,</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span></span> *lookup,</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *child;</span><br><span class="line">int rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 获取dts中的root node */</span></span><br><span class="line">root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">"/"</span>);</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 对root node的child node进行platform device创建 */</span></span><br><span class="line">for_each_child_of_node(root, child) &#123;</span><br><span class="line">rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">of_node_put(child);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">of_node_set_flag(root, OF_POPULATED_BUS);</span><br><span class="line"></span><br><span class="line">of_node_put(root);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int of_platform_bus_create(<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *bus,</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span></span> *matches,</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span></span> *lookup,</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *parent, <span class="built_in">bool</span> strict)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_dev_auxdata</span></span> *auxdata;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *child;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *dev;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *bus_id = NULL;</span><br><span class="line">void *platform_data = NULL;</span><br><span class="line">int rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 确保要创建为platform device的node，拥有"compatible"属性 */</span></span><br><span class="line"><span class="comment">/* Make sure it has a compatible property */</span></span><br><span class="line"><span class="keyword">if</span> (strict &amp;&amp; (!of_get_property(bus, <span class="string">"compatible"</span>, NULL))) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s() - skipping %s, no compatible prop\n"</span>,</span><br><span class="line"> __func__, bus-&gt;full_name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auxdata = of_dev_lookup(lookup, bus);</span><br><span class="line"><span class="keyword">if</span> (auxdata) &#123;</span><br><span class="line">bus_id = auxdata-&gt;name;</span><br><span class="line">platform_data = auxdata-&gt;platform_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">"arm,primecell"</span>)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don't return an error here to keep compatibility with older</span></span><br><span class="line"><span class="comment"> * device tree files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">of_amba_device_create(bus, bus_id, platform_data, parent);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2) 对当前的node创建platform device */</span></span><br><span class="line">dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</span><br><span class="line">    <span class="comment">/* (2.3) 根据of_default_bus_match_table，如果node中含有以下属性：</span></span><br><span class="line"><span class="comment">    compatible = "simple-bus"</span></span><br><span class="line"><span class="comment">    compatible = "simple-mfd"</span></span><br><span class="line"><span class="comment">    compatible = "arm,amba-bus"</span></span><br><span class="line"><span class="comment">    则继续对node的子node进行platform device创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> (!dev || !of_match_node(matches, bus))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.4) 递归对本node的child node进行platform device创建 */</span></span><br><span class="line">for_each_child_of_node(bus, child) &#123;</span><br><span class="line">pr_debug(<span class="string">"   create child: %s\n"</span>, child-&gt;full_name);</span><br><span class="line">rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">of_node_put(child);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">of_node_set_flag(bus, OF_POPULATED_BUS);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *of_platform_device_create_pdata(</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *np,</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *bus_id,</span><br><span class="line">void *platform_data,</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *dev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!of_device_is_available(np) ||</span><br><span class="line">    of_node_test_and_set_flag(np, OF_POPULATED))</span><br><span class="line"><span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.1) 分配node对应的platform_device结构，</span></span><br><span class="line"><span class="comment">     并且解析node中的"reg"、"interrupts"属性，</span></span><br><span class="line"><span class="comment">    作为platform_device-&gt;resource */</span></span><br><span class="line">dev = of_device_alloc(np, bus_id, parent);</span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line">goto err_clear_flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.2) device对应的bus为platform_bus_type  */</span></span><br><span class="line">dev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line">dev-&gt;dev.platform_data = platform_data;</span><br><span class="line">of_dma_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line">of_msi_configure(&amp;dev-&gt;dev, dev-&gt;dev.of_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.3) 注册platform_device-&gt;dev为标准的device */</span></span><br><span class="line"><span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123;</span><br><span class="line">of_dma_deconfigure(&amp;dev-&gt;dev);</span><br><span class="line">platform_device_put(dev);</span><br><span class="line">goto err_clear_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_clear_flag:</span><br><span class="line">of_node_clear_flag(np, OF_POPULATED);</span><br><span class="line"><span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *of_device_alloc(<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span></span> *np,</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">char</span> *bus_id,</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span> *dev;</span><br><span class="line">int rc, i, num_reg = <span class="number">0</span>, num_irq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span></span> *res, temp_res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.1.1) 分配platform_device空间  */</span></span><br><span class="line">dev = platform_device_alloc(<span class="string">""</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.1.2) 计算node中"reg"属性中"address、size"resource的个数  */</span></span><br><span class="line"><span class="comment">/* count the io and irq resources */</span></span><br><span class="line"><span class="keyword">while</span> (of_address_to_resource(np, num_reg, &amp;temp_res) == <span class="number">0</span>)</span><br><span class="line">num_reg++;</span><br><span class="line">num_irq = of_irq_count(np); <span class="comment">/* 计算node中"interrupts"属性中irq的个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.1.3) 给resource分配空间并解析值 */</span></span><br><span class="line"><span class="comment">/* Populate the resource table */</span></span><br><span class="line"><span class="keyword">if</span> (num_irq || num_reg) &#123;</span><br><span class="line">res = kzalloc(sizeof(*res) * (num_irq + num_reg), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!res) &#123;</span><br><span class="line">platform_device_put(dev);</span><br><span class="line"><span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev-&gt;num_resources = num_reg + num_irq;</span><br><span class="line">dev-&gt;resource = res;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_reg; i++, res++) &#123;</span><br><span class="line">rc = of_address_to_resource(np, i, res);</span><br><span class="line">WARN_ON(rc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (of_irq_to_resource_table(np, res, num_irq) != num_irq)</span><br><span class="line">pr_debug(<span class="string">"not all legacy IRQ resources mapped for %s\n"</span>,</span><br><span class="line"> np-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.1.4) 根据device能够找到of node  */</span></span><br><span class="line">dev-&gt;dev.of_node = of_node_get(np);</span><br><span class="line">dev-&gt;dev.parent = parent ? : &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.1.5) 配置device的那么，基本命名规则为：</span></span><br><span class="line"><span class="comment">    dev_set_name(dev, dev_name(dev) ? "%llx.%s:%s" : "%llx.%s",</span></span><br><span class="line"><span class="comment">         (unsigned long long)addr, node-&gt;name,</span></span><br><span class="line"><span class="comment">         dev_name(dev))</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (bus_id)</span><br><span class="line">dev_set_name(&amp;dev-&gt;dev, <span class="string">"%s"</span>, bus_id);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">of_device_make_bus_id(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-mt-i2c-driver"><a href="#3-2-2-mt-i2c-driver" class="headerlink" title="3.2.2 mt_i2c_driver"></a>3.2.2 mt_i2c_driver</h3><p>因为第1级子节点会被注册成platform device，例如i2c/spi控制器，那么对应也需要注册platform driver。已i2c控制器驱动为例：</p><ul><li>控制器首先会创建对应platform driver，把adapter注册成i2c device；</li><li>在adapter的probe过程中，会调用of_i2c_register_devices()函数遍历控制器下挂的i2c设备的DTS节点，并将其注册成i2c_client；</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">drivers\i2c\busses\i2c-mtk.c:</span><br><span class="line"></span><br><span class="line">static const struct of_device_id mtk_i2c_of_match[] = &#123;</span><br><span class="line">&#123; .compatible = <span class="string">"mediatek,mt6735-i2c"</span>, .<span class="keyword">data</span> = &amp;mt6735_compat &#125;,</span><br><span class="line">&#123; .compatible = <span class="string">"mediatek,mt6797-i2c"</span>, .<span class="keyword">data</span> = &amp;mt6797_compat &#125;,</span><br><span class="line">&#123; .compatible = <span class="string">"mediatek,mt6757-i2c"</span>, .<span class="keyword">data</span> = &amp;mt6757_compat &#125;,</span><br><span class="line">&#123; .compatible = <span class="string">"mediatek,mt6799-i2c"</span>, .<span class="keyword">data</span> = &amp;mt6799_compat &#125;,</span><br><span class="line">&#123; .compatible = <span class="string">"mediatek,elbrus-i2c"</span>, .<span class="keyword">data</span> = &amp;elbrus_compat &#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct platform_driver mt_i2c_driver = &#123;</span><br><span class="line">.probe = mt_i2c_probe,</span><br><span class="line">.remove = mt_i2c_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.<span class="keyword">name</span> = I2C_DRV_NAME,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.of_match_table = of_match_ptr(mtk_i2c_of_match),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int mt_i2c_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">int ret = <span class="number">0</span>;</span><br><span class="line">struct mt_i2c *i2c;</span><br><span class="line">unsigned int clk_src_in_hz;</span><br><span class="line">struct resource *res;</span><br><span class="line">const struct of_device_id *of_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">i2c</span> = devm_kzalloc(&amp;pdev-&gt;</span>dev, sizeof(struct mt_i2c), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (i2c == NULL)</span><br><span class="line">return -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ret</span> = mt_i2c_parse_dt(pdev-&gt;</span>dev.of_node, i2c);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line">res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">base</span> = devm_ioremap_resource(&amp;pdev-&gt;</span>dev, res);</span><br><span class="line"><span class="function"><span class="title">if</span> (IS_ERR(i2c-&gt;</span>base))</span><br><span class="line"><span class="function"><span class="title">return</span> PTR_ERR(i2c-&gt;</span>base);</span><br><span class="line"></span><br><span class="line">res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">pdmabase</span> = devm_ioremap_resource(&amp;pdev-&gt;</span>dev, res);</span><br><span class="line"><span class="function"><span class="title">if</span> (IS_ERR(i2c-&gt;</span>pdmabase))</span><br><span class="line"><span class="function"><span class="title">return</span> PTR_ERR(i2c-&gt;</span>pdmabase);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>irqnr = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (i2c-&gt;</span>irqnr &lt;= <span class="number">0</span>)</span><br><span class="line">return -EINVAL;</span><br><span class="line"><span class="function"><span class="title">init_waitqueue_head</span>(&amp;i2c-&gt;</span>wait);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ret</span> = devm_request_irq(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, i2c-&gt;</span>irqnr, mt_i2c_irq,</span><br><span class="line">#ifdef CONFIG_MEIZU_BSP</span><br><span class="line">IRQF_NO_SUSPEND | IRQF_TRIGGER_NONE, I2C_DRV_NAME, i2c);</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">IRQF_TRIGGER_NONE, I2C_DRV_NAME, i2c);</span><br><span class="line">#endif <span class="comment">/*CONFIG_MEIZU_BSP*/</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev,</span><br><span class="line"><span class="string">"Request I2C IRQ %d fail\n"</span>, <span class="function"><span class="title">i2c</span>-&gt;</span>irqnr);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">of_id</span> = of_match_node(mtk_i2c_of_match, pdev-&gt;</span>dev.of_node);</span><br><span class="line"><span class="keyword">if</span> (!of_id)</span><br><span class="line">return -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev_comp</span> = of_id-&gt;</span><span class="keyword">data</span>;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.of_node = pdev-&gt;</span>dev.of_node;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dev</span> = &amp;i2c-&gt;</span>adap.dev;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.dev.parent = &amp;pdev-&gt;</span>dev;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>adap.owner = THIS_MODULE;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo = &amp;mt_i2c_algorithm;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>adap.algo_data = NULL;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>adap.timeout = <span class="number">2</span> * HZ;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>adap.retries = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">adap</span>.nr = i2c-&gt;</span>id;</span><br><span class="line"><span class="function"><span class="title">spin_lock_init</span>(&amp;i2c-&gt;</span>cg_lock);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (i2c-&gt;</span><span class="function"><span class="title">dev_comp</span>-&gt;</span>dma_support == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="function"><span class="title">if</span> (dma_set_mask(&amp;pdev-&gt;</span>dev, DMA_BIT_MASK(<span class="number">33</span>))) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"dma_set_mask return error.\n"</span>);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (i2c-&gt;</span><span class="function"><span class="title">dev_comp</span>-&gt;</span>dma_support == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="function"><span class="title">if</span> (dma_set_mask(&amp;pdev-&gt;</span>dev, DMA_BIT_MASK(<span class="number">36</span>))) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"dma_set_mask return error.\n"</span>);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !defined(CONFIG_MT_I2C_FPGA_ENABLE)</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">clk_main</span> = devm_clk_get(&amp;pdev-&gt;</span>dev, <span class="string">"main"</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (IS_ERR(i2c-&gt;</span>clk_main)) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"cannot get main clock\n"</span>);</span><br><span class="line"><span class="function"><span class="title">return</span> PTR_ERR(i2c-&gt;</span>clk_main);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">clk_dma</span> = devm_clk_get(&amp;pdev-&gt;</span>dev, <span class="string">"dma"</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (IS_ERR(i2c-&gt;</span>clk_dma)) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"cannot get dma clock\n"</span>);</span><br><span class="line"><span class="function"><span class="title">return</span> PTR_ERR(i2c-&gt;</span>clk_dma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">clk_arb</span> = devm_clk_get(&amp;pdev-&gt;</span>dev, <span class="string">"arb"</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (IS_ERR(i2c-&gt;</span>clk_arb))</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>clk_arb = NULL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">dev_dbg</span>(&amp;pdev-&gt;</span><span class="function"><span class="title">dev</span>, "i2c%d has the relevant arbitrator clk.\n", i2c-&gt;</span>id);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (i2c-&gt;</span>have_pmic) &#123;</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">clk_pmic</span> = devm_clk_get(&amp;pdev-&gt;</span>dev, <span class="string">"pmic"</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (IS_ERR(i2c-&gt;</span>clk_pmic)) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"cannot get pmic clock\n"</span>);</span><br><span class="line"><span class="function"><span class="title">return</span> PTR_ERR(i2c-&gt;</span>clk_pmic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">clk_src_in_hz</span> = clk_get_rate(i2c-&gt;</span><span class="function"><span class="title">clk_pmic</span>) / i2c-&gt;</span>clk_src_div;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="function"><span class="title">clk_src_in_hz</span> = clk_get_rate(i2c-&gt;</span><span class="function"><span class="title">clk_main</span>) / i2c-&gt;</span>clk_src_div;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">dev_dbg</span>(&amp;pdev-&gt;</span>dev, <span class="string">"clock source %p,clock src frequency %d\n"</span>,</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span>clk_main, clk_src_in_hz);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">strlcpy</span>(i2c-&gt;</span><span class="function"><span class="title">adap</span>.<span class="keyword">name</span>, I2C_DRV_NAME, sizeof(i2c-&gt;</span>adap.<span class="keyword">name</span>));</span><br><span class="line"><span class="function"><span class="title">mutex_init</span>(&amp;i2c-&gt;</span>i2c_mutex);</span><br><span class="line">ret = i2c_set_speed(i2c, clk_src_in_hz);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"Failed to set the speed\n"</span>);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ret = mt_i2c_clock_enable(i2c);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"clock enable failed!\n"</span>);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">mt_i2c_init_hw(i2c);</span><br><span class="line">mt_i2c_clock_disable(i2c);</span><br><span class="line"><span class="function"><span class="title">i2c</span>-&gt;</span><span class="function"><span class="title">dma_buf</span>.vaddr = dma_alloc_coherent(&amp;pdev-&gt;</span>dev,</span><br><span class="line">PAGE_SIZE, &amp;<span class="function"><span class="title">i2c</span>-&gt;</span>dma_buf.paddr, GFP_KERNEL);</span><br><span class="line"><span class="function"><span class="title">if</span> (i2c-&gt;</span>dma_buf.vaddr == NULL) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"dma_alloc_coherent fail\n"</span>);</span><br><span class="line">return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">i2c_set_adapdata</span>(&amp;i2c-&gt;</span>adap, i2c);</span><br><span class="line"><span class="comment">/* ret = i2c_add_adapter(&amp;i2c-&gt;adap); */</span></span><br><span class="line"><span class="function"><span class="title">ret</span> = i2c_add_numbered_adapter(&amp;i2c-&gt;</span>adap);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;pdev-&gt;</span>dev, <span class="string">"Failed to add i2c bus to i2c core\n"</span>);</span><br><span class="line">free_i2c_dma_bufs(i2c);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">platform_set_drvdata(pdev, i2c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!map_cg_regs(i2c))</span><br><span class="line">pr_warn(<span class="string">"Map cg regs successfully.\n"</span>);</span><br><span class="line"></span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">i2c_add_numbered_adapter</span>() -&gt;</span> __<span class="function"><span class="title">i2c_add_numbered_adapter</span>() -&gt;</span> </span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static int i2c_register_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">int res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can't register until after driver model init */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(WARN_ON(!i2c_bus_type.p))) &#123;</span><br><span class="line">res = -EAGAIN;</span><br><span class="line">goto out_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity checks */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (unlikely(adap-&gt;</span><span class="keyword">name</span>[<span class="number">0</span>] == <span class="string">'\0'</span>)) &#123;</span><br><span class="line">pr_err(<span class="string">"i2c-core: Attempt to register an adapter with "</span></span><br><span class="line">       <span class="string">"no name!\n"</span>);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">if</span> (unlikely(!adap-&gt;</span>algo)) &#123;</span><br><span class="line">pr_err(<span class="string">"i2c-core: Attempt to register adapter '%s' with "</span></span><br><span class="line">       <span class="string">"no algo!\n"</span>, <span class="function"><span class="title">adap</span>-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rt_mutex_init</span>(&amp;adap-&gt;</span>bus_lock);</span><br><span class="line"><span class="function"><span class="title">mutex_init</span>(&amp;adap-&gt;</span>userspace_clients_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="function"><span class="title">adap</span>-&gt;</span>userspace_clients);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (adap-&gt;</span>timeout == <span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="title">adap</span>-&gt;</span>timeout = HZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册adapter为i2c_bus上的device */</span></span><br><span class="line"><span class="function"><span class="title">dev_set_name</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, "i2c-%d", adap-&gt;</span>nr);</span><br><span class="line"><span class="function"><span class="title">adap</span>-&gt;</span>dev.bus = &amp;i2c_bus_type;</span><br><span class="line"><span class="function"><span class="title">adap</span>-&gt;</span>dev.type = &amp;i2c_adapter_type;</span><br><span class="line"><span class="function"><span class="title">res</span> = device_register(&amp;adap-&gt;</span>dev);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line">goto out_list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, "adapter [%s] registered\n", adap-&gt;</span><span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pm_runtime_no_callbacks</span>(&amp;adap-&gt;</span>dev);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_I2C_COMPAT</span><br><span class="line"><span class="function"><span class="title">res</span> = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;</span>dev,</span><br><span class="line">       <span class="function"><span class="title">adap</span>-&gt;</span>dev.parent);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="function"><span class="title">dev_warn</span>(&amp;adap-&gt;</span>dev,</span><br><span class="line"> <span class="string">"Failed to create compatibility class link\n"</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bus recovery specific initialization */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (adap-&gt;</span>bus_recovery_info) &#123;</span><br><span class="line"><span class="function"><span class="title">struct</span> i2c_bus_recovery_info *bri = adap-&gt;</span>bus_recovery_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (!bri-&gt;</span>recover_bus) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"No recover_bus() found, not using recovery\n"</span>);</span><br><span class="line"><span class="function"><span class="title">adap</span>-&gt;</span>bus_recovery_info = NULL;</span><br><span class="line">goto exit_recovery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic GPIO recovery */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (bri-&gt;</span>recover_bus == i2c_generic_gpio_recovery) &#123;</span><br><span class="line"><span class="function"><span class="title">if</span> (!gpio_is_valid(bri-&gt;</span>scl_gpio)) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"Invalid SCL gpio, not using recovery\n"</span>);</span><br><span class="line"><span class="function"><span class="title">adap</span>-&gt;</span>bus_recovery_info = NULL;</span><br><span class="line">goto exit_recovery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (gpio_is_valid(bri-&gt;</span>sda_gpio))</span><br><span class="line"><span class="function"><span class="title">bri</span>-&gt;</span>get_sda = get_sda_gpio_value;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">bri</span>-&gt;</span>get_sda = NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bri</span>-&gt;</span>get_scl = get_scl_gpio_value;</span><br><span class="line"><span class="function"><span class="title">bri</span>-&gt;</span>set_scl = set_scl_gpio_value;</span><br><span class="line">&#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (!bri-&gt;</span><span class="function"><span class="title">set_scl</span> || !bri-&gt;</span>get_scl) &#123;</span><br><span class="line"><span class="comment">/* Generic SCL recovery */</span></span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"No &#123;get|set&#125;_gpio() found, not using recovery\n"</span>);</span><br><span class="line"><span class="function"><span class="title">adap</span>-&gt;</span>bus_recovery_info = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_recovery:</span><br><span class="line"><span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    <span class="comment">/* 循环遍历adapter node下挂载的其他子node，注册成为i2c bus的device */</span></span><br><span class="line">of_i2c_register_devices(adap);</span><br><span class="line">acpi_i2c_register_devices(adap);</span><br><span class="line">acpi_i2c_install_space_handler(adap);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (adap-&gt;</span>nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notify drivers */</span></span><br><span class="line">mutex_lock(&amp;core_lock);</span><br><span class="line">bus_for_each_drv(&amp;i2c_bus_type, NULL, adap, __process_new_adapter);</span><br><span class="line">mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">mutex_lock(&amp;core_lock);</span><br><span class="line"><span class="function"><span class="title">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;</span>nr);</span><br><span class="line">mutex_unlock(&amp;core_lock);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static void of_i2c_register_devices(struct i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">struct device_node *node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only register child devices if the adapter has a node pointer set */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (!adap-&gt;</span>dev.of_node)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span>dev, <span class="string">"of_i2c: walking child nodes\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历adapter node下的子node，并创建标准的i2c bus的device */</span></span><br><span class="line"><span class="function"><span class="title">for_each_available_child_of_node</span>(adap-&gt;</span>dev.of_node, node) &#123;</span><br><span class="line"><span class="keyword">if</span> (of_node_test_and_set_flag(node, OF_POPULATED))</span><br><span class="line">continue;</span><br><span class="line">of_i2c_register_device(adap, node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line">static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,</span><br><span class="line"> struct device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">struct i2c_client *result;</span><br><span class="line">struct i2c_board_info info = &#123;&#125;;</span><br><span class="line">struct dev_archdata dev_ad = &#123;&#125;;</span><br><span class="line">const __be32 *addr_be;</span><br><span class="line">u32 addr;</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dev_dbg</span>(&amp;adap-&gt;</span><span class="function"><span class="title">dev</span>, "of_i2c: register %s\n", node-&gt;</span>full_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_modalias_node(node, info.type, sizeof(info.type)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"of_i2c: modalias failure on %s\n"</span>,</span><br><span class="line"><span class="function"><span class="title">node</span>-&gt;</span>full_name);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr_be = of_get_property(node, <span class="string">"reg"</span>, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (!addr_be || (len &lt; sizeof(*addr_be))) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"of_i2c: invalid reg on %s\n"</span>,</span><br><span class="line"><span class="function"><span class="title">node</span>-&gt;</span>full_name);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr = be32_to_cpup(addr_be);</span><br><span class="line"><span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">info.flags |= I2C_CLIENT_TEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123;</span><br><span class="line">addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">info.flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i2c_check_addr_validity(addr, info.flags)) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"of_i2c: invalid addr=%x on %s\n"</span>,</span><br><span class="line"><span class="function"><span class="title">info</span>.addr, node-&gt;</span>full_name);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.addr = addr;</span><br><span class="line">info.of_node = of_node_get(node);</span><br><span class="line">info.archdata = &amp;dev_ad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_get_property(node, <span class="string">"wakeup-source"</span>, NULL))</span><br><span class="line">info.flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">result = i2c_new_device(adap, &amp;info);</span><br><span class="line"><span class="keyword">if</span> (result == NULL) &#123;</span><br><span class="line"><span class="function"><span class="title">dev_err</span>(&amp;adap-&gt;</span>dev, <span class="string">"of_i2c: Failure registering %s\n"</span>,</span><br><span class="line"><span class="function"><span class="title">node</span>-&gt;</span>full_name);</span><br><span class="line">of_node_put(node);</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-mz-mag-driver"><a href="#3-2-1-mz-mag-driver" class="headerlink" title="3.2.1 mz_mag_driver"></a>3.2.1 mz_mag_driver</h3><p>具体的I2c设备驱动，在总线驱动使用of_i2c_register_devices()创建设备以后，就可以适配工作了。</p><p>dts：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">arch\arm64\boot\dts\mediatek\mt6799.dtsi:</span><br><span class="line"><span class="symbol">i2c1:</span> <span class="class">i2c@11090000 </span>&#123;</span><br><span class="line">compatible = <span class="string">"mediatek,mt6799-i2c"</span>;</span><br><span class="line">id = <span class="params">&lt;<span class="number">1</span>&gt;</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0</span> <span class="number">0x11090000</span> <span class="number">0</span> <span class="number">0x1000</span>&gt;</span>,</span><br><span class="line"><span class="params">&lt;<span class="number">0</span> <span class="number">0x11000100</span> <span class="number">0</span> <span class="number">0x80</span>&gt;</span>;</span><br><span class="line">interrupts = <span class="params">&lt;GIC_SPI <span class="number">85</span> IRQ_TYPE_LEVEL_LOW&gt;</span>;</span><br><span class="line">clocks = <span class="params">&lt;<span class="variable">&amp;pericfg</span> CLK_PERICFG_RG_I2C1_BCLK&gt;</span>, <span class="params">&lt;<span class="variable">&amp;pericfg</span> CLK_PERICFG_RG_AP_DM&gt;</span>;</span><br><span class="line">clock-names = <span class="string">"main"</span>, <span class="string">"dma"</span>;</span><br><span class="line">clock-div = <span class="params">&lt;<span class="number">5</span>&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arch\arm64\boot\dts\mediatek\mz6799_6m_v2_2k_n.dtsi:</span><br><span class="line"><span class="variable">&amp;i2c1</span> &#123;</span><br><span class="line"><span class="symbol">apds9922:</span><span class="class">apds9922@53 </span>&#123;</span><br><span class="line">compatible = <span class="string">"mediatek,apds9922"</span>;</span><br><span class="line">interrupt-parent = <span class="params">&lt;<span class="variable">&amp;eintc</span>&gt;</span>;</span><br><span class="line">interrupts = <span class="params">&lt; <span class="number">8</span> IRQ_TYPE_EDGE_FALLING&gt;</span>;</span><br><span class="line">debounce = <span class="params">&lt;<span class="number">8</span> <span class="number">0</span>&gt;</span>;</span><br><span class="line">gpio = <span class="params">&lt; <span class="number">8</span> &gt;</span>;</span><br><span class="line">reg = <span class="params">&lt;<span class="number">0x53</span>&gt;</span>;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>driver：</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drivers\iio\magnetometer\mz_mag.c:</span><br><span class="line">static <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> mz_mag_id[] = </span>&#123;</span><br><span class="line">&#123;<span class="string">"mediatek,mmc3530"</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123;<span class="string">"mediatek,akm09911"</span>, <span class="number">1</span> &#125;,</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> mz_mag_driver = </span>&#123;</span><br><span class="line">.probe     = mz_mag_probe,</span><br><span class="line">.id_table  = mz_mag_id,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name  = MZ_MAG_DEV_NAME,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line"><span class="comment">#ifdef CONFIG_OF</span></span><br><span class="line">    .of_match_table = of_match_ptr(msensor_of_match),</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DTS </tag>
            
            <tag> DTB </tag>
            
            <tag> DTC </tag>
            
            <tag> Node </tag>
            
            <tag> Property </tag>
            
            <tag> OpenFirmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEE 软件交互流程概述</title>
      <link href="/2017/12/26//tee.html/"/>
      <url>/2017/12/26//tee.html/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><ul><li>本文建立在你已经对 TEE 技术的基础知识有一定了解的基础之上，如需了解，可以阅读本博客的文章《指纹 TEE》<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</li><li>本文将基于 OP-TEE<sup><a href="#fn_2" id="reffn_2">2</a></sup> 开源 TEE 软件，介绍 TEE 软件中，REE 客户端访问 TEE 环境资源的具体调用流程。 为此，本文首先会介绍实现 REE 到 TEE 调用的各个基础组件组成以及各自功能，然后分析各个基础组件的交互流程时序，使读者对 TEE 软件的运行逻辑有大概的了解。</li></ul><h4 id="TEE-软件交互基础组件简介"><a href="#TEE-软件交互基础组件简介" class="headerlink" title="TEE 软件交互基础组件简介"></a><strong>TEE 软件交互基础组件简介</strong></h4><ul><li>TEE 系统软件从整体上包含 REE 和 TEE 两部分，各自对应的基础组件如图1所示。</li></ul><p><img src="ca2ta_arch.png" alt="图1: TEE 系统软件组成" title="图1: TEE 系统软件组成"></p><ul><li>REE 部分 Client Applications（CA） 一般是指指纹录入，支付应用等上层应用，其通过调用 TEE Client API 接口来与 TEE 环境的 Trusted OS 进行交互，这里的 TEE Client API 包括 TEE 厂商自定义的一些接口或 GlobalPlatform（GP） 全球组织定义的通用 API，其目的是制定一套标准的编程接口，方便开发者在不同软硬件平台下使用同一套代码实现其功能。</li><li>TEE Client API 通过 ioctl 系统调用对 TEE Driver 进行操作，TEE Driver 是沟通 REE 和 TEE 的桥梁，其通过 SMC 指令，实现将上层的 OpenSession，InvokeCommand，CloseSession 等标准调用的请求转发到 TEE 环境，同时其也会处理来自 TEE 的请求，将请求转发到 TEE Helper Daemon 让其处理。</li><li><p>TEE Helper Daemon 是一个辅助进程，用于 TEE 请求 REE 的资源。 一般来说，TEE 需要获得存储在 EMMC 的数据文件（例如安全加密文件，TA 可执行镜像文件等），而读写 EMMC 操作需要复杂的内核驱动的支持，显然如果把读写 EMMC 的驱动放到 TEE 侧运行会使软件复杂度会变得很高，因此 REE 需要一个可以访问这些资源的辅助进程支持，这就是 TEE Helper Daemon 的基本功能。TEE Helper Daemon 在软件逻辑实现上比较简单，以 OP-TEE 的 tee-supplicant 辅助进程为例，整体上是一个循环流程: 其首先通过 ioctl 接口查询是否有来自 TEE 的请求，如果没有，则进入睡眠等待状态，等待 TEE Driver 的唤醒信号，当 TEE Driver 收到来自 TEE 的请求后，会唤醒 tee-supplicant 辅助进程，然后根据请求号进行相应处理（读写数据文件，读写 EMMC 设备分区等），最后返回结果到 TEE Driver，完成一次循环，具体实现可参照《OP-TEE 中 tee-supplicant 执行流程》<sup><a href="#fn_3" id="reffn_3">3</a></sup></p><ul><li>TEE 侧的 Secure Monitor 的主要作用是实现 REE 和 TEE 环境的切换，转发请求到 Trusted OS。当 Secure Monitor 收到 TEE Driver 的 SMC 请求后，会将 CPU 切换到 Secure 状态，然后转发请求到 Trusted OS 来处理，Trusted OS 会找到请求对应的 Trusted App（TA） 去处理请求，具体逻辑流程会在下一节中详细说明。 另外 Secure Monitor 还用于开机时候 Trusted OS 的引导工作，此内容不在本文的叙述范围，读者可以参看: 《Secure-EL1 Payloads and Dispatchers》<sup><a href="#fn_4" id="reffn_4">4</a></sup></li><li>Trusted OS 是运行在 TEE 侧的小型操作系统，简单来说，其作用是:<ul><li>构建满足 TA 运行的安全运行环境</li><li>提供安全外设（SPI，I2C，Timer 等）的驱动程序</li><li>根据 REE 的请求，调度相应 TA 处理请求</li><li>提供 TA 运行所需要的加解密，随机数生成，证书生成校验等通用函数库</li></ul></li><li>上文提到 GlobalPlatform（GP） 全球组织定义的通用 API，TEE Client API 供 REE 侧的 CA 使用，TEE Internal API 则是供 TA 调用 Trusted OS 资源的标准 API，同样是用于方便 TA 开发者在不同软硬件平台进行开发。</li></ul></li></ul><h4 id="TEE-软件交互流程"><a href="#TEE-软件交互流程" class="headerlink" title="TEE 软件交互流程"></a><strong>TEE 软件交互流程</strong></h4><p>上文对 REE 调用 TEE 软件交互所需要的基础组件及其基本作用进行了介绍，下面将对各个组件的交互流程进行介绍。</p><p>在 GP 标准中，CA 要与 TA 进行通信，需要建立如图2所示的软件逻辑流程:</p><ol><li>首先 CA 需要与 Trusted OS 之间建立一个 Context（InitializeContext），以后此 CA 与 TEE 环境的所有通信均基于此 Context。</li><li>然后 CA 会向 Trusted OS 申请与请求的 TA 建立一个 Session（OpenSession）。</li><li>CA 与 TA 之间的 Session 建立完成后，CA 就可以向 TA 发送 Command（InvokeCommand）。</li><li>Command 及其参数会通过共享内存的方式传递，TA 从共享内存中获取到 CA 的请求以及请求参数。</li><li>TA 在 TEE 环境下执行处理，得到的处理结果重新填充到共享内存中，CA 通过共享内存就可以获取到处理结果。</li><li>获得处理结果后，如不需要进一步请求，则由 CA 发起关闭 Session 的请求（CloseSession），Trusted OS 回收 TA 相关资源，最后 CA 发起销毁 Context 的请求（FinalizeContext），完成一次完整交互。</li></ol><p><img src="arch-of-tee-plat-de.png" alt="图2: TEE 软件交互逻辑" title="图2: TEE 软件交互逻辑"></p><p>从以上流程可以看到，整个交互流程主要涉及 InitializeContext，OpenSession，InvokeCommand，CloseSession 和 FinalizeContext 5个操作。<br>InitializeContext 用于 Trusted OS 分配 TA 运行需要的安全内存，FinalizeContext 则是销毁相应内存，具体流程分别与 OpenSession 和 CloseSession 类似，本文将不对这两个操作赘述。<br>下面看看 OpenSession，InvokeCommand 和 CloseSession 这几个操作下，各个基础组件的交互时序。</p><p>OpenSession 时序如图3所示，操作步骤如下:</p><p><img src="ca2ta_os.png" alt="图3: OpenSession 时序图" title="图3: OpenSession 时序图"></p><ol><li>CA 经过 TEE Client API 向 TEE Driver 发送 OpenSession 请求。</li><li>TEE Driver 发送 OpenSession SMC 请求到 Trusted OS，此请求中包含要请求 TA 的唯一标识号（UUID）。</li><li>Trusted OS 会根据 TA 的 UUID 查找 TA 是否已经加载了，如果已经加载了，则执行步骤6，否则执行步骤4。</li><li>若请求的 TA 未加载，则 Trusted OS 会向 TEE Helper Daemon 进程发送 Load TA 命令请求，TEE Helper Daemon 收到请求后，会根据要加载的 TA 的 UUID，从文件系统指定路径下找到 TA 镜像文件，并将其加载到预先分配的共享内存中，最后将共享内存的地址回传给 Trusted OS（这次地址回传实际需要经过 TEE Driver 进行虚拟地址与物理地址转换）。</li><li>Trusted OS 从回传的共享地址拷贝 TA 镜像到安全内存中，然后对安全内存中的 TA 镜像的 ELF 格式头，签名信息进行校验，校验通过则加载成功，否则返回错误信息给 CA。</li><li>TA 加载成功后，Trusted OS 分配一个 Session 操作句柄，并定位到已加载镜像的 TA_OpenSessionEntryPoint 函数入口执行。</li><li>最后，Trusted OS 将分配的 Session 句柄逐级返回，最终 CA 拿到 Session 句柄，以后的 InvokeCommand 将需要依赖此句柄进行调用。</li></ol><p>InvokeCommand 和 CloseSession 的流程与 OpenSession 流程相似，差别在于少了 load TA 的流程，时序图如图4和图5所示。</p><p><img src="ca2ta_ic.png" alt="图4: InvokeCommand 时序图" title="图4: InvokeCommand 时序图"></p><p><img src="ca2ta_cs.png" alt="图5: CloseSession 时序图" title="图5: CloseSession 时序图"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><blockquote id="fn_1"><sup>1</sup>. <a href="http://kernel.meizu.com/2017/08/17-33-25-tee_fp.html">指纹 TEE</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://github.com/OP-TEE/optee_os/blob/master/documentation/optee_design.md" target="_blank" rel="noopener">OP-TEE design</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="http://blog.csdn.net/shuaifengyun/article/details/72912238" target="_blank" rel="noopener">OP-TEE中tee-supplicant执行流程</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://github.com/ARM-software/arm-trusted-firmware/blob/master/docs/firmware-design.rst#secure-el1-payloads-and-dispatchers" target="_blank" rel="noopener">Secure-EL1 Payloads and Dispatchers</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> Trusted Execution Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理 —— ION</title>
      <link href="/2017/11/17//memory%20management%20-%20ion.html/"/>
      <url>/2017/11/17//memory%20management%20-%20ion.html/</url>
      
        <content type="html"><![CDATA[<p>ION 是当前 Android 流行的内存分配管理机制，在多媒体部分中使用的最多，例如从 Camera 到 Display，从 Mediaserver 到 Surfaceflinger，都会利用 ION 进行内存分配管理。<br>ION 的前任是 PMEM，关于 PMEM 我在 M030/M04X 项目中有接触过，后来由于 PMEM 的一些局限性，Google 推出了 ION 来取代 PMEM，当前 ION 已经融合到 Linux 主线，被广泛使用。<br>对于魅族，从 M65 项目开始，相机的内存分配管理就已经利用 ION 进行了，本文会结合 M65、M76 和 M86 项目开发介绍下我对 ION 内存管理机制的理解和感悟。</p><h2 id="ION-基本概念"><a href="#ION-基本概念" class="headerlink" title="ION 基本概念"></a>ION 基本概念</h2><p>ION，最显著的特点是它可以被用户空间的进程之间或者内核空间的模块之间进行内存共享，而且这种共享可以是零拷贝的。在实际使用中，ION 和 VIDEOBUF2、DMA-BUF、V4L2 等结合的很紧密。本文主要介绍 ION，其它子系统感兴趣的话后续会陆续进行介绍。</p><p>ION 是在各种 heaps 上分配内存，通过 ion_buffer 来描述所分配的内存。</p><p>下图展示了 ION 的基本框架。图中 PID1、PID2、PID3 表示用户空间进程。ION core 表示 ION 核心层，它提供设备创建、注册等服务，同时提供统一的接口给用户使用。ION Driver 利用 ION core 对相应功能进行实现，可以说它是具体平台相关的，例如 SAMSUNG 平台、QUALCOMM 平台和 MTK 平台都会依据自己的特性开发相应的 ION Driver。</p><p><img src="ION_ARCHI.png" alt="ION_ARCHI"></p><p>上图虽然描述的是用户空间进程使用 ION 的情形，但实际上，在内核空间同样可以直接使用 ION 来分配、管理内存。例如 M76、M86 平台的相机驱动，都有直接使用 ION 分配和管理内存。</p><h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><p>数据结构是程序设计的基础，代码看的多了，其实可以从数据结构看出其能提供的基本功能和大致用法。<br>为了抓住纲领，本文将抓住 ION 的主要数据结构进行介绍。</p><h3 id="ion-device"><a href="#ion-device" class="headerlink" title="ion_device"></a>ion_device</h3><p>ion_device 是 ION 很重要很基础的数据结构，用 struct ion_device 结构体描述，一般在一个系统中只有一个本实例。例如在 M86 中，就是在 exynos_ion_v2.c 的 exynos_ion_probe() 函数中创建了系统唯一的本实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">buffers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">buffer_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plist_head</span> <span class="title">heaps</span>;</span></span><br><span class="line"><span class="keyword">long</span> (*custom_ioctl)(struct ion_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">clients</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debug_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">heaps_debug_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">clients_debug_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">vm_sem</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> page_idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">reserved_vm_area</span>;</span></span><br><span class="line"><span class="keyword">pte_t</span> **pte;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct ion_device 其实是 ION 的核心结构，不过由于对于使用 ION 的用户而言是屏蔽的，即如果是单纯使用 ION，不需要直接和本结构打交道。但是想完全的理解 ION，需要对其有所了解。<br>struct ion_device 是由 ion_device_create() [ion.c] 分配、初始化。</p><ul><li>dev 成员，是 struct miscdevice 类型，所以可想而知 ION 是作为 MISC 设备注册进系统的。从这点还可以看出来，用户空间使用 ION 时必定需要使用 open 啊，ioctl 啊系统调用。事实也正是如此。</li><li>heaps 成员，在 M86 使用过的 KERNEL LINUX 3.10 中是 struct plist_head 类型，但是在此之前并不是此类型，例如在 M65 使用过的 KERNEL LINUX 3.4 中是 struct rb_root 类型。可见随着 KERNEL 和 ION 的演进，struct ion_device 的实现会有所改变。本字段管理的是属于本 struct ion_device 的所有 struct ion_heap 实例。</li><li>clients 成员，是 struct rb_root 类型，struct rb_root 是红黑树，属于二叉树的一种。本字段管理的是 struct ion_client 实例。</li></ul><h3 id="ion-client"><a href="#ion-client" class="headerlink" title="ion_client"></a>ion_client</h3><p>struct ion_client 是由 ion_client_create() [ion.c] 创建，在创建时必须指定上文提到的 struct ion_device 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_client</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">handles</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">char</span> *display_name;</span><br><span class="line"><span class="keyword">int</span> display_serial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debug_root</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>node 成员，是 struct rb_node 结构类型，用于将本 struct ion_client 实例加入到 struct ion_device，具体的是 struct ion_device::clients。</li><li>device 成员，是 struct ion_device 指针结构类型，指向所属的 struct ion_device 实例。</li><li>handles 成员，是 struct rb_root 结构类型，管理其所拥有的 handle，即 struct ion_handle 实例。一个 struct ion_handle 实例表示一个 buffer，即 struct ion_buffer 实例。而 struct ion_buffer 就是从 heap，即 struct ion_heap 中分配的内存。</li></ul><h3 id="ion-heap"><a href="#ion-heap" class="headerlink" title="ion_heap"></a>ion_heap</h3><p>struct ion_heap 表示 ION 中的重要概念 heap。系统会通过链表或者红黑树，这取决与你所使用的 KERNEL 版本，来管理所有的 heap，这些 heap 可用 struct ion_device::heaps 字段来寻找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plist_node</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">enum</span> ion_heap_type type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">shrinker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> free_list_size;</span><br><span class="line"><span class="keyword">spinlock_t</span> free_lock;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> waitqueue;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*debug_show)(struct ion_heap *heap, struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>node 成员，是 struct plist_node 结构，用于将本 heap 实例加入到 struct ion_device 所管理的链表中，详情可以参见 ion_device_add_heap() [ion.c] 函数。</li><li>dev 成员，是 struct ion_device 结构体指针类型，用于指示本 heap 挂在哪一个 struct ion_device 实例下了。</li><li>type 成员，是 enum ion_heap_type 类型，用于表示本 heap 属于哪种类型。用户在使用 ION 分配内存时需要指定 heap 的种类。关于本字段，后续会结合使用方法进行更详细的介绍。</li><li>ops 成员，是 struct ion_heap_ops 类型，它很重要！本字段提供的回调函数是用于从本 heap 中分配内存时所时用的。请参见 ion_buffer_create() [ion.c]，它会调用 struct ion_heap_ops::allocate() 等回调函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> (*allocate)(struct ion_heap *heap,</span><br><span class="line">struct ion_buffer *buffer, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">free</span>)(struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">int</span> (*phys)(struct ion_heap *heap, struct ion_buffer *buffer,</span><br><span class="line">    <span class="keyword">ion_phys_addr_t</span> *addr, <span class="keyword">size_t</span> *len);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> * (*<span class="title">map_dma</span>)(<span class="title">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>,</span></span><br><span class="line"><span class="class">     <span class="title">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span>);</span></span><br><span class="line"><span class="keyword">void</span> (*unmap_dma)(struct ion_heap *heap, struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">void</span> * (*map_kernel)(struct ion_heap *heap, struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">void</span> (*unmap_kernel)(struct ion_heap *heap, struct ion_buffer *buffer);</span><br><span class="line"><span class="keyword">int</span> (*map_user)(struct ion_heap *mapper, struct ion_buffer *buffer,</span><br><span class="line">struct vm_area_struct *vma);</span><br><span class="line"><span class="keyword">int</span> (*shrink)(struct ion_heap *heap, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">int</span> nr_to_scan);</span><br><span class="line"><span class="keyword">void</span> (*preload) (struct ion_heap *heap, <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct ion_preload_object obj[]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>id 成员，也很重要，它可表示优先级，在分配内存时选择哪一个 heap 有关，必须唯一。</li></ul><h3 id="ion-handle"><a href="#ion-handle" class="headerlink" title="ion_handle"></a>ion_handle</h3><p>struct ion_handle 其实就是表示 buffer，用户空间常用它来表示 buffer。本结构通过 ion_handle_create() [ion.c] 分配、初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_handle</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_client</span> *<span class="title">client</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> kmap_cnt;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ref 成员，是 struct kref 结构类型，它在内核中被广泛的用来表示引用计数。ion_handle 的创建和销毁都与其有关，下文会有介绍。</li><li>client 成员，是 struct ion_client 指针类型，指向其所述的 ion_client 实例。</li><li>buffer 成员，是 struct ion_buffer 指针类型，指向真正的 buffer 所在，它可以说是 stuct ion_handle 的核心成员了。</li></ul><p>下面就来介绍 struct ion_buffer 结构。在分配内存时，也是先通过 ion_buffer_create() 创建 ion_buffer 实例，然后交给 ion_handle_create() 创建 ion_handle 实例。</p><h3 id="ion-buffer"><a href="#ion-buffer" class="headerlink" title="ion_buffer"></a>ion_buffer</h3><p>struct ion_buffer 很重要，通过 ION 分配的内存就是通过它表示的。它和上面提到的 ion_handle 的区别主要在于一个是用户空间使用的，一个是内核空间使用的。即虽然常用的接口函数中使用的是 struct ion_handle，但实际上真正表示内存的其实是 struct ion_buffer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">ref</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> private_flags;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">void</span> *priv_virt;</span><br><span class="line"><span class="keyword">ion_phys_addr_t</span> priv_phys;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="keyword">int</span> kmap_cnt;</span><br><span class="line"><span class="keyword">void</span> *vaddr;</span><br><span class="line"><span class="keyword">int</span> dmap_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> *<span class="title">sg_table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">vmas</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">iovas</span>;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ref 成员，是 struct kref 结构实例，维护了本 ion_buffer 的引用计数。当引用计数为 0 时会释放该 buffer，即 struct ion_heap_ops::free 会被调用。分配用 ION_IOC_ALLOC 型 ioctl 系统调用，相应的释放用 ION_IOC_FREE 型 ioctl 系统调用。</li><li>size 成员，当然是本 buffer 所表示的空间的大小，用字节表示。</li><li>priv_virt 成员，是所分配内存的虚拟地址啦，它常与 struct sg_table，或者封装它的结构，有关。它不是我们在内核中读写时所需的内核虚拟地址啦，内核虚拟地址使用 vaddr 成员来表示的。一般而言，物理内存不连续的，使用本字段；否则使用下面的 priv_phys 字段，如 struct ion_heap_ops contig_heap_ops。</li><li>priv_phys 成员，表示所分配的内存的物理地址。它适用于分配的物理内存是连续的 ion heap。这种连续的物理内存：在将其映射到用户空间时，即获取用户空间虚拟地址，可以使用 remap_pfn_range() [memory.c] 这个方便的接口；在将其映射到内核空间时，即获取内核虚拟地址，可以使用 vmap() [vmalloc.c] 这个方便的接口。例子详见 struct ion_heap_ops contig_heap_ops [exynos_ion.c]。priv_virt 成员和 priv_phys 成员组成了一个联合体，其实都表示地址，只不过不同的场景下具体用的不一样而已。</li><li>kmap_cnt 成员，记录本 buffer 被映射到内核空间的次数。</li><li>vaddr 成员，是本 buffer 对应的内核虚拟地址。当 kmap_cnt 不为 0 时有效。可以通过 ion_map_kernel() [ion.c] 来获取本 buffer 对应的内核虚拟地址。ion_map_kernel() [ion.c] 实际上调用的是相应 struct ion_heap_ops::map_kernel 回调函数获取相应的虚拟地址的。</li><li>dmap_cnt 成员，记录本 buffer 被 mapped for DMA 的次数。</li><li>sg_table 成员，是 struct sg_table 结构体类型的指针。本字段与 DMA 操作有关，而且仅仅在 dmap_cnt 成员变量不为 0 时是有效的。可以通过 ion_buffer_create() [ion.c] 来初始化本成员变量，该函数实际上是调用相应 ion_heap 所属的 struct ion_heap_ops::map_dma 回调函数获取本字段的值的。</li><li>dirty 成员，表示 bitmask。即以位图表示本 buffer 的哪一个 page 是 dirty 的，即不能直接用于 DMA。dirty 表示 DMA 的不一致性，即 CPU 缓存中的内容与内存中的实际内容不一样。</li></ul><p>事实上，ION 涉及到的数据结构还有很多，这里列举的都是一些非常重要的。<br>下图展示了上文介绍到的数据结构的基本关系。</p><p><img src="ION_RELAT.png" alt="ION_RELAT"></p><h2 id="重要函数分析"><a href="#重要函数分析" class="headerlink" title="重要函数分析"></a>重要函数分析</h2><p>函数对数据进行处理，完成特定的任务，体现算法的具体实现。</p><h3 id="ion-device-create"><a href="#ion-device-create" class="headerlink" title="ion_device_create"></a>ion_device_create</h3><p>前面分析 ION 的一些核心数据结构时曾经指出，ION 会注册进 MISC 设备，这样用户空间就可以像使用 MISC 设备一样使用 ION 进行内存分配了。<br>先来看 ION 是如何注册进 MISC 子系统的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ion_device *<span class="title">ion_device_create</span><span class="params">(<span class="keyword">long</span> (*custom_ioctl)</span></span></span><br><span class="line"><span class="function"><span class="params">     (struct ion_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">idev</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 分配 struct ion_device 实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">idev = kzalloc(<span class="keyword">sizeof</span>(struct ion_device), GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如前面所说，dev 成员是 struct miscdevice 结构体类型，</span></span><br><span class="line"><span class="comment">* 这里初始化其相关字段，名字指定为 ”ion”，所以提供</span></span><br><span class="line"><span class="comment">* 给用户空间调用的设备节点名为 /dev/ion。</span></span><br><span class="line"><span class="comment">* 用户空间操作该设备节点时，ION 驱动中响应的函数集位于</span></span><br><span class="line"><span class="comment">* ion_fops</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">idev-&gt;dev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">idev-&gt;dev.name = <span class="string">"ion"</span>;</span><br><span class="line">idev-&gt;dev.fops = &amp;ion_fops;</span><br><span class="line">idev-&gt;dev.parent = <span class="literal">NULL</span>;</span><br><span class="line">ret = misc_register(&amp;idev-&gt;dev);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册调试信息接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">idev-&gt;debug_root = debugfs_create_dir(<span class="string">"ion"</span>, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line">idev-&gt;heaps_debug_root = debugfs_create_dir(<span class="string">"heaps"</span>, idev-&gt;debug_root);</span><br><span class="line">...</span><br><span class="line">idev-&gt;clients_debug_root = debugfs_create_dir(<span class="string">"clients"</span>,</span><br><span class="line">idev-&gt;debug_root);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">debugfs_done:</span><br><span class="line"></span><br><span class="line">idev-&gt;custom_ioctl = custom_ioctl;</span><br><span class="line">idev-&gt;buffers = RB_ROOT;</span><br><span class="line">mutex_init(&amp;idev-&gt;buffer_lock);</span><br><span class="line">init_rwsem(&amp;idev-&gt;lock);</span><br><span class="line">plist_head_init(&amp;idev-&gt;heaps);</span><br><span class="line">idev-&gt;clients = RB_ROOT;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* backup of ion device: assumes there is only one ion device */</span></span><br><span class="line">g_idev = idev;</span><br><span class="line"><span class="keyword">return</span> idev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本函数最重要的是分配并初始化了核心 struct ion_device 实例，并将其和 MISC 设备结合起来，这样用户空间就可以通过 open()、ioctl() 等系统调用使用它了。</p><h3 id="ion-open"><a href="#ion-open" class="headerlink" title="ion_open"></a>ion_open</h3><p>用户空间要想使用 ION 进行内存分配，首先必须对设备节点 /dev/ion 进行 open() 系统调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ion_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> *<span class="title">miscdev</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span> = <span class="title">container_of</span>(<span class="title">miscdev</span>, <span class="title">struct</span> <span class="title">ion_device</span>, <span class="title">dev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_client</span> *<span class="title">client</span>;</span></span><br><span class="line"><span class="keyword">char</span> debug_name[<span class="number">64</span>];</span><br><span class="line">…</span><br><span class="line"><span class="built_in">snprintf</span>(debug_name, <span class="number">64</span>, <span class="string">"%u"</span>, task_pid_nr(current-&gt;group_leader));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建struct ion_client 实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">client = ion_client_create(dev, debug_name);</span><br><span class="line">...</span><br><span class="line">file-&gt;private_data = client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ion_open() 函数最重要的作用就是创建了 struct ion_client 实例。这样，后续就可以利用 ioctl 系统调用从其中分配内存了。</p><p>ION 系统提供的 ioctl 类型有很多，常用的有 ION_IOC_ALLOC、ION_IOC_FREE、ION_IOC_SHARE 和 ION_IOC_IMPORT 等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_ALLOC_IOWR(ION_IOC_MAGIC, 0, struct ion_allocation_data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_FREE_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_SHARE_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)</span></span><br></pre></td></tr></table></figure><p>下面就抽出几个典型的进行分析。</p><h3 id="ion-alloc"><a href="#ion-alloc" class="headerlink" title="ion_alloc"></a>ion_alloc</h3><p>这是当用户空间执行 ION_IOC_ALLOC 型 ioctl() 系统调用时所执行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ion_handle *<span class="title">ion_alloc</span><span class="params">(struct ion_client *client, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">int</span> heap_id_mask,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_device</span> *<span class="title">dev</span> = <span class="title">client</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> *<span class="title">buffer</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* len 是用户空间想分配的内存大小，驱动中会将其进行页对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">len = PAGE_ALIGN(len);</span><br><span class="line">...</span><br><span class="line">down_read(&amp;dev-&gt;lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用户空间会指定其想从哪种 heap 分配内存，ION 驱动</span></span><br><span class="line"><span class="comment">* 会对其进行检查并找到最合适的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">heap_id_mask = ion_parse_heap_id(heap_id_mask, flags);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从系统所有的 heap 中找到最合适的 heap 并分配内存，</span></span><br><span class="line"><span class="comment">* 创建 struct ion_buffer 实例。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">plist_for_each_entry(heap, &amp;dev-&gt;heaps, node) &#123;</span><br><span class="line"><span class="comment">/* if the caller didn't specify this heap id */</span></span><br><span class="line"><span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; heap-&gt;id) &amp; heap_id_mask))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">buffer = ion_buffer_create(heap, dev, len, align, flags);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(buffer))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">up_read(&amp;dev-&gt;lock);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在对创建的 ion_buffer 实例进行了一系列的 sanity 检查后</span></span><br><span class="line"><span class="comment">* 利用其创建 struct ion_handle 实例。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">handle = ion_handle_create(client, buffer);</span><br><span class="line">...</span><br><span class="line">mutex_lock(&amp;client-&gt;lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将 struct ion_handle 实例加入到其所属的 struct ion_client</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ret = ion_handle_add(client, handle);</span><br><span class="line">mutex_unlock(&amp;client-&gt;lock);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ion-free"><a href="#ion-free" class="headerlink" title="ion_free"></a>ion_free</h3><p>这是当用户空间执行 ION_IOC_FREE 型 ioctl() 系统调用时所执行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ion_free</span><span class="params">(struct ion_client *client, struct ion_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> valid_handle;</span><br><span class="line"></span><br><span class="line">BUG_ON(client != handle-&gt;client);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;client-&gt;lock);</span><br><span class="line">valid_handle = ion_handle_validate(client, handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!valid_handle) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">"%s: invalid handle passed to free.\n"</span>, __func__);</span><br><span class="line">mutex_unlock(&amp;client-&gt;lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;client-&gt;lock);</span><br><span class="line">ion_handle_put(client, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数比较简单，重点就是通过 ion_handle_put() 来对上文提到的 struct ion_handle::ref 这个 reference count 减一，当 ref 减到 0 时，就会调用 ion_handle_destroy() 来销毁 ion_handle 实例。</p><p>从前文的分析可知，用户空间在利用 ION 分配内存时，需要指定具体的 heap mask，即告知 ION 想从哪种 heap 分配内存。<br>下面就来介绍下。</p><h2 id="HEAP-种类"><a href="#HEAP-种类" class="headerlink" title="HEAP 种类"></a>HEAP 种类</h2><p>以下是通过 ION 分配内存时，可能会使用到的 heap mask。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_SYSTEM_MASK            (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_SYSTEM_CONTIG_MASK     (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_EXYNOS_CONTIG_MASK     (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_EXYNOS_MASK            (1 &lt;&lt; 5)</span></span><br></pre></td></tr></table></figure><p>以 M65 项目为例，系统定义了 4 种 heap，见 dev-ion.c。</p><h3 id="ION-HEAP-TYPE-SYSTEM"><a href="#ION-HEAP-TYPE-SYSTEM" class="headerlink" title="ION_HEAP_TYPE_SYSTEM"></a>ION_HEAP_TYPE_SYSTEM</h3><p>本 heap 的名字为：”ion_noncontig_heap”。相应的 heap mask 为 1，即 ION_HEAP_SYSTEM_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops system_heap_ops [ion_system_heap.c]<br>其内存可以从 HIGHMEM 中分配，所以其物理内存可能不连续。<br>在调试 M65 CAMERA 的 HDR 功能时，一开始发现其写入速度很慢很慢，经过调查，后来在通过 ION 分配内存时指定 ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC | ION_FLAG_PRESERVE_KMAP 标志后速度得到明显提高。</p><h3 id="ION-HEAP-TYPE-SYSTEM-CONTIG"><a href="#ION-HEAP-TYPE-SYSTEM-CONTIG" class="headerlink" title="ION_HEAP_TYPE_SYSTEM_CONTIG"></a>ION_HEAP_TYPE_SYSTEM_CONTIG</h3><p>本 heap 的名字为：”ion_contig_heap”，相应的 heap mask 为 2，即 ION_HEAP_SYSTEM_CONTIG_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops kmalloc_ops [ion_system_heap.c]<br>其内存分配 allocate 回调函数为：ion_system_contig_heap_allocate() [ion_system_heap.c]，该函数很简单，就是利用 kzalloc() 分配内存。</p><h3 id="ION-HEAP-TYPE-EXYNOS"><a href="#ION-HEAP-TYPE-EXYNOS" class="headerlink" title="ION_HEAP_TYPE_EXYNOS"></a>ION_HEAP_TYPE_EXYNOS</h3><p>本 heap 的名字为：”exynos_noncontig_heap”，相应的 heap mask 为 32，即 ION_HEAP_EXYNOS_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops vmheap_ops [exynos_ion.c]<br>其内存可以从 HIGHMEM 中分配，所以其物理内存不一定连续。详情可以见其 allocate 回调函数 ion_exynos_heap_allocate() [exynos_ion.c]。</p><h3 id="ION-HEAP-TYPE-EXYNOS-CONTIG"><a href="#ION-HEAP-TYPE-EXYNOS-CONTIG" class="headerlink" title="ION_HEAP_TYPE_EXYNOS_CONTIG"></a>ION_HEAP_TYPE_EXYNOS_CONTIG</h3><p>本 heap 的名字为：”exynos_contig_heap”。相应的 heap mask 为 16，即 ION_HEAP_EXYNOS_CONTIG_MASK。<br>在本 struct ion_heap 上分配内存的操作集是：<br>struct ion_heap_ops contig_heap_ops [exynos_ion.c]<br>内存由 CMA 分配，所以可以保证其物理地址是连续的。详情可以参见其 allocate 回调函数 ion_exynos_contig_heap_allocate() [exynos_ion.c]。<br>因为本函数是利用 CMA 分配内存，所以可以推测肯定有地方预留了 CMA 所需的物理内存。分析代码后可以发现，这个地方就位于 mach-m65.c 文件。<br>M65 的相机驱动使用了本 ION_HEAP_TYPE_EXYNOS_CONTIG 类型的 heap 来分配内存。<br>按道理，当用户空间获取了 struct ion_handle 实例后，就已经完成了 ION 内存的分配任务。但实际上，为了在不同的进程间，甚至在用户空间和内核空间共享这段内存使用，用户空间还通常需要调用 ION_IOC_SHARE 型ioctl()，获取 ion buffer 相关的 fd，这就和 dma_buf 子系统联系起来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ion_share_dma_buf_fd</span><span class="params">(struct ion_client *client, struct ion_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_buf</span> *<span class="title">dmabuf</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 前面已经说过 struct ion_handle 其实就是对 struct ion_buffer</span></span><br><span class="line"><span class="comment">* 的封装，这里利用 struct ion_client 实例和 struct ion_handle 实例</span></span><br><span class="line"><span class="comment">* 创建了一个 dma_buf。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dmabuf = ion_share_dma_buf(client, handle);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 重要，这样就将 struct ion_buffer 对应的内存转化</span></span><br><span class="line"><span class="comment">* 为文件描述符了。将文件描述符传递给其它进程或者</span></span><br><span class="line"><span class="comment">* 传给内核空间，其它进程或者内核空间就可以使用其内存了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fd = dma_buf_fd(dmabuf, O_CLOEXEC);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，ION 使用过程中涉及到的重要函数都已经介绍完全。当然要完全理解这些函数的细节，需要用户对 dma_buffer 有一定的了解。对 dma_buffer 的介绍不属于本文的范围，有兴趣的话可以参见我写的其它相关文档。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于 Android ION 内存管理机制的介绍就到这里。本文先介绍了什么是 ION，为什么要用 ION。ION 是为了解决内存碎片管理而引入的通用内存管理器，用于取代 PMEM 机制。然后介绍了下 ION 中的重要数据结构，对 struct ion_device、struct ion_client、struct ion_heap、struct ion_handle 和 struct ion_buffer 进行了详细的介绍，并对它们之间的关系进行了阐述。接着，从使用 ION 的场景出发，介绍了一些重要的函数，例如 ion_alloc()，并以实际的相机开发为例介绍了系统中各个 ion_heap 的种类和各自的内存特性。本文还对进程之间、内核空间和用户空间之间的内存共享进行了介绍。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lwn.net/Articles/480055/" target="_blank" rel="noopener">The Android ION memory allocator</a></li><li><a href="https://lwn.net/Articles/565469/" target="_blank" rel="noopener">Integrating the ION memory allocator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 多媒体 </tag>
            
            <tag> ION </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android MTP 分析</title>
      <link href="/2017/11/05/11-52-11-mtp/"/>
      <url>/2017/11/05/11-52-11-mtp/</url>
      
        <content type="html"><![CDATA[<h2 id="mtp简介"><a href="#mtp简介" class="headerlink" title="mtp简介"></a>mtp简介</h2><p>MTP，全称是 Media Transfer Protocol（媒体传输协议）。它是微软的一个为计算机和便携式设备之间传输图像、音乐等所定制的协议。</p><p>Android 从3.0开始支持 MTP。MTP 的应用分两种角色，一个是作为 Initiator，另一个作为 Responder 。以”Android 平板电脑”连接 PC 为例，他们的关系如图所示。</p><p><img src="2.png" alt="mtp_2"></p><p>Initiator —— 在 MTP 中所有的请求都有 Initiator 发起。例如，PC 请求获取 Android 平板电脑上的文件数据。</p><p>Responder —— 它会处理 Initiator 的请求；除此之外，Responder 也会发送 Event 事件。</p><p>这里要注意的是：对于一个 MTP 事件，比如从 PC 拷贝数据到 Android 手机中，整个数据处理是双向通信的。</p><h2 id="mtp-框架"><a href="#mtp-框架" class="headerlink" title="mtp 框架"></a>mtp 框架</h2><p>来张经典的 Android 框架图：</p><p><img src="1.jpg" alt="mtp_frame"></p><p>从图中可以看到，在 kernel 层中分为 MTP 驱动和 USB 驱动，其实呢，真正和底层直接通信的依然是 USB 驱动负责，MTP 驱动只是负责将数据进行打包封装，然后作为一层分别与上层和 USB 之间进行通信。</p><p>再来看一下 JNI 层，那，如果要对 MTP 进行定制化的开发，这一层就需要额外的关注了。相关的源码位置位于：frameworks/av/media/mtp frameworks/base/media/jni/目录下</p><p>在 JNI 层，MtpServer 会不断地监听 Kernel 的消息”MTP 请求”，并对相应的消息进行相关处理。同时，MTP 的 Event 事件也是通过 MtpServer 发送给 MTP 驱动的。 MtpStorage 对应一个”存储单元”；例如，SD 卡就对应一个 MtpStorage。 MtpPacket 和 MtpEventPacket 负责对 MTP 消息进行打包。android_mtp_MtpServer 是一个 JNI 类，它是”JNI 层的 MtpServer 和 Java 层的 MtpServer “沟通的桥梁。android_mtp_MtpDatabase 也是一个 JNI 类，JNI 层通过它实现了对 MtpDatabase (Framework 层)的操作。</p><p>在 Framework 层，MtpServer 相当于一个服务器，它通过和底层进行通信从而提供了 MTP 的相关服务。MtpDatabase 充当着数据库的功能，但它本身并没有数据库对数据进行保存，本质上是通过 MediaProvider 数据库获取所需要的数据。MtpStorage 对应一个”存储单元”，它和”JNI 层的 MtpStorage”相对应。</p><p>在 Apiplication 层，MtpReceiver 负责接收广播，接收到广播后会启动/关闭 MtpService；例如，MtpReceiver 收到 “Android 设备和 PC 连上”的消息时，会启动 MtpService。 MtpService 的作用是提供管理 MTP 的服务，它会启动 MtpServer，以及将本地存储内容和MTP的内容同步。 MediaProvider 在 MTP 中的角色，是本地存储内容查找和本地内容同步；例如，本地新增一个文件时，MediaProvider 会通知 MtpServer 从而进行 MTP 数据同步。</p><h2 id="mtp-移植教程"><a href="#mtp-移植教程" class="headerlink" title="mtp 移植教程"></a>mtp 移植教程</h2><p>说了那么多，那如何在 linux 中移植 MTP 协议呢？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pipe(mtppipe) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    LOGE(<span class="string">"Error creating MTP pipe\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* To enable MTP debug, use the twrp command line feature to</span></span><br><span class="line"><span class="comment"> * twrp set tw_mtp_debug 1</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="comment">//DIR* source=opendir("/tmp");</span></span><br><span class="line"><span class="comment">//DIR* destination=opendir("/data/media/0/backup");</span></span><br><span class="line"><span class="comment">//copy_folder("/tmp","/data/media/0/backup");</span></span><br><span class="line">twrpMtp *mtp = <span class="keyword">new</span> twrpMtp(<span class="number">0</span>);</span><br><span class="line">mtppid = mtp-&gt;forkserver(mtppipe);</span><br><span class="line"><span class="comment">//property_set("sys.usb.config", "mtp,adb");</span></span><br><span class="line"><span class="keyword">if</span> (mtppid) &#123;</span><br><span class="line">    close(mtppipe[<span class="number">0</span>]); <span class="comment">// Host closes read side</span></span><br><span class="line">    mtp_write_fd = mtppipe[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//DataManager::SetValue("tw_mtp_enabled", 1);</span></span><br><span class="line">    <span class="comment">//Add_All_MTP_Storage();</span></span><br><span class="line">    Add_Remove_MTP_Storage(MTP_MESSAGE_ADD_STORAGE);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(mtppipe[<span class="number">0</span>]);</span><br><span class="line">    close(mtppipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//gui_err("mtp_fail=Failed to enable MTP");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先 fork 了进程，通过管道进行通信。那先来看一下父进程做了什么？很简单，初始化了 mtp_message 这个结构体，然后写进 mtp_write_fd ，供子进程读取。该结构体便是控制设备在 PC 端的显示 storage_id 表示该 MTP 设备的 ID 号，path 表示挂载的目录，maxFileSize 表示文件挂载的大小，该值为0表示挂载的大小不做限制，display 是该设备在 PC 端显示的名称<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LOGI(<span class="string">"a[] = %s\n"</span>,a);</span><br><span class="line">LOGI(<span class="string">"mtp_display = %s\n"</span>,mtp_display);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mtp_test=a;</span><br><span class="line">mtp_message.message_type = MTP_MESSAGE_ADD_STORAGE;</span><br><span class="line">mtp_message.storage_id = <span class="number">1</span>;</span><br><span class="line">mtp_message.path = <span class="string">"/data/media/0"</span>;</span><br><span class="line">mtp_message.maxFileSize = <span class="number">0</span>;</span><br><span class="line">mtp_message.display = PROJECT_NAME;</span><br><span class="line">LOGI(<span class="string">"TEST MTP_DISPLAy\n"</span>);</span><br><span class="line">LOGI(<span class="string">"sending message to add %i '%s' '%s'\n"</span>, mtp_message.storage_id, mtp_message.path, mtp_message.display);</span><br><span class="line"><span class="keyword">if</span> (write(mtp_write_fd, &amp;mtp_message, <span class="keyword">sizeof</span>(mtp_message)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    LOGI(<span class="string">"error sending message to add storage %i\n"</span>, mtp_message.storage_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGI(<span class="string">"Message sent, add storage ID: %i\n"</span>,mtp_message.storage_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>分析了父进程的流程，再来分析一下子进程所做的事情，MTP 的整个流程都在这了，很简单，主要就几句代码，可是就这几句代码，揭示了 MTP 的大致思想。首先实例化了一个 twmtp_MtpServer，这里的 twmtp_MtpServer 是个性化制定的设备信息（mtp_MtpServer.cpp 和 MtpServer.cpp 的区别）。之后 set_storages，注意了，就是这里，父进程中的写进去的 mtp_message 就是从这里开始读了，上文我们说道了 MtpStorage 对应一个”存储单元”就是在这里体现了,之后会调用 add_storage 函数将父进程读到的信息写入，这样子一个 MtpStorage 就创建。set_read_pipe 指定了读取的管道，这样子就和父进程建立起了链接，之后 mtp-&gt;start，开始启动 MTP 服务了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twrpMtp::start</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    MTPI(<span class="string">"Starting MTP\n"</span>);</span><br><span class="line">    twmtp_MtpServer *mtp = <span class="keyword">new</span> twmtp_MtpServer();</span><br><span class="line">    mtp-&gt;set_storages(mtpstorages);</span><br><span class="line">    mtp-&gt;set_read_pipe(mtp_read_pipe);</span><br><span class="line">    mtp-&gt;start();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来看一下 start 函数，是否使用 PTP（英语“图片传输协议(picture transfer protocol)”的缩写，手机连接之后可选，用于传输图片），实例化一个 MtpDatabase ，MtpDatabase 在 MTP 中，充当着数据库的功能。但它本身并没有数据库对数据进行保存，本质上是通过 MediaProvider 数据库获取所需要的数据。例如，当在 PC 上，需要读取某个文件时，MtpDatabase 会在 MediaProvider 数据库中查询出文件的相关信息(包括文件名、大小、扩展名等)；然后将这些信息交给 MtpServer，MtpServer 将消息传递给 JNI，在 JNI 中会通过文件名打开，然后再文件句柄等信息传递给 Kernel；Kernel 根据文件句柄读取文件信息，并传给 PC。</p><p>之后打开 mtp 驱动创建的设备节点 /dev/mtp_usb ，底层驱动我们待会分析。</p><p>然后<code>server = new MtpServer(mtpdb, usePtp, 0, 0664, 0775);</code>到这里，终于看到 MTP 协议相关的 server 了，整个 MTP 定义的协议都在这个 class 当中了，这个是 MTP 最核心的东西了。</p><p>add_storage();前文提到，就是在这里将我们初始化的 MtpStorage 加入咯</p><p><code>ThreadPtr mtpptr = &amp;twmtp_MtpServer::mtppipe_thread;</code>喏，这里就是读取那个 mtp_message 了，通过创建了一个线程，用于不断读取管道的数据来添加 mtp 设备<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twmtp_MtpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    usePtp =  <span class="literal">false</span>;</span><br><span class="line">    MyMtpDatabase* mtpdb = <span class="keyword">new</span> MyMtpDatabase();</span><br><span class="line">    <span class="comment">/* Sleep for a bit before we open the MTP USB device because some</span></span><br><span class="line"><span class="comment">     * devices are not ready due to the kernel not responding to our</span></span><br><span class="line"><span class="comment">     * sysfs requests right away.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    usleep(<span class="number">800000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USB_MTP_DEVICE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIFY(x) #x </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND(x) STRINGIFY(x)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mtp_device = EXPAND(USB_MTP_DEVICE);</span><br><span class="line">    MTPI(<span class="string">"Using '%s' for MTP device.\n"</span>, EXPAND(USB_MTP_DEVICE));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>   </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mtp_device = <span class="string">"/dev/mtp_usb"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//fp_mtp =fopen( "/recovery/mtp.log", "a+" );</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(mtp_device, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        MTPE(<span class="string">"could not open MTP driver, errno: %d\n"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    MTPD(<span class="string">"fd: %d\n"</span>, fd);</span><br><span class="line">    server = <span class="keyword">new</span> MtpServer(mtpdb, usePtp, <span class="number">0</span>, <span class="number">0664</span>, <span class="number">0775</span>);</span><br><span class="line">    refserver = server;</span><br><span class="line">    MTPI(<span class="string">"created new mtpserver object\n"</span>);</span><br><span class="line">    add_storage();</span><br><span class="line">    MTPD(<span class="string">"Starting add / remove mtppipe monitor thread\n"</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    ThreadPtr mtpptr = &amp;twmtp_MtpServer::mtppipe_thread;</span><br><span class="line">    PThreadPtr p = *(PThreadPtr*)&amp;mtpptr;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, p, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// This loop restarts the MTP process if the device is unplugged and replugged in</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        server-&gt;run(fd);</span><br><span class="line">        fd = open(mtp_device, O_RDWR);</span><br><span class="line">        usleep(<span class="number">800000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看看 run(fd);函数中的上半段，首先调用 read 函数从 /dev/mtp_usb 中读取数据存入到 mBuffer（实际调用的是 MtpDataPacket::read 函数，该函数还初始化了 mPacketSize，mOffset 两个变量），之后调用了<code>mRequest.getOperationCode</code> <code>mRequest.getTransactionID()</code>两个函数，打开看一下，其实就是对 mBuffer 里面的数据进行处理，要分析为什么这么来的，那就得看 MTP 数据包协议了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MtpServer::run</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mFD = fd;</span><br><span class="line">    MTPI(<span class="string">"MtpServer::run fd: %d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        MTPD(<span class="string">"About to read device...\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = mRequest.read(fd);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ECANCELED) &#123;</span><br><span class="line">                <span class="comment">// return to top of loop and wait for next command</span></span><br><span class="line">                MTPD(<span class="string">"request read returned %d ECANCELED, starting over\n"</span>, ret);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MTPE(<span class="string">"request read returned %d, errno: %d, exiting MtpServer::run loop\n"</span>, ret, errno);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MtpOperationCode operation = mRequest.getOperationCode();</span><br><span class="line">        MtpTransactionID transaction = mRequest.getTransactionID();</span><br><span class="line"></span><br><span class="line">        MTPD(<span class="string">"operation: %s"</span>, MtpDebug::getOperationCodeName(operation));</span><br><span class="line">        mRequest.dump();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// FIXME need to generalize this</span></span><br><span class="line">        <span class="keyword">bool</span> dataIn = (operation == MTP_OPERATION_SEND_OBJECT_INFO</span><br><span class="line">                    || operation == MTP_OPERATION_SET_OBJECT_REFERENCES</span><br><span class="line">                    || operation == MTP_OPERATION_SET_OBJECT_PROP_VALUE</span><br><span class="line">                    || operation == MTP_OPERATION_SET_DEVICE_PROP_VALUE);</span><br><span class="line">        <span class="keyword">if</span> (dataIn) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = mData.read(fd);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == ECANCELED) &#123;</span><br><span class="line">                    <span class="comment">// return to top of loop and wait for next command</span></span><br><span class="line">                    MTPD(<span class="string">"data read returned %d ECANCELED, starting over\n"</span>, ret);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                MTPD(<span class="string">"data read returned %d, errno: %d, exiting MtpServer::run loop\n"</span>, ret, errno);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MTPD(<span class="string">"received data:"</span>);</span><br><span class="line">            mData.dump();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mData.reset();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之后 handleRequest 函数用于处理读到的不同的操作进行不同的操作，每个函数内容都比较多，这里就分析一下从 PC 端拷贝一个数据到手机上的操作，主要做了以下操作,打开看一下，其实都是一些用于解析数据头，之后解析数据的问题了，有兴趣去了解 MTP 协议相关的东西，可以参考去查看一下<a href="https://en.wikipedia.org/wiki/Media_Transfer_Protocol" target="_blank" rel="noopener">mtp wiki</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MTP_OPERATION_SEND_OBJECT_INFO:</span><br><span class="line">    MTPE(<span class="string">"about to call doSendObjectInfo()\n"</span>);</span><br><span class="line">    <span class="comment">//response = MTP_RESPONSE_OBJECT_WRITE_PROTECTED;</span></span><br><span class="line">    response = doSendObjectInfo();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MTP_OPERATION_SEND_OBJECT:</span><br><span class="line">    MTPE(<span class="string">"about to call doSendObject()\n"</span>);</span><br><span class="line">    <span class="comment">//response = MTP_RESPONSE_OBJECT_WRITE_PROTECTED;</span></span><br><span class="line">    response = doSendObject();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><h2 id="mtp-与-kernel-层通信"><a href="#mtp-与-kernel-层通信" class="headerlink" title="mtp 与 kernel 层通信"></a>mtp 与 kernel 层通信</h2><p>kernel 层 MTP 相关的代码在<code>drivers/usb/gadget/function/f_mtp.c</code>中，通过这部分代码，成功创建了 /dev/mtp_usb 节点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file operations for /dev/mtp_usb */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mtp_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read = mtp_read,</span><br><span class="line">    .write = mtp_write,</span><br><span class="line">    .unlocked_ioctl = mtp_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_ioctl = compat_mtp_ioctl,</span><br><span class="line">#endif</span><br><span class="line">    .open = mtp_open,</span><br><span class="line">    .release = mtp_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">mtp_device</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = mtp_shortname,</span><br><span class="line">    .fops = &amp;mtp_fops,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __mtp_setup(struct mtp_instance *fi_mtp)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = misc_register(&amp;mtp_device);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 file_operations 可以知道，上层调用的 write 函数在 kernel 层实则调用的是 mtp_write 函数。现在我们主要来关注一下 mtp_read、mtp_write 这两个函数的实现。</p><ul><li>先来看一下 mtp_write()，主要的几个处理 copy_from_user(req-&gt;buf, buf, xfer) 首先会将用户空间的请求传入到 req-&gt;buf 中，之后通过 usb_ep_queue 函数将 req 中的消息传入到 USB 消息队列中，由 USB 驱动进行之后的数据传送，至于 mtp_write 函数的其他部分都是些对数据处理的过程。总的来说，mtp_write 会将”用户空间”发来的消息拷贝到”内核空间”，并将该消息打包；然后，将打包好的消息添加到 USB 消息队列中。USB 驱动负责将消息队列中的消息传递给 PC<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mtp_write</span><span class="params">(struct file *fp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span> || sendZLP) &#123;</span><br><span class="line"><span class="keyword">if</span> (xfer &amp;&amp; copy_from_user(req-&gt;buf, buf, xfer)) &#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">ret = usb_ep_queue(dev-&gt;ep_in, req, GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>再来看一下 mtp_read() 函数,其实就是 mtp_write() 的逆过程，先从 usb 消息队列中读取 pc 发送给 Android 设备的请求并保存在 req 中，之后等待 read_wq 工作队列将已有的消息处理完毕，最后将 pc 的请求数据通过 copy_to_user 拷贝到用户空间。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mtp_read</span><span class="params">(struct file *fp, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">ret = usb_ep_queue(dev-&gt;ep_out, req, GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">ret = wait_event_interruptible(dev-&gt;read_wq,</span><br><span class="line">                dev-&gt;rx_done || dev-&gt;state != STATE_BUSY);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, req-&gt;buf, xfer))</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>其实通过全文的分析，MTP 协议并没有想象中那么复杂，只是对数据进行了封装，整个数据的传送过程实质还是通过 USB 协议进行的。至于在开发中碰到的数据处理问题，需要的是多去了解 MTP 协议的具体内容而已。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>samsung uboot fastboot command</title>
      <link href="/2017/09/06//samsun-uboot-fastboot-command.html/"/>
      <url>/2017/09/06//samsun-uboot-fastboot-command.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1-fastboot协议"><a href="#1-fastboot协议" class="headerlink" title="1 fastboot协议"></a>1 fastboot协议</h2><p>fastboot 协议是一种通过 usb 连接 pc 和 bootloader 的机制。他被设计的非常容易实现，能够用于多种设备和运行于 Linux、Windows 或者 OSX 的主机。下面将会讲述 pc 和 bootloader 如何通信，以 fastboot flash 命令举例。</p><h3 id="1-1-pc-端"><a href="#1-1-pc-端" class="headerlink" title="1.1 pc 端"></a>1.1 pc 端</h3><p>假设烧写的镜像名为 uboot.bin，烧写的分区名为 bootloader。fastboot flash 命令并会被解析为多个命令。<br>步骤一：pc 发送命令 getvar:partition-type:bootloader<br>pc 发送的第一个命令，获取分区类型，如果你是某种特殊的类型，如 “ext4”。那么 pc 端会发送擦除这个分区的命令，然后在烧写一个 ext4 的类型的镜像进去。此处要烧写的分区是 bootloader，他没有特殊的格式，那么 uboot 就没有回应。<br>步骤二：pc 发送命令 getvar:max-download-size<br>在bootloader 中有一个接受数据的 buffer。这条命令就是获取这个 buffer 的大小。如果 buffer 太小那么 pc 就会把镜像拆分，分段发送。<br>步骤三：pc 发送命令 download:01fbe8b2<br>给出这条命令的时候就是告诉 bootloader，我（pc）现在要发送数据了。接着就是数据的传输过程了。download 命令后面的数据表示发送的数据的大小。<br>步骤四：pc 发送命令 flash:bootloader<br>告诉 bootloader 将发送的数据写到 bootloader 分区中去。如果在写数据的时候发现分区大小比数据大小要小，那么此时就会报错。</p><h3 id="1-2-bootloader-的回应"><a href="#1-2-bootloader-的回应" class="headerlink" title="1.2 bootloader 的回应"></a>1.2 bootloader 的回应</h3><p>bootloader 是被动响应 pc 发送过来的指令。它给 pc 回应信息是一个不大于 64 个字节的包响应， 响应包开头四个字节是 “OKAY”、“FAIL”、“DATA” 或者 “INFO”。<br>        a.INFO：表示信心应该被显示<br>        b.FAIL ：表示命令执行失败<br>        c.OKAY：表示命令执行成功<br>        d.DATA：表示请求的命令已经为数据阶段做好准备<br>对于 pc 端发送过来的命令，bootloader 都会发送响应消息。响应消息的头部就是上述4个中的一个，具体用哪个是具体情况而定。</p><h2 id="2-fastboot-命令"><a href="#2-fastboot-命令" class="headerlink" title="2 fastboot 命令"></a>2 fastboot 命令</h2><p>github 上的 uboot 源码中是没有实现 fastboot 的。这部分是由芯片厂商提供的。此处说的是三星在 uboot 中实现的 fastboot 命令。命令的入口函数为 do_fastboot。因为 usb 设备方面的初始化由芯片厂商完成，所以 usb初始化部分将不是本次讨论的重点。我们将重点关注 fastboot 的流程和其 download 机制。</p><h3 id="2-1-fastboot-的-main-loop"><a href="#2-1-fastboot-的-main-loop" class="headerlink" title="2.1 fastboot 的 main loop"></a>2.1 fastboot 的 main loop</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">continue_from_disconnect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the board specific support */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == fastboot_init(&amp;<span class="keyword">interface</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> poll_status, board_poll_status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we got this far, we are a success */</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">timeout_endtime = get_ticks();</span><br><span class="line">timeout_endtime += timeout_ticks;</span><br><span class="line"></span><br><span class="line">LCD_turnon();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">uint</span>64_t current_time = <span class="number">0</span>;</span><br><span class="line">poll_status = fastboot_poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == check_timeout)</span><br><span class="line">current_time = get_ticks();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the user wanted to terminate with ^C */</span></span><br><span class="line"><span class="keyword">if</span> ( ((poll_status != FASTBOOT_OK) &amp;&amp; (ctrlc())) || gflag_reboot)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Fastboot ended by user\n"</span>);</span><br><span class="line">continue_from_disconnect = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FASTBOOT_ERROR == poll_status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Error */</span></span><br><span class="line">printf(<span class="string">"Fastboot error \n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (FASTBOOT_DISCONNECT == poll_status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* break, cleanup and re-init */</span></span><br><span class="line">printf(<span class="string">"Fastboot disconnect detected\n"</span>);</span><br><span class="line">continue_from_disconnect = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((<span class="number">1</span> == check_timeout) &amp;&amp;</span><br><span class="line">   (FASTBOOT_INACTIVE == poll_status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* No activity */</span></span><br><span class="line"><span class="keyword">if</span> (current_time &gt;= timeout_endtime)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Fastboot inactivity detected\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Something happened */</span></span><br><span class="line"><span class="comment">/* Actual works of parsing are done by rx_handler */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == check_timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Update the timeout endtime */</span></span><br><span class="line">timeout_endtime = current_time;</span><br><span class="line">timeout_endtime += timeout_ticks;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">board_poll_status = board_fastboot_poll();</span><br><span class="line"><span class="keyword">if</span> (BOARD_FASTBOOT_DISCONNECT == board_poll_status)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Fastboot disconnect detected by board action\n"</span>);</span><br><span class="line">continue_from_disconnect = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/* while (1) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset the board specific support */</span></span><br><span class="line">fastboot_shutdown();</span><br><span class="line"></span><br><span class="line">LCD_setfgcolor(<span class="number">0x000010</span>);</span><br><span class="line">LCD_setleftcolor(<span class="number">0x000010</span>);</span><br><span class="line">LCD_setprogress(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* restart the loop if a disconnect was detected */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (continue_from_disconnect);</span><br></pre></td></tr></table></figure><p>上面是 do_fastboot() 函数的主体部分。当调用 do_fastbboot() 函数时给出了第三个参数时候，那么这个值将被解析为超时时间，但是一般都没有传入第三个参数，所以关于超时的检测可以自动屏蔽了。fastboot_init() 函数，完成 usb 硬件设备相关的的初始化。设置了 serial number 以及接受数据的 buffer 的大小。此处的 buffer 和在 rx_handler() 中提及的 buffer 不同。</p><p>while(1) 循环是一直在运行的，除非是检测到了 ctrl+c。通过检测某个中断位是否置 1，判断 pc 是否有消息发送过来，若是有命令发送过来那么将执行 rx_handler() 函数。这个功能是通过函数 fastboot_poll() 函数来实现的。</p><h3 id="2-2-rx-handler"><a href="#2-2-rx-handler" class="headerlink" title="2.2 rx_handler()"></a>2.2 rx_handler()</h3><p>这个函数有两个参数，第一个参数 const unsigned char *buffer 表示接收到的数据在内存中的地址,第二个参数 unsigned int buffer_size 表示接收到的数据大小。 从这个函数的结构来看，它起初并不知道传进来的是命令还是数据，所以命令和数据都是通过一个 buffer 来接受的。那么他是如何实现下载这项功能的呢？</p><h4 id="2-2-1-数据下载"><a href="#2-2-1-数据下载" class="headerlink" title="2.2.1 数据下载"></a>2.2.1 数据下载</h4><p>在前面说过 pc 端在发送数据之前先发送了 download:01fbe8b2 命令，后面接的是即将发送的数据的大小。  rx_handler() 函数会去处理 download 命令，将即将接收的数据大小放在静态变量 download_size 中。 download 命令处理完成，rx_handler() 函数返回。pc 端开始发送数据，buffer 填充满了之后再调用 rx_handler()函数，此时 download_size 的值不为 0，那么就代表此时接收到的是数据。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (download_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Something to download */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Handle possible overflow */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> transfer_size = download_size - download_bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_size &lt; transfer_size)</span><br><span class="line">transfer_size = buffer_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save the data to the transfer buffer */</span></span><br><span class="line"><span class="built_in">memcpy</span> (interface.transfer_buffer + download_bytes,</span><br><span class="line"><span class="built_in">buffer</span>, transfer_size);</span><br><span class="line"></span><br><span class="line">download_bytes += transfer_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if transfer is done */</span></span><br><span class="line"><span class="keyword">if</span> (download_bytes &gt;= download_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Reset global transfer variable, Keep download_bytes because it will be used in the next possible flashing command */</span></span><br><span class="line">download_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (download_error)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* There was an earlier error */</span></span><br><span class="line"><span class="built_in">sprintf</span>(response, <span class="string">"ERROR"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Everything has transferred,</span></span><br><span class="line"><span class="comment">   send the OK response */</span></span><br><span class="line"><span class="built_in">sprintf</span>(response, <span class="string">"OKAY"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fastboot_tx_status(response, <span class="built_in">strlen</span>(response), FASTBOOT_TX_ASYNC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ndownloading of %d bytes finished\n"</span>, download_bytes);</span><br><span class="line">LCD_setprogress(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_RAMDUMP_MODE)</span></span><br><span class="line"><span class="keyword">if</span> (is_ramdump) &#123;</span><br><span class="line">is_ramdump = <span class="number">0</span>;</span><br><span class="line">start_ramdump((<span class="keyword">void</span> *)<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Provide some feedback */</span></span><br><span class="line"><span class="keyword">if</span> (download_bytes &amp;&amp; download_size &amp;&amp; <span class="number">0</span> == (download_bytes &amp; (<span class="number">0x100000</span> - <span class="number">1</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Some feeback that the download is happening */</span></span><br><span class="line"><span class="keyword">if</span> (download_error)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"X"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == (download_bytes % (<span class="number">80</span> * <span class="number">0x100000</span>))) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">LCD_setfgcolor(<span class="number">0x2E8B57</span>);</span><br><span class="line">LCD_setprogress(download_bytes / (download_size/<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Ignore empty buffers */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Warning empty download buffer\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Ignoring\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面是 fastboot 下载数据代码的一部分，其中 download_bytes 表示已经接收的数据的大小。当 download_bytes 大于或等于 download_size 表示数据接收完成，此时将 download_size 置为0，那么就退出了数据接收模式。因为接收数据和接收命令使用的是同一个 buffer，导致buffer不可能太大，所以在接收比较大的image的时候就比较慢，例如刷入system.img。通过修改 buffer 的大小或者在 download 命令中完成数据的接收工作，如此就可以解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> Bootloader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指纹 TEE </title>
      <link href="/2017/08/07/17-33-25-tee_fp/"/>
      <url>/2017/08/07/17-33-25-tee_fp/</url>
      
        <content type="html"><![CDATA[<h1 id="指纹-TEE"><a href="#指纹-TEE" class="headerlink" title="指纹 TEE"></a>指纹 TEE</h1><hr><ul><li><h3 id="TEE-介绍"><a href="#TEE-介绍" class="headerlink" title="TEE 介绍"></a>TEE 介绍</h3><ul><li>TEE 架构</li><li>TEE 启动流程</li><li>TEE 应用场景以及前景</li></ul></li><li><h3 id="指纹硬件原理"><a href="#指纹硬件原理" class="headerlink" title="指纹硬件原理"></a>指纹硬件原理</h3><ul><li>指纹硬件原理</li><li>指纹通信接口与硬件资源</li></ul></li><li><h3 id="指纹软件框架"><a href="#指纹软件框架" class="headerlink" title="指纹软件框架"></a>指纹软件框架</h3><ul><li>指纹TEE软件框架</li><li>指纹软件机制</li></ul></li></ul><h2 id="一、TEE-介绍"><a href="#一、TEE-介绍" class="headerlink" title="一、TEE 介绍"></a>一、TEE 介绍</h2><hr><h3 id="1-TEE-架构"><a href="#1-TEE-架构" class="headerlink" title="1. TEE 架构"></a>1. TEE 架构</h3><p>TEE(Trusted Execution Environment) 是基于 ARM TrustZone 技术拓展而来的，TrustZone 技术是基于 ARM 架构系统级别层次的对 service  以及 device 进行保护的一项技术, 为了支撑该保护技术, ARMV8 本身支持名为 secure mode 的模式，用来区分 normal mode， 其通过设置 Secure Configuration Register 系统寄存器来使能该模式的支持，该寄存器的最后 1 bit 为 0 的话，则表示当前 CPU 处于为 secure mode，如下图所示，并且 ARM 本身支持将系统资源配置成 secure 状态，通过操作 TZPC 控制寄存器可以将系统总线、内存、DMA、cache 等资源配置成 secure  态，配置成 secure 态之后，normal 端运行的程序无法访问其硬件资源。</p><p><img src="tz_two_worlds.png" alt="tz_two_worlds"></p><p>说完 ARMV8 本身支持 secure 模式以及系统硬件资源可配之后，讲解一下 ARMV8 架构。</p><p>ARMv8-a 架构的主要特性包括：</p><blockquote><p>1）新增一套 64-bit 的指令集，称作 A64。</p><p>2）由于需要向前兼容 ARMv7，所以同时支持现存的 32-bit 指令集，称作 A32 和 T32</p><p>3）定义 AArch64 和 AArch32 两套运行环境（称作 Execution state ），分别执行 64-bit 和 32-bit 指令集。软件可以在需要的时候，切换 Execution state。</p><p>4）AArch64 最大的改动，使用新的概念（exception level），重新解释了 processor mode、privilege level 等概念</p><p>5）在 ARMv7 security extension 的基础上，新增 security model，支持安全相关的应用需求。</p><p>6）在 ARMv7 virtualization extension 的基础上，提供完整的 virtualization 框架，从硬件上支持虚拟化。</p></blockquote><p>其中跟 TEE 密切相关的就是 ARMv8-a 实现的 exception level 以及 security 特性。</p><p>ARMV7 架构上，处理器可以工作在多种模式（称作 processor mode）下，包括 User、FIQ、IRQ、Abort、Undefined、System 等, 等于把 ARMV8 架构上 processor mode 的概念去掉了，取而代之的是 4 个固定的 Exception level，简称 EL0-EL3。同时，也淡化了 privilege level 的概念。Exception level 本身就已经包好了 privilege 的信息，即 ELn 的 privilege 随着 n 的增大而增大。类似地，可以将 EL0 归属于 non-privilege level，EL1/2/3 属于 privilege level。</p><p><img src="armv8-a_execution_level.gif" alt="armv8-a_execution_level"></p><p>Exception level 简介:</p><blockquote><p>Application 位于特权等级最低的 EL0，Guest OS（Linux kernel 等）位于 EL1，提供虚拟化支持的 Hypervisor 位于 EL2，提供 Security 支持的 Seurity Monitor 位于 EL3，EL3 的等级最高，其拥有的权限也是最高．</p><p>等级低的 EL 想要陷入到较高等级的 EL 需要通过产生异常，只有异常发生时，才能切换 EL， 并且异常发生时只能是跳转到更高等级的 EL，或是停留在当前 EL．同理，异常处理返回时，只能回到低等级 EL 或是停留在当前 EL。</p><p>其中跟 TEE 运行环境密切相关的就是 EL3，其架构层级所处位置为 security 提供了一个安全环境，首先 EL0 跟 EL1 不能直接访问到 EL3，其次在物理资源(内存 cache 总线等)访问上，不同 security 状态下，可以访问的物理资源是不同的，EL3 具备访问 security 跟 non-security 资源，主要目的保护一些安全应用的数据，例如支付等。</p></blockquote><p>security 简介：<br>ARMv8-a 架构有两个 security state，Security 和  non-Security。主要的功效是物理地址的区隔，以及一些 system control  寄存器的访问控制</p><blockquote><p>在 Security 状态下，处理器可以访问所有的 Secure physical address space 以及 Non-secure physical address space</p><p>在 Non-security 状态下，只能访问 Non-secure physical address space，且不能访问 Secure system control resources</p></blockquote><h3 id="2-TEE-启动流程"><a href="#2-TEE-启动流程" class="headerlink" title="2. TEE 启动流程"></a>2. TEE 启动流程</h3><p><img src="ATF.png" alt="secure_boot"></p><p>TEE 的启动流程是跟手机启动流程密切相关的，如上图所示，上图主要是描述各阶段镜像校验进行，手机芯片出厂时会固化一个启动程序在 IROM(BL1) 里边，里边会存储一把用于校验下一个启动镜像(BL2)的公钥，BL2 镜像会使用对应 BL1 里边公钥的私钥进行签名， 以此类推， BL2 镜像会存有下一个镜像的公钥，用于校验后续的镜像。</p><p>Arm 为 trustzone 提供了一个通用的 Firmware 层 ATF(ARM Trusted Firmware)。ATF 包含了 service router、PSCI、Interrupt Handler 等功能， 该项目是开源的， 相关代码可以参考 GitHub：<a href="https://github.com/ARM-software/arm-trusted-firmware" target="_blank" rel="noopener">https://github.com/ARM-software/arm-trusted-firmware</a></p><p>ATF 会有几个阶段需要进行，分别叫做  BL1、BL2、BL31、BL32、BL33，下面依据自己对源码的理解，简单描述一下各个阶段所做的事情。</p><p>BL1： 上面介绍了 ARM-V8a 的层级关系，为了保证 secure boot，所以 BL1 阶段的启动必须是处于 secure-EL3 层级， 该阶段会做一些架构上的初始化工作，比如说初始化 EL3 异常向量表(比如说跟 TEE 相关的 SMC 异常向量表)、初始化 cpu(cpu0)、控制系统寄存器(EL3层级)设置、使能MMU、配置 storage、 设置传递参数并加载下一阶段镜像。</p><p>BL2： 该镜像运行在 secure-EL1 环境( BL1 会设置一些参数并传递给 BL2，用来设置其运行初始环境)，该阶段会设置 EL1 异常向量表、使能 MMU、配置 storage、设置传递参数 bl2_to_bl31_params、 bl2_to_bl32_params、bl2_to_bl33_params 并加载下阶段的镜像、 发送 SMC 指令陷入到 BL1 初始化好的 SMC 异常向量处理函数，用于设置 BL31 运行的系统环境。</p><p>BL31：该阶段跟 TEE 密切相关， 由于 world-switch 必须是要在 EL3 阶段下才能完成，所以该阶段的进行是需要在 EL3 的环境下执行的， BL2 在加载 BL31 后，会发送一条 SMC 指令(“smc(BL1_SMC_RUN_IMAGE, (unsigned long)bl31_ep_info, 0, 0, 0, 0, 0, 0)”)，并将 BL31 入口参数 (bl31_ep_info) 也传递到 SMC handler 里边进行配置，主要设置当前为 secure-EL3 层级以及 BL31 镜像的 PC 值，进而让 BL31 镜像处于 EL3 层级下运行。 这个阶段会初始化中断GIC、初始化并使能系统计时器， 并且会实现 runtime service init， 这个 runtime service 则是跟 TEE 密切关联的， 该步骤会初始化一系列跟 SMC handler 相关的入口， 其中就包括 TEE 的入口，当然也有跟 CPU 电源管理相关的 PSCI，厂家也可以定制一些入口， 并且会将这个入口地址存放在一个代码段地址上， SMC handler 会依据 SMC CALL 参数来判断，进而从上述代码段地址上选出要进入的处理入口， 其中第三方的 TEE 厂家也会在该阶段进行入口初始化。<br>(SMC CALL 参数规则可以参考  <a href="http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf" target="_blank" rel="noopener">http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf</a> )</p><p>BL32：该阶段会依据BL2阶段设置的启动参数来配置当前运行环境，BL32 运行于 secure-EL1 层级， 针对 TEE 而言，其会初始化好 world-switch 的系统环境，比如说 world-switch 前后的栈保护以及恢复工作。</p><p>BL33： 该阶段会依据BL2阶段设置的启动参数来配置当前运行环境， BL33 运行于 normal-EL1 层级， 该阶段的工作主要是完成 lead kernel 以及 load tee os 镜像的工作。</p><p>至此， TEE 核心部分已经集成并启动完成，TEE 运行依赖已经成功搭建，已经具备了 world-switch 的机制支持， 后续上层的应用则会在这 world-switch 的机制基础上进行交互，下图为基本的 normal-secure 交互框架图</p><p><img src="normal_secure_framework.png" alt="normal-secure-framework"></p><p>应用交互框架主要包含两部分， normal world 的 service &amp; kernel 支持， secure world 的 trusted application(TA) &amp; secure driver。</p><p>normal world 部分， kernel 部分主要是定义了一套 SMC CALL 接口，提供给上层 service 使用。</p><p>secure world 部分，会简单的区分逻辑层(TA)跟驱动层， 驱动层会操作实际的硬件资源，比如说 SPI、I2C总线已经内存资源等。TA 主要是响应来自 normal world 的逻辑需求。</p><p>所有跟私密数据相关，比如说支付密码、指纹数据、鉴权秘钥等不让 normal world 访问的资源，都可以放在 secure world 端进行处理，secure world 可以将数据总线、内存、DMA等硬件资源都保护起来，normal world 无法通过访问硬件通信接口获得数据。</p><p>有了这一套框架的存在，secure world 下的应用程序或是资源，normal world 下正常应用是无法进行访问的，所以只有与 TA 相对应的 normal world 应用，通过定义好的 SMC CALL 规则接口才能切换至 secure world，完成跟 TA 的交互。</p><p>安全防护上，TA 需要校验签名通过方可加载，给 TA 签名的秘钥一般由 OEM 厂家制定，normal world 这边的应用则会受 selinux 权限限制， 无法获得访问 kernel 提供的 SMC CALL 接口权限。</p><h3 id="3-TEE-应用场景以及前景"><a href="#3-TEE-应用场景以及前景" class="headerlink" title="3. TEE 应用场景以及前景"></a>3. TEE 应用场景以及前景</h3><p>TEE 其实是一个安全载体，在业界也有很多安全测试机构对其进行测试评估，就目前而言，还是很多产品、方案厂家承认其安全性的，在移动支付盛行的时代，越来越多在线支付产品会选择使用 TEE 作为安全支持，像现在流行的支付宝、微信支付等都采用了 TEE 方案作为其支付安全保障。</p><p>在未来，相信在身份认证这一领域上，会有越来越多的产品采用 TEE 方案，而其认证形式可能会涉及到指纹、虹膜、人脸等生物识别技术。</p><h2 id="二、指纹硬件环境"><a href="#二、指纹硬件环境" class="headerlink" title="二、指纹硬件环境"></a>二、指纹硬件环境</h2><p>上述介绍了 TEE 的硬件支持、安全启动以及一套完整的应用框架支持，接下来会针对现在市面较为流行的指纹识别技术，简单介绍指纹识别技术以及指纹跟 TEE 的结合。</p><hr><h3 id="1-指纹硬件原理"><a href="#1-指纹硬件原理" class="headerlink" title="1. 指纹硬件原理"></a>1. 指纹硬件原理</h3><p>电容式指纹识别解决方案，是基于电容检测原理而自主开发的按压式指纹识别技术。如下图所示，当 Finger 与 Cover 的接触时，指纹的嵴和峪与 Pixel Array  间会形成不同的耦合电容。 驱动信号由指纹芯片的信号驱动模块产生，通过检测 Finger 与 Sensor 所形成的耦合电容，通过 AD 转换将采集到的数据发送给 Host，从而 Host 可以根据不同的信号耦合量，探测到嵴和峪的位置；指纹 sensor 采集点以阵列式分布,收集实际指纹触碰到的采集点的数据，从而形成指纹图像数据。</p><p><img src="fp.png" alt="fp"></p><h3 id="2-指纹通信接口与硬件资源"><a href="#2-指纹通信接口与硬件资源" class="headerlink" title="2. 指纹通信接口与硬件资源"></a>2. 指纹通信接口与硬件资源</h3><p>(1). 电源：1.8V ~ 3.0V</p><p>(2). 通信总线：SPI 总线。全双工三线同步串行外围接口，采用主从模式（Master Slave）架构；支持多 slave 模式应用，一般仅支持单 Master。时钟由 Master 控制，在时钟移位脉冲下，数据按位传输，高位在前，低位在后，SPI 接口有 2 根单向数据线，为全双工通信。</p><h2 id="三、指纹软件"><a href="#三、指纹软件" class="headerlink" title="三、指纹软件"></a>三、指纹软件</h2><hr><h3 id="1-指纹TEE软件框架"><a href="#1-指纹TEE软件框架" class="headerlink" title="1. 指纹TEE软件框架"></a>1. 指纹TEE软件框架</h3><p><img src="fp_tee_framework.png" alt="fp_tee_framework"></p><p>(1)TA: 处于 secure 端，实现一些基本的硬件操作逻辑功能，如指纹 back  采图等逻辑。</p><p>(2)client: 处于 normal 端，实现安卓上的一些基本接口，如指纹的录入 识别接口等。</p><p>(3)secure driver: 处于 secure 端，主要实现一些总线硬件接口的驱动。如 spi DMA 等。</p><p>(4)secure deamon: 处于 normal 端，响应 client 端需求，桥接 client 跟 kernel 的通信，kernel 端产生异常陷入 EL3，将 client 端指令传至 secure  端。</p><p>(5)secure os: 维持 secure 端 OS 正常运作调度以及提供系统接口给 TA 以及 secure driver 使用。</p><p>简单流程： client 端发起请求(采图、back 中断处理等) —&gt; 经由 secure daemon 到 kernel， 并由 kernel 发起 SMC CALL —&gt;  陷入到EL3，switch 到 secure world —&gt; TA 接收请求 —&gt; secure driver 执行spi数据通信。</p><h3 id="2-指纹软件机制"><a href="#2-指纹软件机制" class="headerlink" title="2. 指纹软件机制"></a>2. 指纹软件机制</h3><p>魅族指纹产品支持两种模式， 一种是 mback 模式，该模式自魅族手机带指纹功能以来就一直存在，具体为轻触返回上一级功能，另一种模式是指纹采图模式，具体为指纹录入识别功能。</p><p>mback 模式下，手指触碰到 pixel 或是 ring 环时，会根据 pixel 或是 ring 的容抗变化阈值来判断<br>是否产生 back 中断，并且会依据变化阈值大小来判断 down 或是 up，down 中断的话，pixel 或是 ring 其中一个达到阈值变化要求，都会产生，如果同时触碰到了 ring 跟 pixel， up中断必须需要 ring 以及 pixel 的阈值变化都达到要<br>求才会产生。</p><p>采图模式下，芯片会定时扫描检测 sensor 区域是否有手指触摸，该扫描周期可以通过配置参数进行调整。当检测到有手指触摸时，会进行指纹数据的扫描，然后会发送中断通知主控读取数据，指纹数据帧以 FIFO 形式边扫描边读取， 采集到的 raw data，首先会经过图像预处理，并且会对图像进行打分，预处理失败该帧图像不会进行进一步的算法处理，在采集流程上，<br>状态为 down irq -&gt; image irq -&gt; image<br>capture -&gt; up irq</p><p><img src="fp_capture.png" alt="fp_capture_image"></p><p>采图模式下，采集完成 raw data 之后需要进行图像算法匹配，其中跟匹配密切相关的是 finger base，finger base 可以简单理解为采集 raw data 后，用来作为比较的原始数据，算法构造指纹数字图像的基准，理想的 finger base 是没有手指在芯片模组上采集的 pixel数据，后续手指置于芯片上采集的 raw data，算法会将采集到的 raw data 跟 finger base 进行对比，从而得出每个 pixel 上的差值，手指的嵴和峪数据会因此不一样，最终会构造出接近真实手指的数字图像。finger base 尤其重要，一般来说，指纹服务开机启动时，由于此时安卓还没有完全启动，此时手指放置于芯片上面的概率最小，默认会采集一帧图像作为原始 finger base，并且会储存在某个位置，后续无论是指纹录入或是指纹匹配都会以这个作为比较基准。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h4 id="http-www-wowotech-net-armv8a-arch-armv8-a-overview-html"><a href="#http-www-wowotech-net-armv8a-arch-armv8-a-overview-html" class="headerlink" title="http://www.wowotech.net/armv8a_arch/armv8-a_overview.html"></a><a href="http://www.wowotech.net/armv8a_arch/armv8-a_overview.html" target="_blank" rel="noopener">http://www.wowotech.net/armv8a_arch/armv8-a_overview.html</a></h4><h4 id="http-genode-org-documentation-articles-trustzone"><a href="#http-genode-org-documentation-articles-trustzone" class="headerlink" title="http://genode.org/documentation/articles/trustzone"></a><a href="http://genode.org/documentation/articles/trustzone" target="_blank" rel="noopener">http://genode.org/documentation/articles/trustzone</a></h4><h4 id="http-www-arm-com-products-security-on-arm-trustzone"><a href="#http-www-arm-com-products-security-on-arm-trustzone" class="headerlink" title="http://www.arm.com/products/security-on-arm/trustzone"></a><a href="http://www.arm.com/products/security-on-arm/trustzone" target="_blank" rel="noopener">http://www.arm.com/products/security-on-arm/trustzone</a></h4>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> Trusted Execution Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dump_stack 实现分析</title>
      <link href="/2017/03/05/18-40-19-dump_stack/"/>
      <url>/2017/03/05/18-40-19-dump_stack/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>说起 <code>dump_stack()</code> ，相信从事 Linux 内核或者驱动相关开发的同行对于此函数肯定不陌生。我们经常会用到此函数来对自己的代码进行 debug，可以快速帮助开发者理清函数调用流程，或者说解决 bug…… 首先我们来看一下 dump_stack 的打印，相信很多人都遇到过 :</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[    4.778339] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[258:charger<span class="emphasis">_thread]CPU: 1 PID: 258 Comm: charger_</span>thread Tainted: G        W       4.4.15+ #50</span><br><span class="line"></span><br><span class="line">[    4.778342] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[258:charger_thread]Hardware name: MT67XX</span><br><span class="line"></span><br><span class="line">[    4.778345] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[258:charger_thread]Call trace:</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778347</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc00008a40c&gt;</span>] dump_backtrace+0x0/0x14c</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778354</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc00008a56c&gt;</span>] show_stack+0x14/0x1c</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778358</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc000368930&gt;</span>] dump_stack+0x8c/0xb0</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778364</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc000852140&gt;</span>] ipanic_die+0x50/0x104</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778368</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc0000bfd94&gt;</span>] notifier<span class="emphasis">_call_</span>chain+0x88/0x2d4</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778374</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc0000c08d4&gt;</span>] notify_die+0x48/0x5c</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778377</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc00008a60c&gt;</span>] die+0x98/0x1b8</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778381</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc000099ab4&gt;</span>] <span class="emphasis">__do_</span>kernel_fault.part.6+0x74/0x90</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778386</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc000097cbc&gt;</span>] do<span class="emphasis">_page_</span>fault+0x2e8/0x2f8</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778392</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc000097d84&gt;</span>] do<span class="emphasis">_translation_</span>fault+0xb8/0xe0</span><br><span class="line"></span><br><span class="line">[<span class="string">    4.778396</span>] <span class="xml"><span class="tag">&lt;<span class="name">1</span>&gt;</span></span>-(1)[<span class="string">258:charger_thread</span>][<span class="symbol">&lt;ffffffc0000822bc&gt;</span>] do<span class="emphasis">_mem_</span>abort+0x40/0xa0</span><br></pre></td></tr></table></figure><p>从打印可以清晰的了解程序到底发生了什么，这是一个很好用的函数，那么今天我们就来透过现象看本质，看看这个函数到底是何方神圣，怎么来实现这种功能的。</p><h2 id="2-实现分析"><a href="#2-实现分析" class="headerlink" title="2 实现分析"></a>2 实现分析</h2><p>通过 grep，发现 dump_stack 函数原型存在于 kernel/lib/dump_stack.c 文件中（注：笔者使用的是 4.4 版本的代码）。它的实现流程如下图所示：</p><p><img src="dump_stack.png" alt="dump_stack"></p><p>可以看到关键的两个函数分别是 dump_stack_print_info 和 show_stack 。其中第一个函数是用来打印 info 信息的，而第二个函数是用来打印 Call trace 的。</p><p><strong>Step 1: dump_stack_print_info</strong></p><p>第一部分主要实现 print info ，函数比较简单，我们直接看代码：</p><pre><code>void dump_stack_print_info(const char *log_lvl){    printk("%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n",        log_lvl, raw_smp_processor_id(), current->pid, current->comm,        print_tainted(), init_utsname()->release,        (int)strcspn(init_utsname()->version, " "),        init_utsname()->version);    if (dump_stack_arch_desc_str[0] != '\0')        printk("%sHardware name: %s\n",        log_lvl, dump_stack_arch_desc_str);    print_worker_info(log_lvl, current);} </code></pre><p>其实 print info 的关键信息就是一句代码实现的：</p><pre><code>printk(&quot;%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n&quot;，     log_lvl, raw_smp_processor_id(), current-&gt;pid, current-&gt;comm,     print_tainted(), init_utsname()-&gt;release,    (int)strcspn(init_utsname()-&gt;version, &quot; &quot;),    init_utsname()-&gt;version);</code></pre><p> current 指针指向的是当前进程，那么这句代码就是分别打印出了：log_level, CPU id, command, kernel taint state, kernel version,  这样就和前面例子中的打印信息对上了 ~</p><p>关于这个 <code>print_tainted()</code> 函数，笔者也不甚了解，通过函数的注释可以知其一二：</p><pre><code>/**  *  print_tainted - return a string to represent the kernel taint state.  *  *  'P' - Proprietary module has been loaded.  *  'F' - Module has been forcibly loaded.  *  'S' - SMP with CPUs not designed for SMP.  *  'R' - User forced a module unload.  *  'M' - System experienced a machine check exception.  *  'B' - System has hit bad_page.  *  'U' - Userspace-defined naughtiness.  *  'D' - Kernel has oopsed before  *  'A' - ACPI table overridden.  *  'W' - Taint on warning.  *  'C' - modules from drivers/staging are loaded.  *  'I' - Working around severe firmware bug.  *  'O' - Out-of-tree module has been loaded.  *  'E' - Unsigned module has been loaded.  *  'L' - A soft lockup has previously occurred.  *  'K' - Kernel has been live patched.  *  *  The string is overwritten by the next call to print_tainted().  */</code></pre><p><strong>Step 2: show_stack</strong></p><p>第二部分的主要功能是实现 Call trace ，它的执行流程如下：</p><p><img src="show_dump.png" alt="show_stack"></p><p> unwind_frame 是判断是否到达栈底的函数，一个线程堆栈大小为 THREAD_SIZE，SP 寄存器存储的是栈顶，由此可以找到对应的栈底，如果没有到堆栈底部，则每次持续打印出相关的函数调用列表。</p><p>接下来就是另一个关键函数 dump_backtrace_entry ，看一下它的代码：</p><pre><code>static void dump_backtrace_entry(unsigned long where){    /*  * Note that 'where' can have a physical address, but it's not handled.  */    print_ip_sym(where);}static inline void print_ip_sym(unsigned long ip){    printk("[<%p>] %pS\n", (void *) ip, (void *) ip);}</code></pre><p>可以看到真正的打印函数也就一句代码，这个是真正的精髓所在：</p><pre><code>printk(&quot;[&lt;%p&gt;] %pS\n&quot;, (void *) ip, (void *) ip);</code></pre><p>把 %pS 作为格式化参数传递给 printk，printk 将负责把对应地址的函数名打印出来。由此看来，如何从地址转换到函数名这个最复杂的工作内核已经帮你做好了，dump stack 直接去用做好的轮子就行了。</p><h2 id="3-关于堆栈"><a href="#3-关于堆栈" class="headerlink" title="3 关于堆栈"></a>3 关于堆栈</h2><p>关于堆栈，首先要从 CPU 说起，以 ARM 32bit 为例来说，我们知道它有很多种 mode，usr/fiq/irq/svc/abt/und/sys。对于每一种 mode 都存在自己的堆栈，并由 SP 寄存器指定，由于进行模式切换就需要保护现场，因此不同 mode 的 SP 要设置为不同值。在内核态使用的都是 svc mode 的堆栈，那如何把不同线程的堆栈分开呢，实际上内核针对不同线程会分配不同的堆栈地址，而堆栈地址都被存在 task_struct 中，这样每次线程调度时就可以把相应的地址设置给 SP 寄存器，由此实现不同内核线程堆栈的切换。</p><p>再来说中断，不管 CPU 是在 usr mode 还是在 svc mode，只要中断到来都会使 CPU 进入到 irq mode，这是一种硬件行为，不过在这之后的处理就属于软件范畴了，kernel 中只是把 irq mode 作为一个中转状态，只存在了很短暂的时间，甚至中断处理程序都不再 irq mode 里执行。根据代码可知，经过短暂的 irq mode 中转后，CPU 会进入到 svc mode 来处理中断服务程序，此时使用的堆栈就是当前被中断进程的内核 svc 堆栈。</p><p>综上所述，dump_stack 其实就是根据当前 svc mode 的 SP 寄存器，打印出堆栈中的函数信息的。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>dump_stack 的实现流程其实都是基于如下两条关键代码：</p><pre><code>printk(&quot;%sCPU: %d PID: %d Comm: %.20s %s %s %.*s\n&quot;，     log_lvl, raw_smp_processor_id(), current-&gt;pid, current-&gt;comm,     print_tainted(), init_utsname()-&gt;release,    (int)strcspn(init_utsname()-&gt;version, &quot; &quot;),    init_utsname()-&gt;version);</code></pre><p>以及</p><pre><code>printk(&quot;[&lt;%p&gt;] %pS\n&quot;, (void *) ip, (void *) ip);</code></pre><p>  有了这两个作为基础，其实对于我们来说，实现一个自己的 dump stack 函数又有何难呢？这个任务就交给读者练习吧，相信一定会收获更多的！</p>]]></content>
      
      
      <categories>
          
          <category> 调试与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dump_stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 搭建 Jenkins 服务指南 </title>
      <link href="/2016/10/15//configure-jenkins-guide.html/"/>
      <url>/2016/10/15//configure-jenkins-guide.html/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果常常需要给其他相关部门输出固件验证问题，那么用 Jenkins 搭建一个自动化的编译环境会是一个不错的选择。这篇文章简单的介绍了 Jenkins 的基本使用，及如何利用插件进行权限的管理，邮件的发送设置。</p><h3 id="一-在-Ubuntu-上搭建-jenkins"><a href="#一-在-Ubuntu-上搭建-jenkins" class="headerlink" title="一 .  在 Ubuntu 上搭建 jenkins"></a>一 .  在 Ubuntu 上搭建 jenkins</h3><ol><li><p>在终端上执行</p> <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - http://pkg.jenkins-ci<span class="meta">.org</span>/debian/jenkins-ci<span class="meta">.org</span>.key | sudo apt-key <span class="keyword">add</span> -</span><br></pre></td></tr></table></figure></li><li><p>在 /etc/apt/sources.list 加上</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:<span class="regexp">//</span>pkg.jenkins-ci.org<span class="regexp">/debian binary/</span></span><br></pre></td></tr></table></figure></li><li><p>更新 package 然后安装 jenkins</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update &amp;&amp; sudo apt-<span class="builtin-name">get</span> install jenkins</span><br></pre></td></tr></table></figure></li><li><p>访问 jenkins 页面</p><ul><li>本地：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li><li>局域网其他电脑：<a href="http://172.16.132.37:8080" target="_blank" rel="noopener">http://172.16.132.37:8080</a></li></ul></li><li><p>终端 Jenkins 操作基本指令</p><ul><li><code>sudo service jenkins status</code> - 查看运行状态</li><li><code>sudo service jenkins start</code> - 启动</li><li><code>sudo service jenkins stop</code> - 停止</li><li><code>sudo service jenkins restart</code> - 重启</li></ul></li></ol><h2 id="二-启用-Jenkins-功能扩展插件"><a href="#二-启用-Jenkins-功能扩展插件" class="headerlink" title="二 . 启用 Jenkins 功能扩展插件"></a>二 . 启用 Jenkins 功能扩展插件</h2><p>Jenkins 提供了很多插件扩展功能，安装插件有两种方式：</p><ol><li>在系统管理 -&gt; 插件管理 -&gt; 可选插件，勾选需要的插件 , 安装重启即可</li><li>安装某些插件，时常会出现网络异常问题，可通过下载安装包，手动安装。<br> 系统管理 -&gt; 插件管理 -&gt; 高级，上传已下载的 hpi 后缀的插件文件，安装重启即可</li></ol><p>安装插件如下：</p><ul><li>Email Extension Plugin ：扩展的邮件功能<br>Jenkins 有内置的邮件功能，但每次只能发送给固定的对象，且格式单一。所以需要使用插件进行扩展。</li></ul><p>扩展的插件可根据构建的结果，选择是否需要发送报告，也可自定义邮件的格式，指定接收对象。</p><p>设置发送配置：在系统设置，邮件通知中，添加 Jenkins 发送人信息。需注意的是，这里使用 SMTP 认证的邮件用户名应与 Jenkins Location 中的系统管理员邮件地址一致，否则会无法使用。设置后可通过发送测试邮件测试配置，</p><p>如能正常受到邮件，则账户设置成功。</p><p>设置邮件默认格式：系统设置中找到 Extended E-mail Notification 配置发送信息</p><p><img src="defalut_Notification.png" alt="默认邮件配置"></p><p>其中 Default Recipients 为默认的邮件接收对象，Default Subject 为邮件标题，Default Content 为邮件内容。</p><p>变量是一个以 $( 美元符号 ) 开始，并以空格结束的字符串。当一个邮件触发时，主题和内容主体字段的所有变量都会通过真实的值动态地替换。同样，变量中的“值”能包含其它的变量，都将被替换成真实的内容。</p><p>常用的属性如下 :</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span>：显示项目的全名</span><br><span class="line"><span class="variable">$&#123;BUILD_NUMBER&#125;</span>: 显示当前构建的编号</span><br><span class="line"><span class="variable">$&#123;CAUSE&#125;</span>: 显示此次构建的触发用户</span><br><span class="line"><span class="variable">$&#123;JENKINS_URL&#125;</span>： 显示 Jenkins 服务器的 url 地址（可在系统设置页面修改）</span><br><span class="line"><span class="variable">$&#123;BUILD_LOG&#125;</span>： 显示最终构建的日志</span><br><span class="line"><span class="variable">$&#123;BUILD_STATUS&#125;</span>：显示当前构建的状态 ( 失败、成功等 )</span><br><span class="line"><span class="variable">$&#123;CHANGES &#125;</span> ：显示上一次构建之后的变化</span><br></pre></td></tr></table></figure><p>项目配置中选择构建后操作 Editable Email Notification，如果不设置，则使用系统的默认设置，</p><p>也可在高级设置中，设置触发邮件发送的条件及接收人。</p><ul><li>Environment Injector Plugin :  自定义用户变量如上图邮件默认内容中的 <code>$BUILD_VERSION_FAC</code>,<code>$FIRMWARE_ADDRESS</code> 就是利用这个插件定义的变量</li></ul><p>安装此插件后，可在项目配置中的构建环境勾选 Inject environment variables to the build process，使用自定义的变量。设置后可在系统管理的系统信息里查看当前环境变量信息</p><ul><li>Role-based Authorization Strategy : 用户权限管理插件<br>安装此插件后，需在系统管理的 Configure Global Security 中的授权策略勾选 Role-Based Strategy，在系统管理页面会多出一个 Manage and Assign Roles 选项，点击该选项，可以看到 Manage Roles 和 Assign Roles 这两个选项，通过它俩，便可以根据需求设置用户的相关权限。</li></ul><p>首先设置各角色的权限，点击 Manage Roles，如下图</p><p><img src="manage_roles.png" alt="角色权限管理"></p><p>需要注意的是在 Global roles 的权限设置会覆盖 Project roles 中的权限，例如一个账户的 Global roles 具有 Job 的 read 权限 ，那么不管这个账户的 Project roles 怎么设置，它都会具备所有 Job 的 read 权限。在 Project roles 有个 Pattern 选项，该选项可设置角色对不同项目的访问权限，如填写 M.* ，表示设置的权限仅对项目名以 M 开头的有效。</p><p>在 Manage Roles 中设置完角色权限后，方可进入 Assign Roles 界面，给用户分配角色，如下图</p><p><img src="Assign_roles.png" alt="角色分配"></p><h2 id="三-建立项目"><a href="#三-建立项目" class="headerlink" title="三 . 建立项目"></a>三 . 建立项目</h2><p>以建立可以实现 Android 系统编译的项目为例，简单介绍项目的建立过程</p><ul><li><p>新建项目，选择“构建一个自由风格的软件项目”</p></li><li><p>在项目配置中，如需用户输入，如编译选项，账户密码或上传文件作为构建参数，则勾选 “参数化构建过程”，根据参数的类型添加参数。</p></li><li><p>源码管理选择 Gerrit Repo，在高级设置里填写源码 repo 的基本信息即可</p></li><li><p>增加构建步骤，选择 Execute Shell，在此处可以执行编译脚本。注意用 bash 执行</p></li><li><p>增加构建后操作步骤，选择 Editable Email Notification , 发送构建结果邮件。</p></li></ul><p>完成以上步骤后，一个简单的用来编译 Android 源码的项目就完成了</p>]]></content>
      
      
      <categories>
          
          <category> 系统管理和维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的设计模式 —— 单例模式</title>
      <link href="/2016/09/18/./android-design-pattern-singleton.html/"/>
      <url>/2016/09/18/./android-design-pattern-singleton.html/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>当我们讨论设计模式的时候，其实我们在讨论面向对象的设计问题。</p><p>软件设计中很多问题都会一次又一次的重复出现，而经过一定的总结之后会有一些优秀的解法沉淀下来，可以用于以后出现的类似问题，我们把这些解法叫做设计模式。</p><p>软件的生命周期决定了其设计要尽可能地面对（需求）改变，所以在开发和维护过程中，面临的较大问题，除了解决问题的关键点，另一个就是解决需求变更和扩展所带来的代码结构变化问题。而设计模式刚好可以让我们的设计更加灵活，在解决问题的基础上，也使得后期的功能扩展对原有结构的影响尽可能小。</p><p><strong>推荐书籍：</strong></p><ol><li>[ 设计模式：可复用面向对象软件的基础 ] [ 推荐书籍 1]</li><li>[Head First 设计模式 ] [ 推荐书籍 2]</li></ol><p>[ 推荐书籍 1]: <a href="http://item.jd.com/10057319.html" target="_blank" rel="noopener">http://item.jd.com/10057319.html</a> ‘ 设计模式：可复用面向对象软件的基础 ‘</p><p>[ 推荐书籍 2]: <a href="http://item.jd.com/10100236.html" target="_blank" rel="noopener">http://item.jd.com/10100236.html</a> ‘Head First 设计模式 ‘</p><h2 id="面向对象软件设计原则"><a href="#面向对象软件设计原则" class="headerlink" title="面向对象软件设计原则"></a>面向对象软件设计原则</h2><p>[《Head First 设计模式》] [ 推荐书籍 2] 一书里面提炼了很多 OO 设计的原则，在这里分析其中的一些。</p><ol><li><strong>找出需求中“可能变化”之处，把它们独立出来。</strong> 这样，新需求对原架构的影响就会减小很多。这个是程序设计最基本的原则，也可以说成，让每次的变化，尽可能地影响最少的代码。</li><li><strong>针对接口编程，而不是针对实现编程。</strong> 这里的接口，可以是 Interface，也可以是 base class，最关键的是，当行为改变时，对使用该接口的地方来讲是透明的。也就是说，要有效利用多态的特性。</li><li><strong>多用组合、少用继承。</strong> 为什么要少用继承？个人的理解是，继承都需要用在能表现多态的地方。</li><li><strong>为了交互对象之间的松耦合设计而努力。</strong> 这个好像不用解释。</li><li><strong>要依赖抽象，不要依赖具体类。</strong> 一旦依赖了具体类，就没办法低耦合了。</li><li><strong>一个类只应该有一个引起变化的原因。</strong> 这是我们奋斗的目标，但是有时候需要综合其他的原则一起考虑。</li></ol><p>还有一些其他原则，有待在实践中不断深化，这里不一一列举了。</p><h2 id="设计模式举例"><a href="#设计模式举例" class="headerlink" title="设计模式举例"></a>设计模式举例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式应该是最简单的一个模式，因为它不涉及和其他类交互的问题。但是写好单例模式并不容易，特别是在多线程环境下，单例模式有时候并不好写。</p><p>当确定系统只需要某个对象的唯一实例时，就需要使用单例模式。</p><p>先看看关系图如下：</p><p><img src="http://i.imgur.com/qAjcNLz.jpg" alt=" 单例模式 UML 类图 "></p><p>最简单的写法就是只提供一个 private 的构造方法，一个 static 的对象和获取这个对象的函数，如下所示：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="literal">null</span>;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种写法即使是在笔试的时候，也的不了多少分的。</p><h4 id="实际应用举例"><a href="#实际应用举例" class="headerlink" title="实际应用举例"></a>实际应用举例</h4><p>一个比较过关的写法是考虑多线程的情况下能够正常运行，并且尽可能推迟生成实例（在生成实例代价较大的情况下比较有用）。以下是一个具体的场景：要根据手机屏幕的亮灭来控制手机 LED 灯的亮灭，这样可以在无屏幕的状态下根据 LED 的情况判断手机是否处于开机状态。</p><p>因为 Framework 中 <code>DisplayPowerState</code> 这个类有在 <code>PowerManagerService</code> 里面更新屏幕的状态，如果不用单例模式，会出现生成多个控制 LED 灯的对象，导致 LED 在指定状态下是一闪一闪的状态，无法达到指定需求。所以考虑使用单例模式来写 LED 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LightHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LightHandler mlightHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LightHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LightHandler</span><span class="params">(Looper looper)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(looper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LightHandler <span class="title">getInstance</span><span class="params">(Looper looper)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mlightHandler == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(mLock)&#123;</span><br><span class="line"><span class="keyword">if</span>(mlightHandler == <span class="keyword">null</span>)</span><br><span class="line">mlightHandler = <span class="keyword">new</span> LightHandler(looper);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mlightHandler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑目前的 Android 版本使用的 java 都在 1.6 以上，所以 <code>volatile</code> 关键字可以有效使用。实测该方法可以有效控制 LED 灯不再闪烁。</p><h4 id="Framework-层代码使用单例模式的例子"><a href="#Framework-层代码使用单例模式的例子" class="headerlink" title="Framework 层代码使用单例模式的例子"></a>Framework 层代码使用单例模式的例子</h4><p>github 上有一个很完整的例子：<a href="https://github.com/simple-Android-framework/android_design_patterns_analysis/tree/master/singleton/mr.simple" target="_blank" rel="noopener" title="Framework 中的单例模式 ">Framework 中的单例模式</a></p><p>这个例子里面解释了 <code>LayoutInflater</code> 使用单例的情况，写得非常详细。里面也提到了 Framework 层的很多  Serivce 都是单例模式，那这里就去看看源代码吧。</p><p><code>.frameworks/base/core/java/com/Android/server/LocalServices.java</code> 这个文件就是典型的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.util.ArrayMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalServices</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LocalServices</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects =</span><br><span class="line"><span class="keyword">new</span> ArrayMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getService</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sLocalServiceObjects) &#123;</span><br><span class="line"><span class="keyword">return</span> (T) sLocalServiceObjects.get(type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addService</span><span class="params">(Class&lt;T&gt; type, T service)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sLocalServiceObjects) &#123;</span><br><span class="line"><span class="keyword">if</span> (sLocalServiceObjects.containsKey(type)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Overriding service registration"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sLocalServiceObjects.put(type, service);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次添加 Service 的时候，都是往 <code>ArrayMap</code> 里面添加一个 <code>key-value</code> 对，通过控制这个数据结构来达到单例的要求。所有的 <code>LoacalServices</code> 在系统中都保持只有一个实例，需要用到的时候，使用 <code>getService()</code> 函数获取即可。可以看到以下一些使用的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./services/core/java/com/android/server/<span class="module-access"><span class="module"><span class="identifier">VibratorService</span>.</span></span>java:<span class="number">230</span>: mPowerManagerInternal = <span class="module-access"><span class="module"><span class="identifier">LocalServices</span>.</span></span>get<span class="constructor">Service(PowerManagerInternal.<span class="params">class</span>)</span>;</span><br><span class="line">./services/core/java/com/android/server/power/<span class="module-access"><span class="module"><span class="identifier">Notifier</span>.</span></span>java:<span class="number">141</span>:mActivityManagerInternal = <span class="module-access"><span class="module"><span class="identifier">LocalServices</span>.</span></span>get<span class="constructor">Service(ActivityManagerInternal.<span class="params">class</span>)</span>;</span><br><span class="line">./services/core/java/com/android/server/<span class="module-access"><span class="module"><span class="identifier">SystemService</span>.</span></span>java:<span class="number">197</span>:        return <span class="module-access"><span class="module"><span class="identifier">LocalServices</span>.</span></span>get<span class="constructor">Service(SystemServiceManager.<span class="params">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>这些都是需要使用 <code>LoacalServices</code> 的例子。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android M 外部存储剖析 </title>
      <link href="/2016/09/11//android-m-external-storage.html/"/>
      <url>/2016/09/11//android-m-external-storage.html/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是建立在你已经对 Android 外部存储的基础知识有一定了解的基础之上，如果之前并不是太了解这个部分，阅读起来可能会比较费劲，可以先阅读参考下面文章：<a href="http://blog.csdn.net/zjbpku/article/details/25161131" target="_blank" rel="noopener">http://blog.csdn.net/zjbpku/article/details/25161131</a></p></blockquote><h2 id="Android-M-外部存储的变化"><a href="#Android-M-外部存储的变化" class="headerlink" title="Android M 外部存储的变化"></a>Android M 外部存储的变化</h2><p>从 Android 6.0 开始，Android 支持移动存储（adoptable storage），例如 SD 卡或者 USB 。移动存储可以像内部存储一样加密和格式化，可以存储所有类型的应用数据。</p><h3 id="权限变化"><a href="#权限变化" class="headerlink" title="权限变化"></a>权限变化</h3><p>是否访问外部存储由各种 Android 权限保护。</p><ul><li>从 Android 1.0 开始，写访问需要 <code>WRITE_EXTERNAL_STORAGE</code> 权限。</li><li>从 Android 4.0 开始，读访问需要 <code>READ_EXTERNAL_STORAGE</code> 权限。</li><li>从 Android 4.4 开始，外部存储设备上的文件，也能够基于目录结构来合成（ synthesized ）不同的 DAC 权限（ owner，group，mode ）。这允许应用能够在外部存储上管理一个包相关的目录，而无需 <code>WRITE_EXTERNAL_STORAGE</code> 权限。例如， 应用 com.example.foo 可以自由访问外部存储上的 Android/data/com.example.foo/ 。这种合成权限是通过 fuse 守护来包裹原始存储设备来完成的。</li><li>Android 6.0 引入了新的运行时权限（runtime permissions ）模型，用于应用在运行中必要时申请权限。由于新模型包含了 READ/WRITE_EXTERNAL_STORAGE ，因此平台需要在不杀死或者重启运行中的应用的前提下，动态对存储访问授权。</li></ul><h4 id="关于运行时权限"><a href="#关于运行时权限" class="headerlink" title="关于运行时权限"></a>关于运行时权限</h4><p>Android 6.0 引入了一个新的应用权限模型，期望对用户更容易理解，更易用和更安全。该模型将标记为危险的权限从安装时权限 ( Install Time Permission ) 模型移动到运行时权限模型（ Runtime Permissions ）:</p><ul><li>安装时权限模型 ( Android 5.1 以及更早 )。用户在应用安装和更新时，对危险权限授权。但是 OEM 和运行商预装的应用将自动预授权。</li><li>运行时权限 ( Android 6.0 及以后 )。用户在应用运行时，对应用授予危险权限。由应用决定何时去申请权限（例如，在应用启动时或者用户访问某个特性时），但必须允许用户来授予或者拒绝应用对特定权限组的访问。OEM 和运营商可以预装应用，但是不能对权限进行预授权（例外情况请看这里 Create exception ）。</li></ul><p>运行时权限提供给用户关于应用所需权限更多的相关上下文和可视性，这也让开发者帮助用户更好的理解：为什么应用需要所请求的权限，授权将有什么样的好处，拒绝将有何种不便。用户可以通过设置中的菜单来撤销应用的权限。</p><h3 id="目录的变化"><a href="#目录的变化" class="headerlink" title="目录的变化"></a>目录的变化</h3><p><strong>Android L:</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">on init</span><br><span class="line">    <span class="comment"># See storage config details at http://source.android.com/tech/storage/</span></span><br><span class="line">    mkdir /mnt/shell/emulated 0700 shell shell</span><br><span class="line">    mkdir /storage/emulated 0555 root root</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> EXTERNAL_STORAGE /storage/emulated/legacy</span><br><span class="line">    <span class="built_in">export</span> EMULATED_STORAGE_SOURCE /mnt/shell/emulated</span><br><span class="line">    <span class="built_in">export</span> EMULATED_STORAGE_TARGET /storage/emulated</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Support legacy paths</span></span><br><span class="line">    symlink /storage/emulated/legacy /sdcard</span><br><span class="line">    symlink /storage/emulated/legacy /mnt/sdcard</span><br><span class="line">    symlink /storage/emulated/legacy /storage/sdcard0</span><br><span class="line">    symlink /mnt/shell/emulated/0 /storage/emulated/legacy</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>mx5:/mnt # ls -l</span><br><span class="line">drwxr-xr-x root     system            <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> asec</span><br><span class="line">dr-xr-xr-x root     root              <span class="number">2014</span><span class="number">-08</span><span class="number">-14</span> <span class="number">20</span>:<span class="number">41</span> cd-rom</span><br><span class="line">drwx------ media_rw media_rw          <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> media_rw</span><br><span class="line">drwxr-xr-x root     system            <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> obb</span><br><span class="line">lrwxrwxrwx root     root              <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> sdcard -&gt; /storage/emulated/legacy</span><br><span class="line">lrwxrwxrwx root     root              <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> sdcard2 -&gt; /storage/sdcard1</span><br><span class="line">drwx------ root     root              <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> secure</span><br><span class="line">drwxr-x--- shell    sdcard_r          <span class="number">2016</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">20</span> shell</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>mx5:/sdcard # ls -l</span><br><span class="line">drwxrwx--x root     sdcard_r          <span class="number">2016</span><span class="number">-07</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">33</span> Android</span><br><span class="line">drwxrwx--- root     sdcard_r          <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span> Customize</span><br><span class="line">drwxrwx--- root     sdcard_r          <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span> DCIM</span><br><span class="line">drwxrwx--- root     sdcard_r          <span class="number">2016</span><span class="number">-07</span><span class="number">-05</span> <span class="number">19</span>:<span class="number">55</span> Download</span><br><span class="line">drwxrwx--- root     sdcard_r          <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span> Movies</span><br><span class="line">drwxrwx--- root     sdcard_r          <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span> Music</span><br><span class="line">drwxrwx--- root     sdcard_r          <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span> Pictures</span><br></pre></td></tr></table></figure><p>在 Android L 上 , 访问 sdcard 的安全主要是通过用户组和权限来控制，详细介绍可以阅读本文开头的链接，这里就不赘述了。</p><p><strong>Android M:</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set up the global environment</span></span><br><span class="line">on init</span><br><span class="line">    <span class="built_in">export</span> ANDROID_STORAGE /storage</span><br><span class="line">    <span class="built_in">export</span> EXTERNAL_STORAGE /sdcard</span><br><span class="line">    <span class="built_in">export</span> ASEC_MOUNTPOINT /mnt/asec</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx root     root              <span class="number">1970</span><span class="number">-10</span><span class="number">-09</span> <span class="number">20</span>:<span class="number">28</span> sdcard -&gt; /storage/self/primary</span><br></pre></td></tr></table></figure><p>所以，在 Android M 上 , <strong>/storage/self</strong> 是访问 sdcard 的关键路径。这个路径非常重要，会在后面的原理介绍中讲到。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="Step-1-sdcard-挂载"><a href="#Step-1-sdcard-挂载" class="headerlink" title="Step 1: sdcard 挂载"></a>Step 1: sdcard 挂载</h4><p>不得已，首先得挂一串代码出来：<em>/system/core/sdcard/sdcard.c</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fuse_setup</span><span class="params">(struct fuse* fuse, <span class="keyword">gid_t</span> gid, <span class="keyword">mode_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> opts[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    fuse-&gt;fd = <span class="built_in">open</span>(<span class="string">"/dev/fuse"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fuse-&gt;fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to open fuse device: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umount2(fuse-&gt;dest_path, MNT_DETACH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(opts, <span class="keyword">sizeof</span>(opts),</span><br><span class="line">            <span class="string">"fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d"</span>,</span><br><span class="line">            fuse-&gt;fd, fuse-&gt;global-&gt;uid, fuse-&gt;global-&gt;gid);</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">"/dev/fuse"</span>, fuse-&gt;dest_path, <span class="string">"fuse"</span>, MS_NOSUID | MS_NODEV | MS_NOEXEC |</span><br><span class="line">            MS_NOATIME, opts) != <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to mount fuse filesystem: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fuse-&gt;gid = gid;</span><br><span class="line">    fuse-&gt;mask = mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* source_path, <span class="keyword">const</span> <span class="keyword">char</span>* label, <span class="keyword">uid_t</span> uid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">gid_t</span> gid, <span class="keyword">userid_t</span> userid, <span class="keyword">bool</span> multi_user, <span class="keyword">bool</span> full_write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_global</span> <span class="title">global</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse</span> <span class="title">fuse_default</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse</span> <span class="title">fuse_read</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse</span> <span class="title">fuse_write</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_handler</span> <span class="title">handler_default</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_handler</span> <span class="title">handler_read</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fuse_handler</span> <span class="title">handler_write</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_default;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_read;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;global, <span class="number">0</span>, <span class="keyword">sizeof</span>(global));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fuse_default, <span class="number">0</span>, <span class="keyword">sizeof</span>(fuse_default));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fuse_read, <span class="number">0</span>, <span class="keyword">sizeof</span>(fuse_read));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fuse_write, <span class="number">0</span>, <span class="keyword">sizeof</span>(fuse_write));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;handler_default, <span class="number">0</span>, <span class="keyword">sizeof</span>(handler_default));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;handler_read, <span class="number">0</span>, <span class="keyword">sizeof</span>(handler_read));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;handler_write, <span class="number">0</span>, <span class="keyword">sizeof</span>(handler_write));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;global.lock, <span class="literal">NULL</span>);</span><br><span class="line">    global.package_to_appid = hashmapCreate(<span class="number">256</span>, str_hash, str_icase_equals);</span><br><span class="line">    global.uid = uid;</span><br><span class="line">    global.gid = gid;</span><br><span class="line">    global.multi_user = multi_user;</span><br><span class="line">    global.next_generation = <span class="number">0</span>;</span><br><span class="line">    global.inode_ctr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;global.root, <span class="number">0</span>, <span class="keyword">sizeof</span>(global.root));</span><br><span class="line">    global.root.nid = FUSE_ROOT_ID; <span class="comment">/* 1 */</span></span><br><span class="line">    global.root.refcount = <span class="number">2</span>;</span><br><span class="line">    global.root.namelen = <span class="built_in">strlen</span>(source_path);</span><br><span class="line">    global.root.name = strdup(source_path);</span><br><span class="line">    global.root.userid = userid;</span><br><span class="line">    global.root.uid = AID_ROOT;</span><br><span class="line">    global.root.under_android = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(global.source_path, source_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multi_user) &#123;</span><br><span class="line">        global.root.perm = PERM_PRE_ROOT;</span><br><span class="line">        <span class="built_in">snprintf</span>(global.obb_path, <span class="keyword">sizeof</span>(global.obb_path), <span class="string">"%s/obb"</span>, source_path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        global.root.perm = PERM_ROOT;</span><br><span class="line">        <span class="built_in">snprintf</span>(global.obb_path, <span class="keyword">sizeof</span>(global.obb_path), <span class="string">"%s/Android/obb"</span>, source_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fuse_default.global = &amp;global;</span><br><span class="line">    fuse_read.global = &amp;global;</span><br><span class="line">    fuse_write.global = &amp;global;</span><br><span class="line"></span><br><span class="line">    global.fuse_default = &amp;fuse_default;</span><br><span class="line">    global.fuse_read = &amp;fuse_read;</span><br><span class="line">    global.fuse_write = &amp;fuse_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(fuse_default.dest_path, PATH_MAX, <span class="string">"/mnt/runtime/default/%s"</span>, label);</span><br><span class="line">    <span class="built_in">snprintf</span>(fuse_read.dest_path, PATH_MAX, <span class="string">"/mnt/runtime/read/%s"</span>, label);</span><br><span class="line">    <span class="built_in">snprintf</span>(fuse_write.dest_path, PATH_MAX, <span class="string">"/mnt/runtime/write/%s"</span>, label);</span><br><span class="line"></span><br><span class="line">    handler_default.fuse = &amp;fuse_default;</span><br><span class="line">    handler_read.fuse = &amp;fuse_read;</span><br><span class="line">    handler_write.fuse = &amp;fuse_write;</span><br><span class="line"></span><br><span class="line">    handler_default.token = <span class="number">0</span>;</span><br><span class="line">    handler_read.token = <span class="number">1</span>;</span><br><span class="line">    handler_write.token = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multi_user) &#123;</span><br><span class="line">        <span class="comment">/* Multi-user storage is fully isolated per user, so "other"</span></span><br><span class="line"><span class="comment">         * permissions are completely masked off. */</span></span><br><span class="line">        <span class="keyword">if</span> (fuse_setup(&amp;fuse_default, AID_SDCARD_RW, <span class="number">0006</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_read, AID_EVERYBODY, <span class="number">0027</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_write, AID_EVERYBODY, full_write ? <span class="number">0007</span> : <span class="number">0027</span>)) &#123;</span><br><span class="line">            ERROR(<span class="string">"failed to fuse_setup\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Physical storage is readable by all users on device, but</span></span><br><span class="line"><span class="comment">         * the Android directories are masked off to a single user</span></span><br><span class="line"><span class="comment">         * deep inside attr_from_stat(). */</span></span><br><span class="line">        <span class="keyword">if</span> (fuse_setup(&amp;fuse_default, AID_SDCARD_RW, <span class="number">0006</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_read, AID_EVERYBODY, full_write ? <span class="number">0027</span> : <span class="number">0022</span>)</span><br><span class="line">                || fuse_setup(&amp;fuse_write, AID_EVERYBODY, full_write ? <span class="number">0007</span> : <span class="number">0022</span>)) &#123;</span><br><span class="line">            ERROR(<span class="string">"failed to fuse_setup\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Drop privs */</span></span><br><span class="line">    <span class="keyword">if</span> (setgroups(<span class="keyword">sizeof</span>(kGroups) / <span class="keyword">sizeof</span>(kGroups[<span class="number">0</span>]), kGroups) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot setgroups: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setgid(gid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot setgid: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setuid(uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"cannot setuid: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multi_user) &#123;</span><br><span class="line">        fs_prepare_dir(global.obb_path, <span class="number">0775</span>, uid, gid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_default, <span class="literal">NULL</span>, start_handler, &amp;handler_default)</span><br><span class="line">            || pthread_create(&amp;thread_read, <span class="literal">NULL</span>, start_handler, &amp;handler_read)</span><br><span class="line">            || pthread_create(&amp;thread_write, <span class="literal">NULL</span>, start_handler, &amp;handler_write)) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to pthread_create\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watch_package_list(&amp;global);</span><br><span class="line">    ERROR(<span class="string">"terminated prematurely\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sdcard service 是 fuse 的守护进程，在 4.0 以后的 android 版本上，sdcard 都是通过 sdcard 服务来挂载和访问的，而且该服务程序还提供额外的权限控制。</p><p>上述代码是 sdcard 的挂载部分，关键代码即根据 vold 传过来的参数来准备好 uid/gid/userid 等信息，并且根据是否为多用户 ( multi_user )，是否 full_write 来准备好下面三个目录的用户组及其对应的权限：</p><ul><li>/mnt/runtime/default/emulated</li><li>/mnt/runtime/read/emulated</li><li>/mnt/runtime/write/emulated</li></ul><h4 id="Step-2-三视图"><a href="#Step-2-三视图" class="headerlink" title="Step 2: 三视图"></a>Step 2: 三视图</h4><p>在第一步结束后，所有挂载的存储设备都会维护三个不同视图：</p><ul><li><strong>/mnt/runtime/default</strong> - 对所有的应用、root 命名空间（adb 和其他系统组件）可见，而无需任何权限</li><li><strong>/mnt/runtime/read</strong> - 对有 <code>READ_EXTERNAL_STORAGE</code> 权限的应用可见。</li><li><strong>/mnt/runtime/write</strong> - 对有 <code>WRITE_EXTERNAL_STORAGE</code> 权限的应用可见。</li></ul><blockquote><p>为什么这样，请一直看到文章结尾，自然知晓原理。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>bullhead:/mnt/runtime/<span class="keyword">default</span>/emulated # ls -l</span><br><span class="line">drwxrwx--x root     sdcard_rw          <span class="number">1970</span><span class="number">-03</span><span class="number">-04</span> <span class="number">02</span>:<span class="number">51</span> <span class="number">0</span></span><br><span class="line">drwxrwx--x root     sdcard_rw          <span class="number">1970</span><span class="number">-03</span><span class="number">-04</span> <span class="number">02</span>:<span class="number">51</span> obb</span><br><span class="line"></span><br><span class="line"><span class="symbol">root@</span>bullhead:/mnt/runtime/read/emulated # ls -l</span><br><span class="line">drwxr-x--- root     everybody          <span class="number">1970</span><span class="number">-03</span><span class="number">-04</span> <span class="number">02</span>:<span class="number">51</span> <span class="number">0</span></span><br><span class="line">drwxr-x--- root     everybody          <span class="number">1970</span><span class="number">-03</span><span class="number">-04</span> <span class="number">02</span>:<span class="number">51</span> obb</span><br><span class="line"></span><br><span class="line"><span class="symbol">root@</span>bullhead:/mnt/runtime/write/emulated # ls -l</span><br><span class="line">drwxrwx--- root     everybody          <span class="number">1970</span><span class="number">-03</span><span class="number">-04</span> <span class="number">02</span>:<span class="number">51</span> <span class="number">0</span></span><br><span class="line">drwxrwx--- root     everybody          <span class="number">1970</span><span class="number">-03</span><span class="number">-04</span> <span class="number">02</span>:<span class="number">51</span> obb</span><br></pre></td></tr></table></figure><p>上述 <strong>default/read/write</strong> 三个目录下的 <strong>0</strong> 和 <strong>obb</strong> 目录所赋予的用户组和权限各不相同。<br>这将为后面不同应用程序的运行时权限打下了基础。</p><blockquote><p>注意，这里的 0 代表用户 0 , 这里需要特别说明一下，从 4.0 后 android 也同时逐步引入了多用户的支持。</p></blockquote><h4 id="Step-3-应用程序启动授权"><a href="#Step-3-应用程序启动授权" class="headerlink" title="Step 3: 应用程序启动授权"></a>Step 3: 应用程序启动授权</h4><p>在 zygote fork app 时，我们为每个运行中的应用创建一个 mount 名字空间，并在其中 bind mount 合适的初始视图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a private mount namespace and bind mount appropriate emulated</span></span><br><span class="line"><span class="comment">// storage for the given user.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> bool <span class="title">MountEmulatedStorage</span><span class="params">(uid_t uid, jint mount_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">        bool force_mount_namespace)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See storage config details at http://source.android.com/tech/storage/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a second private mount namespace for our process</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNS) == -<span class="number">1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to unshare(): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unmount storage provided by root namespace and mount requested view</span></span><br><span class="line">    UnmountTree(<span class="string">"/storage"</span>);</span><br><span class="line"></span><br><span class="line">    String8 storageSource;</span><br><span class="line">    <span class="keyword">if</span> (mount_mode == MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">        storageSource = <span class="string">"/mnt/runtime/default"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mount_mode == MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">        storageSource = <span class="string">"/mnt/runtime/read"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mount_mode == MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">        storageSource = <span class="string">"/mnt/runtime/write"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Sane default of no storage visible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(storageSource.string(), <span class="string">"/storage"</span>,</span><br><span class="line">            NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to mount %s to /storage: %s"</span>, storageSource.string(), strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mount user-specific symlink helper into place</span></span><br><span class="line">    userid_t user_id = multiuser_get_user_id(uid);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> String8 <span class="title">userSource</span><span class="params">(String8::format(<span class="string">"/mnt/user/%d"</span>, user_id)</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (fs_prepare_dir(userSource.string(), <span class="number">0751</span>, <span class="number">0</span>, <span class="number">0</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(userSource.string(), <span class="string">"/storage/self"</span>,</span><br><span class="line">            NULL, MS_BIND, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to mount %s to /storage/self: %s"</span>, userSource.string(), strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仔细的分析这段代码做了些什么：</p><ol><li><p>根据 mount mode 从上面三个已经准备好的路径中选择一个默认的挂载路径，并将这个路径挂到 <code>/storage</code> 上去。注意：这里带的是 <code>MS_BIND | MS_REC | MS_SLAVE</code> 参数，这意味着会拷贝命名空间，所以，每个 app 进入的 <code>/storage</code> 都是私有的。</p></li><li><p>再根据当前的 user_id ，将 <code>/mnt/user/user_id</code> bind 到当前 <code>/storage</code> 的 self 目录上。</p></li></ol><p><strong>经过上述两步之后，达到了一个什么目的呢？</strong></p><p><strong><em>每个 app 都根据自己的授权，选择了不同权限的 runtime 目录进行访问，而不同用户访问的目录也跟去当前用户的 id 区分开了。</em></strong></p><blockquote><p>一切都完美的工作起来了，好像可以结束了！</p></blockquote><h4 id="Step-4-应用程序-runtime-授权"><a href="#Step-4-应用程序-runtime-授权" class="headerlink" title="Step 4: 应用程序 runtime 授权"></a>Step 4: 应用程序 runtime 授权</h4><blockquote><p>回到我们文章开头介绍的 runtime 权限，我们发现，到目前为止，我们似乎并不能 runtime 控制权限？那我们要如何做呢？</p></blockquote><p>其实方法特别简单，当被授予运行时权限时，vold 在运行中的应用的名字空间上，通过 bind mount 来更新视图。</p><ul><li>我猜测 runtime 授权的入口代码是这个：<br>  <em>/frameworks/base/services/core/java/com/android/server/pm/PermissionsState.java</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grantRuntimePermission</span><br><span class="line">  -&gt; onExternalStoragePolicyChanged</span><br><span class="line">    --&gt;remountUidExternalStorage</span><br><span class="line">    mConnector.execute(<span class="string">"volume"</span>, <span class="string">"remount_uid"</span>, uid, modeName);</span><br></pre></td></tr></table></figure><ul><li>然后 <em>/system/vold/CommandListener.cpp</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CommandListener::VolumeCmd::runCommand</span><br><span class="line">  -&gt;sendGenericOkFail(cli, vm-&gt;remountUid(uid, mode));</span><br></pre></td></tr></table></figure><ul><li>重点 <em>/system/vold/VolumeManager.cpp</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> VolumeManager::remountUid(uid_t uid, <span class="keyword">const</span> std::string&amp; mode) &#123;</span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">"Remounting "</span> &lt;&lt; uid &lt;&lt; <span class="string">" as mode "</span> &lt;&lt; mode;</span><br><span class="line"></span><br><span class="line">    DIR* dir;</span><br><span class="line">    struct dirent* de;</span><br><span class="line">    <span class="keyword">char</span> rootName[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> pidName[PATH_MAX];</span><br><span class="line">    <span class="keyword">int</span> pidFd;</span><br><span class="line">    <span class="keyword">int</span> nsFd;</span><br><span class="line">    struct stat sb;</span><br><span class="line">    pid_t child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(dir = opendir(<span class="string">"/proc"</span>))) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to opendir"</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out root namespace to compare against below</span></span><br><span class="line">    <span class="keyword">if</span> (sane_readlinkat(dirfd(dir), <span class="string">"1/ns/mnt"</span>, rootName, PATH_MAX) == -<span class="number">1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to readlink"</span>;</span><br><span class="line">        closedir(dir);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poke through all running PIDs look for apps running as UID</span></span><br><span class="line">    <span class="keyword">while</span> ((de = readdir(dir))) &#123;</span><br><span class="line">        pidFd = -<span class="number">1</span>;</span><br><span class="line">        nsFd = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        pidFd = openat(dirfd(dir), de-&gt;d_name, O_RDONLY | O_DIRECTORY | O_CLOEXEC);</span><br><span class="line">        <span class="keyword">if</span> (pidFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fstat(pidFd, &amp;sb) != <span class="number">0</span>) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">"Failed to stat "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.st_uid != uid) &#123;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Matches so far, but refuse to touch if in root namespace</span></span><br><span class="line">        LOG(DEBUG) &lt;&lt; <span class="string">"Found matching PID "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span> (sane_readlinkat(pidFd, <span class="string">"ns/mnt"</span>, pidName, PATH_MAX) == -<span class="number">1</span>) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">"Failed to read namespace for "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!strcmp(rootName, pidName)) &#123;</span><br><span class="line">            LOG(WARNING) &lt;&lt; <span class="string">"Skipping due to root namespace"</span>;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We purposefully leave the namespace open across the fork</span></span><br><span class="line">        nsFd = openat(pidFd, <span class="string">"ns/mnt"</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (nsFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">"Failed to open namespace for "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(child = fork())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setns(nsFd, CLONE_NEWNS) != <span class="number">0</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Failed to setns for "</span> &lt;&lt; de-&gt;d_name;</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            unmount_tree(<span class="string">"/storage"</span>);</span><br><span class="line"></span><br><span class="line">            std::string storageSource;</span><br><span class="line">            <span class="keyword">if</span> (mode == <span class="string">"default"</span>) &#123;</span><br><span class="line">                storageSource = <span class="string">"/mnt/runtime/default"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">"read"</span>) &#123;</span><br><span class="line">                storageSource = <span class="string">"/mnt/runtime/read"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">"write"</span>) &#123;</span><br><span class="line">                storageSource = <span class="string">"/mnt/runtime/write"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Sane default of no storage visible</span></span><br><span class="line">                _exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(storageSource.c_str(), <span class="string">"/storage"</span>,</span><br><span class="line">                    NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Failed to mount "</span> &lt;&lt; storageSource &lt;&lt; <span class="string">" for "</span></span><br><span class="line">                        &lt;&lt; de-&gt;d_name;</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mount user-specific symlink helper into place</span></span><br><span class="line">            userid_t user_id = multiuser_get_user_id(uid);</span><br><span class="line">            std::<span class="function">string <span class="title">userSource</span><span class="params">(StringPrintf(<span class="string">"/mnt/user/%d"</span>, user_id)</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (TEMP_FAILURE_RETRY(mount(userSource.c_str(), <span class="string">"/storage/self"</span>,</span><br><span class="line">                    NULL, MS_BIND, NULL)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">"Failed to mount "</span> &lt;&lt; userSource &lt;&lt; <span class="string">" for "</span></span><br><span class="line">                        &lt;&lt; de-&gt;d_name;</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child == -<span class="number">1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"Failed to fork"</span>;</span><br><span class="line">            goto next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TEMP_FAILURE_RETRY(waitpid(child, nullptr, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">        close(nsFd);</span><br><span class="line">        close(pidFd)</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述核心代码和 zygote 中很类似，不再赘述，至此，才算彻底搞清楚了 Androd M 在外置存储上权限控制的改变和多用户多进程下的安全原理。</p><blockquote><p>系统使用 <code>setns()</code> 函数来实现上述特性，这要求 Linux 3.8 , 不过 Linux 3.4 加上补丁上也可以支持该功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 外置存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Interrupt</title>
      <link href="/2016/09/01//linux-interrupt.html/"/>
      <url>/2016/09/01//linux-interrupt.html/</url>
      
        <content type="html"><![CDATA[<p>在面试的时候我们常常被问及一个问题：几种中断下半部机制 softirq、tasklet、workqueue 有什么区别？Linux 为什么要设计这几种机制？真正能够回答清楚的人还是少数的。下面我们就详细分析一下这其中的区别。</p><blockquote><p>本文的代码分析基于 Linux kernel 3.18.22 和 arm64 架构，最好的学习方法还是 “RTFSC”</p></blockquote><h2 id="1-Linux-中断"><a href="#1-Linux-中断" class="headerlink" title="1. Linux 中断"></a>1. Linux 中断</h2><p>arm64 和其他所有 CPU 架构的中断处理流程都是一样：正常执行流程被打断进入中断服务程序，保护现场、处理中断、恢复现场：</p><p><img src="int_handler.png" alt=" 中断处理"><sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><p>在整个中断处理过程中，arm64 的 CPU 全局中断是自动 disable 的 (PSTATE 寄存器中的 interrupt bit 被 masks)。如果用户想支持 interrupt nested，需要自己在中断服务程序中使能中断。Linux 现在是不使用中断嵌套的。</p><p><img src="int_nested_handler.png" alt=" 中断嵌套处理 "><sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><h3 id="1-1-CPU-中断打开-关闭"><a href="#1-1-CPU-中断打开-关闭" class="headerlink" title="1.1 CPU 中断打开 / 关闭"></a>1.1 CPU 中断打开 / 关闭</h3><p>arm64 关闭和打开本地 CPU 的全局中断的方法，是操作 SPSR(Saved Process Status Register) 寄存器 IRQ mask bit。</p><p><img src="int_arm64_spsr.png" alt="Arm64 SPSR"><sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><p>Linux 中 arm64 关闭和打开本地 CPU 中断的函数实现。</p><ul><li>arch/arm64/include/asm/irqflags.h:</li><li><code>local_irq_disable()</code> -&gt; <code>raw_local_irq_disable()</code> -&gt; <code>arch_local_irq_disable()</code></li><li><code>local_irq_enable()</code> -&gt; <code>raw_local_irq_enable()</code> -&gt; <code>arch_local_irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_local_irq_enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (1) 清除 DAIF 中的 bit2 I 标志位，打开中断</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"msrdaifclr, #2// arch_local_irq_enable"</span></span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">arch_local_irq_disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (2) 设置 DAIF 中的 bit2 I 标志位，关闭中断</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"msrdaifset, #2// arch_local_irq_disable"</span></span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_local_irq_save</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (3) 备份 DAIF 标志</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mrs%0, daif// arch_local_irq_save\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"msrdaifset, #2"</span></span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"=r"</span> (flags)</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_local_save_flags</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// (4) 恢复 DAIF 标志</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mrs%0, daif// arch_local_save_flags"</span></span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"=r"</span> (flags)</span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line"><span class="function"><span class="params">: <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-中断控制器-GIC"><a href="#1-2-中断控制器-GIC" class="headerlink" title="1.2 中断控制器 GIC"></a>1.2 中断控制器 GIC</h3><p>上面描述了 CPU 对全局中断的处理，但是还有一个工作需要有人去做：就是把外部中断、内部中断、CPU 间中断等各种中断按照优先级、亲和力、私有性等发送给多个 CPU。负责这个工作的就是中断控制器 GIC(Generic Interrupt Controller)。</p><p><img src="int_gic400.gif" alt="GIC400"><sup><a href="#fn_GICANALY" id="reffn_GICANALY">GICANALY</a></sup></p><p>从软件角度上看，GIC 可以分成两个功能模块：<sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><ul><li>Distributor。负责连接系统中所有的中断源，通过寄存器可以独立的配置每个中断的属性：priority、state、security、outing information、enable status。定义哪些中断可以转发到 CPU core。</li><li>CPU Interface。CPU core 用来接收中断，寄存器主要提供的功能：mask、 identify 、control states of interrupts forwarded to that core。每个 CPU core 拥有自己的 CPU interface。</li></ul><p>对 GIC 来说，中断可以分成以下几种类型：<sup><a href="#fn_ARMPG" id="reffn_ARMPG">ARMPG</a></sup></p><ul><li>SGI(Software Generated Interrupt)，Interrupt IDs 0-15。系统一般用其来实现 IPI 中断。</li><li>PPI(Private Peripheral Interrupt)，Interrupt IDs16-31。私有中断，这种中断对每个 CPU 都是独立一份的，比如 per-core timer 中断。</li><li>SPI(Shared Peripheral Interrupt)，Interrupt numbers 32-1020。最常用的外设中断，中断可以发给一个或者多个 CPU。</li><li>LPI(Locality-specific Peripheral Interrupt)。基于 message 的中断，GICv2 和 GICv1 中不支持。</li></ul><p>GIC 从原理上理解并不难，但是如果涉及到级联等技术细节，整个初始化过程还是比较复杂。大家可以自行下载 GIC 手册：<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0471b/index.html" target="_blank" rel="noopener">GIC-400</a>、<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0516e/index.html" target="_blank" rel="noopener">GIC-500</a> 学习，<a href="http://www.wowotech.net/irq_subsystem/gic_driver.html" target="_blank" rel="noopener">GIC 代码分析 </a> 也是一篇很不错的分析文章。</p><p>一款 GIC 相关的操作函数都会集中到 irq_chip 数据结构中，以 GIC-400 为例，它的相关操作函数如下：</p><ul><li>drivers/irqchip/irq-gic.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> <span class="title">gic_chip</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"GIC"</span>,</span><br><span class="line">.irq_mask= gic_mask_irq,</span><br><span class="line">.irq_unmask= gic_unmask_irq,</span><br><span class="line">.irq_eoi= gic_eoi_irq,</span><br><span class="line">.irq_set_type= gic_set_type,</span><br><span class="line">.irq_retrigger= gic_retrigger,</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">.irq_set_affinity= gic_set_affinity,</span><br><span class="line">#endif</span><br><span class="line">.irq_set_wake= gic_set_wake,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-Linux-中断处理流程"><a href="#1-3-Linux-中断处理流程" class="headerlink" title="1.3 Linux 中断处理流程"></a>1.3 Linux 中断处理流程</h3><p>从代码上看 Linux 中断的处理流程大概是这样的：</p><p><img src="int_handle_flow.png" alt="Linux 中断处理基本流程 "></p><p>从处理流程上看，对于 gic 的每个中断源，Linux 系统分配一个 irq_desc 数据结构与之对应。irq_desc 结构中有两个中断处理函数 <code>desc-&gt;handle_irq()</code> 和 <code>desc-&gt;action-&gt;handler()</code>，这两个函数代表中断处理的两个层级：</p><ul><li><p><code>desc-&gt;handle_irq()</code>。第一层次的中断处理函数，这个是系统在初始化时根据中断源的特征统一分配的，不同类型的中断源的 gic 操作是不一样的，把这些通用 gic 操作提取出来就是第一层次的操作函数。具体实现包括：</p><ul><li><code>handle_fasteoi_irq()</code></li><li><code>handle_simple_irq()</code></li><li><code>handle_edge_irq()</code></li><li><code>handle_level_irq()</code></li><li><code>handle_percpu_irq()</code></li><li><code>handle_percpu_devid_irq()</code></li></ul></li><li><p><code>desc-&gt;action-&gt;handler()</code> 第二层次的中断处理函数，由用户注册实现具体设备的驱动服务程序，都是和 GIC 操作无关的代码。同时一个中断源可以多个设备共享，所以一个 desc 可以挂载多个 action，由链表结构组织起来。</p></li></ul><p><img src="int_handler_action.png" alt="Linux 中断处理层级 "></p><h3 id="1-4-中断服务注册"><a href="#1-4-中断服务注册" class="headerlink" title="1.4 中断服务注册"></a>1.4 中断服务注册</h3><p>从上一节的中断二层结构中可以看到第二层的中断处理函数 desc-&gt;action-&gt;handler 是由用户来注册的，下面我们来分析具体注册过程：</p><ul><li>kernel/irq/manage.c:</li><li><code>request_irq()</code> -&gt; <code>request_threaded_irq()</code> -&gt; <code>__setup_irq()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __must_check</span><br><span class="line">request_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment"> * otherwise we'll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment"> * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment"> * logic etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 根据中断号找到对应的 desc 结构</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 如果 action-&gt;handler 为空，那么用户是想创建一个线程化中断</span></span><br><span class="line"><span class="comment">// 将线程化中断的 action-&gt;handler 初始化为 irq_default_primary_handler()</span></span><br><span class="line"><span class="comment">// irq_default_primary_handler() 非常简单，只是返回一个 IRQ_WAKE_THREAD 值</span></span><br><span class="line"><span class="keyword">if</span> (!handler) &#123;</span><br><span class="line"><span class="keyword">if</span> (!thread_fn)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">handler = irq_default_primary_handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 分配新的 action 数据结构</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(struct irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;</span><br><span class="line">action-&gt;thread_fn = thread_fn;</span><br><span class="line">action-&gt;flags = irqflags;</span><br><span class="line">action-&gt;name = devname;</span><br><span class="line">action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">chip_bus_lock(desc);</span><br><span class="line"><span class="comment">// (4) 将新的 action 结构安装到 desc 中</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br><span class="line">chip_bus_sync_unlock(desc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">kfree(action);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line"><span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It's a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment"> * to happen immediately, so let's make sure....</span></span><br><span class="line"><span class="comment"> * We disable the irq to make sure that a 'real' IRQ doesn't</span></span><br><span class="line"><span class="comment"> * run in parallel with our fake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">disable_irq(irq);</span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">enable_irq(irq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__setup_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_desc *desc, struct irqaction *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">old</span>, **<span class="title">old_ptr</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags, thread_mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret, nested, shared = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">cpumask_var_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip == &amp;no_irq_chip)</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(desc-&gt;owner))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether the interrupt nests into another interrupt</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nested = irq_settings_is_nested_thread(desc);</span><br><span class="line"><span class="comment">// (4.1) 判断中断是否是支持嵌套</span></span><br><span class="line"><span class="keyword">if</span> (nested) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>-&gt;thread_fn) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Replace the primary handler which was provided from</span></span><br><span class="line"><span class="comment"> * the driver for non nested interrupt handling by the</span></span><br><span class="line"><span class="comment"> * dummy function which warns when called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span>-&gt;handler = irq_nested_primary_handler;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (4.2) 判断中断是否可以被线程化</span></span><br><span class="line"><span class="comment">// 如果中断没有设置 _IRQ_NOTHREAD 标志 &amp; 强制中断线程化标志被设置 (force_irqthreads=1)</span></span><br><span class="line"><span class="comment">// 强制把中断线程化：</span></span><br><span class="line"><span class="comment">// new-&gt;thread_fn = new-&gt;handler;new-&gt;handler = irq_default_primary_handler;</span></span><br><span class="line"><span class="keyword">if</span> (irq_settings_can_thread(desc))</span><br><span class="line">irq_setup_forced_threading(<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a handler thread when a thread function is supplied</span></span><br><span class="line"><span class="comment"> * and the interrupt does not nest into another interrupt</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.3) 如果是线程化中断，创建线程化中断对应的线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span></span><br><span class="line">.sched_priority = MAX_USER_RT_PRIO/<span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">t = kthread_create(irq_thread, <span class="keyword">new</span>, <span class="string">"irq/%d-%s"</span>, irq,</span><br><span class="line">   <span class="keyword">new</span>-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(t)) &#123;</span><br><span class="line">ret = PTR_ERR(t);</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sched_setscheduler_nocheck(t, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We keep the reference to the task struct even if</span></span><br><span class="line"><span class="comment"> * the thread dies to avoid that the interrupt code</span></span><br><span class="line"><span class="comment"> * references an already freed task_struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">get_task_struct(t);</span><br><span class="line"><span class="comment">// 赋值给 -&gt;thread 成员</span></span><br><span class="line"><span class="keyword">new</span>-&gt;thread = t;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell the thread to set its affinity. This is</span></span><br><span class="line"><span class="comment"> * important for shared interrupt handlers as we do</span></span><br><span class="line"><span class="comment"> * not invoke setup_affinity() for the secondary</span></span><br><span class="line"><span class="comment"> * handlers as everything is already set up. Even for</span></span><br><span class="line"><span class="comment"> * interrupts marked with IRQF_NO_BALANCE this is</span></span><br><span class="line"><span class="comment"> * correct as we want the thread to move to the cpu(s)</span></span><br><span class="line"><span class="comment"> * on which the requesting code placed the interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_bit(IRQTF_AFFINITY, &amp;<span class="keyword">new</span>-&gt;thread_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!alloc_cpumask_var(&amp;mask, GFP_KERNEL)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Drivers are often written to work w/o knowledge about the</span></span><br><span class="line"><span class="comment"> * underlying irq chip implementation, so a request for a</span></span><br><span class="line"><span class="comment"> * threaded irq without a primary hard irq context handler</span></span><br><span class="line"><span class="comment"> * requires the ONESHOT flag to be set. Some irq chips like</span></span><br><span class="line"><span class="comment"> * MSI based interrupts are per se one shot safe. Check the</span></span><br><span class="line"><span class="comment"> * chip flags, so we can avoid the unmask dance at the end of</span></span><br><span class="line"><span class="comment"> * the threaded handler for those.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)</span><br><span class="line"><span class="keyword">new</span>-&gt;flags &amp;= ~IRQF_ONESHOT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following block of code has to be executed atomically</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.4) 找到最后一个 action 结构</span></span><br><span class="line">raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</span><br><span class="line">old_ptr = &amp;desc-&gt;action;</span><br><span class="line">old = *old_ptr;</span><br><span class="line"><span class="keyword">if</span> (old) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Can't share interrupts unless both agree to and are</span></span><br><span class="line"><span class="comment"> * the same type (level, edge, polarity). So both flag</span></span><br><span class="line"><span class="comment"> * fields must have IRQF_SHARED set and the bits which</span></span><br><span class="line"><span class="comment"> * set the trigger type must match. Also all must</span></span><br><span class="line"><span class="comment"> * agree on ONESHOT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!((old-&gt;flags &amp; <span class="keyword">new</span>-&gt;flags) &amp; IRQF_SHARED) ||</span><br><span class="line">    ((old-&gt;flags ^ <span class="keyword">new</span>-&gt;flags) &amp; IRQF_TRIGGER_MASK) ||</span><br><span class="line">    ((old-&gt;flags ^ <span class="keyword">new</span>-&gt;flags) &amp; IRQF_ONESHOT))</span><br><span class="line"><span class="keyword">goto</span> mismatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All handlers must agree on per-cpuness */</span></span><br><span class="line"><span class="keyword">if</span> ((old-&gt;flags &amp; IRQF_PERCPU) !=</span><br><span class="line">    (<span class="keyword">new</span>-&gt;flags &amp; IRQF_PERCPU))</span><br><span class="line"><span class="keyword">goto</span> mismatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* add new interrupt at end of irq queue */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Or all existing action-&gt;thread_mask bits,</span></span><br><span class="line"><span class="comment"> * so we can find the next zero bit for this</span></span><br><span class="line"><span class="comment"> * new action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">thread_mask |= old-&gt;thread_mask;</span><br><span class="line">old_ptr = &amp;old-&gt;next;</span><br><span class="line">old = *old_ptr;</span><br><span class="line">&#125; <span class="keyword">while</span> (old);</span><br><span class="line"><span class="comment">// 如果有多个 action，共享标志设为 1</span></span><br><span class="line">shared = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the thread mask for this irqaction for ONESHOT. For</span></span><br><span class="line"><span class="comment"> * !ONESHOT irqs the thread mask is 0 so we can avoid a</span></span><br><span class="line"><span class="comment"> * conditional in irq_wake_thread().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_ONESHOT) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unlikely to have 32 resp 64 irqs sharing one line,</span></span><br><span class="line"><span class="comment"> * but who knows.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (thread_mask == ~<span class="number">0U</span>L) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The thread_mask for the action is or'ed to</span></span><br><span class="line"><span class="comment"> * desc-&gt;thread_active to indicate that the</span></span><br><span class="line"><span class="comment"> * IRQF_ONESHOT thread handler has been woken, but not</span></span><br><span class="line"><span class="comment"> * yet finished. The bit is cleared when a thread</span></span><br><span class="line"><span class="comment"> * completes. When all threads of a shared interrupt</span></span><br><span class="line"><span class="comment"> * line have completed desc-&gt;threads_active becomes</span></span><br><span class="line"><span class="comment"> * zero and the interrupt line is unmasked. See</span></span><br><span class="line"><span class="comment"> * handle.c:irq_wake_thread() for further information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no thread is woken by primary (hard irq context)</span></span><br><span class="line"><span class="comment"> * interrupt handlers, then desc-&gt;threads_active is</span></span><br><span class="line"><span class="comment"> * also checked for zero to unmask the irq line in the</span></span><br><span class="line"><span class="comment"> * affected hard irq flow handlers</span></span><br><span class="line"><span class="comment"> * (handle_[fasteoi|level]_irq).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The new action gets the first zero bit of</span></span><br><span class="line"><span class="comment"> * thread_mask assigned. See the loop above which or's</span></span><br><span class="line"><span class="comment"> * all existing action-&gt;thread_mask bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span>-&gt;thread_mask = <span class="number">1</span> &lt;&lt; ffz(thread_mask);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;handler == irq_default_primary_handler &amp;&amp;</span><br><span class="line">   !(desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The interrupt was requested with handler = NULL, so</span></span><br><span class="line"><span class="comment"> * we use the default primary handler for it. But it</span></span><br><span class="line"><span class="comment"> * does not have the oneshot flag set. In combination</span></span><br><span class="line"><span class="comment"> * with level interrupts this is deadly, because the</span></span><br><span class="line"><span class="comment"> * default primary handler just wakes the thread, then</span></span><br><span class="line"><span class="comment"> * the irq lines is reenabled, but the device still</span></span><br><span class="line"><span class="comment"> * has the level irq asserted. Rinse and repeat....</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * While this works for edge type interrupts, we play</span></span><br><span class="line"><span class="comment"> * it safe and reject unconditionally because we can't</span></span><br><span class="line"><span class="comment"> * say for sure which type this interrupt really</span></span><br><span class="line"><span class="comment"> * has. The type flags are unreliable as the</span></span><br><span class="line"><span class="comment"> * underlying chip implementation can override them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pr_err(<span class="string">"Threaded irq requested with handler=NULL and !ONESHOT for irq %d\n"</span>,</span><br><span class="line">       irq);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.5) 如果是第一个 action，做一些初始化工作</span></span><br><span class="line"><span class="keyword">if</span> (!shared) &#123;</span><br><span class="line">ret = irq_request_resources(desc);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">"Failed to request resources for %s (irq %d) on irqchip %s\n"</span>,</span><br><span class="line">       <span class="keyword">new</span>-&gt;name, irq, desc-&gt;irq_data.chip-&gt;name);</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_waitqueue_head(&amp;desc-&gt;wait_for_threads);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup the type (level, edge polarity) if configured: */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK) &#123;</span><br><span class="line">ret = __irq_set_trigger(desc, irq,</span><br><span class="line"><span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \</span><br><span class="line">  IRQS_ONESHOT | IRQS_WAITING);</span><br><span class="line">irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_PERCPU) &#123;</span><br><span class="line">irqd_set(&amp;desc-&gt;irq_data, IRQD_PER_CPU);</span><br><span class="line">irq_settings_set_per_cpu(desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_ONESHOT)</span><br><span class="line">desc-&gt;istate |= IRQS_ONESHOT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq_settings_can_autoenable(desc))</span><br><span class="line">irq_startup(desc, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* Undo nested disables: */</span></span><br><span class="line">desc-&gt;depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exclude IRQ from balancing if requested */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_NOBALANCING) &#123;</span><br><span class="line">irq_settings_set_no_balancing(desc);</span><br><span class="line">irqd_set(&amp;desc-&gt;irq_data, IRQD_NO_BALANCING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断亲和力</span></span><br><span class="line"><span class="comment">/* Set default affinity mask once everything is setup */</span></span><br><span class="line">setup_affinity(irq, desc, mask);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nmsk = <span class="keyword">new</span>-&gt;flags &amp; IRQF_TRIGGER_MASK;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> omsk = irq_settings_get_trigger_mask(desc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nmsk != omsk)</span><br><span class="line"><span class="comment">/* hope the handler works with current  trigger mode */</span></span><br><span class="line">pr_warning(<span class="string">"irq %d uses trigger mode %u; requested %u\n"</span>,</span><br><span class="line">   irq, nmsk, omsk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.6) 将新的 action 插入到 desc 链表中</span></span><br><span class="line"><span class="keyword">new</span>-&gt;irq = irq;</span><br><span class="line">*old_ptr = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">irq_pm_install_action(desc, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset broken irq detection when installing new handler */</span></span><br><span class="line">desc-&gt;irq_count = <span class="number">0</span>;</span><br><span class="line">desc-&gt;irqs_unhandled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether we disabled the irq via the spurious handler</span></span><br><span class="line"><span class="comment"> * before. Reenable it and give it another chance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.7) 如果中断之前被虚假 disable 了，重新 enable 中断</span></span><br><span class="line"><span class="keyword">if</span> (shared &amp;&amp; (desc-&gt;istate &amp; IRQS_SPURIOUS_DISABLED)) &#123;</span><br><span class="line">desc-&gt;istate &amp;= ~IRQS_SPURIOUS_DISABLED;</span><br><span class="line">__enable_irq(desc, irq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Strictly no need to wake it up, but hung_task complains</span></span><br><span class="line"><span class="comment"> * when no hard interrupt wakes the thread up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.8) 唤醒线程化中断对应的线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread)</span><br><span class="line">wake_up_process(<span class="keyword">new</span>-&gt;thread);</span><br><span class="line"></span><br><span class="line">register_irq_proc(irq, desc);</span><br><span class="line"><span class="keyword">new</span>-&gt;dir = <span class="literal">NULL</span>;</span><br><span class="line">register_handler_proc(irq, <span class="keyword">new</span>);</span><br><span class="line">free_cpumask_var(mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mismatch:</span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">new</span>-&gt;flags &amp; IRQF_PROBE_SHARED)) &#123;</span><br><span class="line">pr_err(<span class="string">"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\n"</span>,</span><br><span class="line">       irq, <span class="keyword">new</span>-&gt;flags, <span class="keyword">new</span>-&gt;name, old-&gt;flags, old-&gt;name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SHIRQ</span></span><br><span class="line">dump_stack();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"></span><br><span class="line">out_mask:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line">free_cpumask_var(mask);</span><br><span class="line"></span><br><span class="line">out_thread:</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;thread) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span> = <span class="title">new</span>-&gt;<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;thread = <span class="literal">NULL</span>;</span><br><span class="line">kthread_stop(t);</span><br><span class="line">put_task_struct(t);</span><br><span class="line">&#125;</span><br><span class="line">out_mput:</span><br><span class="line">module_put(desc-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-中断线程化"><a href="#1-5-中断线程化" class="headerlink" title="1.5 中断线程化"></a>1.5 中断线程化</h3><p>从上一节可以看到，使用 <code>request_irq()</code> 注册的是传统中断，而直接使用 <code>request_threaded_irq()</code> 注册的是线程化中断。线程化中断的主要目的是把中断上下文的任务迁移到线程中，减少系统关中断的时间，增强系统的实时性。</p><p>中断对应的线程命名规则为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = kthread_create(irq_thread, <span class="keyword">new</span>, <span class="string">"irq/%d-%s"</span>, irq, <span class="keyword">new</span>-&gt;name);</span><br></pre></td></tr></table></figure><p>我们通过 ps 命令查看系统中的中断线程，注意这些线程是实时线程 SCHED_FIFO：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@:/ <span class="meta"># ps | grep <span class="meta-string">"irq/"</span></span></span><br><span class="line">root      <span class="number">171</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">389</span>-charger</span><br><span class="line">root      <span class="number">239</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">296</span>-PS_int-</span><br><span class="line">root      <span class="number">247</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">297</span><span class="number">-1124000</span></span><br><span class="line">root      <span class="number">1415</span>  <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     irq_thread <span class="number">0000000000</span> S irq/<span class="number">293</span>-goodix_</span><br><span class="line">root@a0255:/ #</span><br></pre></td></tr></table></figure><p>线程化中断的创建和处理任务流程如下：</p><p><img src="int_thread_irq.png" alt="Linux 线程化中断 "></p><p>线程和 action 是一一对应的，即用户注册一个中断处理程序对应一个中断线程。</p><h3 id="1-6-外设中断打开-关闭"><a href="#1-6-外设中断打开-关闭" class="headerlink" title="1.6 外设中断打开 / 关闭"></a>1.6 外设中断打开 / 关闭</h3><p>前面的章节讲述了本地 CPU 全局中断的 enable/disable。如果要操作单个中断源的 enable/disable，使用 <code>enable_irq()</code>/<code>disable_irq()</code> 函数。最后调用主要是 GIC chip 相关的函数：</p><ul><li>kernel/irq/manage.c:</li><li><code>enable_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_get_desc_buslock</span>(<span class="title">irq</span>, &amp;<span class="title">flags</span>, <span class="title">IRQ_GET_DESC_CHECK_GLOBAL</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (WARN(!desc-&gt;irq_data.chip,</span><br><span class="line"> KERN_ERR <span class="string">"enable_irq before setup/request_irq: irq %u\n"</span>, irq))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">__enable_irq(desc, irq);</span><br><span class="line">out:</span><br><span class="line">irq_put_desc_busunlock(desc, flags);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">void</span> __enable_irq(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (desc-&gt;depth) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> err_out:</span><br><span class="line">WARN(<span class="number">1</span>, KERN_WARNING <span class="string">"Unbalanced enable for IRQ %d\n"</span>, irq);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_SUSPENDED)</span><br><span class="line"><span class="keyword">goto</span> err_out;</span><br><span class="line"><span class="comment">/* Prevent probing on this irq: */</span></span><br><span class="line">irq_settings_set_noprobe(desc);</span><br><span class="line">irq_enable(desc);</span><br><span class="line">check_irq_resend(desc, irq);</span><br><span class="line"><span class="comment">/* fall-through */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">desc-&gt;depth--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_enable</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 操作 GIC chip 对应的函数</span></span><br><span class="line">irq_state_clr_disabled(desc);</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;irq_enable)</span><br><span class="line">desc-&gt;irq_data.chip-&gt;irq_enable(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">desc-&gt;irq_data.chip-&gt;irq_unmask(&amp;desc-&gt;irq_data);</span><br><span class="line">irq_state_clr_masked(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kernel/irq/manage.c:</li><li><code>enable_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!__disable_irq_nosync(irq))</span><br><span class="line">synchronize_irq(irq);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __disable_irq_nosync(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_get_desc_buslock</span>(<span class="title">irq</span>, &amp;<span class="title">flags</span>, <span class="title">IRQ_GET_DESC_CHECK_GLOBAL</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">__disable_irq(desc, irq);</span><br><span class="line">irq_put_desc_busunlock(desc, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">void</span> __disable_irq(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!desc-&gt;depth++)</span><br><span class="line">irq_disable(desc);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_disable</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 操作 GIC chip 对应的函数</span></span><br><span class="line">irq_state_set_disabled(desc);</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;irq_disable) &#123;</span><br><span class="line">desc-&gt;irq_data.chip-&gt;irq_disable(&amp;desc-&gt;irq_data);</span><br><span class="line">irq_state_set_masked(desc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_to_desc</span>(<span class="title">irq</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc) &#123;</span><br><span class="line">__synchronize_hardirq(desc);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We made sure that no hardirq handler is</span></span><br><span class="line"><span class="comment"> * running. Now verify that no threaded handlers are</span></span><br><span class="line"><span class="comment"> * active.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果是线程化中断，需要等到线程执行完成</span></span><br><span class="line">wait_event(desc-&gt;wait_for_threads,</span><br><span class="line">   !atomic_read(&amp;desc-&gt;threads_active));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-中断亲和力"><a href="#1-7-中断亲和力" class="headerlink" title="1.7 中断亲和力"></a>1.7 中断亲和力</h3><p>同样基于 GIC chip 提供的能力，我们能配置中断源对 CPU 的亲和力。</p><ul><li>kernel/irq/manage.c:</li><li><code>enable_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">irq_set_affinity(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">const</span> struct cpumask *cpumask)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __irq_set_affinity(irq, cpumask, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">int</span> __irq_set_affinity(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">const</span> struct cpumask *mask, <span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_to_desc</span>(<span class="title">irq</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</span><br><span class="line">ret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq_set_affinity_locked</span><span class="params">(struct irq_data *data, <span class="keyword">const</span> struct cpumask *mask,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> = <span class="title">irq_data_get_irq_chip</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_data_to_desc</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!chip || !chip-&gt;irq_set_affinity)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq_can_move_pcntxt(data)) &#123;</span><br><span class="line">ret = irq_do_set_affinity(data, mask, force);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">irqd_set_move_pending(data);</span><br><span class="line">irq_copy_pending(desc, mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;affinity_notify) &#123;</span><br><span class="line">kref_get(&amp;desc-&gt;affinity_notify-&gt;kref);</span><br><span class="line">schedule_work(&amp;desc-&gt;affinity_notify-&gt;work);</span><br><span class="line">&#125;</span><br><span class="line">irqd_set(data, IRQD_AFFINITY_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq_do_set_affinity</span><span class="params">(struct irq_data *data, <span class="keyword">const</span> struct cpumask *mask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_data_to_desc</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> = <span class="title">irq_data_get_irq_chip</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作 GIC chip 对应的函数</span></span><br><span class="line">ret = chip-&gt;irq_set_affinity(data, mask, force);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> IRQ_SET_MASK_OK:</span><br><span class="line"><span class="keyword">case</span> IRQ_SET_MASK_OK_DONE:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_IRQ_NEW_DESIGN</span></span><br><span class="line">update_affinity_settings(desc, mask, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">cpumask_copy(data-&gt;affinity, mask);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">case</span> IRQ_SET_MASK_OK_NOCOPY:</span><br><span class="line">irq_set_thread_affinity(desc);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Linux-中断下半部"><a href="#2-Linux-中断下半部" class="headerlink" title="2. Linux 中断下半部"></a>2. Linux 中断下半部</h2><p>接下来就是大名鼎鼎的中断下半部了，包括：softirq、tasklet、workqueue。中断下半部的主要目的就是减少系统关中断的时间，把关键代码放在中断中做，大部分处理代码放到不用关中断的空间去做。</p><p>上面有最激进的方法中断线程化，但是大部分时候还是需要用到中断上、下半部的方法。</p><p>workqueue 在另外文章中已经有详细解析，本处只解析 softirq、tasklet。</p><h3 id="2-1-preempt-count"><a href="#2-1-preempt-count" class="headerlink" title="2.1 preempt_count"></a>2.1 preempt_count</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span> <span class="title">preempt_count</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current_thread_info()-&gt;preempt_count;<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始之前先了解一下 preempt_count 这个背景知识，preempt_count 是 thread_info 结构中的一个字段，用来表示当前进程能否被抢占。</p><p>所谓的抢占：是指在进程在内核空间运行，如果主动不释放 CPU，在时间片用完或者高优先级任务就绪的情况下，会被强行剥夺掉 CPU 的使用权。</p><p>但是进程可能在做一些关键操作，不能被抢占，被抢占后系统会出错。所以 Linux 设计了 preempt_count 字段，=0 可以被抢占，&gt;0 不能被抢占。</p><p>进程在中断返回内核态时，做是否可抢占的检查：</p><ul><li>arch/arm64/kernel/entry.s:</li><li><code>el1_irq()</code> -&gt; <code>__enable_irq()</code> -&gt; <code>irq_enable()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.align<span class="number">6</span></span><br><span class="line">el1_irq:</span><br><span class="line">kernel_entry <span class="number">1</span></span><br><span class="line">enable_dbg</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_off</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">bl  MT_trace_hardirqs_off</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">irq_handler</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">get_thread_info tsk</span><br><span class="line">ldrw24, [tsk, #TI_PREEMPT]<span class="comment">// get preempt count</span></span><br><span class="line"><span class="comment">// (1) 如果 preempt_count!=0，不进行可抢占判断</span></span><br><span class="line">cbnzw24, <span class="number">1f</span><span class="comment">// preempt count != 0</span></span><br><span class="line">ldrx0, [tsk, #TI_FLAGS]<span class="comment">// get flags</span></span><br><span class="line"><span class="comment">// (2) 如果 preempt_count==0 &amp; TIF_NEED_RESCHED 被置位</span></span><br><span class="line"><span class="comment">// 进行调度</span></span><br><span class="line">tbzx0, #TIF_NEED_RESCHED, <span class="number">1f</span><span class="comment">// needs rescheduling?</span></span><br><span class="line">blel1_preempt</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTPROF</span></span><br><span class="line">bl  MT_trace_hardirqs_on</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_on</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">kernel_exit <span class="number">1</span></span><br><span class="line">ENDPROC(el1_irq)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">el1_preempt:</span><br><span class="line">movx24, lr</span><br><span class="line"><span class="comment">// (3) 抢占调度</span></span><br><span class="line"><span class="number">1</span>:blpreempt_schedule_irq<span class="comment">// irq en/disable is done inside</span></span><br><span class="line">ldrx0, [tsk, #TI_FLAGS]<span class="comment">// get new tasks TI_FLAGS</span></span><br><span class="line">tbnzx0, #TIF_NEED_RESCHED, <span class="number">1b</span><span class="comment">// needs rescheduling?</span></span><br><span class="line">retx24</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">| →</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">preempt_schedule_irq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> ctx_state prev_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Catch callers which need to be fixed */</span></span><br><span class="line">BUG_ON(preempt_count() || !irqs_disabled());</span><br><span class="line"></span><br><span class="line">prev_state = exception_enter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">__preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">local_irq_enable();</span><br><span class="line">__schedule();</span><br><span class="line">local_irq_disable();</span><br><span class="line">__preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check again in case we missed a preemption opportunity</span></span><br><span class="line"><span class="comment"> * between schedule and now.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">barrier();</span><br><span class="line">&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line"></span><br><span class="line">exception_exit(prev_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 preempt_count&gt;0 就是禁止抢占，Linux 进一步按照各种场景对 preempt_count bit 进行了资源划分：</p><div class="table-container"><table><thead><tr><th>reserved bits</th><th style="text-align:center">bit21</th><th style="text-align:center">bit20</th><th style="text-align:center">bit19-bit16</th><th style="text-align:center">bit15-bit8</th><th style="text-align:center">bit7-bit0</th></tr></thead><tbody><tr><td></td><td style="text-align:center">PREEMPT_ACTIVE</td><td style="text-align:center">NMI</td><td style="text-align:center">HARDIRQ</td><td style="text-align:center">SOFTIRQ</td><td style="text-align:center">PREEMPT</td></tr></tbody></table></div><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/*</span></span><br><span class="line"> <span class="string">*</span> <span class="attr">PREEMPT_MASK:</span><span class="number">0x000000ff</span></span><br><span class="line"> <span class="string">*</span> <span class="attr">SOFTIRQ_MASK:</span><span class="number">0x0000ff00</span></span><br><span class="line"> <span class="string">*</span> <span class="attr">HARDIRQ_MASK:</span><span class="number">0x000f0000</span></span><br><span class="line"> <span class="string">*</span>     <span class="attr">NMI_MASK:</span><span class="number">0x00100000</span></span><br><span class="line"> <span class="string">*</span> <span class="attr">PREEMPT_ACTIVE:</span><span class="number">0x00200000</span></span><br><span class="line"> <span class="string">*/</span></span><br><span class="line"><span class="comment">#define PREEMPT_BITS8</span></span><br><span class="line"><span class="comment">#define SOFTIRQ_BITS8</span></span><br><span class="line"><span class="comment">#define HARDIRQ_BITS4</span></span><br><span class="line"><span class="comment">#define NMI_BITS1</span></span><br></pre></td></tr></table></figure><p>各场景分别利用各自的 bit 来 disable/enable 抢占：</p><ul><li>普通场景 (PREEMPT_MASK)。对应函数 <code>preempt_disable()</code>、<code>preempt_enable()</code>。</li><li>软中断场景 (SOFTIRQ_MASK)。对应函数 <code>local_bh_disable()</code>、<code>local_bh_enable()</code>。</li><li>普通中断场景 (HARDIRQ_MASK)。对应函数 <code>__irq_enter()</code>、<code>__irq_exit()</code>。</li><li>NMI 中断场景 (NMI_MASK)。对应函数 <code>nmi_enter()</code>、<code>nmi_exit()</code>。</li></ul><p>所以反过来，我们也可以通过 preempt_count 的值来判断当前在什么场景：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define in_irq()(<span class="name">hardirq_count</span>())</span><br><span class="line">#define in_softirq()(<span class="name">softirq_count</span>())</span><br><span class="line">#define in_interrupt()(<span class="name">irq_count</span>())</span><br><span class="line">#define in_serving_softirq()(<span class="name">softirq_count</span>() &amp; SOFTIRQ_OFFSET)</span><br><span class="line">#define in_nmi()(<span class="name">preempt_count</span>() &amp; NMI_MASK)</span><br><span class="line"></span><br><span class="line">#define hardirq_count()(<span class="name">preempt_count</span>() &amp; HARDIRQ_MASK)</span><br><span class="line">#define softirq_count()(<span class="name">preempt_count</span>() &amp; SOFTIRQ_MASK)</span><br><span class="line">#define irq_count()(<span class="name">preempt_count</span>() &amp; (<span class="name">HARDIRQ_MASK</span> | SOFTIRQ_MASK \</span><br><span class="line"> | NMI_MASK))</span><br></pre></td></tr></table></figure><h3 id="2-2-softirq"><a href="#2-2-softirq" class="headerlink" title="2.2 softirq"></a>2.2 softirq</h3><p>回到中断上下半部的架构，linux 系统虽然将大部分工作移出了中断上下文，不关闭中断。但是它也希望移出的工作能够很快的得到执行，软中断为了保证自己能很快执行，使用 <code>__local_bh_disable_ip()</code> 禁止抢占。</p><p>softirq 的具体实现机制如下：</p><ul><li>系统支持固定的几种软中断，softirq_vec 数组用来记录这些软中断执行函数：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">TIMER_SOFTIRQ,</span><br><span class="line">NET_TX_SOFTIRQ,</span><br><span class="line">NET_RX_SOFTIRQ,</span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ,</span><br><span class="line">SCHED_SOFTIRQ,</span><br><span class="line">HRTIMER_SOFTIRQ,</span><br><span class="line">RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册软中断的服务程序</span></span><br><span class="line">void <span class="keyword">open</span><span class="constructor">_softirq(<span class="params">int</span> <span class="params">nr</span>, <span class="params">void</span> (<span class="operator">*</span><span class="params">action</span>)</span>(<span class="keyword">struct</span> softirq_action *))</span><br><span class="line">&#123;</span><br><span class="line">softirq_vec<span class="literal">[<span class="identifier">nr</span>]</span>.action = action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TASKLET_SOFTIRQ、HI_SOFTIRQ 两个软中断用来给 tasklet 服务。</span></span><br><span class="line"><span class="keyword">open</span><span class="constructor">_softirq(TASKLET_SOFTIRQ, <span class="params">tasklet_action</span>)</span>;</span><br><span class="line"><span class="keyword">open</span><span class="constructor">_softirq(HI_SOFTIRQ, <span class="params">tasklet_hi_action</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>使用 irq_stat[cpu].__softirq_pending 来记录每个 cpu 上所有 softirq 的 pending 状态，<code>raise_softirq()</code> 用来置位一个 softirq pending：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void raise<span class="constructor">_softirq(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">nr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">local<span class="constructor">_irq_save(<span class="params">flags</span>)</span>;</span><br><span class="line">raise<span class="constructor">_softirq_irqoff(<span class="params">nr</span>)</span>;</span><br><span class="line">local<span class="constructor">_irq_restore(<span class="params">flags</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">| →</span></span><br><span class="line"><span class="pattern-match">inline void raise<span class="constructor">_softirq_irqoff(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">nr</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">__raise_softirq_irqoff(<span class="params">nr</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (!<span class="keyword">in</span><span class="constructor">_interrupt()</span>)</span></span><br><span class="line"><span class="pattern-match">wakeup<span class="constructor">_softirqd()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">||</span> →</span></span><br><span class="line"><span class="pattern-match">void <span class="constructor">__raise_softirq_irqoff(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">nr</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">trace<span class="constructor">_softirq_raise(<span class="params">nr</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">or</span><span class="constructor">_softirq_pending(1UL &lt;&lt; <span class="params">nr</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">||</span>| →</span></span><br><span class="line"><span class="pattern-match">#define <span class="keyword">or</span><span class="constructor">_softirq_pending(<span class="params">x</span>)</span>  (local<span class="constructor">_softirq_pending()</span> |= (x))</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">#ifndef <span class="constructor">__ARCH_IRQ_STAT</span></span></span><br><span class="line"><span class="pattern-match">extern irq<span class="constructor">_cpustat_t</span> irq<span class="constructor">_stat</span>[];<span class="operator">/</span><span class="operator">*</span> defined <span class="keyword">in</span> asm<span class="operator">/</span>hardirq.h <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">#define <span class="constructor">__IRQ_STAT(<span class="params">cpu</span>, <span class="params">member</span>)</span>(irq<span class="constructor">_stat</span>[cpu].member)</span></span><br><span class="line"><span class="pattern-match">#endif</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">  <span class="operator">/</span><span class="operator">*</span> arch independent irq<span class="constructor">_stat</span> fields <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">#define local<span class="constructor">_softirq_pending()</span> \</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">__IRQ_STAT(<span class="params">smp_processor_id</span>()</span>, <span class="constructor">__softirq_pending</span>)</span></span><br></pre></td></tr></table></figure><ul><li>softirq 的执行有两个时刻：在退出中断 <code>irq_exit()</code> 时或者在 softirqd 线程当中：</li></ul><p><img src="int_softirq_flow.png" alt="linux 软中断流程 "></p><p>软中断使用 <code>smpboot_register_percpu_thread()</code> 函数，给每个 cpu 上创建了对应的 softirqd 线程：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>:/ # ps | grep softirq</span><br><span class="line">root      <span class="number">3</span>     <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     smpboot_th <span class="number">0000000000</span> S ksoftirqd/<span class="number">0</span></span><br><span class="line">root      <span class="number">12</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">1</span></span><br><span class="line">root      <span class="number">16</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">2</span></span><br><span class="line">root      <span class="number">20</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">3</span></span><br><span class="line">root      <span class="number">24</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">4</span></span><br><span class="line">root      <span class="number">28</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">5</span></span><br><span class="line">root      <span class="number">32</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">6</span></span><br><span class="line">root      <span class="number">36</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R ksoftirqd/<span class="number">7</span></span><br></pre></td></tr></table></figure><p>软中断优先在 <code>irq_exit()</code> 中执行，如果超过时间等条件转为 softirqd 线程中执行。满足以下任一条件软中断在 softirqd 线程中执行：</p><ul><li>在 <code>irq_exit()</code>-&gt;<code>__do_softirq()</code> 中运行，时间超过 2ms。</li><li>在 <code>irq_exit()</code>-&gt;<code>__do_softirq()</code> 中运行，轮询软中断超过 10 次。</li><li>在 <code>irq_exit()</code>-&gt;<code>__do_softirq()</code> 中运行，本线程需要被调度。</li><li>调用 <code>raise_softirq()</code> 唤醒软中断时，不在中断环境中。</li></ul><p>我们也看到，软中断处理是按照优先级逐个调用 softirq_vec[] 数组中的软中断处理函数，所以前面的软中断是可以阻塞后面的软中断的。这个在我们写程序的时候需要注意。</p><h3 id="2-3-tasklet"><a href="#2-3-tasklet" class="headerlink" title="2.3 tasklet"></a>2.3 tasklet</h3><p>Linux 已经有了 softirq 机制，为什么还需要 tasklet 机制？最主要的原因是 softirq 是多 cpu 执行的，可能碰到很多重入的问题，而 tasklet 同一时刻只能在一个 cpu 上执行，不需要处理重入互斥问题。另外 Linux 也不建议用户去添加新的软中断。</p><p>下面我们来具体分析一下 tasklet 的实现机制：</p><ul><li>per-cpu 变量 tasklet_vec/tasklet_hi_vec 以链表的形式记录了当前 cpu 需要处理的 tasklet 任务：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="comment">// (1)tasklet_vec 为低优先级的 tasklet 链表</span></span><br><span class="line">per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line"><span class="comment">// (2)tasklet_hi_vec 为高优先级的 tasklet 链表</span></span><br><span class="line">per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>push 一个 tasklet 任务：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"><span class="comment">// (1) 将新的 tasklet 插入到本 cpu 链表尾部</span></span><br><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line"><span class="comment">// (2)raise 软中断来处理 tasklet</span></span><br><span class="line">raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理一个 tasklet 任务：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tasklet_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="comment">// (1)list 取出当前链表中所有已有的 tasklet</span></span><br><span class="line"><span class="built_in">list</span> = __this_cpu_read(tasklet_vec.head);</span><br><span class="line"><span class="comment">// (2)tasklet_vec.head 和 tasklet_vec.tail 返回初始化状态，继续接收新的 tasklet</span></span><br><span class="line">__this_cpu_write(tasklet_vec.head, <span class="literal">NULL</span>);</span><br><span class="line">__this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&amp;tasklet_vec.head));</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 逐个处理取出的 list 链表中的 tasklet</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> = <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4)tasklet 互斥锁，保证 tasklet 同时只能在一个 cpu 上执行</span></span><br><span class="line"><span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!atomic_read(&amp;t-&gt;count)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 在 tasklet 运行前清除 TASKLET_STATE_SCHED 标志</span></span><br><span class="line"><span class="comment">// 这个时候 tasklet 可以重新加入新的队列了，但是还不能执行</span></span><br><span class="line"><span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED,</span><br><span class="line">&amp;t-&gt;state))</span><br><span class="line">BUG();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (7) 执行实际的 tasklet 处理函数</span></span><br><span class="line">t-&gt;func(t-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8) 释放 tasklet 锁，其他 cpu 可以运行这个 tasklet 了</span></span><br><span class="line">tasklet_unlock(t);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">tasklet_unlock(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="comment">// (5) 如果获取 tasklet 互斥锁失败，先加入到 cpu tasklet_vec 链表中</span></span><br><span class="line"><span class="comment">// 下次执行</span></span><br><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">__raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_ARMPG"><sup>ARMPG</sup>. <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/index.html" target="_blank" rel="noopener">ARM Cortex-A Series Programmer’s Guide for ARMv8-A</a><a href="#reffn_ARMPG" title="Jump back to footnote [ARMPG] in the text."> &#8617;</a></blockquote><blockquote id="fn_GICANALY"><sup>GICANALY</sup>. <a href="http://www.wowotech.net/irq_subsystem/gic_driver.html" target="_blank" rel="noopener">GIC 代码分析 </a><a href="#reffn_GICANALY" title="Jump back to footnote [GICANALY] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中断管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gic </tag>
            
            <tag>  中断线程化  </tag>
            
            <tag> softirq </tag>
            
            <tag> tasklet </tag>
            
            <tag> linux 中断  </tag>
            
            <tag> linux interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Workqueue</title>
      <link href="/2016/08/20//linux-workqueue.html/"/>
      <url>/2016/08/20//linux-workqueue.html/</url>
      
        <content type="html"><![CDATA[<p>Workqueue 是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务 (work) 都不会自己起一个线程来处理，而是扔到 Workqueue 中处理。Workqueue 的主要工作就是用进程上下文来处理内核中大量的小任务。</p><p>所以 Workqueue 的主要设计思想：一个是并行，多个 work 不要相互阻塞；另外一个是节省资源，多个 work 尽量共享资源 ( 进程、调度、内存 )，不要造成系统过多的资源浪费。</p><p>为了实现的设计思想，workqueue 的设计实现也更新了很多版本。最新的 workqueue 实现叫做 CMWQ(Concurrency Managed Workqueue)，也就是用更加智能的算法来实现“并行和节省”。新版本的 workqueue 创建函数改成 <code>alloc_workqueue()</code>，旧版本的函数 <code>create_workqueue()</code> 逐渐会被被废弃。</p><blockquote><p>本文的代码分析基于 Linux kernel 3.18.22，最好的学习方法还是 “read the fucking source code”</p></blockquote><h2 id="1-CMWQ-的几个基本概念"><a href="#1-CMWQ-的几个基本概念" class="headerlink" title="1.CMWQ 的几个基本概念"></a>1.CMWQ 的几个基本概念</h2><p>关于 workqueue 中几个概念都是 work 相关的数据结构非常容易混淆，大概可以这样来理解：</p><ul><li>work        ：工作。</li><li>workqueue    ：工作的集合。workqueue 和 work 是一对多的关系。</li><li>worker    ：工人。在代码中 worker 对应一个 <code>work_thread()</code> 内核线程。</li><li>worker_pool：工人的集合。worker_pool 和 worker 是一对多的关系。</li><li>pwq(pool_workqueue)：中间人 / 中介，负责建立起 workqueue 和 worker_pool 之间的关系。workqueue 和 pwq 是一对多的关系，pwq 和 worker_pool 是一对一的关系。</li></ul><p><img src="wq_topology.png" alt="normal wq_topology"></p><p>最终的目的还是把 work( 工作 ) 传递给 worker( 工人 ) 去执行，中间的数据结构和各种关系目的是把这件事组织的更加清晰高效。</p><h3 id="1-1-worker-pool"><a href="#1-1-worker-pool" class="headerlink" title="1.1 worker_pool"></a>1.1 worker_pool</h3><p>每个执行 work 的线程叫做 worker，一组 worker 的集合叫做 worker_pool。CMWQ 的精髓就在 worker_pool 里面 worker 的动态增减管理上 <code>manage_workers()</code>。</p><p>CMWQ 对 worker_pool 分成两类：</p><ul><li>normal worker_pool，给通用的 workqueue 使用；</li><li>unbound worker_pool，给 WQ_UNBOUND 类型的的 workqueue 使用；</li></ul><h4 id="1-1-1-normal-worker-pool"><a href="#1-1-1-normal-worker-pool" class="headerlink" title="1.1.1 normal worker_pool"></a>1.1.1 normal worker_pool</h4><p>默认 work 是在 normal worker_pool 中处理的。系统的规划是每个 CPU 创建两个 normal worker_pool：一个 normal 优先级 (nice=0)、一个高优先级 (nice=HIGHPRI_NICE_LEVEL)，对应创建出来的 worker 的进程 nice 不一样。</p><p>每个 worker 对应一个 <code>worker_thread()</code> 内核线程，一个 worker_pool 包含一个或者多个 worker，worker_pool 中 worker 的数量是根据 worker_pool 中 work 的负载来动态增减的。</p><p>我们可以通过 <code>ps | grep kworker</code> 命令来查看所有 worker 对应的内核线程，normal worker_pool 对应内核线程 (<code>worker_thread()</code>) 的命名规则是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line"> pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure><p>so 类似名字是 normal worker_pool：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">shell@</span>PRO5:/ $ ps | grep <span class="string">"kworker"</span></span><br><span class="line">root      <span class="number">14</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">1</span>:<span class="number">0</span>H<span class="comment">// cpu1 高优先级 worker_pool 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">17</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">2</span>:<span class="number">0</span><span class="comment">// cpu2 低优先级 worker_pool 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">18</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">2</span>:<span class="number">0</span>H<span class="comment">// cpu2 高优先级 worker_pool 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">23699</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">0</span>:<span class="number">1</span><span class="comment">// cpu0 低优先级 worker_pool 的第 1 个 worker 进程</span></span><br></pre></td></tr></table></figure><p><img src="wq_worker_pool.png" alt="normal worker_pool"></p><p>对应的拓扑图如下：</p><p><img src="wq_normal_wq_topology.png" alt="normal worker_pool topology"></p><p>以下是 normal worker_pool 详细的创建过程代码分析：</p><ul><li>kernel/workqueue.c:</li><li><code>init_workqueues()</code> -&gt; <code>init_worker_pool()</code>/<code>create_worker()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line"><span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 给每个 cpu 创建对应的 worker_pool</span></span><br><span class="line"><span class="comment">/* initialize CPU pools */</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">BUG_ON(init_worker_pool(pool));</span><br><span class="line"><span class="comment">// 指定 cpu</span></span><br><span class="line">pool-&gt;cpu = cpu;</span><br><span class="line">cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line"><span class="comment">// 指定进程优先级 nice</span></span><br><span class="line">pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alloc pool ID */</span></span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 给每个 worker_pool 创建第一个 worker</span></span><br><span class="line"><span class="comment">/* create the initial worker */</span></span><br><span class="line">for_each_online_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">BUG_ON(!create_worker(pool));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_worker_pool</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">spin_lock_init(&amp;pool-&gt;lock);</span><br><span class="line">pool-&gt;id = <span class="number">-1</span>;</span><br><span class="line">pool-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">pool-&gt;node = NUMA_NO_NODE;</span><br><span class="line">pool-&gt;flags |= POOL_DISASSOCIATED;</span><br><span class="line"><span class="comment">// (1.1) worker_pool 的 work list，各个 workqueue 把 work 挂载到这个链表上，</span></span><br><span class="line"><span class="comment">// 让 worker_pool 对应的多个 worker 来执行</span></span><br><span class="line">INIT_LIST_HEAD(&amp;pool-&gt;worklist);</span><br><span class="line"><span class="comment">// (1.2) worker_pool 的 idle worker list，</span></span><br><span class="line"><span class="comment">// worker 没有活干时，不会马上销毁，先进入 idle 状态备选</span></span><br><span class="line">INIT_LIST_HEAD(&amp;pool-&gt;idle_list);</span><br><span class="line"><span class="comment">// (1.3) worker_pool 的 busy worker list，</span></span><br><span class="line"><span class="comment">// worker 正在干活，在执行 work</span></span><br><span class="line">hash_init(pool-&gt;busy_hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4) 检查 idle 状态 worker 是否需要 destroy 的 timer</span></span><br><span class="line">init_timer_deferrable(&amp;pool-&gt;idle_timer);</span><br><span class="line">pool-&gt;idle_timer.function = idle_worker_timeout;</span><br><span class="line">pool-&gt;idle_timer.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.5) 在 worker_pool 创建新的 worker 时，检查是否超时的 timer</span></span><br><span class="line">setup_timer(&amp;pool-&gt;mayday_timer, pool_mayday_timeout,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool);</span><br><span class="line"></span><br><span class="line">mutex_init(&amp;pool-&gt;manager_arb);</span><br><span class="line">mutex_init(&amp;pool-&gt;attach_mutex);</span><br><span class="line">INIT_LIST_HEAD(&amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">ida_init(&amp;pool-&gt;worker_ida);</span><br><span class="line">INIT_HLIST_NODE(&amp;pool-&gt;hash_node);</span><br><span class="line">pool-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* shouldn't fail above this point */</span></span><br><span class="line">pool-&gt;attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!pool-&gt;attrs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">id = ida_simple_get(&amp;pool-&gt;worker_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">worker = alloc_worker(pool-&gt;node);</span><br><span class="line"><span class="keyword">if</span> (!worker)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">worker-&gt;pool = pool;</span><br><span class="line">worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment">// (2.1) 给 normal worker_pool 的 worker 构造进程名</span></span><br><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line"> pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// (2.2) 给 unbound worker_pool 的 worker 构造进程名</span></span><br><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.3) 创建 worker 对应的内核进程</span></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">"kworker/%s"</span>, id_buf);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.4) 设置内核进程对应的优先级 nice</span></span><br><span class="line">set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prevent userland from meddling with cpumask of workqueue workers */</span></span><br><span class="line">worker-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5) 将 worker 和 worker_pool 绑定</span></span><br><span class="line"><span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6) 将 worker 初始状态设置成 idle，</span></span><br><span class="line"><span class="comment">// wake_up_process 以后，worker 自动 leave idle 状态</span></span><br><span class="line"><span class="comment">/* start the newly created worker */</span></span><br><span class="line">spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">worker_enter_idle(worker);</span><br><span class="line">wake_up_process(worker-&gt;task);</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"><span class="keyword">if</span> (id &gt;= <span class="number">0</span>)</span><br><span class="line">ida_simple_remove(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">kfree(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker_attach_to_pool</span><span class="params">(struct worker *worker,</span></span></span><br><span class="line"><span class="function"><span class="params">   struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5.1) 将 worker 线程和 cpu 绑定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any</span></span><br><span class="line"><span class="comment"> * online CPUs.  It'll be re-applied when any of the CPUs come up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_cpus_allowed_ptr(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pool-&gt;attach_mutex ensures %POOL_DISASSOCIATED remains</span></span><br><span class="line"><span class="comment"> * stable across this function.  See the comments above the</span></span><br><span class="line"><span class="comment"> * flag definition for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;flags &amp; POOL_DISASSOCIATED)</span><br><span class="line">worker-&gt;flags |= WORKER_UNBOUND;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5.2) 将 worker 加入 worker_pool 链表</span></span><br><span class="line">list_add_tail(&amp;worker-&gt;node, &amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-unbound-worker-pool"><a href="#1-1-2-unbound-worker-pool" class="headerlink" title="1.1.2 unbound worker_pool"></a>1.1.2 unbound worker_pool</h4><p>大部分的 work 都是通过 normal worker_pool 来执行的 ( 例如通过 <code>schedule_work()</code>、<code>schedule_work_on()</code> 压入到系统 workqueue(system_wq) 中的 work)，最后都是通过 normal worker_pool 中的 worker 来执行的。这些 worker 是和某个 CPU 绑定的，work 一旦被 worker 开始执行，都是一直运行到某个 CPU 上的不会切换 CPU。</p><p>unbound worker_pool 相对应的意思，就是 worker 可以在多个 CPU 上调度的。但是他其实也是绑定的，只不过它绑定的单位不是 CPU 而是 node。所谓的 node 是对 NUMA(Non Uniform Memory Access Architecture) 系统来说的，NUMA 可能存在多个 node，每个 node 可能包含一个或者多个 CPU。</p><p>unbound worker_pool 对应内核线程 (<code>worker_thread()</code>) 的命名规则是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure><p>so 类似名字是 unbound worker_pool：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">shell@</span>PRO5:/ $ ps | grep <span class="string">"kworker"</span></span><br><span class="line">root      <span class="number">23906</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/u20:<span class="number">2</span><span class="comment">// unbound pool 20 的第 2 个 worker 进程</span></span><br><span class="line">root      <span class="number">24564</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/u20:<span class="number">0</span><span class="comment">// unbound pool 20 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">24622</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/u21:<span class="number">1</span><span class="comment">// unbound pool 21 的第 1 个 worker 进程</span></span><br></pre></td></tr></table></figure><p>unbound worker_pool 也分成两类：</p><ul><li>unbound_std_wq。每个 node 对应一个 worker_pool，多个 node 就对应多个 worker_pool;</li></ul><p><img src="wq_unbound_std_wq.png" alt="unbound worker_pool: unbound_std_wq"></p><p>对应的拓扑图如下：</p><p><img src="2016/08/wq_unboundstd_wq_topology.png" alt="unbound_std_wq topology"></p><ul><li>ordered_wq。所有 node 对应一个 default worker_pool；</li></ul><p><img src="wq_ordered_wq.png" alt="unbound worker_pool: ordered_wq"></p><p>对应的拓扑图如下：</p><p><img src="wq_ordered_wq_topology.png" alt="ordered_wq topology"></p><p>以下是 unbound worker_pool 详细的创建过程代码分析：</p><ul><li>kernel/workqueue.c:</li><li><code>init_workqueues()</code> -&gt; unbound_std_wq_attrs/ordered_wq_attrs</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 初始化 normal 和 high nice 对应的 unbound attrs</span></span><br><span class="line"><span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) unbound_std_wq_attrs</span></span><br><span class="line">BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">attrs-&gt;nice = std_nice[i];</span><br><span class="line">unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment"> * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment"> * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (3) ordered_wq_attrs，no_numa = true;</span></span><br><span class="line">BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">attrs-&gt;nice = std_nice[i];</span><br><span class="line">attrs-&gt;no_numa = <span class="literal">true</span>;</span><br><span class="line">ordered_wq_attrs[i] = attrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kernel/workqueue.c:</li><li><code>__alloc_workqueue_key()</code> -&gt; <code>alloc_and_link_pwqs()</code> -&gt; <code>apply_workqueue_attrs()</code> -&gt; <code>alloc_unbound_pwq()</code>/<code>numa_pwq_tbl_install()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">       <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">       <span class="title">int</span> <span class="title">max_active</span>,</span></span><br><span class="line"><span class="class">       <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate wq and format name */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 分配 workqueue_struct 数据结构</span></span><br><span class="line">wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wq)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">wq-&gt;unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line"><span class="keyword">goto</span> err_free_wq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">va_start(args, lock_name);</span><br><span class="line">vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">va_end(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) pwq 最多放到 worker_pool 中的 work 数</span></span><br><span class="line">max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init wq */</span></span><br><span class="line">wq-&gt;flags = flags;</span><br><span class="line">wq-&gt;saved_max_active = max_active;</span><br><span class="line">mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">lockdep_init_map(&amp;wq-&gt;lockdep_map, lock_name, key, <span class="number">0</span>);</span><br><span class="line">INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 给 workqueue 分配对应的 pool_workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 将 workqueue 和 worker_pool 链接起来</span></span><br><span class="line"><span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_free_wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果是 WQ_MEM_RECLAIM 类型的 workqueue</span></span><br><span class="line"><span class="comment">// 创建对应的 rescuer_thread() 内核进程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Workqueues which may be used during memory reclaim should</span></span><br><span class="line"><span class="comment"> * have a rescuer to guarantee forward progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; WQ_MEM_RECLAIM) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"></span><br><span class="line">rescuer = alloc_worker(NUMA_NO_NODE);</span><br><span class="line"><span class="keyword">if</span> (!rescuer)</span><br><span class="line"><span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">rescuer-&gt;rescue_wq = wq;</span><br><span class="line">rescuer-&gt;task = kthread_create(rescuer_thread, rescuer, <span class="string">"%s"</span>,</span><br><span class="line">       wq-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rescuer-&gt;task)) &#123;</span><br><span class="line">kfree(rescuer);</span><br><span class="line"><span class="keyword">goto</span> err_destroy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wq-&gt;rescuer = rescuer;</span><br><span class="line">rescuer-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line">wake_up_process(rescuer-&gt;task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) 如果是需要，创建 workqueue 对应的 sysfs 文件</span></span><br><span class="line"><span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line"><span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment"> * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment"> * list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">for_each_pwq(pwq, wq)</span><br><span class="line">pwq_adjust_max_active(pwq);</span><br><span class="line">mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 将新的 workqueue 加入到全局链表 workqueues 中</span></span><br><span class="line">list_add(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_free_wq:</span><br><span class="line">free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">kfree(wq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">destroy_workqueue(wq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line"><span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3.1) normal workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line"><span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line"><span class="comment">// 给 workqueue 的每个 cpu 分配对应的 pool_workqueue，赋值给 wq-&gt;cpu_pwqs</span></span><br><span class="line">wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line"><span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line"><span class="class"><span class="title">per_cpu_ptr</span>(<span class="title">wq</span>-&gt;<span class="title">cpu_pwqs</span>, <span class="title">cpu</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line"><span class="class"><span class="title">per_cpu</span>(<span class="title">cpu_worker_pools</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将初始化时已经创建好的 normal worker_pool，赋值给 pool_workqueue</span></span><br><span class="line">init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line"><span class="comment">// 将 pool_workqueue 和 workqueue 链接起来</span></span><br><span class="line">link_pwq(pwq);</span><br><span class="line">mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line"><span class="comment">// (3.2) unbound ordered_wq workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line">ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line"><span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">     <span class="string">"ordering guarantee broken for workqueue %s\n"</span>, wq-&gt;name);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (3.3) unbound unbound_std_wq workqueue</span></span><br><span class="line"><span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line"><span class="keyword">return</span> apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply_workqueue_attrs</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3.2.1) 根据的 ubound 的 ordered_wq_attrs/unbound_std_wq_attrs</span></span><br><span class="line"><span class="comment">// 创建对应的 pool_workqueue 和 worker_pool</span></span><br><span class="line"><span class="comment">// 其中 worker_pool 不是默认创建好的，是需要动态创建的，对应的 worker 内核进程也要重新创建</span></span><br><span class="line"><span class="comment">// 创建好的 pool_workqueue 赋值给 pwq_tbl[node]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If something goes wrong during CPU up/down, we'll fall back to</span></span><br><span class="line"><span class="comment"> * the default pwq covering whole @attrs-&gt;cpumask.  Always create</span></span><br><span class="line"><span class="comment"> * it even if we don't use it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dfl_pwq = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line"><span class="keyword">if</span> (!dfl_pwq)</span><br><span class="line"><span class="keyword">goto</span> enomem_pwq;</span><br><span class="line"></span><br><span class="line">for_each_node(node) &#123;</span><br><span class="line"><span class="keyword">if</span> (wq_calc_node_cpumask(attrs, node, <span class="number">-1</span>, tmp_attrs-&gt;cpumask)) &#123;</span><br><span class="line">pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);</span><br><span class="line"><span class="keyword">if</span> (!pwq_tbl[node])</span><br><span class="line"><span class="keyword">goto</span> enomem_pwq;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfl_pwq-&gt;refcnt++;</span><br><span class="line">pwq_tbl[node] = dfl_pwq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* save the previous pwq and install the new one */</span></span><br><span class="line"><span class="comment">// (3.2.2) 将临时 pwq_tbl[node] 赋值给 wq-&gt;numa_pwq_tbl[node]</span></span><br><span class="line">for_each_node(node)</span><br><span class="line">pwq_tbl[node] = numa_pwq_tbl_install(wq, node, pwq_tbl[node]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pool_workqueue *<span class="title">alloc_unbound_pwq</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3.2.1.1) 如果对应 attrs 已经创建多对应的 unbound_pool，则使用已有的 unbound_pool</span></span><br><span class="line"><span class="comment">// 否则根据 attrs 创建新的 unbound_pool</span></span><br><span class="line">pool = get_unbound_pool(attrs);</span><br><span class="line"><span class="keyword">if</span> (!pool)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);</span><br><span class="line"><span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">put_unbound_pool(pool);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_pwq(pwq, wq, pool);</span><br><span class="line"><span class="keyword">return</span> pwq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-worker"><a href="#1-2-worker" class="headerlink" title="1.2 worker"></a>1.2 worker</h3><p>每个 worker 对应一个 <code>worker_thread()</code> 内核线程，一个 worker_pool 对应一个或者多个 worker。多个 worker 从同一个链表中 worker_pool-&gt;worklist 获取 work 进行处理。</p><p>所以这其中有几个重点：</p><ul><li>worker 怎么处理 work；</li><li>worker_pool 怎么动态管理 worker 的数量；</li></ul><h4 id="1-2-1-worker-处理-work"><a href="#1-2-1-worker-处理-work" class="headerlink" title="1.2.1 worker 处理 work"></a>1.2.1 worker 处理 work</h4><p>处理 work 的过程主要在 <code>worker_thread()</code> -&gt; <code>process_one_work()</code> 中处理，我们具体看看代码的实现过程。</p><ul><li>kernel/workqueue.c:</li><li><code>worker_thread()</code> -&gt; <code>process_one_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = __<span class="title">worker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 是否 die</span></span><br><span class="line"><span class="comment">/* am I supposed to die? */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">set_task_comm(worker-&gt;task, <span class="string">"kworker/dying"</span>);</span><br><span class="line">ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">worker_detach_from_pool(worker, pool);</span><br><span class="line">kfree(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 脱离 idle 状态</span></span><br><span class="line"><span class="comment">// 被唤醒之前 worker 都是 idle 状态</span></span><br><span class="line">worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 如果需要本 worker 继续执行则继续，否则进入 idle 状态</span></span><br><span class="line"><span class="comment">// need more worker 的条件： (pool-&gt;worklist != 0) &amp;&amp; (pool-&gt;nr_running == 0)</span></span><br><span class="line"><span class="comment">// worklist 上有 work 需要执行，并且现在没有处于 running 的 work</span></span><br><span class="line"><span class="comment">/* no more worker necessary? */</span></span><br><span class="line"><span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line"><span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果 (pool-&gt;nr_idle == 0)，则启动创建更多的 worker</span></span><br><span class="line"><span class="comment">// 说明 idle 队列中已经没有备用 worker 了，先创建 一些 worker 备用</span></span><br><span class="line"><span class="comment">/* do we need to manage? */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line"><span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment"> * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment"> * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finish PREP stage.  We're guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment"> * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment"> * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment"> * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment"> * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// (5) 如果 pool-&gt;worklist 不为空，从其中取出一个 work 进行处理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line"><span class="class"><span class="title">list_first_entry</span>(&amp;<span class="title">pool</span>-&gt;<span class="title">worklist</span>,</span></span><br><span class="line"><span class="class"> <span class="title">struct</span> <span class="title">work_struct</span>, <span class="title">entry</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line"><span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line"><span class="comment">// (6) 执行正常的 work</span></span><br><span class="line">process_one_work(worker, work);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">process_scheduled_works(worker);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (7) 执行系统特意 scheduled 给某个 worker 的 work</span></span><br><span class="line"><span class="comment">// 普通的 work 是放在池子的公共 list 中的 pool-&gt;worklist</span></span><br><span class="line"><span class="comment">// 只有一些特殊的 work 被特意派送给某个 worker 的 worker-&gt;scheduled</span></span><br><span class="line"><span class="comment">// 包括：1、执行 flush_work 时插入的 barrier work；</span></span><br><span class="line"><span class="comment">// 2、collision 时从其他 worker 推送到本 worker 的 work</span></span><br><span class="line">move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">process_scheduled_works(worker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (8) worker keep_working 的条件：</span></span><br><span class="line"><span class="comment">// pool-&gt;worklist 不为空 &amp;&amp; (pool-&gt;nr_running &lt;= 1)</span></span><br><span class="line">&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">worker_set_flags(worker, WORKER_PREP);supposed</span><br><span class="line">sleep:</span><br><span class="line"><span class="comment">// (9) worker 进入 idle 状态</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pool-&gt;lock is held and there's no work to process and no need to</span></span><br><span class="line"><span class="comment"> * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment"> * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment"> * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment"> * event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">worker_enter_idle(worker);</span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> = <span class="title">get_work_pwq</span>(<span class="title">work</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"><span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"><span class="keyword">int</span> work_color;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It is permissible to free the struct work_struct from</span></span><br><span class="line"><span class="comment"> * inside the function that is called from it, this we need to</span></span><br><span class="line"><span class="comment"> * take into account for lockdep too.  To avoid bogus "held</span></span><br><span class="line"><span class="comment"> * lock freed" warnings as well as problems when looking into</span></span><br><span class="line"><span class="comment"> * work-&gt;lockdep_map, make a copy and use that here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"></span><br><span class="line">lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* ensure we're on the correct CPU */</span></span><br><span class="line">WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.1) 如果 work 已经在 worker_pool 的其他 worker 上执行，</span></span><br><span class="line"><span class="comment">// 将 work 放入对应 worker 的 scheduled 队列中延后执行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A single work shouldn't be executed concurrently by</span></span><br><span class="line"><span class="comment"> * multiple workers on a single cpu.  Check whether anyone is</span></span><br><span class="line"><span class="comment"> * already processing the work.  If so, defer the work to the</span></span><br><span class="line"><span class="comment"> * currently executing one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">collision = find_worker_executing_work(pool, work);</span><br><span class="line"><span class="keyword">if</span> (unlikely(collision)) &#123;</span><br><span class="line">move_linked_works(work, &amp;collision-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.2) 将 worker 加入 busy 队列 pool-&gt;busy_hash</span></span><br><span class="line"><span class="comment">/* claim and dequeue */</span></span><br><span class="line">debug_work_deactivate(work);</span><br><span class="line">hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)work);</span><br><span class="line">worker-&gt;current_work = work;</span><br><span class="line">worker-&gt;current_func = work-&gt;func;</span><br><span class="line">worker-&gt;current_pwq = pwq;</span><br><span class="line">work_color = get_work_color(work);</span><br><span class="line"></span><br><span class="line">list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.3) 如果 work 所在的 wq 是 cpu 密集型的 WQ_CPU_INTENSIVE</span></span><br><span class="line"><span class="comment">// 则当前 work 的执行脱离 worker_pool 的动态调度，成为一个独立的线程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment"> * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment"> * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment"> * execution of the pending work items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (8.4) 在 UNBOUND 或者 CPU_INTENSIVE work 中判断是否需要唤醒 idle worker</span></span><br><span class="line"><span class="comment">// 普通 work 不会执行这个操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment"> * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment"> * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment"> * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment"> * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment"> * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment"> * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment"> * disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">trace_workqueue_execute_start(work);</span><br><span class="line"><span class="comment">// (8.5) 执行 work 函数</span></span><br><span class="line">worker-&gt;current_func(work);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While we must be careful to not use "work" after this, the trace</span></span><br><span class="line"><span class="comment"> * point will only record its address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_workqueue_execute_end(work);</span><br><span class="line">lock_map_release(&amp;lockdep_map);</span><br><span class="line">lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">pr_err(<span class="string">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"</span></span><br><span class="line">       <span class="string">"     last function: %pf\n"</span>,</span><br><span class="line">       current-&gt;comm, preempt_count(), task_pid_nr(current),</span><br><span class="line">       worker-&gt;current_func);</span><br><span class="line">debug_show_held_locks(current);</span><br><span class="line">dump_stack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following prevents a kworker from hogging CPU on !PREEMPT</span></span><br><span class="line"><span class="comment"> * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment"> * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment"> * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment"> * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment"> * the same condition doesn't freeze RCU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cond_resched_rcu_qs();</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear cpu intensive status */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we're done with it, release */</span></span><br><span class="line">hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;desc_valid = <span class="literal">false</span>;</span><br><span class="line">pwq_dec_nr_in_flight(pwq, work_color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-worker-pool-动态管理-worker"><a href="#1-2-2-worker-pool-动态管理-worker" class="headerlink" title="1.2.2 worker_pool 动态管理 worker"></a>1.2.2 worker_pool 动态管理 worker</h4><p>worker_pool 怎么来动态增减 worker，这部分的算法是 CMWQ 的核心。其思想如下：</p><ul><li>worker_pool 中的 worker 有 3 种状态：idle、running、suspend；</li><li>如果 worker_pool 中有 work 需要处理，保持至少一个 running worker 来处理；</li><li>running worker 在处理 work 的过程中进入了阻塞 suspend 状态，为了保持其他 work 的执行，需要唤醒新的 idle worker 来处理 work；</li><li>如果有 work 需要执行且 running worker 大于 1 个，会让多余的 running worker 进入 idle 状态；</li><li>如果没有 work 需要执行，会让所有 worker 进入 idle 状态；</li><li>如果创建的 worker 过多，destroy_worker 在 300s(IDLE_WORKER_TIMEOUT) 时间内没有再次运行的 idle worker。</li></ul><p><img src="wq_worker_statusmachine.png" alt="worker status machine"></p><p>详细代码可以参考上节 <code>worker_thread()</code> -&gt; <code>process_one_work()</code> 的分析。</p><p>为了追踪 worker 的 running 和 suspend 状态，用来动态调整 worker 的数量。wq 使用在进程调度中加钩子函数的技巧：</p><ul><li>追踪 worker 从 suspend 进入 running 状态：<code>ttwu_activate()</code> -&gt; <code>wq_worker_waking_up()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wq_worker_waking_up</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">WARN_ON_ONCE(worker-&gt;pool-&gt;cpu != cpu);</span><br><span class="line"><span class="comment">// 增加 worker_pool 中 running 的 worker 数量</span></span><br><span class="line">atomic_inc(&amp;worker-&gt;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>追踪 worker 从 running 进入 suspend 状态：<code>__schedule()</code> -&gt; <code>wq_worker_sleeping()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">wq_worker_sleeping</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>), *<span class="title">to_wakeup</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Rescuers, which may not have all the fields set up like normal</span></span><br><span class="line"><span class="comment"> * workers, also reach here, let's not access anything before</span></span><br><span class="line"><span class="comment"> * checking NOT_RUNNING.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (worker-&gt;flags &amp; WORKER_NOT_RUNNING)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this can only happen on the local cpu */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(cpu != raw_smp_processor_id() || pool-&gt;cpu != cpu))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The counterpart of the following dec_and_test, implied mb,</span></span><br><span class="line"><span class="comment"> * worklist not empty test sequence is in insert_work().</span></span><br><span class="line"><span class="comment"> * Please read comment there.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOT_RUNNING is clear.  This means that we're bound to and</span></span><br><span class="line"><span class="comment"> * running on the local cpu w/ rq lock held and preemption</span></span><br><span class="line"><span class="comment"> * disabled, which in turn means that none else could be</span></span><br><span class="line"><span class="comment"> * manipulating idle_list, so dereferencing idle_list without pool</span></span><br><span class="line"><span class="comment"> * lock is safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 减少 worker_pool 中 running 的 worker 数量</span></span><br><span class="line"><span class="comment">// 如果 worklist 还有 work 需要处理，唤醒第一个 idle worker 进行处理</span></span><br><span class="line"><span class="keyword">if</span> (atomic_dec_and_test(&amp;pool-&gt;nr_running) &amp;&amp;</span><br><span class="line">    !list_empty(&amp;pool-&gt;worklist))</span><br><span class="line">to_wakeup = first_idle_worker(pool);</span><br><span class="line"><span class="keyword">return</span> to_wakeup ? to_wakeup-&gt;task : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 worker_pool 的调度思想是：如果有 work 需要处理，保持一个 running 状态的 worker 处理，不多也不少。</p><p>但是这里有一个问题如果 work 是 CPU 密集型的，它虽然也没有进入 suspend 状态，但是会长时间的占用 CPU，让后续的 work 阻塞太长时间。</p><p>为了解决这个问题，CMWQ 设计了 WQ_CPU_INTENSIVE，如果一个 wq 声明自己是 CPU_INTENSIVE，则让当前 worker 脱离动态调度，像是进入了 suspend 状态，那么 CMWQ 会创建新的 worker，后续的 work 会得到执行。</p><ul><li>kernel/workqueue.c:</li><li><code>worker_thread()</code> -&gt; <code>process_one_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 设置当前 worker 的 WORKER_CPU_INTENSIVE 标志</span></span><br><span class="line"><span class="comment">// nr_running 会被减 1</span></span><br><span class="line"><span class="comment">// 对 worker_pool 来说，当前 worker 相当于进入了 suspend 状态</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment"> * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment"> * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment"> * execution of the pending work items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 接上一步，判断是否需要唤醒新的 worker 来处理 work</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment"> * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment"> * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment"> * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment"> * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 执行 work</span></span><br><span class="line">worker-&gt;current_func(work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 执行完，清理当前 worker 的 WORKER_CPU_INTENSIVE 标志</span></span><br><span class="line"><span class="comment">// 当前 worker 重新进入 running 状态</span></span><br><span class="line"><span class="comment">/* clear cpu intensive status */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WORKER_NOT_RUNNING= WORKER_PREP | WORKER_CPU_INTENSIVE |</span><br><span class="line">  WORKER_UNBOUND | WORKER_REBOUND,</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> worker_set_flags(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">struct worker_pool *pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If transitioning into NOT_RUNNING, adjust nr_running. */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;</span><br><span class="line">    !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">atomic_dec(&amp;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">worker_clr_flags</span><span class="params">(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> oflags = worker-&gt;flags;</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">worker-&gt;flags &amp;= ~flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If transitioning out of NOT_RUNNING, increment nr_running.  Note</span></span><br><span class="line"><span class="comment"> * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask</span></span><br><span class="line"><span class="comment"> * of multiple flags, not a single flag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp; (oflags &amp; WORKER_NOT_RUNNING))</span><br><span class="line"><span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">atomic_inc(&amp;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-CPU-hotplug-处理"><a href="#1-2-3-CPU-hotplug-处理" class="headerlink" title="1.2.3 CPU hotplug 处理"></a>1.2.3 CPU hotplug 处理</h4><p>从上几节可以看到，系统会创建和 CPU 绑定的 normal worker_pool 和不绑定 CPU 的 unbound worker_pool，worker_pool 又会动态的创建 worker。</p><p>那么在 CPU hotplug 的时候，会怎么样动态的处理 worker_pool 和 worker 呢？来看具体的代码分析：</p><ul><li>kernel/workqueue.c:</li><li><code>workqueue_cpu_up_callback()</code>/<code>workqueue_cpu_down_callback()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);</span><br><span class="line">hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_down_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpu = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">unbind_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line"><span class="keyword">case</span> CPU_DOWN_PREPARE:</span><br><span class="line"><span class="comment">/* unbinding per-cpu workers should happen on the local CPU */</span></span><br><span class="line">INIT_WORK_ONSTACK(&amp;unbind_work, wq_unbind_fn);</span><br><span class="line"><span class="comment">// (1) cpu down_prepare</span></span><br><span class="line"><span class="comment">// 把和当前 cpu 绑定的 normal worker_pool 上的 worker 停工</span></span><br><span class="line"><span class="comment">// 随着当前 cpu 被 down 掉，这些 worker 会迁移到其他 cpu 上</span></span><br><span class="line">queue_work_on(cpu, system_highpri_wq, &amp;unbind_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) unbound wq 对 cpu 变化的更新</span></span><br><span class="line"><span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">wq_update_unbound_numa(wq, cpu, <span class="literal">false</span>);</span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wait for per-cpu unbinding to finish */</span></span><br><span class="line">flush_work(&amp;unbind_work);</span><br><span class="line">destroy_work_on_stack(&amp;unbind_work);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_up_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> CPU = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"><span class="keyword">int</span> pi;</span><br><span class="line"><span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line"><span class="keyword">case</span> CPU_UP_PREPARE:</span><br><span class="line">for_each_cpu_worker_pool(pool, CPU) &#123;</span><br><span class="line"><span class="keyword">if</span> (pool-&gt;nr_workers)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!create_worker(pool))</span><br><span class="line"><span class="keyword">return</span> NOTIFY_BAD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CPU_DOWN_FAILED:</span><br><span class="line"><span class="keyword">case</span> CPU_ONLINE:</span><br><span class="line">mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"><span class="comment">// (3) CPU up</span></span><br><span class="line">for_each_pool(pool, pi) &#123;</span><br><span class="line">mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"><span class="comment">// 如果和当前 CPU 绑定的 normal worker_pool 上，有 WORKER_UNBOUND 停工的 worker</span></span><br><span class="line"><span class="comment">// 重新绑定 worker 到 worker_pool</span></span><br><span class="line"><span class="comment">// 让这些 worker 开工，并绑定到当前 CPU</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;CPU == CPU)</span><br><span class="line">rebind_workers(pool);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pool-&gt;CPU &lt; <span class="number">0</span>)</span><br><span class="line">restore_unbound_workers_cpumask(pool, CPU);</span><br><span class="line">mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">wq_update_unbound_numa(wq, CPU, <span class="literal">true</span>);</span><br><span class="line">mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-workqueue"><a href="#1-3-workqueue" class="headerlink" title="1.3 workqueue"></a>1.3 workqueue</h3><p>workqueue 就是存放一组 work 的集合，基本可以分为两类：一类系统创建的 workqueue，一类是用户自己创建的 workqueue。</p><p>不论是系统还是用户的 workqueue，如果没有指定 WQ_UNBOUND，默认都是和 normal worker_pool 绑定。</p><h4 id="1-3-1-系统-workqueue"><a href="#1-3-1-系统-workqueue" class="headerlink" title="1.3.1 系统 workqueue"></a>1.3.1 系统 workqueue</h4><p>系统在初始化时创建了一批默认的 workqueue：system_wq、system_highpri_wq、system_long_wq、system_unbound_wq、system_freezable_wq、system_power_efficient_wq、system_freezable_power_efficient_wq。</p><p>像 system_wq，就是 schedule_work() 默认使用的。</p><ul><li>kernel/workqueue.c:</li><li>init_workqueues()</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int __init init_workqueues(void)</span><br><span class="line">&#123;</span><br><span class="line">system_wq = alloc_workqueue(<span class="string">"events"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">system_highpri_wq = alloc_workqueue(<span class="string">"events_highpri"</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">system_long_wq = alloc_workqueue(<span class="string">"events_long"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">system_unbound_wq = alloc_workqueue(<span class="string">"events_unbound"</span>, WQ_UNBOUND,</span><br><span class="line">    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">system_freezable_wq = alloc_workqueue(<span class="string">"events_freezable"</span>,</span><br><span class="line">      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">system_power_efficient_wq = alloc_workqueue(<span class="string">"events_power_efficient"</span>,</span><br><span class="line">      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">"events_freezable_power_efficient"</span>,</span><br><span class="line">      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-workqueue-创建"><a href="#1-3-2-workqueue-创建" class="headerlink" title="1.3.2 workqueue 创建"></a>1.3.2 workqueue 创建</h4><p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p><h4 id="1-3-3-flush-workqueue"><a href="#1-3-3-flush-workqueue" class="headerlink" title="1.3.3 flush_workqueue()"></a>1.3.3 flush_workqueue()</h4><p>这一部分的逻辑，wq-&gt;work_color、wq-&gt;flush_color 换来换去的逻辑实在看的头晕。看不懂暂时不想看，放着以后看吧，或者有谁看懂了教我一下。：）</p><h3 id="1-4-pool-workqueue"><a href="#1-4-pool-workqueue" class="headerlink" title="1.4 pool_workqueue"></a>1.4 pool_workqueue</h3><p>pool_workqueue 只是一个中介角色。</p><p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p><h3 id="1-5-work"><a href="#1-5-work" class="headerlink" title="1.5 work"></a>1.5 work</h3><p>描述一份待执行的工作。</p><h4 id="1-5-1-queue-work"><a href="#1-5-1-queue-work" class="headerlink" title="1.5.1 queue_work()"></a>1.5.1 queue_work()</h4><p>将 work 压入到 workqueue 当中。</p><ul><li>kernel/workqueue.c:</li><li>queue_work() -&gt; queue_work_on() -&gt; __queue_work()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line"> struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">worklist</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> work_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While a work item is PENDING &amp;&amp; off queue, a task trying to</span></span><br><span class="line"><span class="comment"> * steal the PENDING will busy-loop waiting for it to either get</span></span><br><span class="line"><span class="comment"> * queued or lose PENDING.  Grabbing PENDING and queueing should</span></span><br><span class="line"><span class="comment"> * happen with IRQ disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">debug_work_activate(work);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if draining, only works from the same workqueue are allowed */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;</span><br><span class="line">    WARN_ON_ONCE(!is_chained_work(wq)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">// (1) 如果没有指定 cpu，则使用当前 cpu</span></span><br><span class="line"><span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pwq which will be used unless @work is executing elsewhere */</span></span><br><span class="line"><span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND))</span><br><span class="line"><span class="comment">// (2) 对于 normal wq，使用当前 cpu 对应的 normal worker_pool</span></span><br><span class="line">pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// (3) 对于 unbound wq，使用当前 cpu 对应 node 的 worker_pool</span></span><br><span class="line">pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果 work 在其他 worker 上正在被执行，把 work 压到对应的 worker 上去</span></span><br><span class="line"><span class="comment">// 避免 work 出现重入的问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @work was previously on a different pool, it might still be</span></span><br><span class="line"><span class="comment"> * running there, in which case the work needs to be queued on that</span></span><br><span class="line"><span class="comment"> * pool to guarantee non-reentrancy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">last_pool = get_work_pool(work);</span><br><span class="line"><span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">pwq = worker-&gt;current_pwq;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pwq is determined and locked.  For unbound pools, we could have</span></span><br><span class="line"><span class="comment"> * raced with pwq release and it could already be dead.  If its</span></span><br><span class="line"><span class="comment"> * refcnt is zero, repeat pwq selection.  Note that pwqs never die</span></span><br><span class="line"><span class="comment"> * without another pwq replacing it in the numa_pwq_tbl or while</span></span><br><span class="line"><span class="comment"> * work items are executing on it, so the retrying is guaranteed to</span></span><br><span class="line"><span class="comment"> * make forward-progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line"><span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">cpu_relax();</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* oops */</span></span><br><span class="line">WARN_ONCE(<span class="literal">true</span>, <span class="string">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt"</span>,</span><br><span class="line">  wq-&gt;name, cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pwq determined, queue */</span></span><br><span class="line">trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry))) &#123;</span><br><span class="line">spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) 如果还没有达到 max_active，将 work 挂载到 pool-&gt;worklist</span></span><br><span class="line"><span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">trace_workqueue_activate_work(work);</span><br><span class="line">pwq-&gt;nr_active++;</span><br><span class="line">worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line"><span class="comment">// 否则，将 work 挂载到临时队列 pwq-&gt;delayed_works</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) 将 work 压入 worklist 当中</span></span><br><span class="line">insert_work(pwq, work, worklist, work_flags);</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-flush-work"><a href="#1-5-2-flush-work" class="headerlink" title="1.5.2 flush_work()"></a>1.5.2 <code>flush_work()</code></h4><p>flush 某个 work，确保 work 执行完成。</p><p>怎么判断异步的 work 已经执行完成？这里面使用了一个技巧：在目标 work 的后面插入一个新的 work wq_barrier，如果 wq_barrier 执行完成，那么目标 work 肯定已经执行完成。</p><ul><li>kernel/workqueue.c:</li><li><code>queue_work()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flush_work - wait for a work to finish executing the last queueing instance</span></span><br><span class="line"><span class="comment"> * @work: the work to flush</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait until @work has finished execution.  @work is guaranteed to be idle</span></span><br><span class="line"><span class="comment"> * on return if it hasn't been requeued since flush started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * %true if flush_work() waited for the work to finish execution,</span></span><br><span class="line"><span class="comment"> * %false if it was already idle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">lock_map_acquire(&amp;work-&gt;lockdep_map);</span><br><span class="line">lock_map_release(&amp;work-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start_flush_work(work, &amp;barr)) &#123;</span><br><span class="line"><span class="comment">// 等待 barr work 执行完成的信号</span></span><br><span class="line">wait_for_completion(&amp;barr.done);</span><br><span class="line">destroy_work_on_stack(&amp;barr.work);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_flush_work</span><span class="params">(struct work_struct *work, struct wq_barrier *barr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 如果 work 所在 worker_pool 为 NULL，说明 work 已经执行完</span></span><br><span class="line">local_irq_disable();</span><br><span class="line">pool = get_work_pool(work);</span><br><span class="line"><span class="keyword">if</span> (!pool) &#123;</span><br><span class="line">local_irq_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;pool-&gt;lock);</span><br><span class="line"><span class="comment">/* see the comment in try_to_grab_pending() with the same code */</span></span><br><span class="line">pwq = get_work_pwq(work);</span><br><span class="line"><span class="keyword">if</span> (pwq) &#123;</span><br><span class="line"><span class="comment">// (2) 如果 work 所在 pwq 指向的 worker_pool 不等于上一步得到的 worker_pool，说明 work 已经执行完</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(pwq-&gt;pool != pool))</span><br><span class="line"><span class="keyword">goto</span> already_gone;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (3) 如果 work 所在 pwq 为 NULL，并且也没有在当前执行的 work 中，说明 work 已经执行完</span></span><br><span class="line">worker = find_worker_executing_work(pool, work);</span><br><span class="line"><span class="keyword">if</span> (!worker)</span><br><span class="line"><span class="keyword">goto</span> already_gone;</span><br><span class="line">pwq = worker-&gt;current_pwq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 如果 work 没有执行完，向 work 的后面插入 barr work</span></span><br><span class="line">insert_wq_barrier(pwq, barr, work, worker);</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @max_active is 1 or rescuer is in use, flushing another work</span></span><br><span class="line"><span class="comment"> * item on the same workqueue may lead to deadlock.  Make sure the</span></span><br><span class="line"><span class="comment"> * flusher is not running on the same workqueue by verifying write</span></span><br><span class="line"><span class="comment"> * access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pwq-&gt;wq-&gt;saved_max_active == <span class="number">1</span> || pwq-&gt;wq-&gt;rescuer)</span><br><span class="line">lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">already_gone:</span><br><span class="line">spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_wq_barrier</span><span class="params">(struct pool_workqueue *pwq,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct wq_barrier *barr,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct work_struct *target, struct worker *worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> linked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * debugobject calls are safe here even with pool-&gt;lock locked</span></span><br><span class="line"><span class="comment"> * as we know for sure that this will not trigger any of the</span></span><br><span class="line"><span class="comment"> * checks and call back into the fixup functions where we</span></span><br><span class="line"><span class="comment"> * might deadlock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.1) barr work 的执行函数 wq_barrier_func()</span></span><br><span class="line">INIT_WORK_ONSTACK(&amp;barr-&gt;work, wq_barrier_func);</span><br><span class="line">__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&amp;barr-&gt;work));</span><br><span class="line">init_completion(&amp;barr-&gt;done);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @target is currently being executed, schedule the</span></span><br><span class="line"><span class="comment"> * barrier to the worker; otherwise, put it after @target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4.2) 如果 work 当前在 worker 中执行，则 barr work 插入 scheduled 队列</span></span><br><span class="line"><span class="keyword">if</span> (worker)</span><br><span class="line">head = worker-&gt;scheduled.next;</span><br><span class="line"><span class="comment">// 否则，则 barr work 插入正常的 worklist 队列中，插入位置在目标 work 后面</span></span><br><span class="line"><span class="comment">// 并且置上 WORK_STRUCT_LINKED 标志</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *bits = work_data_bits(target);</span><br><span class="line"></span><br><span class="line">head = target-&gt;entry.next;</span><br><span class="line"><span class="comment">/* there can already be other linked works, inherit and set */</span></span><br><span class="line">linked = *bits &amp; WORK_STRUCT_LINKED;</span><br><span class="line">__set_bit(WORK_STRUCT_LINKED_BIT, bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug_work_activate(&amp;barr-&gt;work);</span><br><span class="line">insert_work(pwq, &amp;barr-&gt;work, head,</span><br><span class="line">    work_color_to_flags(WORK_NO_COLOR) | linked);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wq_barrier_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> *<span class="title">barr</span> = <span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">wq_barrier</span>, <span class="title">work</span>);</span></span><br><span class="line"><span class="comment">// (4.1.1) barr work 执行完成，发出 complete 信号。</span></span><br><span class="line">complete(&amp;barr-&gt;done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Workqueue-对外接口函数"><a href="#2-Workqueue-对外接口函数" class="headerlink" title="2.Workqueue 对外接口函数"></a>2.Workqueue 对外接口函数</h2><p>CMWQ 实现的 workqueue 机制，被包装成相应的对外接口函数。</p><h3 id="2-1-schedule-work"><a href="#2-1-schedule-work" class="headerlink" title="2.1 schedule_work()"></a>2.1 <code>schedule_work()</code></h3><p>把 work 压入系统默认 wq system_wq，WORK_CPU_UNBOUND 指定 worker 为当前 CPU 绑定的 normal worker_pool 创建的 worker。</p><ul><li>kernel/workqueue.c:</li><li><code>schedule_work()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-sschedule-work-on"><a href="#2-2-sschedule-work-on" class="headerlink" title="2.2 sschedule_work_on()"></a>2.2 <code>sschedule_work_on()</code></h3><p>在 <code>schedule_work()</code> 基础上，可以指定 work 运行的 CPU。</p><ul><li>kernel/workqueue.c:</li><li><code>schedule_work_on()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_work_on(cpu, system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-schedule-delayed-work"><a href="#2-3-schedule-delayed-work" class="headerlink" title="2.3 schedule_delayed_work()"></a>2.3 <code>schedule_delayed_work()</code></h3><p>启动一个 timer，在 timer 定时到了以后调用 <code>delayed_work_timer_fn()</code> 把 work 压入系统默认 wq system_wq。</p><ul><li>kernel/workqueue.c:</li><li><code>schedule_work_on()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_delayed_work(system_wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">   struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line"><span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* read the comment in __queue_work() */</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">__queue_delayed_work(cpu, wq, dwork, delay);</span><br><span class="line">ret = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_delayed_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">timer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||</span><br><span class="line">     timer-&gt;data != (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dwork);</span><br><span class="line">WARN_ON_ONCE(timer_pending(timer));</span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;work-&gt;entry));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If @delay is 0, queue @dwork-&gt;work immediately.  This is for</span></span><br><span class="line"><span class="comment"> * both optimization and correctness.  The earliest @timer can</span></span><br><span class="line"><span class="comment"> * expire is on the closest next tick and delayed_work users depend</span></span><br><span class="line"><span class="comment"> * on that there's no such delay when @delay is 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!delay) &#123;</span><br><span class="line">__queue_work(cpu, wq, &amp;dwork-&gt;work);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);</span><br><span class="line"></span><br><span class="line">dwork-&gt;wq = wq;</span><br><span class="line">dwork-&gt;cpu = cpu;</span><br><span class="line">timer-&gt;expires = jiffies + delay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu != WORK_CPU_UNBOUND))</span><br><span class="line">add_timer_on(timer, cpu);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayed_work_timer_fn</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> __data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> = (<span class="title">struct</span> <span class="title">delayed_work</span> *)__<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* should have been called from irqsafe timer with irq already off */</span></span><br><span class="line">__queue_work(dwork-&gt;cpu, dwork-&gt;wq, &amp;dwork-&gt;work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://git.kernel.org/cgit/Linux/kernel/git/torvalds/Linux.git/tree/Documentation/workqueue.txt?id=refs/tags/v4.7-rc5" target="_blank" rel="noopener">Documentation/workqueue.txt</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 进程管理与通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Workqueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SELinux 安全策略解析 </title>
      <link href="/2016/08/11//linux-selinux-intro.html/"/>
      <url>/2016/08/11//linux-selinux-intro.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>SELinux 是 Security-Enhanced Linux 的简称，是美国国家安全局（NSA=The National Security Agency) 和 SCC（Secure Computing Corporation）开发的基于 Linux 的一个强制访问控制安全模块扩展。原先是在 Fluke 上开发的，2000 年以 GNU GPL 协议发布。对于目前可用的 Linux 安全模块来说，SELinux 是功能最全面 , 而且测试最充分的，它是在 20 年的 MAC 研究基础上建立的。SELinux 已足够成熟、稳定，因此应用非常广泛，现在 Android M 上已经默认开启 SELinux。</p><h2 id="2、自主访问控制"><a href="#2、自主访问控制" class="headerlink" title="2、自主访问控制"></a>2、自主访问控制</h2><p>标准 Linux 也不是没有一点安全性，对于用户对资源的访问也是有一定的限制的，这个限制由三个因素来决定：用户及其组 ID、资源所属的用户及其组 ID、访问模式。这里以文件访问为例，介绍一下标准 Linux 访问控制及其安全漏洞。</p><p>Linux 是一个多用户多任务的分时操作系统，如果要使用系统资源，就必须向系统管理员申请一个账户，然后通过这个账户进入系统。这个账户就是用户 ID。有时需要让多个用户具有相同的权限，为了简化管理，将具有相同特征用户组成一个逻辑集合，就叫用户组。而文件所属用户，一般为文件的创建者，谁创建了该文件 , 就天然的成为该文件的所有者，创建者所在组就是该文件的所属用户组。</p><p><code>ls -l</code> 显示文件的属性如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r‐<span class="number">-1</span> dengtaiping dengtaiping <span class="number">4096</span> <span class="number">6</span> 月 <span class="number">2</span> <span class="number">09</span>:<span class="number">39</span> temp</span><br></pre></td></tr></table></figure><p>前面 10 个字符代表了标准 Linux 对 temp 这个文件的访问控制：</p><ul><li>第一个字符代表文件（-）、目录（d），链接（l）</li><li>其余字符每 3 个一组（rwx），读（r）、写（w）、执行（x）</li><li>第一组 rwx：文件所有者的权限是读、写和执行</li><li>第二组 rw-：与文件所有者同一组的用户的权限是读、写但不能执行</li><li>第三组 r—：不与文件所有者同组的其他用户的权限是读不能写和执行</li></ul><p>后面是文件的所有者、所有者所在的组及其它属性。在安全访问中，访问的发起者称为主体，被访问的资源成为客体。标准 Linux 世界里这种由客体的属主对自己的客体进行管理，由属主自己决定是否将自己的客体访问权或部分访问权授予其他主体的访问控制称为自主访问控制（Discretionary Access Control——DAC）。也就是说，在自主访问控制下，用户可以按自己的意愿，有选择地与其他用户共享他的文件。如在标准 Linux 里，可以通过 chmod、chgrp、chown 分别改变文件的权限、用户组及所有者。所以，DAC 最大的缺点是它不能区分用户和程序，即授权许可是给用户的，只要用户有授权，该用户的所有程序都自动获得授权，包括侵入该用户名下的恶意程序。如果恶意程序获得 root 用户权限，那在标准 Liunx 世界里，就无所不能了。</p><h2 id="3、强制访问控制"><a href="#3、强制访问控制" class="headerlink" title="3、强制访问控制"></a>3、强制访问控制</h2><p>强制访问控制（Mandatory Access Control——MAC），用于将系统中的客体分密级和类进行管理，以保证每个主体只能访问到那些被标明可以由它访问的一种访问约束机制。在 SELinux 的强制访问控制下，访问的主体不再是用户，而是进程。客体可以是文件、目录、共享内存、套接字、网络主机等。主体和客体都被标记了固定的安全属性（如安全等级、访问权限等），在每次访问发生时，系统检测安全属性以便确定一个主体是否有权访问该客体。因此在这里，决定访问权限的不再是主体和客体，而是访问控制策略。这就意味着在 SELinux 中没有默认的超级用户。SELinux 实现了一个灵活的 MAC 机制，引入了两套安全策略，分别是类型强制 (Type Enforcement) 和多层安全 (Multi-Level Security)。</p><h3 id="3-1、类型强制"><a href="#3-1、类型强制" class="headerlink" title="3.1、类型强制"></a>3.1、类型强制</h3><p>类型强制访问控制通过指定主体类型（即域）和客体类型使用 allow 规则授予访问权限，allow 规则由四部分组成：</p><ul><li>源类型（Source type(s)）：通常是尝试访问的进程的域类型</li><li>目标类型（Target type(s)）： 被进程访问的客体的类型</li><li>客体类别（Object class(es)）： 指定允许访问的客体的类型</li><li>许可（Permission(s)）： 象征目标类型允许源类型访问客体类型的访问种类</li></ul><p>下面以 Android 手机中一个例子说明 TE 是如何工作的。在手机的 console 环境中，运行 <code>ls -Z | grep proc</code>，可看到 proc 目录的安全上下文如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dr</span>-xr-xr-x root     root              u:object_r:<span class="meta">proc</span>:<span class="built_in">s0</span> <span class="meta">proc</span></span><br></pre></td></tr></table></figure><p>再运行 <code>ps -Z | grep adbd</code>，看看进程 adbd 的安全上下文：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">u:</span><span class="string">r:</span><span class="string">su:</span>s0                      root      <span class="number">2935</span>  <span class="number">1</span>     <span class="regexp">/sbin/</span>adbd</span><br></pre></td></tr></table></figure><p>可以看到，目录 proc 和进程 adbd 各自有自己的安全上下文，安全上下文实际上是附加在对象上的一个标签，由用户、角色、类型和安全级别四部分组成，由冒号隔开。安全级别下一节再介绍，在 SEAndroid 里，只定义了一个用户 u，所以文件和进程安全上下文中，所有的用户都为 u。文件的角色一般都为 object_r，而进程的角色固定为 r。用户和角色定义得这么随意，是因为对安全策略来说它们并不重要，在类型强制访问控制的安全上下文中，最重要的就是类型，它才是定义规则时需要的。假如要想通过 adb 读写 proc 目录下的文件节点，则需要定义如下一条规则来授权：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow init <span class="function"><span class="keyword">proc</span>:<span class="title">dir</span> <span class="title">rw_dir_perms</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2、多级安全"><a href="#3-2、多级安全" class="headerlink" title="3.2、多级安全"></a>3.2、多级安全</h3><p>SELinux 引入的另外一个安全策略是多级安全 (Multi-Level Security)。多级安全是建立在 TE 的基础之上的，这个安全策略在 SELinux 中是可选的，但引入多级安全，不仅是对安全访问的增强，更是因为对于一组对象进行分类访问授权，使用多级安全是非常高效的。在前面所举例子中，proc 和 adbd 都有一个安全级别 s0。</p><p>在多级安全中，主体和客体都有一个关联的安全级别，多级安全的访问规则就是：安全级别较高的主体可以读取安全级别较低的客体；而安全级别较低的主体可以写入安全级别较高的客体。前者称为 “read down”，后者称为 “write up”。通过这种规则，可以允许数据从安全级别较低的客体流向安全级别较高的主体，而限制数据从安全级别较高的客体流向安全级别较低的主体，从而有效的保护了数据。对于安全级别相同的主体和客体，主体对客体的读写都是允许的。</p><p>基于多级安全策略的 MAC 数据流向，如下所示：</p><p><img src="SELinux_1.png" alt="MAC 数据流向 "></p><p>图中定义来两个安全级别，PUBLIC 和 SECRET，其中，SECRET 安全级别高于 PUBLIC。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>SELinux 原来是作为一个内核补丁实现的，现在已经将 Linux 安全模块（LSM）重新实现为一个安全模块。嵌入到标准 Linux 中的方式是 LSM 提供一套钩子函数 (hook)，MAC 安全策略检查在这些钩子函数中实现。钩子函数通常放在标准 Linux 检查后、内核调用访问真实资源前调用。系统调用进入内核后，会做常规的错误检查 ( 如参数有效性等 )，然后是标准 Linux 的 DAC 检查。MAC 在这些检查都通过之后才会生效。所以，在 SELinux 中，DAC 和 MAC 同时起作用，两者并行而不悖。LSM 具体实现机制及代码解读将在后续文章中介绍。最终 SELinux 的访问控制流程就如下图所示：</p><p><img src="SELinux_2.png" alt="SELinux 控制流程 "></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SELinux </tag>
            
            <tag> 类型强制 </tag>
            
            <tag> 多级安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS 调度器移植体验 </title>
      <link href="/2016/08/05//bfs-porting.html/"/>
      <url>/2016/08/05//bfs-porting.html/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>BFS 全称 Brain Fuck Scheduler. 至于为什么叫这个名字，可以参考 BFS-FAQ<sup><a href="#fn_FAQ" id="reffn_FAQ">FAQ</a></sup>．</p><p>作者 Con Kolivas 在介绍中表示，BFS 的设计的初衷是带来更好的桌面交互式体验，特别是对于大多数的低规格机器．</p><p>Android 也曾经评估过 BFS, 测试的结果对用户体验没有明显的改进，因此并没有最终导入．</p><p>通过一些第三方机构的测试数据来看，低配置的硬件平台使用 BFS 带来的体验提升会更加明显．比如笔者正在用的这台　thinkpad t61 ( 所以手上有比较老的笔记本 / PC 尽管来体验吧 )．</p><h3 id="Get-Prepared"><a href="#Get-Prepared" class="headerlink" title="Get Prepared"></a>Get Prepared</h3><ol><li><p>选择内核版本<br>从 <a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a> 选择下载需要的版本 , 比如 3.18.31.tx.gz</p></li><li><p>解压缩该版本到你想要路径 , 网络上有建议放在 /usr/src 下 , 看起来更合理 , 因为内核的源代码默认就存放在该路径 , 但我就遇到了编译时空间不够的问题 , 因为我给 ‘/‘ 分配的空间是 20GB, 能用的不到 8GB 了 . 所以建议放在空间够的分区 , 至少有 15GB, 例如 ~/projects/3.18.31-ck1-bfs/</p></li></ol><h3 id="Apply-BFS-Patch"><a href="#Apply-BFS-Patch" class="headerlink" title="Apply BFS Patch"></a>Apply BFS Patch</h3><ol><li>获取对应内核版本的 BFS patch, 从 BFS 作者 <a href="http://ck.kolivas.org/" target="_blank" rel="noopener">Con Kolivas 的个人站点 </a> 获得指定内核版本的 BFS patch, 例如 <code>http://ck.kolivas.org/patches/bfs/3.0/3.18/</code> 下面就有 3.18-sched-bfs-460.patch 等</li><li>进入到内核目录 ~/projects/3.18.31-ck1-bfs/, <code>patch -p1 &lt;xxxx.patch</code>, patch 不止一个 , 建议都打上 , 省的后期再 tunning 了</li></ol><h3 id="Build-Kernel-with-BFS-patch"><a href="#Build-Kernel-with-BFS-patch" class="headerlink" title="Build Kernel with BFS patch"></a>Build Kernel with BFS patch</h3><ol><li><p><code>$ make menuconfig</code><br>注意再 General Setup 确认 BFS 是不是已经勾选上了，OK 之后就保存 .config 文件</p></li><li><p><code>$ make bzImage -j4</code><br>这取决于机器的性能, 一般是 -jx 是 CPU core 的 2 倍 , 考虑到有些电脑太老了, 可以把源码的编译放在性能更好的机器上做 , 完事后 copy 过来就 OK 了</p></li><li><p><code>$ make modules -j4</code><br>同上 , 完成这一步之后 , 可以把整个源码包复制到你想要的电脑上</p></li><li><p><code>$ make modules_install</code></p></li><li><code>$ sudo mkinitramfs -o /boot/initrd.img-3.18.31-ck1-bfs</code></li></ol><h3 id="Configure-New-Kernel"><a href="#Configure-New-Kernel" class="headerlink" title="Configure New Kernel"></a>Configure New Kernel</h3><ol><li><p>Copy bzImage 到 /boot/<br><code>$ sudo cp arch/x86_64/boot/bzImage /boot/vmlinuz-3.18.31-ck1-bfs</code><br>具体取决于系统架构 , 也不一定是 x86_64 目录</p></li><li><p>Copy System.map 到 /boot/, 建立新的软链接<br><code>$ sudo cp System.map /boot/System.map-3.18.31-ck1-bfs</code><br><code>$ sudo ln -s /boot/System.map-3.18.31-ck1-bfs /boot/System.map</code></p></li><li><p>配置引导文件<br><code>$ sudo update-grub2</code></p></li></ol><p>至此 , 工作完成 , reboot 之后就可以体验啦</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote id="fn_FAQ"><sup>FAQ</sup>. <a href="http://ck.kolivas.org/patches/bfs/bfs-faq.txt" target="_blank" rel="noopener">http://ck.kolivas.org/patches/bfs/bfs-faq.txt</a><a href="#reffn_FAQ" title="Jump back to footnote [FAQ] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 调度器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> scheduler </tag>
            
            <tag> BFS </tag>
            
            <tag> 调度器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 死锁检测模块 Lockdep 简介</title>
      <link href="/2016/07/24//linux-dead-lock-detect-lockdep.html/"/>
      <url>/2016/07/24//linux-dead-lock-detect-lockdep.html/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h2><p>死锁是指多个进程（线程）因为长久等待已被其他进程占有的的资源而陷入阻塞的一种状态。当等待的资源一直得不到释放，死锁会一直持续下去。死锁一旦发生，程序本身是解决不了的，只能依靠外部力量使得程序恢复运行，例如重启，开门狗复位等。</p><p>Linux 提供了检测死锁的机制，主要分为 D 状态死锁和 R 状态死锁。</p><ul><li><p><strong>D 状态死锁</strong></p><p>进程等待 I/O 资源无法得到满足，长时间（系统默认配置 120 秒）处于 TASK_UNINTERRUPTIBLE 睡眠状态，这种状态下进程不响应异步信号（包括 kill -9）。如：进程与外设硬件的交互（如 read），通常使用这种状态来保证进程与设备的交互过程不被打断，否则设备可能处于不可控的状态。对于这种死锁的检测 Linux 提供的是 hung task 机制，MTK 也提供 hang detect 机制来检测 Android 系统 hang 机问题。触发该问题成因比较复杂多样，可能因为 synchronized_irq、mutex lock、内存不足等。D 状态死锁只是局部多进程间互锁，一般来说只是 hang 机、冻屏，机器某些功能没法使用，但不会导致没喂狗，而被狗咬死。</p></li><li><p><strong>R 状态死锁</strong></p><p>进程长时间（系统默认配置 60 秒）处于 TASK_RUNNING 状态垄断 CPU 而不发生切换，一般情况下是进程关抢占或关中断后长时候执行任务、死循环，此时往往会导致多 CPU 间互锁，整个系统无法正常调度，导致喂狗线程无法执行，无法喂狗而最终看门狗复位的重启。该问题多为原子操作，spinlock 等 CPU 间并发操作处理不当造成。本文所介绍的 Lockdep 死锁检测工具检测的死锁类型就是 R 状态死锁。</p></li></ul><p><strong>常见错误</strong></p><ul><li>AA: 重复上锁</li><li>ABBA: 曾经使用 AB 顺序上锁，又使用 BA 上锁</li><li>ABBCCA: 这种类型是 ABBA 的扩展。AB 顺序 , AB 顺序，CA 顺序。这种锁人工很难发现。</li><li>多次 unlock</li></ul><h2 id="AB-BA-死锁的形成"><a href="#AB-BA-死锁的形成" class="headerlink" title="AB-BA 死锁的形成"></a>AB-BA 死锁的形成</h2><p>假设有两处代码（比如不同线程的两个函数 thread_P 和 thread_Q）都要获取两个锁（分别为 lockA 和 lockB），如果 thread_P 持有 lockA 后再去获取 lockB，而此时恰好由 thread_Q 持有 lockB 且它也正在尝试获取 lockA，那么此时就是处于死锁的状态，这是一个最简单的死锁例子，也即所谓的 AB-BA 死锁。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">thread<span class="constructor">_P()</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    spin<span class="constructor">_lock(&amp;<span class="params">lockA</span>)</span>;</span><br><span class="line">    spin<span class="constructor">_lock(&amp;<span class="params">lockB</span>)</span>;</span><br><span class="line"></span><br><span class="line">    spin<span class="constructor">_unlock(&amp;<span class="params">lockA</span>)</span>;</span><br><span class="line">    spin<span class="constructor">_unlock(&amp;<span class="params">lockB</span>)</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread<span class="constructor">_Q()</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    spin<span class="constructor">_lock(&amp;<span class="params">lockB</span>)</span>;</span><br><span class="line">    spin<span class="constructor">_lock(&amp;<span class="params">lockA</span>)</span>;</span><br><span class="line"></span><br><span class="line">    spin<span class="constructor">_unlock(&amp;<span class="params">lockB</span>)</span>;</span><br><span class="line">    spin<span class="constructor">_unlock(&amp;<span class="params">lockA</span>)</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面接合时间轴来观察死锁发生的时机：</p><p><img src="lockdep-ABBA-1.png" alt="ABBA 死锁示意图 1"></p><p>X 轴表示进程 P 执行的时间轴，Y 轴表示进程 Q 执行的时间轴。</p><p>这幅图依据两个进程并发时间点不同而给出了 6 种执行线路：</p><ol><li>Q 获得 B，然后获得 A；然后释放 B，然后释放 A；此时 P 执行时，它可以获得全部资源</li><li>Q 获得 B，然后获得 A；此时 P 执行并阻塞在对 A 的请求上；Q 释放 B 和 A，当 P 恢复执行时，它可以获得全部资源</li><li>Q 获得 B，然后 P 执行获得 A；此时 Q 阻塞在对 A 的请求上；P 阻塞在对 B 的请求上，大家都在互相等待各自的资源而死锁</li><li>P 获得 A，然后 Q 执行获得 B；此时 P 阻塞在对 B 的请求上；Q 阻塞在对 A 的请求上，大家都在互相等待各自的资源而死锁</li><li>P 获得 A，然后获得 B；此时 Q 执行并阻塞在对 B 的请求上；P 释放 A 和 B，当 Q 恢复执行时，它可以获得全部资源</li><li>P 获得 A，然后获得 B；然后释放 A，然后释放 B；此时 Q 执行时，它可以获得全部资源</li></ol><p>下面这种情况是任何时间点都不会出现死锁的</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Process</span> P                  Process Q</span><br><span class="line">  •••                        •••</span><br><span class="line"> <span class="meta">Get</span> A                      <span class="meta">Get</span> <span class="keyword">B</span></span><br><span class="line"><span class="keyword"> </span> •••                        •••</span><br><span class="line"><span class="symbol">Release</span> A                   <span class="meta">Get</span> A</span><br><span class="line">  •••                        •••</span><br><span class="line"> <span class="meta">Get</span> <span class="keyword">B </span>                    Release <span class="keyword">B</span></span><br><span class="line"><span class="keyword"> </span> •••                        •••</span><br><span class="line"><span class="symbol">Release</span> <span class="keyword">B </span>                 Release A</span><br><span class="line">  •••                        •••</span><br></pre></td></tr></table></figure><p><img src="lockdep-ABBA-2.png" alt="ABBA 死锁示意图 2"></p><h2 id="lockdep-死锁检测模块"><a href="#lockdep-死锁检测模块" class="headerlink" title="lockdep 死锁检测模块"></a>lockdep 死锁检测模块</h2><p>介绍了最简单的 ABBA 死锁的形成，回到正题，回到 kernel, 里面有千千万万锁，错综复杂，也不可能要求所有开发人员熟悉 spin_lock, spin_lock_irq, spin_lock_irqsave, spin_lock_nested 的区别。所以，在锁死发生前，还是要做好预防胜于治疗，防患于未然的工作，尽量提前发现并且提前在开发阶段发现和解决这其中潜在的死锁风险，而不是等到最后真正出现死锁时给用户带来糟糕的体验。应运而生的就是 lockdep 死锁检测模块，在 2006 年已经引入内核（<a href="https://lwn.net/Articles/185666/）。" target="_blank" rel="noopener">https://lwn.net/Articles/185666/）。</a></p><h3 id="1-相关内核配置选项"><a href="#1-相关内核配置选项" class="headerlink" title="1. 相关内核配置选项"></a>1. 相关内核配置选项</h3><ul><li><p><strong>CONFIG_PROVE_LOCKING</strong></p><p>This feature enables the kernel to report locking related deadlocks before they actually occur. For more details, see Documentation/locking/lockdep-design.txt.</p></li><li><p><strong>CONFIG_DEBUG_LOCK_ALLOC</strong></p><p>Detect incorrect freeing of live locks.</p></li><li><p><strong>CONFIG_DEBUG_LOCKDEP</strong></p><p>The lock dependency engine will do additional runtime checks to debug itself, at the price of more runtime overhead.</p></li><li><p><strong>CONFIG_LOCK_STAT</strong></p><p>Lock usage statistics. For more details, see Documentation/locking/lockstat.txt</p></li><li><p><strong>CONFIG_DEBUG_LOCKING_API_SELFTESTS</strong></p><p>The kernel to run a short self-test during bootup in <code>start_kernel()</code>. The self-test checks whether common types of locking bugs are detected by debugging mechanisms or not. For more details, see lib/locking-selftest.c</p></li></ul><h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2. 基本实现"></a>2. 基本实现</h3><p>lockdep 操作的基本单元并非单个的锁实例，而是锁类（lock-class），事实上，也没必要跟踪千千万万的锁，完全可以用同一方式对待同一类锁的行为。比如，struct inode 结构体中的自旋锁 i_lock 字段就代表了这一类锁，而具体每个 inode 节点的锁只是该类锁中的一个实例。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> raw_spin_lock_init(lock)\</span></span><br><span class="line"><span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> lock_class_key __key;\</span><br><span class="line">\</span><br><span class="line">__raw_spin_lock_init((<span class="keyword">lock</span>), <span class="meta">#lock, &amp;__key);\</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对于每个锁的初始化，这段代码创建了一个静态变量 (__key)，并使用它的地址作为识别锁的类型。因此，系统中的每个锁 ( 包括 rwlocks 和 mutexes ) 都被分配一个特定的 key 值，并且都是静态声明的，同一类的锁会对应同一个 key 值。这里用得是哈希表来存储。</p><p>Lockdep 为每个锁类维护了两个链表：</p><ul><li>before 链：锁类 L 前曾经获取的所有锁类，也就是锁类 L 前可能获取的锁类集合。</li><li>after 链：锁类 L 后曾经获取的所有锁类。</li></ul><p>Lockdep 逻辑：</p><p>当获取 L 时，检查 after 链中的锁类是否已经被获取，如果存在则报重复上锁。联合 L 的 after 链，和已经获取的锁的 before 链。递归检查是否某个已经获取的锁中包含 L after 锁。为了加速，lockdep 检查锁类顺序关系，计算出 64bit 的 hash key。当新的 lock 顺序出现则计算 hash key 并放入表中。当获取锁时，则直接扫描表，用于加速。</p><p>也由于上述的设计逻辑，不可避免会存在误报。例如，同一类（对应相同 key 值）的多个锁同时持有时，Lockdep 会误报“重复上锁”的警报。此时，你就需要使用 spin_lock_nested 这类 API 设置不同的子类来区分同类锁，消除警报。</p><p>随便找一个代码例子：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dentry_lock_for_move() @fs/dcache.c</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">if</span> (d_ancestor(dentry-&gt;</span><span class="function"><span class="title">d_parent</span>, target-&gt;</span>d_parent)) &#123;</span><br><span class="line"><span class="function"><span class="title">spin_lock</span>(&amp;dentry-&gt;</span><span class="function"><span class="title">d_parent</span>-&gt;</span>d_lock);</span><br><span class="line"><span class="function"><span class="title">spin_lock_nested</span>(&amp;target-&gt;</span><span class="function"><span class="title">d_parent</span>-&gt;</span>d_lock,</span><br><span class="line">DENTRY_D_LOCK_NESTED);  <span class="comment">//set sub-class</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="function"><span class="title">spin_lock</span>(&amp;target-&gt;</span><span class="function"><span class="title">d_parent</span>-&gt;</span>d_lock);</span><br><span class="line"><span class="function"><span class="title">spin_lock_nested</span>(&amp;dentry-&gt;</span><span class="function"><span class="title">d_parent</span>-&gt;</span>d_lock,</span><br><span class="line">DENTRY_D_LOCK_NESTED); <span class="comment">//set sub-class</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）初始化</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">spin_lock_init</span>()</span></span><br><span class="line">        ↓</span><br><span class="line"><span class="function"><span class="title">raw_spin_lock_init</span>()</span></span><br><span class="line">        ↓</span><br><span class="line"><span class="function"><span class="title">__raw_spin_lock_init</span>()</span></span><br><span class="line">        → <span class="function"><span class="title">debug_check_no_locks_freed</span>()</span></span><br><span class="line">        → <span class="function"><span class="title">lockdep_init_map</span>()</span></span><br><span class="line">        → 初始化 <span class="variable">spin_lock</span> 的值</span><br></pre></td></tr></table></figure><p>2）获取锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spin<span class="constructor">_lock()</span></span><br><span class="line">    ↓</span><br><span class="line">raw<span class="constructor">_spin_lock()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="constructor">_raw_spin_lock()</span> @kernel/spinlock.c</span><br><span class="line">    ↓</span><br><span class="line"><span class="constructor">__raw_spin_lock()</span> @<span class="keyword">include</span>/linux/spinlock_api_smp.h</span><br><span class="line">    → preempt<span class="constructor">_disable()</span>;</span><br><span class="line">    → spin<span class="constructor">_acquire(&amp;<span class="params">lock</span>-&gt;<span class="params">dep_map</span>, 0, 0, <span class="params">_RET_IP_</span>)</span>;</span><br><span class="line">            ↓</span><br><span class="line">        lock<span class="constructor">_acquire()</span> → <span class="constructor">__lock_acquire()</span> → <span class="constructor">__lock_acquire()</span></span><br><span class="line">        <span class="constructor">__lock_acquire()</span> 是 lockdep 死锁检测的核心，所有原理中描述的死锁错误都是在这里检测的。如果出错，最终会调用 print<span class="constructor">_xxx_bug()</span> 函数。</span><br><span class="line">    → <span class="constructor">LOCK_CONTENDED(<span class="params">lock</span>, <span class="params">do_raw_spin_trylock</span>, <span class="params">do_raw_spin_lock</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-检查规则"><a href="#3-检查规则" class="headerlink" title="3. 检查规则"></a>3. 检查规则</h3><p><strong>1）概述</strong></p><p>Lockdep 操作的基本单元并非单个的锁实例，而是锁类（lock-class）。比如，struct inode 结构体中的自旋锁 i_lock 字段就代表了这一类锁，而具体每个 inode 节点的锁只是该类锁中的一个实例。</p><p>lockdep 跟踪每个锁类的自身状态，也跟踪各个锁类之间的依赖关系，通过一系列的验证规则，以确保锁类状态和锁类之间的依赖总是正确的。另外，锁类一旦在初次使用时被注册，那么后续就会一直存在，所有它的具体实例都会关联到它。</p><p><strong>2）状态</strong></p><p>锁类有 4n + 1 种不同的使用历史状态：</p><p>其中的 4 是指：</p><ul><li>‘ever held in STATE context’ –&gt; 该锁曾在 STATE 上下文被持有过</li><li>‘ever held as readlock in STATE context’ –&gt; 该锁曾在 STATE 上下文被以读锁形式持有过</li><li>‘ever held with STATE enabled’ –&gt; 该锁曾在启用 STATE 的情况下被持有过</li><li>‘ever held as readlock with STATE enabled’ –&gt; 该锁曾在启用 STATE 的情况下被以读锁形式持有过</li></ul><p>其中的 n 也就是 STATE 状态的个数：</p><ul><li>hardirq –&gt; 硬中断</li><li>softirq –&gt; 软中断</li><li>reclaim_fs –&gt; fs 回收</li></ul><p>其中的 1 是：</p><ul><li>ever used  [ == !unused ] –&gt; 不属于上面提到的任何特殊情况，仅仅只是表示该锁曾经被使用过</li></ul><p>当触发 lockdep 检测锁的安全规则时，会在 log 中提示对应的状态位信息</p><p>比如：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe/<span class="number">2287</span> is trying <span class="keyword">to</span> acquire lock:</span><br><span class="line"> (&amp;sio_locks[i].lock)&#123;-.-...&#125;, at: <span class="meta">[&lt;c02867fd&gt;]</span> mutex_lock+<span class="number">0x21</span>/<span class="number">0x24</span></span><br><span class="line"></span><br><span class="line">but task is already holding lock:</span><br><span class="line"> (&amp;sio_locks[i].lock)&#123;-.-...&#125;, at: <span class="meta">[&lt;c02867fd&gt;]</span> mutex_lock+<span class="number">0x21</span>/<span class="number">0x24</span></span><br></pre></td></tr></table></figure><p>注意大括号内的符号，一共有 6 个字符，分别对应 STATE 和 STATE-read 这六种（因为目前每个 STATE 有 3 种不同含义）情况，各个字符代表的含义分别如下：</p><ul><li>‘.’  表示在在进程上下文，在 irq 关闭时获得一把锁</li><li>‘-‘  表示在中断上下文，获得一把锁</li><li>‘+’  表示在 irq 打开时获得一把锁</li><li>‘?’  表示在中断上下文，在 irq 打开时获得一把锁</li></ul><p><strong>3）单锁状态规则（Single-lock state rules）</strong></p><ul><li>一个软中断不安全 (softirq-unsafe) 的锁类也是硬中断不安全 (hardirq-unsafe) 的锁类。</li><li>对于任何一个锁类，它不可能同时是 hardirq-safe  和 hardirq-unsafe，也不可能同时是 softirq-safe 和 softirq-unsafe，即这两对对应状态是互斥的。</li></ul><p>上面这两条就是 lockdep 判断单锁是否会发生死锁的检测规则。</p><p>关于四个名称的概念如下 :</p><ul><li>ever held in hard interrupt context (hardirq-safe);</li><li>ever held in soft interrupt context (softirg-safe);</li><li>ever held in hard interrupt with interrupts enabled (hardirq-unsafe);</li><li>ever held with soft interrupts and hard interrupts enabled (softirq-unsafe);</li></ul><p><strong>4）多锁依赖规则（Multi-lock dependency rules）</strong></p><ul><li>同一个锁类不能被获取两次，否则会导致递归死锁（AA）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CPU0</span>:    <span class="selector-attr">[ L1 ]</span> <span class="selector-tag">-</span>&gt; <span class="selector-attr">[ L1 ]</span></span><br></pre></td></tr></table></figure><ul><li>不能以不同的顺序获取两个锁类，即：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----                    ----</span><br><span class="line">[<span class="meta"> L1 </span>]</span><br><span class="line">                        [<span class="meta"> L2 </span>]</span><br><span class="line">                        [<span class="meta"> L1 </span>]</span><br><span class="line">[<span class="meta"> L2 </span>]</span><br><span class="line">*** DEADLOCK ***</span><br></pre></td></tr></table></figure><p>是不行的。因为这会非常容易的导致 AB-BA 死锁。当然，下面这样的情况也不行，即在中间插入了其它正常顺序的锁也能被 lockdep 检测出来：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPU0                    CPU1</span><br><span class="line">----                    ----</span><br><span class="line">[<span class="meta"> L1 </span>]</span><br><span class="line">[<span class="meta"> L3 </span>]</span><br><span class="line">[<span class="meta"> L4 </span>]</span><br><span class="line">                        [<span class="meta"> L2 </span>]</span><br><span class="line">                        [<span class="meta"> L3 </span>]</span><br><span class="line">                        [<span class="meta"> L4 </span>]</span><br><span class="line">                        [<span class="meta"> L1 </span>]</span><br><span class="line">[<span class="meta"> L2 </span>]</span><br><span class="line">*** DEADLOCK ***</span><br></pre></td></tr></table></figure><ul><li>同一个锁实例在任何两个锁类之间，嵌套获取锁的状态前后需要保持一致，即：</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hardirq-<span class="keyword">safe</span>]   -&gt;  [hardirq-<span class="keyword">unsafe</span>]</span><br><span class="line"></span><br><span class="line">[softirq-<span class="keyword">safe</span>]   -&gt;  [softirq-<span class="keyword">unsafe</span>]</span><br></pre></td></tr></table></figure><p>这意味着，如果同一个锁实例，在某些地方是 hardirq-safe（即采用 spin_lock_irqsave(…)），而在某些地方又是 hardirq-unsafe（即采用 spin_lock(…)），那么就存在死锁的风险。这应该容易理解，比如在进程上下文中持有锁 A，并且锁 A 是 hardirq-unsafe，如果此时触发硬中断，而硬中断处理函数又要去获取锁 A，那么就导致了死锁。后面会有例子分析。</p><p>在锁类状态发生变化时，进行如下几个规则检测，判断是否存在潜在死锁。比较简单，就是判断 hardirq-safe 和 hardirq-unsafe 以 及 softirq-safe 和 softirq-unsafe 是否发生了碰撞，直接引用英文，如下：</p><ul><li>if a new hardirq-safe lock is discovered, we check whether it took any hardirq-unsafe lock in the past.</li><li>if a new softirq-safe lock is discovered, we check whether it took any softirq-unsafe lock in the past.</li><li>if a new hardirq-unsafe lock is discovered, we check whether any hardirq-safe lock took it in the past.</li><li>if a new softirq-unsafe lock is discovered, we check whether any softirq-safe lock took it in the past.</li></ul><p>所以要注意嵌套获取锁前后的状态需要保持一致，避免死锁风险。</p><p><strong>5) 出错处理 </strong></p><p>当检测到死锁风险时，lockdep 会打印下面几种类型的风险提示，更完整的 LOG 会在下面例子中展示。</p><ul><li>[ INFO: possible circular locking dependency detected ] // 圆形锁，获取锁的顺序异常（ABBA）</li><li>[ INFO: %s-safe -&gt; %s-unsafe lock order detected ] // 获取从 safe 的锁类到 unsafe 的锁类的操作</li><li>[ INFO: possible recursive locking detected ] // 重复去获取同类锁（AA）</li><li>[ INFO: inconsistent lock state ]  // 锁的状态前后不一致</li><li>[ INFO: possible irq lock inversion dependency detected ]  // 嵌套获取锁的状态前后需要保持一致，即 [hardirq-safe]   -&gt;  [hardirq-unsafe]，[softirq-safe]   -&gt;  [softirq-unsafe] 会警报死锁风险</li><li>[ INFO: suspicious RCU usage. ] // 可疑的 RCU 用法</li></ul><h3 id="4-使用实例"><a href="#4-使用实例" class="headerlink" title="4. 使用实例"></a>4. 使用实例</h3><p>Lockdep 每次都只检测并 report 第一次出错的地方。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@lib/debug_locks.c</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * We want <span class="keyword">to</span> turn all lock-debugging facilities <span class="keyword">on</span>/off <span class="keyword">at</span> once,</span><br><span class="line"> * via a <span class="keyword">global</span> flag. The reason <span class="keyword">is</span> <span class="keyword">that</span> once a single bug has been</span><br><span class="line"> * detected <span class="keyword">and</span> reported, there might be cascade <span class="keyword">of</span> followup bugs</span><br><span class="line"> * <span class="keyword">that</span> would just muddy <span class="keyword">the</span> <span class="built_in">log</span>. So we report <span class="keyword">the</span> <span class="keyword">first</span> one <span class="keyword">and</span></span><br><span class="line"> * shut up <span class="keyword">after</span> <span class="keyword">that</span>.</span><br><span class="line"> */</span><br><span class="line">int debug_locks = <span class="number">1</span>;</span><br><span class="line">EXPORT_SYMBOL_GPL(debug_locks);</span><br></pre></td></tr></table></figure><p>只报一次死锁风险打印提示就不报了，因为第一个报出来的可能会引发其他的风险提示，就像编译错误一样。并且，这只是一个 warning info, 在实时运行的系统中，LOG 可能一下子就被冲掉了。本着魅族手机对用户体验极致的追求，不允许任何一个死锁风险在开发阶段侥幸存在，我们会把 lockdep warning 转化为 <code>BUG_ON()</code>，使机器在遇到死锁风险就主动重启来引起开发人员的关注，从而不放过每一个可能存在的漏洞。</p><p>下面是实际开发中遇到 lockdep 报的死锁风险 LOG：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]======================================================</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server][ INFO: HARDIRQ-safe -&gt; HARDIRQ-unsafe lock order detected ]</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]<span class="number">3.18</span><span class="number">.22</span>-eng<span class="number">-01315</span>-gea95810-cIb68b198-dirty #<span class="number">2</span> Tainted: G        W</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]------------------------------------------------------</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]system_server/<span class="number">1132</span> [HC0[<span class="number">0</span>]:SC0[<span class="number">0</span>]:HE0:SE1] is trying <span class="keyword">to</span> acquire:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]lockdep: [ffffffc0013a6b18] (resume_reason_lock)&#123;+.+...&#125;</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]lockdep: , at:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]<span class="meta">[&lt;ffffffc00011a2e0&gt;]</span> log_wakeup_reason+<span class="number">0x40</span>/<span class="number">0x17c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]</span><br><span class="line"><span class="keyword">and</span> this task is already holding:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]lockdep: [ffffffc001401440] (__spm_lock)&#123;-.....&#125;</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]lockdep: , at:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]<span class="meta">[&lt;ffffffc000492164&gt;]</span> spm_go_to_sleep+<span class="number">0x200</span>/<span class="number">0x948</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]which would create a <span class="keyword">new</span> lock dependency:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server] (__spm_lock)&#123;-.....&#125; -&gt; (resume_reason_lock)&#123;+.+...&#125;</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]</span><br><span class="line">but this <span class="keyword">new</span> dependency connects a HARDIRQ-irq-safe lock:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server] (__spm_lock)&#123;-.....&#125;</span><br><span class="line">... which became HARDIRQ-irq-safe at:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00010b834&gt;]</span> mark_lock+<span class="number">0x180</span>/<span class="number">0x770</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00010e868&gt;]</span> __lock_acquire+<span class="number">0xaf8</span>/<span class="number">0x243c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000110b08&gt;]</span> lock_acquire+<span class="number">0xe8</span>/<span class="number">0x1a8</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000c73eb4&gt;]</span> _raw_spin_lock_irqsave+<span class="number">0x54</span>/<span class="number">0x84</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00048f880&gt;]</span> spm_irq0_handler+<span class="number">0x2c</span>/<span class="number">0x12c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00011f948&gt;]</span> handle_irq_event_percpu+<span class="number">0xc0</span>/<span class="number">0x338</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00011fc08&gt;]</span> handle_irq_event+<span class="number">0x48</span>/<span class="number">0x78</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000122d68&gt;]</span> handle_fasteoi_irq+<span class="number">0xe0</span>/<span class="number">0x1a4</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00011eee0&gt;]</span> generic_handle_irq+<span class="number">0x30</span>/<span class="number">0x4c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00011effc&gt;]</span> __handle_domain_irq+<span class="number">0x100</span>/<span class="number">0x2a4</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000081568&gt;]</span> gic_handle_irq+<span class="number">0x54</span>/<span class="number">0xe0</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000085290&gt;]</span> el0_irq_naked+<span class="number">0x14</span>/<span class="number">0x24</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]</span><br><span class="line"><span class="keyword">to</span> a HARDIRQ-irq-unsafe lock:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server] (resume_reason_lock)&#123;+.+...&#125;</span><br><span class="line">... which became HARDIRQ-irq-unsafe at:</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]...  <span class="meta">[&lt;ffffffc00010b834&gt;]</span> mark_lock+<span class="number">0x180</span>/<span class="number">0x770</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00010e65c&gt;]</span> __lock_acquire+<span class="number">0x8ec</span>/<span class="number">0x243c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000110b08&gt;]</span> lock_acquire+<span class="number">0xe8</span>/<span class="number">0x1a8</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000c73e48&gt;]</span> _raw_spin_lock+<span class="number">0x38</span>/<span class="number">0x50</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc00011a258&gt;]</span> wakeup_reason_pm_event+<span class="number">0x54</span>/<span class="number">0x9c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0000c4d88&gt;]</span> notifier_call_chain+<span class="number">0x84</span>/<span class="number">0x2d4</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0000c5400&gt;]</span> __blocking_notifier_call_chain+<span class="number">0x40</span>/<span class="number">0x74</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0000c5444&gt;]</span> blocking_notifier_call_chain+<span class="number">0x10</span>/<span class="number">0x1c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000115ed4&gt;]</span> pm_notifier_call_chain+<span class="number">0x1c</span>/<span class="number">0x48</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000117b68&gt;]</span> pm_suspend+<span class="number">0x36c</span>/<span class="number">0x70c</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000115e40&gt;]</span> state_store+<span class="number">0xb0</span>/<span class="number">0xe0</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0003b1f28&gt;]</span> kobj_attr_store+<span class="number">0x10</span>/<span class="number">0x24</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc000266f88&gt;]</span> sysfs_kf_write+<span class="number">0x50</span>/<span class="number">0x64</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0002662c8&gt;]</span> kernfs_fop_write+<span class="number">0x110</span>/<span class="number">0x180</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0001f6570&gt;]</span> vfs_write+<span class="number">0x98</span>/<span class="number">0x1b8</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0001f678c&gt;]</span> SyS_write+<span class="number">0x4c</span>/<span class="number">0xb0</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  <span class="meta">[&lt;ffffffc0000854ac&gt;]</span> el0_svc_naked+<span class="number">0x20</span>/<span class="number">0x28</span></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]</span><br><span class="line">other info that might help us debug this:</span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server] Possible interrupt unsafe locking scenario:</span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]       CPU0                    CPU1</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]       ----                    ----</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  lock(resume_reason_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]                         local_irq_disable();</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]                         lock(__spm_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]                         lock(resume_reason_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  &lt;Interrupt&gt;</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  lock(__spm_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  *** DEADLOCK ***</span><br></pre></td></tr></table></figure><p>从上面的 LOG 信息可以知道：system_server 已经合了一个 HARDIRQ-safe 的锁 __spm_lock， 此时再去拿一个 HARDIRQ-unsafe 的锁 resume_reason_lock，违反了嵌套获取锁前后的状态需要保持一致的规则。</p><p>记得上面说过一条规则吗？</p><blockquote><p>if a new hardirq-unsafe lock is discovered, we check whether any hardirq-safe lock took it in the past.（当要获取一个 hardirq-unsafe lock 时，lockdep 就会检查该进程是否在之前已经获取 hardirq-safe lock）</p></blockquote><p>HARDIRQ-safe 是不允许 irq 的锁，如：spin_lock_irqsave(&amp;lock, flags);</p><p>HARDIRQ-unsafe 是允许 irq 的锁，如：spin_lock(&amp;lock);</p><p>在之前已经使用 spin_lock_irqsave 的方式拿了 __spm_lock， 再以 spin_lock 的方式拿 resume_reason_lock。再来看看可能发生死锁的情景：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server] Possible <span class="built_in">int</span>errupt unsafe locking scenario:</span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]       CPU0                    CPU1</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]       ----                    ----</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  lock(resume_reason_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]                         local_irq_disable();</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]                         lock(__spm_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]                         lock(resume_reason_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  &lt;Interrupt&gt;</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  lock(__spm_lock);</span><br><span class="line">(<span class="number">0</span>)[<span class="number">1132</span>:system_server]  *** DEADLOCK ***</span><br></pre></td></tr></table></figure><p>Lockdep 列出一个可能发生死锁的设想：</p><ul><li>CPU0 先获取了一个 HARDIRQ-unsafe 的锁 lock(resume_reason_lock)，CPU0 本地 irq 是开启的。</li><li>接着 CPU1 再获取了 HARDIRQ-safe 的锁 lock(__spm_lock)，此时 CPU1 本地 irq 是关闭的。</li><li>接着 CPU1 又去获取 lock(resume_reason_lock)，但此时该锁正在被 CPU0 锁持有，CPU1 唯有等待 lock(resume_reason_lock) 释放而无法继续执行。</li><li>假如此时 CPU0 来了一个中断，并且在中断里去获取 lock(__spm_lock)，CPU0 也会因为该锁被 CPU1 持有而未被释放而一直等待无法继续执行。</li><li>CPU0， CPU1 都因为互相等待对方释放锁而不能继续执行，导致 AB-BA 死锁。</li></ul><p>分析到这里，自然知道死锁风险点和正确使用锁的规则了，按照这个规则去修复代码，避免死锁就可以了。解决办法：</p><ol><li>分析 resume_reason_lock 是否在其他地方中断上下文有使用这把锁。</li><li>如果没有，直接把获取这把锁的地方 wakeup_reason_pm_event+0x54/0x9c 从 spin_lock 改成 spin_lock_irqsave 就可以了。保持嵌套获取锁前后的状态一致。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/onestraw/ebook/blob/master/03_operating_system/Operating%20Systems%20-%20Internals%20and%20Design%20Principles%207th.pdf" target="_blank" rel="noopener">《Operating systems : internals and design principles / William Stallings. — 7th ed.》</a></li><li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/locking/lockdep-design.txt" target="_blank" rel="noopener"> 内核文档 lockdep-design.txt</a></li><li><a href="http://www.lenky.info/archives/2013/04/2253" target="_blank" rel="noopener"> 死锁检测模块 lockdep 简介 </a></li><li><a href="http://www.freepatentsonline.com/8145903.html" target="_blank" rel="noopener">Method and system for a kernel lock validator</a></li><li><a href="https://lwn.net/Articles/185666/" target="_blank" rel="noopener">The kernel lock validator</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 调试与稳定性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可靠性 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Tick 和 Tickless</title>
      <link href="/2016/07/19//linux-tick-and-tickless.html/"/>
      <url>/2016/07/19//linux-tick-and-tickless.html/</url>
      
        <content type="html"><![CDATA[<p>Tick，即周期性产生的 timer 中断事件，可用于系统时间管理、进程信息统计、低精度 timer 处理等等。这样就会有一个问题，那就是在系统空闲的时候也还是周期性的产生中断，系统会被周期性的唤醒导致功耗的增加，这对于追求低功耗的嵌入式设备来说是很难接受的。为此，内核开发者提出了动态时钟的概念，即在系统空闲阶段停掉周期性的时钟达到节省功耗的目的。内核可以通过配置项 CONFIG_NO_HZ 及 CONFIG_NO_HZ_IDLE 来打开该功能，这样在系统空闲的时候就可以停掉 tick 一段时间，但并不是完全没有 tick 了，当有除了 idle 进程之外的其它进程运行的时候会恢复 tick 。</p><h2 id="Tick-事件"><a href="#Tick-事件" class="headerlink" title="Tick 事件"></a>Tick 事件</h2><h3 id="clock-event-device"><a href="#clock-event-device" class="headerlink" title="clock_event_device"></a>clock_event_device</h3><p>clock_event_device，代表一个可以产生时钟事件的硬件时钟设备，这样的时钟设备就像单片机的定时器，可以对它编程设置要触发的定时时间，在定时时间到达的时候产生中断，它可以工作在周期模式或者单触发模式。周期模式就是周期性的产生 timer 中断事件，这和 tick 的定义很像。</p><p>clock_event_device 结构定义如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> &#123;</span></span><br><span class="line">/* 回调函数指针，在硬件时钟设备的中断服务程序中调用 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">void(*event_handler)(struct clock_event_device *);</span></span><br><span class="line"><span class="regexp">/</span>* 设置下一个定时时间，以 counter 的 cycle 数值为参数 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">int(*set_next_event)(unsigned long evt,</span></span><br><span class="line"><span class="regexp">  struct clock_event_device *);</span></span><br><span class="line"><span class="regexp">/</span>* 设置下一个定时时间，要设置的定时时间是 ktime 格式，要配合 CLOCK_EVT_FEAT_KTIME 标记使用 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">int(*set_next_ktime)(ktime_t expires,</span></span><br><span class="line"><span class="regexp">  struct clock_event_device *);</span></span><br><span class="line"><span class="regexp">ktime_tnext_event;</span></span><br><span class="line"><span class="regexp">u64max_delta_ns;</span></span><br><span class="line"><span class="regexp">u64min_delta_ns;</span></span><br><span class="line"><span class="regexp">u32mult;</span></span><br><span class="line"><span class="regexp">u32shift;</span></span><br><span class="line"><span class="regexp">enum clock_event_modemode;</span></span><br><span class="line"><span class="regexp">unsigned intfeatures;</span></span><br><span class="line"><span class="regexp">unsigned longretries;</span></span><br><span class="line"><span class="regexp">void(*broadcast)(const struct cpumask *mask);</span></span><br><span class="line"><span class="regexp">void(*set_mode)(enum clock_event_mode mode,</span></span><br><span class="line"><span class="regexp">    struct clock_event_device *);</span></span><br><span class="line"><span class="regexp">void(*suspend)(struct clock_event_device *);</span></span><br><span class="line"><span class="regexp">void(*resume)(struct clock_event_device *);</span></span><br><span class="line"><span class="regexp">unsigned longmin_delta_ticks;</span></span><br><span class="line"><span class="regexp">unsigned longmax_delta_ticks;</span></span><br><span class="line"><span class="regexp">const char*name;</span></span><br><span class="line"><span class="regexp">intrating;</span></span><br><span class="line"><span class="regexp">intirq;</span></span><br><span class="line"><span class="regexp">const struct cpumask*cpumask;</span></span><br><span class="line"><span class="regexp">struct list_headlist;</span></span><br><span class="line"><span class="regexp">struct module*owner;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>SMP 系统，每个 CPU 都有一个只属于自己的 local timer 用于提供时钟事件服务，在 CPU 启动的时候通过调用 percpu_timer_setup 函数完成初始化工作。以三星 exynos7420 平台为例，percpu_timer_setup 函数最终调用 exynos4_local_timer_setup 函数来初始化每个 CPU 的 local timer ，配置和注册 clock_event_device。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t exynos4<span class="constructor">_mct_tick_isr(<span class="params">int</span> <span class="params">irq</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">dev_id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> mct_clock_event_device *mevt = dev_id;</span><br><span class="line"><span class="keyword">struct</span> clock_event_device *evt = mevt-&gt;evt;</span><br><span class="line">exynos4<span class="constructor">_mct_tick_stop(<span class="params">mevt</span>, 0)</span>;</span><br><span class="line"><span class="comment">/* 调用 clock_event_device 的 event_handler */</span></span><br><span class="line">evt-&gt;event<span class="constructor">_handler(<span class="params">evt</span>)</span>;</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="constructor">DEFINE_PER_CPU(<span class="params">struct</span> <span class="params">irqaction</span>, <span class="params">percpu_mct_irq</span>)</span> = &#123;</span><br><span class="line">.flags          = IRQF_TIMER <span class="pattern-match">| <span class="constructor">IRQF_NOBALANCING</span>,</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> 中断处理程序 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">.handler        = exynos4<span class="constructor">_mct_tick_isr</span>,</span></span><br><span class="line"><span class="pattern-match">&#125;;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">static <span class="built_in">int</span> exynos4<span class="constructor">_local_timer_setup(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">evt</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">struct</span> mct<span class="constructor">_clock_event_device</span> <span class="operator">*</span>mevt;</span></span><br><span class="line"><span class="pattern-match">unsigned <span class="built_in">int</span> cpu = smp<span class="constructor">_processor_id()</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">mevt = this<span class="constructor">_cpu_ptr(&amp;<span class="params">percpu_mct_tick</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">mevt-&gt;evt = evt;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">mevt-&gt;base = <span class="constructor">EXYNOS4_MCT_L_BASE(<span class="params">cpu</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> 每个 <span class="constructor">CPU</span> local timer 的名字分别为 mct<span class="constructor">_tick0</span>, mct<span class="constructor">_tick1</span> <span class="operator">...</span> mct<span class="constructor">_tick7</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">snprintf(mevt-&gt;name, sizeof(mevt-&gt;name), "mct<span class="constructor">_tick</span>%d", cpu);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">evt-&gt;name = mevt-&gt;name;</span></span><br><span class="line"><span class="pattern-match">evt-&gt;cpumask = cpumask<span class="constructor">_of(<span class="params">cpu</span>)</span>;  <span class="operator">/</span><span class="operator">*</span> 属于哪个 <span class="constructor">CPU</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> 设置下次触发的时间，即把时间编程到定时器 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">evt-&gt;set<span class="constructor">_next_event</span> = exynos4<span class="constructor">_tick_set_next_event</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> 设置工作模式，例如周期模式，单触发模式等 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">evt-&gt;set<span class="constructor">_mode</span> = exynos4<span class="constructor">_tick_set_mode</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> 支持周期模式和单触发模式 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">evt-&gt;features = <span class="constructor">CLOCK_EVT_FEAT_PERIODIC</span> | <span class="constructor">CLOCK_EVT_FEAT_ONESHOT</span>;</span></span><br><span class="line"><span class="pattern-match">evt-&gt;rating = 450;</span></span><br><span class="line"><span class="pattern-match">tick<span class="constructor">_base_cnt</span> = 0;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (!soc<span class="constructor">_is_exynos5433()</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">tick<span class="constructor">_base_cnt</span> = 1;</span></span><br><span class="line"><span class="pattern-match">exynos4<span class="constructor">_mct_write(<span class="params">tick_base_cnt</span>, <span class="params">mevt</span>-&gt;<span class="params">base</span> + MCT_L_TCNTB_OFFSET)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> exynos7420 每个 <span class="constructor">CPU</span> 的 local timer 都是使用的 <span class="constructor">SPI</span> 类型中断 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (mct<span class="constructor">_int_type</span> <span class="operator">==</span> <span class="constructor">MCT_INT_SPI</span>) &#123;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">struct</span> irqaction <span class="operator">*</span>mct<span class="constructor">_irq</span> = this<span class="constructor">_cpu_ptr(&amp;<span class="params">percpu_mct_irq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">mct<span class="constructor">_irq</span>-&gt;dev<span class="constructor">_id</span> = mevt;</span></span><br><span class="line"><span class="pattern-match">evt-&gt;irq = mct<span class="constructor">_irqs</span>[<span class="constructor">MCT_L0_IRQ</span> + cpu];</span></span><br><span class="line"><span class="pattern-match">irq<span class="constructor">_set_affinity(<span class="params">evt</span>-&gt;<span class="params">irq</span>, <span class="params">cpumask_of</span>(<span class="params">cpu</span>)</span>);</span></span><br><span class="line"><span class="pattern-match">enable<span class="constructor">_irq(<span class="params">evt</span>-&gt;<span class="params">irq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">enable<span class="constructor">_percpu_irq(<span class="params">mct_irqs</span>[MCT_L0_IRQ], 0)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">*</span> 配置和注册 clock<span class="constructor">_event_device</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">clockevents<span class="constructor">_config_and_register(<span class="params">evt</span>, <span class="params">clk_rate</span> <span class="operator">/</span> (<span class="params">tick_base_cnt</span> + 1)</span>,</span></span><br><span class="line"><span class="pattern-match">0xf, 0x7fffffff);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">return 0;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>Exynos7420 平台 local timer 使用的是 SPI 类型的中断，它可以直接唤醒 idle 状态的 CPU，这样就不需要使用 broadcast framework 了。MTK 平台 CPU 的 local timer 一般使用 PPI 中断，它不具有唤醒处于 idle 状态的 CPU 的能力，所以需要一个 global HW timer 作为 broadcast tick，由它来服务每个 CPU，例如将 tick 事件广播到 CPU，唤醒 CPU 等等。</p><h3 id="tick-device"><a href="#tick-device" class="headerlink" title="tick_device"></a>tick_device</h3><p>tick_device，tick 设备，是对 clock_event_device 及其工作模式的封装：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">evtdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tick_device_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tick_device_mode 只有两种模式，TICKDEV_MODE_PERIODIC 和 TICKDEV_MODE_ONESHOT，即周期模式和单触发模式。在 clock_event_device 注册的时候，tick_device 通过 tick_check_new_device 和 tick_setup_device 函数绑定一个属于该 CPU 且精度最高的 clock_event_device。这样，tick_device 工作在 TICKDEV_MODE_PERIODIC 模式时可以产生周期性的时钟事件，传统意义上的 tick 就是这么来的。周期模式下，clock_event_device 的 event_handler 被设置为 tick_periodic ，每个 tick 事件到来时 tick_periodic 就会被调用，它会通过 update_process_times 函数进行系统时间的更新、到期 hrtimer 的处理、TIMER_SOFTIRQ 软中断处理、进程信息更新及负载均衡等等。</p><h2 id="模拟-tick-事件"><a href="#模拟-tick-事件" class="headerlink" title="模拟 tick 事件"></a>模拟 tick 事件</h2><h3 id="低分辨率定时器"><a href="#低分辨率定时器" class="headerlink" title="低分辨率定时器"></a>低分辨率定时器</h3><p>低分辨率定时器是基于 HZ 来实现的，精度为 1/HZ，内核 HZ 一般配置为 100，那么低分辨率定时器的精度就是 10ms。对定时器精度要求不高的内核模块还在大量使用低分辨率定时器，例如 CPU DVFS，CPU Hotplug 等。内核通过 time_list  结构体来描述低分辨率定时器。</p><h3 id="高精度定时器"><a href="#高精度定时器" class="headerlink" title="高精度定时器"></a>高精度定时器</h3><p>高精度定时器可以提供纳秒级别的定时精度，以满足对时间精度要求严格的内核模块，例如音频模块，内核通过 hrtimer 结构体来描述高精度定时器。在系统启动的开始阶段，高精度定时器只能工作在低精度周期模式，在条件满足之后的某个阶段就会切换到高精度单触发模式。上面所说的 tick_periodic 函数，最后会调用 hrtimer_run_pending 函数来判断是否可以切换到高精度模式。另外，动态时钟也是在这里判断和切换的。流程如下：</p><p>tick_periodic -&gt; update_process_times -&gt; run_local_timers -&gt; raise_softirq(TIMER_SOFTIRQ) == run_timer_softirq -&gt; hrtimer_run_pending</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer<span class="constructor">_run_pending(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果 hrtimer 已经是高精度模式则返回 */</span></span><br><span class="line"><span class="keyword">if</span> (hrtimer<span class="constructor">_hres_active()</span>)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tick<span class="constructor">_check_oneshot_change(!<span class="params">hrtimer_is_hres_enabled</span>()</span>))</span><br><span class="line">hrtimer<span class="constructor">_switch_to_hres()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> tick<span class="constructor">_init_highres(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return tick<span class="constructor">_switch_to_oneshot(<span class="params">hrtimer_interrupt</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> hrtimer<span class="constructor">_switch_to_hres(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i, cpu = smp<span class="constructor">_processor_id()</span>;</span><br><span class="line"><span class="keyword">struct</span> hrtimer_cpu_base *base = &amp;per<span class="constructor">_cpu(<span class="params">hrtimer_bases</span>, <span class="params">cpu</span>)</span>;</span><br><span class="line">unsigned long flags;</span><br><span class="line"><span class="comment">/* 如果已经是高精度模式了，则返回 */</span></span><br><span class="line"><span class="keyword">if</span> (base-&gt;hres_active)</span><br><span class="line">return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">local<span class="constructor">_irq_save(<span class="params">flags</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tick<span class="constructor">_init_highres()</span>) &#123;</span><br><span class="line">local<span class="constructor">_irq_restore(<span class="params">flags</span>)</span>;</span><br><span class="line">printk(KERN_WARNING <span class="string">"Could not switch to high resolution "</span></span><br><span class="line">    <span class="string">"mode on CPU %d\n"</span>, cpu);</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 表示工作在高精度模式了 */</span></span><br><span class="line">base-&gt;hres_active = <span class="number">1</span>;</span><br><span class="line">for (i = <span class="number">0</span>; i &lt; HRTIMER_MAX_CLOCK_BASES; i++)</span><br><span class="line">base-&gt;clock_base<span class="literal">[<span class="identifier">i</span>]</span>.resolution = KTIME_HIGH_RES;</span><br><span class="line"><span class="comment">/* 创建一个 hrtimer 来模拟 tick，初始化这个 hrtimer */</span></span><br><span class="line">tick<span class="constructor">_setup_sched_timer()</span>;</span><br><span class="line"><span class="comment">/* "Retrigger" the interrupt to get things going */</span></span><br><span class="line">retrigger<span class="constructor">_next_event(NULL)</span>;</span><br><span class="line">local<span class="constructor">_irq_restore(<span class="params">flags</span>)</span>;</span><br><span class="line">return <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，通过 hrtimer_switch_to_hres 完成低精度周期模式到高精度单触发模式的切换。tick_device 的工作模式变成了 TICKDEV_MODE_ONESHOT，其 clock_event_device 的 event_handler 被替换为 hrtimer_interrupt。至此，tick_device 不能再定期产生 tick 事件了，但是系统还离不开 tick 事件，所以内核通过一个 hrtimer 模拟了 tick，这个是在 tick_setup_sched_timer 函数中完成的。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void tick_setup_sched_timer(void)</span><br><span class="line">&#123;</span><br><span class="line">struct tick_sched *ts = &amp;__get_cpu_var(tick_cpu_sched);</span><br><span class="line">ktime_t now = ktime_get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Emulate tick processing via per-CPU hrtimers:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 初始化用作模拟 tick 的 hrtimer */</span></span><br><span class="line"><span class="function"><span class="title">hrtimer_init</span>(&amp;ts-&gt;</span>sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);</span><br><span class="line"><span class="comment">/* 设置该 hrtimer 的回调函数 */</span></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>sched_timer.function = tick_sched_timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the next period (per cpu) */</span></span><br><span class="line"><span class="function"><span class="title">hrtimer_set_expires</span>(&amp;ts-&gt;</span>sched_timer, tick_init_jiffy_update());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="comment">/* tick_period 就是一个 tick 周期，HZ 为 100 的话就是 10ms */</span></span><br><span class="line"><span class="function"><span class="title">hrtimer_forward</span>(&amp;ts-&gt;</span>sched_timer, now, tick_period);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动 hrtimer，加入 hrtimer 红黑树，如果这个 hrtimer 的到期时间是最近的，*/</span></span><br><span class="line">                <span class="comment">/* 还会把它编程到硬件时钟设备，即 clock_event_device */</span></span><br><span class="line"><span class="function"><span class="title">hrtimer_start_expires</span>(&amp;ts-&gt;</span>sched_timer,</span><br><span class="line">      HRTIMER_MODE_ABS_PINNED);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check, if the timer was already in the past */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (hrtimer_active(&amp;ts-&gt;</span>sched_timer))</span><br><span class="line">break;</span><br><span class="line">now = ktime_get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_COMMON</span><br><span class="line"><span class="keyword">if</span> (tick_nohz_enabled)</span><br><span class="line"><span class="comment">/* NO_HZ 的工作模式，表明是使用的 hrtimer 实现 NO_HZ */</span></span><br><span class="line"><span class="function"><span class="title">ts</span>-&gt;</span>nohz_mode = NOHZ_MODE_HIGHRES;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，sched_timer 就是模拟 tick 使用的 hrtimer，在其回调函数 tick_sched_timer 中会设置下次触发时间为 tick_period，这样就可以定期产生 tick 事件了。另外，还会通过 tick_sched_handle 函数调用 update_process_times 函数，相信很多人对 u pdate_process_times 很眼熟，前面说的系统时间的更新、到期 hrtimer 的处理、TIMER_SOFTIRQ 软中断处理、进程信息更新及负载均衡等等就是由它完成的。所以说利用 hrtimer 很完美的模拟了 tick 。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static enum hrtimer_restart tick<span class="constructor">_sched_timer(<span class="params">struct</span> <span class="params">hrtimer</span> <span class="operator">*</span><span class="params">timer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> tick_sched *ts =</span><br><span class="line">container<span class="constructor">_of(<span class="params">timer</span>, <span class="params">struct</span> <span class="params">tick_sched</span>, <span class="params">sched_timer</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> pt_regs *regs = get<span class="constructor">_irq_regs()</span>;</span><br><span class="line">ktime_t now = ktime<span class="constructor">_get()</span>;</span><br><span class="line"></span><br><span class="line">tick<span class="constructor">_sched_do_timer(<span class="params">now</span>)</span>;   <span class="comment">/* 更新时间 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not call, when we are not in irq context and have</span></span><br><span class="line"><span class="comment"> * no valid regs pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (regs)</span><br><span class="line"><span class="comment">/* tick_sched_handle 会调用 update_process_times 函数 */</span></span><br><span class="line">tick<span class="constructor">_sched_handle(<span class="params">ts</span>, <span class="params">regs</span>)</span>;</span><br><span class="line"><span class="comment">/* 设置下次触发时间为 tick_period */</span></span><br><span class="line">hrtimer<span class="constructor">_forward(<span class="params">timer</span>, <span class="params">now</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line"></span><br><span class="line">return HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tickless"><a href="#tickless" class="headerlink" title="tickless"></a>tickless</h2><p>tickless，即上面所说的动态时钟，之所以被称为 tickless，估计是为了更好的和 tick 联系起来。另外，并不是真的没有 tick 了，只是在系统空闲的时候停掉 tick 一段时间。使能了动态时钟之后，周期时钟的开关就由 idle 进程控制，当满足条件时就可以停掉 tick 若干时间，这个流程如下：</p><p>cpu_idle_loop -&gt; tick_nohz_idle_enter -&gt; __tick_nohz_idle_enter -&gt; tick_nohz_stop_sched_tick</p><p>最后，通过 tick_nohz_stop_sched_tick 停止掉若干 tick。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void cpu<span class="constructor">_idle_loop(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 开始进入 NO_HZ idle */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!need<span class="constructor">_resched()</span>) &#123;</span><br><span class="line">check<span class="constructor">_pgt_cache()</span>;</span><br><span class="line">rmb<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu<span class="constructor">_is_offline(<span class="params">smp_processor_id</span>()</span>))</span><br><span class="line">arch<span class="constructor">_cpu_idle_dead()</span>;</span><br><span class="line"></span><br><span class="line">local<span class="constructor">_irq_disable()</span>;</span><br><span class="line">arch<span class="constructor">_cpu_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu_idle_force_poll<span class="operator"> || </span>tick<span class="constructor">_check_broadcast_expired()</span>) &#123;</span><br><span class="line">cpu<span class="constructor">_idle_poll()</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!current<span class="constructor">_clr_polling_and_test()</span>) &#123;</span><br><span class="line">stop<span class="constructor">_critical_timings()</span>;</span><br><span class="line">rcu<span class="constructor">_idle_enter()</span>;</span><br><span class="line">arch<span class="constructor">_cpu_idle()</span>;</span><br><span class="line"><span class="constructor">WARN_ON_ONCE(<span class="params">irqs_disabled</span>()</span>);</span><br><span class="line">rcu<span class="constructor">_idle_exit()</span>;</span><br><span class="line">start<span class="constructor">_critical_timings()</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">local<span class="constructor">_irq_enable()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">__current_set_polling()</span>;</span><br><span class="line">&#125;</span><br><span class="line">arch<span class="constructor">_cpu_idle_exit()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 有其它进程运行，退出 NO_HZ，恢复之前的周期时钟 */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_exit()</span>;</span><br><span class="line">schedule<span class="constructor">_preempt_disabled()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停掉 tick 若干时间，那么这个若干时间是怎么得来的呢？系统此时处于空闲状态只有 idle 进程在运行，还要处理可能产生的中断，但是无法获知除了定时器中断以外的其它中断何时产生，而定时器第一个即将到期的中断时间是可以得到的，在这个时间到期之前都可以停掉 tick，由此得到需要停掉的 tick 数。另外，停掉 tick 的时间不能超过 clock_event_device 的 max_delta_ns，不然可能会造成 clocksource 的溢出。</p><p>回顾一下 tick 事件产生时的工作流程。首先是中断处理函数 exynos4_mct_tick_isr 被运行，它会调用 clock_event_device 的 event_handler，即 hrtimer_interrupt，hrtimer_interrupt 会调用 __run_hrtimer 处理到期的 hrtimer， tick_sched_timer 这个 hrtimer 的回调函数 tick_sched_timer 被调用，tick_sched_timer 会把下次唤醒时间设置为 tick_period，相当于恢复了周期时钟。如果没有别的进程需要运行，恢复周期时钟的做法显然是不合理的，我们需要的是在第一个定时时间到来之前停止若干 tick。 通过前面的内容可以了解到 tick 产生时会触发 TIMER_SOFTIRQ 软中断，所以内核在软中断的 irq_exit 函数中做了些手脚，解决了刚才所说的周期时钟恢复的问题，流程如下：</p><p>irq_exit -&gt; tick_irq_exit -&gt; tick_nohz_irq_exit -&gt; __tick_nohz_idle_enter -&gt; tick_nohz_stop_sched_tick</p><p>看到了熟悉的身影 tick_nohz_stop_sched_tick，通过它又可以停掉若干的 tick。</p><p>tick_irq_exit  函数如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick<span class="constructor">_irq_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_NO_HZ_COMMON</span><br><span class="line"><span class="built_in">int</span> cpu = smp<span class="constructor">_processor_id()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure that timer wheel updates are propagated */</span></span><br><span class="line"><span class="keyword">if</span> ((idle<span class="constructor">_cpu(<span class="params">cpu</span>)</span><span class="operator"> &amp;&amp; </span>!need<span class="constructor">_resched()</span>)<span class="operator"> || </span>tick<span class="constructor">_nohz_full_cpu(<span class="params">cpu</span>)</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">in</span><span class="constructor">_interrupt()</span>)</span><br><span class="line">tick<span class="constructor">_nohz_irq_exit()</span>;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有别的进程需要运行，<code>need_resched()</code> 就会为 1，就不能进入 tick_nohz_irq_exit 函数，也就无法停掉若干 tick，下次唤醒的时间就还是一个 tick_period。</p><p>没有使能 tickless，tick 周期性产生，如下图所示：</p><p><img src="tick.jpg" alt="Tick"></p><p>配置了 tickless，tick 会被停掉若干时间，变得没有规律，如下图所示：</p><p><img src="tickless.jpg" alt="Tickless"></p>]]></content>
      
      
      <categories>
          
          <category> 时间管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Thermal 框架解析 </title>
      <link href="/2016/07/15//linux-thermal-framework-intro.html/"/>
      <url>/2016/07/15//linux-thermal-framework-intro.html/</url>
      
        <content type="html"><![CDATA[<p>Linux Thermal 是 Linux 系统下温度控制相关的模块，主要用来控制系统运行过程中芯片产生的热量，使芯片温度和设备外壳温度维持在一个安全、舒适的范围。</p><p>那下面我们就来一起看看对于温度控制这样一个需求，Linux 内核是怎么实现的。</p><h2 id="Thermal-的主要框架"><a href="#Thermal-的主要框架" class="headerlink" title="Thermal 的主要框架"></a>Thermal 的主要框架</h2><p>要实现一个温度控制的需求，试想一下我们是不是最少要有获取温度的设备和控制温度的设备这两个最基本的东西？当然附带的也会产生一些使用温度控制设备的策略。</p><p>那上面这些东西在 Linux Thermal 框架中怎么体现呢？通过阅读源码我们发现代码中对上面的东西进行了一些抽象。</p><ul><li>获取温度的设备：在 Thermal 框架中被抽象为 Thermal Zone Device;</li><li>控制温度的设备：在 Thermal 框架中被抽象为 Thermal Cooling Device;</li><li>控制温度策略：在 Thermal 框架中被抽象为 Thermal Governor;</li></ul><p><img src="thermal.png" alt="Thermal 框架 "></p><h2 id="Thermal-Zone-Device"><a href="#Thermal-Zone-Device" class="headerlink" title="Thermal Zone Device"></a>Thermal Zone Device</h2><p>上面说到 Thermal Zone Device 是获取温度设备的抽象，怎么抽象的？终究我们还是要 RTFSC。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span> &#123;</span></span><br><span class="line">        int id;</span><br><span class="line">        char <span class="keyword">type</span>[THERMAL_NAME_LENGTH];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">device</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thermal_attr</span> *<span class="title">trip_temp_attrs</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thermal_attr</span> *<span class="title">trip_type_attrs</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thermal_attr</span> *<span class="title">trip_hyst_attrs</span>;</span></span><br><span class="line">        void *devdata;</span><br><span class="line">        int trips;</span><br><span class="line">/* 轮询时间 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        int passive_delay;</span></span><br><span class="line"><span class="regexp">        int polling_delay;</span></span><br><span class="line"><span class="regexp">        int temperature;</span></span><br><span class="line"><span class="regexp">        int last_temperature;</span></span><br><span class="line"><span class="regexp">        int emul_temperature;</span></span><br><span class="line"><span class="regexp">        int passive;</span></span><br><span class="line"><span class="regexp">        unsigned int forced_passive;</span></span><br><span class="line"><span class="regexp">/</span>* 设备的操作函数 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        struct thermal_zone_device_ops *ops;</span></span><br><span class="line"><span class="regexp">        const struct thermal_zone_params *tzp;</span></span><br><span class="line"><span class="regexp">        struct thermal_governor *governor;</span></span><br><span class="line"><span class="regexp">        struct list_head thermal_instances;</span></span><br><span class="line"><span class="regexp">        struct idr idr;</span></span><br><span class="line"><span class="regexp">        struct mutex lock;</span></span><br><span class="line"><span class="regexp">        struct list_head node;</span></span><br><span class="line"><span class="regexp">/</span>* 用来循环处理的 delayed_work *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        struct delayed_work poll_queue;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">struct thermal_zone_device_ops &#123;</span></span><br><span class="line"><span class="regexp">/</span>* 绑定函数 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        int (*bind) (struct thermal_zone_device *,</span></span><br><span class="line"><span class="regexp">                     struct thermal_cooling_device *);</span></span><br><span class="line"><span class="regexp">        int (*unbind) (struct thermal_zone_device *,</span></span><br><span class="line"><span class="regexp">                       struct thermal_cooling_device *);</span></span><br><span class="line"><span class="regexp">/</span>* 获取温度函数 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        int (*get_temp) (struct thermal_zone_device *, unsigned long *);</span></span><br><span class="line"><span class="regexp">        int (*get_mode) (struct thermal_zone_device *,</span></span><br><span class="line"><span class="regexp">                         enum thermal_device_mode *);</span></span><br><span class="line"><span class="regexp">        int (*set_mode) (struct thermal_zone_device *,</span></span><br><span class="line"><span class="regexp">                enum thermal_device_mode);</span></span><br><span class="line"><span class="regexp">        int (*get_trip_type) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                enum thermal_trip_type *);</span></span><br><span class="line"><span class="regexp">/</span>* 获取触发点温度 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        int (*get_trip_temp) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                              unsigned long *);</span></span><br><span class="line"><span class="regexp">        int (*set_trip_temp) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                              unsigned long);</span></span><br><span class="line"><span class="regexp">        int (*get_trip_hyst) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                              unsigned long *);</span></span><br><span class="line"><span class="regexp">        int (*set_trip_hyst) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                              unsigned long);</span></span><br><span class="line"><span class="regexp">        int (*get_crit_temp) (struct thermal_zone_device *, unsigned long *);</span></span><br><span class="line"><span class="regexp">        int (*set_emul_temp) (struct thermal_zone_device *, unsigned long);</span></span><br><span class="line"><span class="regexp">        int (*get_trend) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                          enum thermal_trend *);</span></span><br><span class="line"><span class="regexp">        int (*notify) (struct thermal_zone_device *, int,</span></span><br><span class="line"><span class="regexp">                       enum thermal_trip_type);</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>通过代码我们可以看到，一个能提供温度的设备操作函数主要有 : 绑定函数、获取温度函数、获取触发点温度函数。</p><p>绑定函数 : Thermal core 用来绑定用的 , 这个后面会讲 ;</p><p>获取温度函数 : 获取设备温度用的，这个也好理解 , 一般 SOC 内部会有温度传感器提供温度，有些热敏电阻通过 ADC 也算出温度，这个函数就是取这些温度值 ;</p><p>获取触发点温度函数 : 这个是什么用来做什么呢 ?　这个其实是 thermal 框架里面一个关键点，因为要控制温度，那么什么时候控制就需要有东西来描述，</p><p>描述什么时候控制的东西就是触发点，每个 thermal zone device 会定义很多触发点，那么每个触发点的温度就是通过该函数获得；</p><h2 id="Thermal-Cooling-Devices"><a href="#Thermal-Cooling-Devices" class="headerlink" title="Thermal Cooling Devices"></a>Thermal Cooling Devices</h2><p>Thermal Cooling Device 是可以降温设备的抽象，能降温的设备比如风扇，这些好理解，但是想 CPU,GPU 这些 Cooling devices 怎么理解呢？</p><p>其实降温可以从两方面来理解，一个是加快散热，另外一个就是降低产热量。风扇，散热片这些是用来加快散热，CPU,GPU 这些 Cooling devices 是通过降低产热来降温。</p><p>那代码是怎么将这两个方式统一起来呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> type[THERMAL_NAME_LENGTH];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">device</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">        <span class="keyword">void</span> *devdata;</span><br><span class="line"><span class="comment">/* cooling device 操作函数 */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">        <span class="keyword">bool</span> updated; <span class="comment">/* true if the cooling device does not need update */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* protect thermal_instances list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thermal_instances</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_cooling_device_ops</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> (*get_max_state) (struct thermal_cooling_device *, <span class="keyword">unsigned</span> <span class="keyword">long</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*get_cur_state) (struct thermal_cooling_device *, <span class="keyword">unsigned</span> <span class="keyword">long</span> *);</span><br><span class="line"><span class="comment">/* 设定等级 */</span></span><br><span class="line">        <span class="keyword">int</span> (*set_cur_state) (struct thermal_cooling_device *, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Thermal Cooling device 抽象的方式是，认为所有的能降温的设备有很多可以单独控制的状态。例如，风扇有不同的风速状态，</p><p>CPU/GPU Cooling device 有不同最大运行频率状态，这样当温度高了之后通过调整这些状态来降低温度；</p><h2 id="Thermal-Governor"><a href="#Thermal-Governor" class="headerlink" title="Thermal Governor"></a>Thermal Governor</h2><p>Thermal Governor 是降温策略的一个抽象 , 主要是根据温度来选择 thermal cooling devices 等级的方法，举个简单的例子，当前的温度升高速很快，选择风扇３档风，温度升高不快，选择１档风。这就是一个 Governor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct thermal_governor - structure that holds thermal governor information</span></span><br><span class="line"><span class="comment"> * @name:       name of the governor</span></span><br><span class="line"><span class="comment"> * @throttle:   callback called for every trip point even if temperature is</span></span><br><span class="line"><span class="comment"> *              below the trip point temperature</span></span><br><span class="line"><span class="comment"> * @governor_list:      node in thermal_governor_list (in thermal_core.c)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thermal_governor</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[THERMAL_NAME_LENGTH];</span><br><span class="line"><span class="comment">/* 策略函数 */</span></span><br><span class="line">        <span class="keyword">int</span> (*throttle)(struct thermal_zone_device *tz, <span class="keyword">int</span> trip);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">governor_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很简单，所有的策略都通过 throttle 这个函数实现，内核已经实现了一些策略，step_wise, user_space, power_allocator, bang_bang 等具体实现算法细节就不展开；</p><h2 id="Thermal-Core"><a href="#Thermal-Core" class="headerlink" title="Thermal Core"></a>Thermal Core</h2><p>有了获取温度的设备，有了温控控制的设备，有了控制方法，Thermal Core 就负责把这些整合在一起。下面看一下整合的简单流程。</p><p>１．注册函数 ,thermal Core 通过对外提供注册的接口，让 thermal zone device、thermal cooling device、thermal governor 注册进来。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thermal_zone_device *thermal_zone_device_register(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>,</span><br><span class="line">                <span class="keyword">void</span> *, <span class="keyword">struct</span> thermal_zone_device_ops *,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> thermal_zone_params *, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> thermal_cooling_device *thermal_cooling_device_register(<span class="keyword">char</span> *, <span class="keyword">void</span> *,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> thermal_cooling_device_ops *);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thermal_register_governor</span>(<span class="params"><span class="keyword">struct</span> thermal_governor *</span>)</span>;</span><br></pre></td></tr></table></figure><p>２．Thermal zone/cooling device 注册的过程中 thermal core 会调用绑定函数，绑定的过程最主要是一个 cooling device 绑定到一个 thremal_zone 的触发点上</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> thermal<span class="constructor">_zone_bind_cooling_device(<span class="params">struct</span> <span class="params">thermal_zone_device</span> <span class="operator">*</span><span class="params">tz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">struct</span> thermal_instance *dev;</span><br><span class="line">        <span class="keyword">struct</span> thermal_instance *pos;</span><br><span class="line">        <span class="keyword">struct</span> thermal_zone_device *pos1;</span><br><span class="line">        <span class="keyword">struct</span> thermal_cooling_device *pos2;</span><br><span class="line">        unsigned long max_state;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* thermal_instace 就是绑定之后的实例 */</span></span><br><span class="line">        dev =</span><br><span class="line">            kzalloc(sizeof(<span class="keyword">struct</span> thermal_instance), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!dev)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line">        dev-&gt;tz = tz;</span><br><span class="line">        dev-&gt;cdev = cdev;</span><br><span class="line">        dev-&gt;trip = trip;</span><br><span class="line">    dev-&gt;upper = upper;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            sysfs<span class="constructor">_create_link(&amp;<span class="params">tz</span>-&gt;<span class="params">device</span>.<span class="params">kobj</span>, &amp;<span class="params">cdev</span>-&gt;<span class="params">device</span>.<span class="params">kobj</span>, <span class="params">dev</span>-&gt;<span class="params">name</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">                goto release_idr;</span><br><span class="line"></span><br><span class="line">        sprintf(dev-&gt;attr_name, <span class="string">"cdev%d_trip_point"</span>, dev-&gt;id);</span><br><span class="line">        sysfs<span class="constructor">_attr_init(&amp;<span class="params">dev</span>-&gt;<span class="params">attr</span>.<span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span><span class="constructor">_for_each_entry(<span class="params">pos</span>, &amp;<span class="params">tz</span>-&gt;<span class="params">thermal_instances</span>, <span class="params">tz_node</span>)</span></span><br><span class="line">            <span class="keyword">if</span> (pos-&gt;tz<span class="operator"> == </span>tz<span class="operator"> &amp;&amp; </span>pos-&gt;trip<span class="operator"> == </span>trip<span class="operator"> &amp;&amp; </span>pos-&gt;cdev<span class="operator"> == </span>cdev) &#123;</span><br><span class="line">                result = -EEXIST;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line"><span class="comment">/* 绑定完了就添加到链表中 */</span></span><br><span class="line">                <span class="built_in">list</span><span class="constructor">_add_tail(&amp;<span class="params">dev</span>-&gt;<span class="params">tz_node</span>, &amp;<span class="params">tz</span>-&gt;<span class="params">thermal_instances</span>)</span>;</span><br><span class="line">                <span class="built_in">list</span><span class="constructor">_add_tail(&amp;<span class="params">dev</span>-&gt;<span class="params">cdev_node</span>, &amp;<span class="params">cdev</span>-&gt;<span class="params">thermal_instances</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>３．Thermal core 使能 delayed_work 循环处理 , 使整个 thermal 控制流程运转起来。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void thermal_zone_device_check(<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span></span> *wrok)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span></span> *tz = container_of(work, <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                                                      <span class="title">thermal_zone_device</span></span>,</span><br><span class="line">                                                      poll_queue.work);</span><br><span class="line"><span class="comment">/* 处理函数 */</span></span><br><span class="line">        thermal_zone_device_update(tz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thermal_zone_device_update(<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span></span> *tz)</span><br><span class="line">&#123;</span><br><span class="line">        int count;</span><br><span class="line">        <span class="keyword">if</span> (!tz-&gt;ops-&gt;get_temp)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* 更新温度 */</span></span><br><span class="line">        update_temperature(tz);-</span><br><span class="line">        <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; tz-&gt;trips; count++)</span><br><span class="line"><span class="comment">/* 处理触发点，这里面就会调到具体的 governor */</span></span><br><span class="line">                handle_thermal_trip(tz, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void thermal_zone_device_set_polling(<span class="class"><span class="keyword">struct</span> <span class="title">thermal_zone_device</span></span> *tz, int delay)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">1000</span>)</span><br><span class="line"><span class="comment">/* 更改 delayed_work 下次唤醒时间完成轮询 */</span></span><br><span class="line">                mod_delayed_work(system_freezable_wq, &amp;tz-&gt;poll_queue,</span><br><span class="line">                                 round_jiffies(msecs_to_jiffies(delay)));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (delay)</span><br><span class="line">                mod_delayed_work(system_freezable_wq, &amp;tz-&gt;poll_queue,</span><br><span class="line">                                 msecs_to_jiffies(delay));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                cancel_delayed_work(&amp;tz-&gt;poll_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="thermal_control_flow.png" alt="Thermal 控制流程 "></p><p>当温度升高超过温度触发点的话，就会使能对应的 cooling device 进行降温处理，至此 Linux Thermal 相关的一些基本框架就介绍完了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://lxr.free-electrons.com/source/drivers/thermal/" target="_blank" rel="noopener">Thermal 内核源码 </a></p>]]></content>
      
      
      <categories>
          
          <category> 温升与功耗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thermal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程中 Stop, Park, Freeze</title>
      <link href="/2016/07/10//linux-process-stop.html/"/>
      <url>/2016/07/10//linux-process-stop.html/</url>
      
        <content type="html"><![CDATA[<p>在调试内核的时候，经常会碰到几个相近的概念：进程 stop、进程 park、进程 freeze。这几个名词看起来都是停止进程，那么他们之间的区别和应用场景在分别是什么呢？下面就来分析一番。</p><blockquote><p>本文的代码分析基于 Linux kernel 3.18.22，最好的学习方法还是 “RTFSC”</p></blockquote><h2 id="1-进程-stop"><a href="#1-进程-stop" class="headerlink" title="1. 进程 stop"></a>1. 进程 stop</h2><p>进程 stop 分成两种：用户进程 stop 和内核进程 stop。</p><p>用户进程 stop 可以通过给进程发送 STOP 信号来实现，可以参考“Linux Signal”这一篇的描述。但是对内核进程来说不会响应信号，如果碰到需要 stop 内核进程的场景怎么处理？比如：我们在设备打开的时候创建了内核处理进程，在设备关闭的时候需要 stop 内核进程。</p><p>Linux 实现了一套 <code>kthread_stop()</code> 的机制来实现内核进程 stop。</p><h3 id="1-1-内核进程的创建"><a href="#1-1-内核进程的创建" class="headerlink" title="1.1 内核进程的创建"></a>1.1 内核进程的创建</h3><p>内核进程创建过程，是理解本篇的基础。</p><p>可以看到 <code>kthread_create()</code> 并不是自己去创建内核进程，而是把创建任务推送给 <code>kthreadd()</code> 进程执行。</p><p><code>kthreadd()</code> -&gt; <code>create_kthread()</code> -&gt; <code>kernel_thread()</code> 创建的新进程也不是直接使用用户的函数 <code>threadfn()</code>，而是创建通用函数 <code>kthread()</code>，<code>kthread()</code> 再来调用 <code>threadfn()</code>。</p><ul><li>kernel/kthread.c:</li></ul><p><img src="stop_kthread_create.png" alt="kthread_create"></p><h3 id="1-2-内核进程的-stop"><a href="#1-2-内核进程的-stop" class="headerlink" title="1.2 内核进程的 stop"></a>1.2 内核进程的 stop</h3><p>如果内核进程需要支持 <code>kthread_stop()</code>，需要根据以下框架来写代码。用户在主循环中调用 <code>kthread_should_stop()</code> 来判断当前 kthread 是否需要 stop，如果被 stop 则退出循环。</p><p>这种代码为什么不做到通用代码 <code>kthread()</code> 中？这应该是和 Linux 的设计思想相关的。Linux 运行内核态的策略比较灵活，而对用户态的策略更加严格统一。</p><p><img src="stop_kthread_should_stop.png" alt="kthread_should_stop"></p><p><code>kthread_should_stop()</code> 和 <code>kthread_stop()</code> 的代码实现：</p><ul><li>kernel/kthread.c:</li><li><code>kthread_should_stop()</code>/<code>kthread_stop()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kthread_should_stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (1) 判断进程所在 kthread 结构中的 KTHREAD_SHOULD_STOP 是否被置位</span></span><br><span class="line"><span class="keyword">return</span> test_bit(KTHREAD_SHOULD_STOP, &amp;to_kthread(current)-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">trace_sched_kthread_stop(k);</span><br><span class="line"></span><br><span class="line">get_task_struct(k);</span><br><span class="line">kthread = to_live_kthread(k);</span><br><span class="line"><span class="keyword">if</span> (kthread) &#123;</span><br><span class="line"><span class="comment">// (2) 置位进程所在 kthread 结构中的 KTHREAD_SHOULD_STOP</span></span><br><span class="line">set_bit(KTHREAD_SHOULD_STOP, &amp;kthread-&gt;flags);</span><br><span class="line"><span class="comment">// (3) unpark &amp; wake_up 进程来响应 stop 信号</span></span><br><span class="line">__kthread_unpark(k, kthread);</span><br><span class="line">wake_up_process(k);</span><br><span class="line">wait_for_completion(&amp;kthread-&gt;exited);</span><br><span class="line">&#125;</span><br><span class="line">ret = k-&gt;exit_code;</span><br><span class="line">put_task_struct(k);</span><br><span class="line"></span><br><span class="line">trace_sched_kthread_stop_ret(ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-进程-park"><a href="#2-进程-park" class="headerlink" title="2. 进程 park"></a>2. 进程 park</h2><p><code>smpboot_register_percpu_thread()</code> 用来创建 per_cpu 内核进程，所谓的 per_cpu 进程是指需要在每个 online cpu 上创建线程。比如执行 <code>stop_machine()</code> 中 cpu 同步操作的 migration 进程：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">shell@</span>:/ $ ps | grep migration</span><br><span class="line">root      <span class="number">10</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     smpboot_th <span class="number">0000000000</span> S migration/<span class="number">0</span></span><br><span class="line">root      <span class="number">11</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     smpboot_th <span class="number">0000000000</span> S migration/<span class="number">1</span></span><br><span class="line">root      <span class="number">15</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">2</span></span><br><span class="line">root      <span class="number">19</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">3</span></span><br><span class="line">root      <span class="number">207</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">8</span></span><br><span class="line">root      <span class="number">247</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">4</span></span><br><span class="line">root      <span class="number">251</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">5</span></span><br><span class="line">root      <span class="number">265</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">6</span></span><br><span class="line">root      <span class="number">356</span>   <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">7</span></span><br><span class="line">root      <span class="number">2165</span>  <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     __kthread_ <span class="number">0000000000</span> R migration/<span class="number">9</span></span><br></pre></td></tr></table></figure><p>问题来了，既然 per_cpu 进程是和 cpu 绑定的，那么在 cpu hotplug 的时候，进程需要相应的 disable 和 enable。实现的方法可以有多种：</p><ul><li>动态的销毁和创建线程。缺点是开销比较大。</li><li>设置进程的 cpu 亲和力 <code>set_cpus_allowed_ptr()</code>。缺点是进程绑定的 cpu 如果被 down 掉，进程会迁移到其他 cpu 继续执行。</li></ul><p>为了克服上述方案的缺点，适配 per_cpu 进程的 cpu hotplug 操作，设计了 <code>kthread_park()</code>/<code>kthread_unpark()</code> 机制。</p><h3 id="2-1-smpboot-register-percpu-thread"><a href="#2-1-smpboot-register-percpu-thread" class="headerlink" title="2.1 smpboot_register_percpu_thread()"></a>2.1 <code>smpboot_register_percpu_thread()</code></h3><p>per_cpu 进程从代码上看，实际也是调用 <code>kthread_create()</code> 来创建的。</p><ul><li>kernel/smpboot.c:</li><li>kernel/kthread.c:</li></ul><p><img src="stop_smpboot_register.png" alt="smpboot_register_percpu_thread"></p><p>我们可以看到 smpboot_register 又增加了一层封装：<code>kthread()</code> -&gt; <code>smpboot_thread_fn()</code> -&gt; <code>ht-&gt;thread_fn()</code>，这种封装的使用可以参考 cpu_stop_threads。</p><ul><li>kernel/stop_machine.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">cpu_stop_threads</span> = &#123;</span></span><br><span class="line">.store= &amp;cpu_stopper_task,</span><br><span class="line">.thread_should_run= cpu_stop_should_run,</span><br><span class="line">.thread_fn= cpu_stopper_thread,</span><br><span class="line">.thread_comm= <span class="string">"migration/%u"</span>,</span><br><span class="line">.create= cpu_stop_create,</span><br><span class="line">.setup= cpu_stop_unpark,</span><br><span class="line">.park= cpu_stop_park,</span><br><span class="line">.pre_unpark= cpu_stop_unpark,</span><br><span class="line">.selfparking= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">cpu_stop_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_stopper</span> *<span class="title">stopper</span> = &amp;<span class="title">per_cpu</span>(<span class="title">cpu_stopper</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;stopper-&gt;lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;stopper-&gt;works);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUG_ON(smpboot_register_percpu_thread(&amp;cpu_stop_threads));</span><br><span class="line">stop_machine_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>smpboot_thread_fn()</code> 循环中实现了对 park 的支持，具体实现 <code>kthread_should_park()</code>、<code>kthread_parkme()</code>、<code>kthread_park()</code>、<code>kthread_unpark()</code> 的代码分析：</p><ul><li>kernel/kthread.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kthread_should_park</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (1) 判断进程所在 kthread 结构中的 KTHREAD_SHOULD_PARK 是否被置位</span></span><br><span class="line"><span class="keyword">return</span> test_bit(KTHREAD_SHOULD_PARK, &amp;to_kthread(current)-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kthread_parkme</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__kthread_parkme(to_kthread(current));</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kthread_parkme(struct kthread *self)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (2) 如果当前进程的 KTHREAD_SHOULD_PARK 标志被置位 ,</span></span><br><span class="line"><span class="comment">// 将当前进程进入 TASK_PARKED 的阻塞状态。</span></span><br><span class="line"><span class="comment">// 如果 KTHREAD_SHOULD_PARK 不清除，</span></span><br><span class="line"><span class="comment">// 就算被 wake_up 唤醒还是会循环进入 TASK_PARKED 的阻塞状态。</span></span><br><span class="line">__set_current_state(TASK_PARKED);</span><br><span class="line"><span class="keyword">while</span> (test_bit(KTHREAD_SHOULD_PARK, &amp;self-&gt;flags)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(KTHREAD_IS_PARKED, &amp;self-&gt;flags))</span><br><span class="line">complete(&amp;self-&gt;parked);</span><br><span class="line">schedule();</span><br><span class="line">__set_current_state(TASK_PARKED);</span><br><span class="line">&#125;</span><br><span class="line">clear_bit(KTHREAD_IS_PARKED, &amp;self-&gt;flags);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_park</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span> = <span class="title">to_live_kthread</span>(<span class="title">k</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kthread) &#123;</span><br><span class="line"><span class="comment">// (3) 设置 KTHREAD_IS_PARKED 标志位，并且唤醒进程进入 park 状态</span></span><br><span class="line"><span class="keyword">if</span> (!test_bit(KTHREAD_IS_PARKED, &amp;kthread-&gt;flags)) &#123;</span><br><span class="line">set_bit(KTHREAD_SHOULD_PARK, &amp;kthread-&gt;flags);</span><br><span class="line"><span class="keyword">if</span> (k != current) &#123;</span><br><span class="line">wake_up_process(k);</span><br><span class="line">wait_for_completion(&amp;kthread-&gt;parked);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kthread_unpark</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span> = <span class="title">to_live_kthread</span>(<span class="title">k</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kthread)</span><br><span class="line">__kthread_unpark(k, kthread);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kthread_unpark(struct task_struct *k, struct kthread *kthread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (4) 清除 KTHREAD_IS_PARKED 标志位</span></span><br><span class="line">clear_bit(KTHREAD_SHOULD_PARK, &amp;kthread-&gt;flags);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We clear the IS_PARKED bit here as we don't wait</span></span><br><span class="line"><span class="comment"> * until the task has left the park code. So if we'd</span></span><br><span class="line"><span class="comment"> * park before that happens we'd see the IS_PARKED bit</span></span><br><span class="line"><span class="comment"> * which might be about to be cleared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果进程已经被 park，并且 wake_up 唤醒进程</span></span><br><span class="line"><span class="keyword">if</span> (test_and_clear_bit(KTHREAD_IS_PARKED, &amp;kthread-&gt;flags)) &#123;</span><br><span class="line"><span class="comment">// 如果是 per_cpu 进程，重新绑定进程 cpu</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(KTHREAD_IS_PER_CPU, &amp;kthread-&gt;flags))</span><br><span class="line">__kthread_bind(k, kthread-&gt;cpu, TASK_PARKED);</span><br><span class="line">wake_up_state(k, TASK_PARKED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-cpu-hotplug-支持"><a href="#2-2-cpu-hotplug-支持" class="headerlink" title="2.2 cpu hotplug 支持"></a>2.2 cpu hotplug 支持</h3><p>我们前面说到 park 机制的主要目的是为了 per_cpu 进程支持 cpu hotplug，具体怎么响应热插拔事件呢？</p><ul><li>kernel/smpboot.c:</li></ul><p><img src="stop_park_hotplug.png" alt="park_hotplug"></p><h2 id="3-进程-freeze"><a href="#3-进程-freeze" class="headerlink" title="3. 进程 freeze"></a>3. 进程 freeze</h2><p>在系统进入 suspend 的时候，会尝试冻住一些进程，以避免一些进程无关操作影响系统的 suspend 状态。主要的流程如下：</p><ul><li>kernel/power/suspend.c:</li></ul><p><img src="stop_pm_suspend.png" alt="suspend_freeze_processes"></p><p>这 suspend_freeze 里面判断当前在那个阶段，有 3 个重要的变量：</p><ul><li>system_freezing_cnt - &gt;0 表示系统全局的 freeze 开始；</li><li>pm_freezing - =true 表示用户进程 freeze 开始；</li><li>pm_nosig_freezing - =true 表示内核进程 freeze 开始；</li></ul><p>具体代码分析如下：</p><ul><li>kernel/power/process.c:</li><li>kernel/freezer.c:</li><li><code>suspend_freeze_processes()</code> -&gt; <code>freeze_processes()</code> -&gt; <code>try_to_freeze_tasks()</code> -&gt; <code>freeze_task()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeze_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">int</span> oom_kills_saved;</span><br><span class="line"></span><br><span class="line">error = __usermodehelper_disable(UMH_FREEZING);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 置位 PF_SUSPEND_TASK，确保当前进程不会被 freeze</span></span><br><span class="line"><span class="comment">/* Make sure this task doesn't get frozen */</span></span><br><span class="line">current-&gt;flags |= PF_SUSPEND_TASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 使用全局 freeze 标志 system_freezing_cnt</span></span><br><span class="line"><span class="keyword">if</span> (!pm_freezing)</span><br><span class="line">atomic_inc(&amp;system_freezing_cnt);</span><br><span class="line"></span><br><span class="line">pm_wakeup_clear();</span><br><span class="line">printk(<span class="string">"Freezing user space processes ... "</span>);</span><br><span class="line"><span class="comment">// (3) 使用用户进程 freeze 标志 pm_freezing</span></span><br><span class="line">pm_freezing = <span class="literal">true</span>;</span><br><span class="line">oom_kills_saved = oom_kills_count();</span><br><span class="line"><span class="comment">// (4) freeze user_only 进程</span></span><br><span class="line"><span class="comment">// 判断进程是否可以被 freeze，唤醒进程 freeze 自己</span></span><br><span class="line">error = try_to_freeze_tasks(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">__usermodehelper_set_disable_depth(UMH_DISABLED);</span><br><span class="line">oom_killer_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There might have been an OOM kill while we were</span></span><br><span class="line"><span class="comment"> * freezing tasks and the killed task might be still</span></span><br><span class="line"><span class="comment"> * on the way out so we have to double check for race.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (oom_kills_count() != oom_kills_saved &amp;&amp;</span><br><span class="line">    !check_frozen_processes()) &#123;</span><br><span class="line">__usermodehelper_set_disable_depth(UMH_ENABLED);</span><br><span class="line">printk(<span class="string">"OOM in progress."</span>);</span><br><span class="line">error = -EBUSY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">"done."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line">BUG_ON(in_atomic());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">thaw_processes();</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_freeze_tasks</span><span class="params">(<span class="keyword">bool</span> user_only)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_time;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> todo;</span><br><span class="line"><span class="keyword">bool</span> wq_busy = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">u64 elapsed_msecs64;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> elapsed_msecs;</span><br><span class="line"><span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> sleep_usecs = USEC_PER_MSEC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line"><span class="keyword">char</span> suspend_abort[MAX_SUSPEND_ABORT_LEN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">do_gettimeofday(&amp;start);</span><br><span class="line"></span><br><span class="line">end_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.1) 如果是 kernel freeze，</span></span><br><span class="line"><span class="comment">// 停工有 WQ_FREEZABLE 标志的 workqueue</span></span><br><span class="line"><span class="comment">// 将 wq 的 pwq-&gt;max_active 设置成 0，新的 work 不能被执行</span></span><br><span class="line"><span class="keyword">if</span> (!user_only)</span><br><span class="line">freeze_workqueues_begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">todo = <span class="number">0</span>;</span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line"><span class="comment">// (4.2) 对每个进程执行 freeze_task()</span></span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p == current || !freeze_task(p))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!freezer_should_skip(p))</span><br><span class="line">todo++;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.3) 如果是 kernel freeze，</span></span><br><span class="line"><span class="comment">// 判断停工的 workqueue 中残留的 work 有没有执行完</span></span><br><span class="line"><span class="keyword">if</span> (!user_only) &#123;</span><br><span class="line">wq_busy = freeze_workqueues_busy();</span><br><span class="line">todo += wq_busy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!todo || time_after(jiffies, end_time))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pm_wakeup_pending()) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">pm_get_active_wakeup_sources(suspend_abort,</span><br><span class="line">MAX_SUSPEND_ABORT_LEN);</span><br><span class="line">log_suspend_abort_reason(suspend_abort);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">wakeup = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to retry, but first give the freezing tasks some</span></span><br><span class="line"><span class="comment"> * time to enter the refrigerator.  Start with an initial</span></span><br><span class="line"><span class="comment"> * 1 ms sleep followed by exponential backoff until 8 ms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">usleep_range(sleep_usecs / <span class="number">2</span>, sleep_usecs);</span><br><span class="line"><span class="keyword">if</span> (sleep_usecs &lt; <span class="number">8</span> * USEC_PER_MSEC)</span><br><span class="line">sleep_usecs *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_gettimeofday(&amp;end);</span><br><span class="line">elapsed_msecs64 = timeval_to_ns(&amp;end) - timeval_to_ns(&amp;start);</span><br><span class="line">do_div(elapsed_msecs64, NSEC_PER_MSEC);</span><br><span class="line">elapsed_msecs = elapsed_msecs64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wakeup) &#123;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line">printk(KERN_ERR <span class="string">"Freezing of tasks aborted after %d.%03d seconds"</span>,</span><br><span class="line">       elapsed_msecs / <span class="number">1000</span>, elapsed_msecs % <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (todo) &#123;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line">printk(KERN_ERR <span class="string">"Freezing of tasks failed after %d.%03d seconds"</span></span><br><span class="line">       <span class="string">" (%d tasks refusing to freeze, wq_busy=%d):\n"</span>,</span><br><span class="line">       elapsed_msecs / <span class="number">1000</span>, elapsed_msecs % <span class="number">1000</span>,</span><br><span class="line">       todo - wq_busy, wq_busy);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p != current &amp;&amp; !freezer_should_skip(p)</span><br><span class="line">    &amp;&amp; freezing(p) &amp;&amp; !frozen(p))</span><br><span class="line">sched_show_task(p);</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">"(elapsed %d.%03d seconds) "</span>, elapsed_msecs / <span class="number">1000</span>,</span><br><span class="line">elapsed_msecs % <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> todo ? -EBUSY : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freeze_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This check can race with freezer_do_not_count, but worst case that</span></span><br><span class="line"><span class="comment"> * will result in an extra wakeup being sent to the task.  It does not</span></span><br><span class="line"><span class="comment"> * race with freezer_count(), the barriers in freezer_count() and</span></span><br><span class="line"><span class="comment"> * freezer_should_skip() ensure that either freezer_count() sees</span></span><br><span class="line"><span class="comment"> * freezing == true in try_to_freeze() and freezes, or</span></span><br><span class="line"><span class="comment"> * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task</span></span><br><span class="line"><span class="comment"> * normally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (freezer_should_skip(p))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;freezer_lock, flags);</span><br><span class="line"><span class="comment">// (4.2.1) 检查当前进程是否可以被 freeze，</span></span><br><span class="line"><span class="comment">// 或者是否已经被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (!freezing(p) || frozen(p)) &#123;</span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4.2.2) 如果是用户进程，伪造一个 signal 发送给进程</span></span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">fake_signal_wake_up(p);</span><br><span class="line"><span class="comment">// (4.2.3) 如果是内核进程，wake_up 内核进程</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">wake_up_state(p, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">freezing</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; 具体代码分析如下：</span><br><span class="line"></span><br><span class="line">- kernel/power/process.c:</span><br><span class="line">- kernel/freezer.c:</span><br><span class="line"><span class="comment">// 如果 system_freezing_cnt 为 0，说明全局 freeze 还没有开始</span></span><br><span class="line"><span class="keyword">if</span> (likely(!atomic_read(&amp;system_freezing_cnt)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> freezing_slow_path(p);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freezing_slow_path</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (PF_NOFREEZE | PF_SUSPEND_TASK) 当前进程不能被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; (PF_NOFREEZE | PF_SUSPEND_TASK))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_thread_flag(TIF_MEMDIE))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 pm_nosig_freezing 为 true，内核进程 freeze 已经开始，</span></span><br><span class="line"><span class="comment">// 当前进程可以被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (pm_nosig_freezing || cgroup_freezing(p))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 pm_freezing 为 true，且当前进程为用户进程</span></span><br><span class="line"><span class="comment">// 当前进程可以被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (pm_freezing &amp;&amp; !(p-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-用户进程-freeze"><a href="#3-1-用户进程-freeze" class="headerlink" title="3.1 用户进程 freeze"></a>3.1 用户进程 freeze</h3><p>freeze 用户态的进程利用了 signal 机制，系统 suspend 使能了 suspend 以后，调用 <code>fake_signal_wake_up()</code> 伪造一个信号唤醒进程，进程在 <code>ret_to_user()</code> -&gt; <code>do_notify_resume()</code> -&gt; <code>do_signal()</code> -&gt; <code>get_signal()</code> -&gt; <code>try_to_freeze()</code> 中 freeze 自己。</p><p>具体代码分析如下：</p><ul><li>kernel/freezer.c:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_NOFREEZE))</span><br><span class="line">debug_check_no_locks_held();</span><br><span class="line"><span class="keyword">return</span> try_to_freeze_unsafe();</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze_unsafe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"><span class="comment">// 当前进程是否可以被 freeze</span></span><br><span class="line"><span class="keyword">if</span> (likely(!freezing(current)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 调用 __refrigerator() freeze 当前进程</span></span><br><span class="line"><span class="keyword">return</span> __refrigerator(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">bool</span> __refrigerator(<span class="keyword">bool</span> check_kthr_stop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Hmm, should we be allowed to suspend when there are realtime</span></span><br><span class="line"><span class="comment">   processes around? */</span></span><br><span class="line"><span class="keyword">bool</span> was_frozen = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">long</span> save = current-&gt;state;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s entered refrigerator\n"</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// (1) 设置当前进程进入 TASK_UNINTERRUPTIBLE 阻塞状态</span></span><br><span class="line">set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;freezer_lock);</span><br><span class="line"><span class="comment">// (2) 设置已经 freeze 标志 PF_FROZEN</span></span><br><span class="line">current-&gt;flags |= PF_FROZEN;</span><br><span class="line"><span class="comment">// (3) 如果当前进程已经不是 freeze 状态，</span></span><br><span class="line"><span class="comment">// 退出 freeze</span></span><br><span class="line"><span class="keyword">if</span> (!freezing(current) ||</span><br><span class="line">    (check_kthr_stop &amp;&amp; kthread_should_stop()))</span><br><span class="line">current-&gt;flags &amp;= ~PF_FROZEN;</span><br><span class="line">spin_unlock_irq(&amp;freezer_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_FROZEN))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">was_frozen = <span class="literal">true</span>;</span><br><span class="line">schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s left refrigerator\n"</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Restore saved task state before returning.  The mb'd version</span></span><br><span class="line"><span class="comment"> * needs to be used; otherwise, it might silently break</span></span><br><span class="line"><span class="comment"> * synchronization which depends on ordered task state change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_current_state(save);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> was_frozen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-内核进程-freeze"><a href="#3-2-内核进程-freeze" class="headerlink" title="3.2 内核进程 freeze"></a>3.2 内核进程 freeze</h3><p>内核进程对 freeze 的响应，有两个问题：</p><ul><li>wake_up_state(p, TASK_INTERRUPTIBLE) 能唤醒哪些内核进程。</li><li>内核进程怎么样来响应 freeze 状态，怎么样来 freeze 自己。</li></ul><p>如果进程阻塞在信号量、mutex 等内核同步机制上，wake_up_state 并不能解除阻塞。因为这些机制都有 while(1) 循环来判断条件，是否成立，不成立只是简单的唤醒随即又会进入阻塞睡眠状态。</p><ul><li>kernel/locking/mutex.c:</li><li><code>mutex_lock()</code> -&gt; <code>__mutex_lock_common()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__mutex_lock_common(struct mutex *lock, <span class="keyword">long</span> state, <span class="keyword">unsigned</span> <span class="keyword">int</span> subclass,</span><br><span class="line">    struct lockdep_map *nest_lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip,</span><br><span class="line">    struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> <span class="keyword">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lets try to take the lock again - this is needed even if</span></span><br><span class="line"><span class="comment"> * we get here for the first time (shortly after failing to</span></span><br><span class="line"><span class="comment"> * acquire the lock), to make sure that we get a wakeup once</span></span><br><span class="line"><span class="comment"> * it's unlocked. Later on, if we sleep, this is the</span></span><br><span class="line"><span class="comment"> * operation that gives us the lock. We xchg it to -1, so</span></span><br><span class="line"><span class="comment"> * that when we release the lock, we properly wake up the</span></span><br><span class="line"><span class="comment"> * other waiters. We only attempt the xchg if the count is</span></span><br><span class="line"><span class="comment"> * non-negative in order to avoid unnecessary xchg operations:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1) 如果 mutex_lock 条件成立，才退出</span></span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;lock-&gt;count) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    (atomic_xchg(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 如果如果有信号阻塞，也退出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * got a signal? (This code gets eliminated in the</span></span><br><span class="line"><span class="comment"> * TASK_UNINTERRUPTIBLE case.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;</span><br><span class="line">ret = -EINTR;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx-&gt;acquired &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = __mutex_lock_check_stamp(lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 否则继续进入阻塞休眠状态</span></span><br><span class="line">__set_task_state(task, state);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* didn't get the lock, go to sleep: */</span></span><br><span class="line">spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line">spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>wake_up_state()</code> 只能唤醒这种简单阻塞的内核进程，而对于阻塞在内核同步机制上是无能无力的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">schedule();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核进程响应 freeze 操作，也必须显式的调用 <code>try_to_freeze()</code> 或者 <code>kthread_freezable_should_stop()</code> 来 freeze 自己：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!kthread_should_stop()) &#123;</span><br><span class="line"></span><br><span class="line">try_to_freeze();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以从代码逻辑上看内核进程 freeze，并不会 freeze 所有内核进程，只 freeze 了 2 部分：一部分是设置了 WQ_FREEZABLE 标志的 workqueue，另一部分是内核进程主动调用 <code>try_to_freeze()</code> 并且在架构上设计的可以响应 freeze。</p>]]></content>
      
      
      <categories>
          
          <category> 进程管理与通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kthread_stop </tag>
            
            <tag> kthread_park </tag>
            
            <tag> freeze_processes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Signal</title>
      <link href="/2016/07/03//linux-signal.html/"/>
      <url>/2016/07/03//linux-signal.html/</url>
      
        <content type="html"><![CDATA[<p>信号的基本使用场景：使用 <code>ctrl+c</code> 中止一个程序，或者使用 <code>kill pid</code> 命令杀掉一个进程。Linux 信号机制基本上每个同学都用过，但是信号的具体实现机制还是有很多人不清楚的。在很多人的概念中信号是一种异步机制，像中断一样。但是除了硬中断，信号也是由中断实现的吗？如果不是中断，系统又怎么样来利用软件机制模拟类似如异步中断的动作？</p><blockquote><p>本文的代码分析基于 Linux Kernel 3.18.22，最好的学习方法还是 “read the fucking source code”</p></blockquote><h2 id="1-信号的响应时机"><a href="#1-信号的响应时机" class="headerlink" title="1.信号的响应时机"></a>1.信号的响应时机</h2><p>理解信号异步机制的关键是信号的响应时机，我们对一个进程发送一个信号以后，其实并没有硬中断发生，只是简单把信号挂载到目标进程的信号 pending 队列上去，信号真正得到执行的时机是进程执行完异常/中断返回到用户态的时刻。</p><p>让信号看起来是一个异步中断的关键就是，正常的用户进程是会频繁的在用户态和内核态之间切换的（这种切换包括：系统调用、缺页异常、系统中断…），所以信号能很快的能得到执行。但这也带来了一点问题，内核进程是不响应信号的，除非它刻意的去查询。所以通常情况下我们无法通过kill命令去杀死一个内核进程。</p><p><img src="signal_ret_to_user.png" alt="信号响应时机"></p><ul><li>arch/arm64/kernel/entry.s:</li><li>el0_sync()/el0_irq() -&gt; ret_to_user() -&gt; work_pending() -&gt; do_notify_resume()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) 在arm64架构中，kernel运行在el1，用户态运行在el0。</span></span><br><span class="line"><span class="comment">// el0_sync是用户态发生异常的入口，el0_irq是用户态发生中断的的入口。</span></span><br><span class="line"><span class="comment">// 异常包括几种：系统调用el0_svc、数据异常el0_da、指令异常el0_ia等等几种。</span></span><br><span class="line">.align<span class="number">11</span></span><br><span class="line">ENTRY(vectors)</span><br><span class="line">ventryel0_sync<span class="comment">// Synchronous 64-bit EL0</span></span><br><span class="line">ventryel0_irq<span class="comment">// IRQ 64-bit EL0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 用户态异常el0_sync</span></span><br><span class="line">.align<span class="number">6</span></span><br><span class="line">el0_sync:</span><br><span class="line">kernel_entry <span class="number">0</span></span><br><span class="line">mrsx25, esr_el1<span class="comment">// read the syndrome register</span></span><br><span class="line">lsrx24, x25, #ESR_EL1_EC_SHIFT<span class="comment">// exception class</span></span><br><span class="line">cmpx24, #ESR_EL1_EC_SVC64<span class="comment">// SVC in 64-bit state</span></span><br><span class="line">b.eqel0_svc</span><br><span class="line">cmpx24, #ESR_EL1_EC_DABT_EL0<span class="comment">// data abort in EL0</span></span><br><span class="line">b.eqel0_da</span><br><span class="line">cmpx24, #ESR_EL1_EC_IABT_EL0<span class="comment">// instruction abort in EL0</span></span><br><span class="line">b.eqel0_ia</span><br><span class="line">cmpx24, #ESR_EL1_EC_FP_ASIMD<span class="comment">// FP/ASIMD access</span></span><br><span class="line">b.eqel0_fpsimd_acc</span><br><span class="line">cmpx24, #ESR_EL1_EC_FP_EXC64<span class="comment">// FP/ASIMD exception</span></span><br><span class="line">b.eqel0_fpsimd_exc</span><br><span class="line">cmpx24, #ESR_EL1_EC_SYS64<span class="comment">// configurable trap</span></span><br><span class="line">b.eqel0_undef</span><br><span class="line">cmpx24, #ESR_EL1_EC_SP_ALIGN<span class="comment">// stack alignment exception</span></span><br><span class="line">b.eqel0_sp_pc</span><br><span class="line">cmpx24, #ESR_EL1_EC_PC_ALIGN<span class="comment">// pc alignment exception</span></span><br><span class="line">b.eqel0_sp_pc</span><br><span class="line">cmpx24, #ESR_EL1_EC_UNKNOWN<span class="comment">// unknown exception in EL0</span></span><br><span class="line">b.eqel0_undef</span><br><span class="line">cmpx24, #ESR_EL1_EC_BREAKPT_EL0<span class="comment">// debug exception in EL0</span></span><br><span class="line">b.geel0_dbg</span><br><span class="line">bel0_inv</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.1) 用户态数据访问el0_da</span></span><br><span class="line">el0_da:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Data abort handling</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mrsx26, far_el1</span><br><span class="line"><span class="comment">// enable interrupts before calling the main handler</span></span><br><span class="line">enable_dbg_and_irq</span><br><span class="line">ct_user_exit</span><br><span class="line">bicx0, x26, #(<span class="number">0xff</span> &lt;&lt; <span class="number">56</span>)</span><br><span class="line">movx1, x25</span><br><span class="line">movx2, sp</span><br><span class="line">bldo_mem_abort</span><br><span class="line">bret_to_user</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 用户态中断el0_irq</span></span><br><span class="line">.align<span class="number">6</span></span><br><span class="line">el0_irq:</span><br><span class="line">kernel_entry <span class="number">0</span></span><br><span class="line">el0_irq_naked:</span><br><span class="line">enable_dbg</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_off</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ct_user_exit</span><br><span class="line">irq_handler</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">bltrace_hardirqs_on</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">bret_to_user</span><br><span class="line">ENDPROC(el0_irq)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 返回用户态的处理函数ret_to_user</span></span><br><span class="line"><span class="comment">// 判断thread_info-&gt;flags与#_TIF_WORK_MASK，是否有置位，有则跳转到work_pending执行。</span></span><br><span class="line"><span class="comment">// _TIF_SIGPENDING置位即代表了进程有信号需要处理</span></span><br><span class="line"><span class="comment">// #define _TIF_WORK_MASK(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \</span></span><br><span class="line"><span class="comment">// _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE)</span></span><br><span class="line">ret_to_user:</span><br><span class="line">disable_irq<span class="comment">// disable interrupts</span></span><br><span class="line">ldrx1, [tsk, #TI_FLAGS]</span><br><span class="line"><span class="keyword">and</span>x2, x1, #_TIF_WORK_MASK</span><br><span class="line">cbnzx2, work_pending</span><br><span class="line">enable_step_tsk x1, x2</span><br><span class="line">no_work_pending:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTK_COMPAT</span></span><br><span class="line">kernel_exit_compat ret = <span class="number">0</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">kernel_exit <span class="number">0</span>, ret = <span class="number">0</span></span><br><span class="line">#endif</span><br><span class="line">ENDPROC(ret_to_user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5) work_pending</span></span><br><span class="line">fast_work_pending:</span><br><span class="line">strx0, [sp, #S_X0]<span class="comment">// returned x0</span></span><br><span class="line">work_pending:</span><br><span class="line">tbnzx1, #TIF_NEED_RESCHED, work_resched</span><br><span class="line"><span class="comment">/* TIF_SIGPENDING, TIF_NOTIFY_RESUME or TIF_FOREIGN_FPSTATE case */</span></span><br><span class="line">ldrx2, [sp, #S_PSTATE]</span><br><span class="line">movx0, sp<span class="comment">// 'regs'</span></span><br><span class="line">Markdown</span><br><span class="line">Toggle Zen Mode</span><br><span class="line">Preview</span><br><span class="line"></span><br><span class="line">tstx2, #PSR_MODE_MASK<span class="comment">// user mode regs?</span></span><br><span class="line">b.neno_work_pending<span class="comment">// returning to kernel</span></span><br><span class="line">enable_irq<span class="comment">// enable interrupts for do_notify_resume()</span></span><br><span class="line">bldo_notify_resume</span><br><span class="line">bret_to_user</span><br><span class="line">work_resched:</span><br><span class="line">blschedule</span><br></pre></td></tr></table></figure><ul><li>arch/arm64/kernel/signal.c:</li><li>-&gt; do_notify_resume() -&gt; do_signal() -&gt; get_signal()/handle_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_notify_resume</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">unsigned</span> <span class="keyword">int</span> thread_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (5.1)具体的信号处理过程</span></span><br><span class="line"><span class="keyword">if</span> (thread_flags &amp; _TIF_SIGPENDING)</span><br><span class="line">do_signal(regs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread_flags &amp; _TIF_NOTIFY_RESUME) &#123;</span><br><span class="line">clear_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">tracehook_notify_resume(regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread_flags &amp; _TIF_FOREIGN_FPSTATE)</span><br><span class="line">fpsimd_restore_current_state();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-INTERRUPTIBLE-UNINTERRUPTIBLE-进程对信号的响应"><a href="#1-1-INTERRUPTIBLE-UNINTERRUPTIBLE-进程对信号的响应" class="headerlink" title="1.1 INTERRUPTIBLE/UNINTERRUPTIBLE 进程对信号的响应"></a>1.1 INTERRUPTIBLE/UNINTERRUPTIBLE 进程对信号的响应</h3><p>上节主要描述运行状态（TASK_RUNNING）进程对信号的响应时机：信号发送后挂到目标进程的信号队列，进程返回用户态的时候在 <code>do_notify_resume()</code> 中处理信号。</p><p>那么对于阻塞状态的进程又怎么样来响应信号呢？</p><p>让一个进程进入阻塞状态，我们可以选择让其进入可中断（TASK_INTERRUPTIBLE）或者不可中断（TASK_UNINTERRUPTIBLE）状态，比如 mutex 操作分为 <code>mutex_lock()</code> 和 <code>mutex_lock_interruptible()</code>。所谓的可中断和不可中断就是说是否可以被中断信号打断：如果进程处于可中断（TASK_INTERRUPTIBLE）状态，信号发送函数会直接唤醒进程，让进程处理完内核态操作去返回用户态，让进程迅速去执行信号处理函数；如果进程处于不可中断（TASK_UNINTERRUPTIBLE）状态俗称为 D 进程，信号只会挂到信号队列，但是没有机会去立即执行。</p><ul><li>kernel/signal.c:</li><li>__send_signal() -&gt; complete_signal() -&gt; signal_wake_up() -&gt; signal_wake_up_state()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_wake_up_state</span><span class="params">(struct task_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TASK_WAKEKILL also means wake it up in the stopped/traced/killable</span></span><br><span class="line"><span class="comment"> * case. We don't check t-&gt;state here because there is a race with it</span></span><br><span class="line"><span class="comment"> * executing another processor and just now entering stopped state.</span></span><br><span class="line"><span class="comment"> * By using wake_up_state, we ensure the process will wake up and</span></span><br><span class="line"><span class="comment"> * handle its death signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1)在发送完信号后，会唤醒状态为TASK_INTERRUPTIBLE的进程。</span></span><br><span class="line"><span class="keyword">if</span> (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2内核进程响应信号"><a href="#1-2内核进程响应信号" class="headerlink" title="1.2内核进程响应信号"></a>1.2内核进程响应信号</h3><p>上面说到内核进程普通情况下是不会响应信号的，如果需要内核进程响应信号，可以在内核进程中加入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义信号处理函数</span></span><br><span class="line">&#125;</span><br><span class="line">flush_signals(current);</span><br></pre></td></tr></table></figure><h2 id="2-信号简介"><a href="#2-信号简介" class="headerlink" title="2.信号简介"></a>2.信号简介</h2><p>在给大家引出重点的信号响应时机以后，还是简单介绍以下信号的背景知识。信号也是一种进程间通讯的机制，它传递的信息很短，只有一个编号。</p><h3 id="2-1-常规信号和实时信号"><a href="#2-1-常规信号和实时信号" class="headerlink" title="2.1 常规信号和实时信号"></a>2.1 常规信号和实时信号</h3><p>Linux 传统的信号 1~31 为常规信号（regular signal），POSIX 还引入了一种新的信号实时信号（real-time signal）编号为 32~64。它们的不同在于：常规信号同一个编号在 pending 队列中只存在一份，如果有重复的则直接丢弃；实时信号的多个相同信号不能丢弃，需要保证每个信号都能送达。</p><p>Linux 常用的是常规信号，以下是具体的定义<sup><a href="#fn_ULK" id="reffn_ULK">ULK</a></sup>：</p><div class="table-container"><table><thead><tr><th>编号</th><th style="text-align:center">信号名称</th><th style="text-align:center">缺省操作</th><th style="text-align:center">解释</th><th style="text-align:center">POSIX</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">SIGHUP</td><td style="text-align:center">Terminate</td><td style="text-align:center">Hang up controlling terminal or process</td><td style="text-align:center">Yes</td></tr><tr><td>2</td><td style="text-align:center">SIGINT</td><td style="text-align:center">Terminate</td><td style="text-align:center">Interrupt from keyboard</td><td style="text-align:center">Yes</td></tr><tr><td>3</td><td style="text-align:center">SIGQUIT</td><td style="text-align:center">Dump</td><td style="text-align:center">Quit from keyboard</td><td style="text-align:center">Yes</td></tr><tr><td>4</td><td style="text-align:center">SIGILL</td><td style="text-align:center">Dump</td><td style="text-align:center">Illegal instruction</td><td style="text-align:center">Yes</td></tr><tr><td>5</td><td style="text-align:center">SIGTRAP</td><td style="text-align:center">Dump</td><td style="text-align:center">Breakpoint for debugging</td><td style="text-align:center">No</td></tr><tr><td>6</td><td style="text-align:center">SIGABRT</td><td style="text-align:center">Dump</td><td style="text-align:center">Abnormal termination</td><td style="text-align:center">Yes</td></tr><tr><td>6</td><td style="text-align:center">SIGIOT</td><td style="text-align:center">Dump</td><td style="text-align:center">Equivalent to SIGABRT</td><td style="text-align:center">No</td></tr><tr><td>7</td><td style="text-align:center">SIGBUS</td><td style="text-align:center">Dump</td><td style="text-align:center">Bus error</td><td style="text-align:center">No</td></tr><tr><td>8</td><td style="text-align:center">SIGFPE</td><td style="text-align:center">Dump</td><td style="text-align:center">Floating-point exception</td><td style="text-align:center">Yes</td></tr><tr><td>9</td><td style="text-align:center">SIGKILL</td><td style="text-align:center">Terminate</td><td style="text-align:center">Forced-process termination</td><td style="text-align:center">Yes</td></tr><tr><td>10</td><td style="text-align:center">SIGUSR1</td><td style="text-align:center">Terminate</td><td style="text-align:center">Available to processes</td><td style="text-align:center">Yes</td></tr><tr><td>11</td><td style="text-align:center">SIGSEGV</td><td style="text-align:center">Dump</td><td style="text-align:center">Invalid memory reference</td><td style="text-align:center">Yes</td></tr><tr><td>12</td><td style="text-align:center">SIGUSR2</td><td style="text-align:center">Terminate</td><td style="text-align:center">Available to processes</td><td style="text-align:center">Yes</td></tr><tr><td>13</td><td style="text-align:center">SIGPIPE</td><td style="text-align:center">Terminate</td><td style="text-align:center">Write to pipe with no readers</td><td style="text-align:center">Yes</td></tr><tr><td>14</td><td style="text-align:center">SIGALRM</td><td style="text-align:center">Terminate</td><td style="text-align:center">Real-timerclock</td><td style="text-align:center">Yes</td></tr><tr><td>15</td><td style="text-align:center">SIGTERM</td><td style="text-align:center">Terminate</td><td style="text-align:center">Process termination</td><td style="text-align:center">Yes</td></tr><tr><td>16</td><td style="text-align:center">SIGSTKFLT</td><td style="text-align:center">Terminate</td><td style="text-align:center">Coprocessor stack error</td><td style="text-align:center">No</td></tr><tr><td>17</td><td style="text-align:center">SIGCHLD</td><td style="text-align:center">Ignore</td><td style="text-align:center">Child process stopped or terminated, or got signal if traced</td><td style="text-align:center">Yes</td></tr><tr><td>18</td><td style="text-align:center">SIGCONT</td><td style="text-align:center">Continue</td><td style="text-align:center">Resume execution, if stopped</td><td style="text-align:center">Yes</td></tr><tr><td>19</td><td style="text-align:center">SIGSTOP</td><td style="text-align:center">Stop</td><td style="text-align:center">Stop process execution</td><td style="text-align:center">Yes</td></tr><tr><td>20</td><td style="text-align:center">SIGTSTP</td><td style="text-align:center">Stop</td><td style="text-align:center">Stop process issued from tty</td><td style="text-align:center">Yes</td></tr><tr><td>21</td><td style="text-align:center">SIGTTIN</td><td style="text-align:center">Stop</td><td style="text-align:center">Background process requires input</td><td style="text-align:center">Yes</td></tr><tr><td>22</td><td style="text-align:center">SIGTTOU</td><td style="text-align:center">Stop</td><td style="text-align:center">Background process requires output</td><td style="text-align:center">Yes</td></tr><tr><td>23</td><td style="text-align:center">SIGURG</td><td style="text-align:center">Ignore</td><td style="text-align:center">Urgent condition on socket</td><td style="text-align:center">No</td></tr><tr><td>24</td><td style="text-align:center">SIGXCPU</td><td style="text-align:center">Dump</td><td style="text-align:center">CPU time limit exceeded</td><td style="text-align:center">No</td></tr><tr><td>25</td><td style="text-align:center">SIGXFSZ</td><td style="text-align:center">Dump</td><td style="text-align:center">File size limit exceeded</td><td style="text-align:center">No</td></tr><tr><td>26</td><td style="text-align:center">SIGVTALRM</td><td style="text-align:center">Terminate</td><td style="text-align:center">Virtual timer clock</td><td style="text-align:center">No</td></tr><tr><td>27</td><td style="text-align:center">SIGPROF</td><td style="text-align:center">Terminate</td><td style="text-align:center">Profile timer clock</td><td style="text-align:center">No</td></tr><tr><td>28</td><td style="text-align:center">SIGWINCH</td><td style="text-align:center">Ignore</td><td style="text-align:center">Window resizing</td><td style="text-align:center">No</td></tr><tr><td>29</td><td style="text-align:center">SIGIO</td><td style="text-align:center">Terminate</td><td style="text-align:center">I/O now possible</td><td style="text-align:center">No</td></tr><tr><td>29</td><td style="text-align:center">SIGPOLL</td><td style="text-align:center">Terminate</td><td style="text-align:center">Equivalent to SIGIO</td><td style="text-align:center">No</td></tr><tr><td>30</td><td style="text-align:center">SIGPWR</td><td style="text-align:center">Terminate</td><td style="text-align:center">Power supply failure</td><td style="text-align:center">No</td></tr><tr><td>31</td><td style="text-align:center">SIGSYS</td><td style="text-align:center">Dump</td><td style="text-align:center">Bad system call</td><td style="text-align:center">No</td></tr><tr><td>31</td><td style="text-align:center">SIGUNUSED</td><td style="text-align:center">Dump</td><td style="text-align:center">Equivalent to SIGSYS</td><td style="text-align:center">No</td></tr></tbody></table></div><p>所谓的缺省操作：是在用户没有注册用户态的信号处理函数的情况下，默认的信号内核处理方法。在第4节中会详细的讲解。</p><h2 id="3-信号的发送"><a href="#3-信号的发送" class="headerlink" title="3.信号的发送"></a>3.信号的发送</h2><p>信号的发送者可以是 user 也可以是 kernel，我们经常是通过用户态来调用 kill()、tkill() 等函数来发送信号的，我们通过分析这些系统调用来理解信号的具体发送过程。</p><ul><li>与信号相关的系统调用主要有以下函数：</li></ul><div class="table-container"><table><thead><tr><th>系统调用</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>kill</td><td style="text-align:center">向线程组发送信号</td></tr><tr><td>tkill</td><td style="text-align:center">向进程发送信号</td></tr><tr><td>tgkill</td><td style="text-align:center">向指定线程组中的进程发送信号</td></tr><tr><td>signal</td><td style="text-align:center">注册信号的用户态处理函数</td></tr><tr><td>sigprocmask</td><td style="text-align:center">block/unblock信号</td></tr></tbody></table></div><h3 id="3-1-kill"><a href="#3-1-kill" class="headerlink" title="3.1 kill()"></a>3.1 kill()</h3><p><code>kill()</code> 系统调用的功能是发送一个信号给线程组，只需要线程组挑出一个线程来响应处理信号。但是对于致命信号，线程组内所有进程都会被杀死，而不仅仅是处理信号的线程。</p><p><img src="signal_kill.png" alt="kill 调用"></p><ul><li>kernel/signal.c:</li><li>kill() -&gt; kill_something_info() -&gt; kill_pid_info() -&gt; group_send_sig_info() -&gt; do_send_sig_info() -&gt; send_signal() -&gt; __send_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_USER;</span><br><span class="line">info.si_pid = task_tgid_vnr(current);</span><br><span class="line">info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">// (1)pid&gt;0, 发送信号给pid进程所在的线程组</span></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line"><span class="comment">// (2)(pid &lt;= 0) &amp;&amp; (pid != -1), 发送信号给pid进程所在进程组中的每一个线程组</span></span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">ret = __kill_pgrp_info(sig, info,</span><br><span class="line">pid ? find_vpid(-pid) : task_pgrp(current));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// (3)pid = -1, 发送信号给所有进程的进程组，除了pid=1和当前进程自己</span></span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(p) &#123;</span><br><span class="line"><span class="keyword">if</span> (task_pid_vnr(p) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">!same_thread_group(p, current)) &#123;</span><br><span class="line"><span class="keyword">int</span> err = group_send_sig_info(sig, info, p);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">if</span> (err != -EPERM)</span><br><span class="line">retval = err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = count ? retval : -ESRCH;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = check_kill_permission(sig, info, p);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line"><span class="comment">// (1.1)参数group=ture，信号发送给线程组</span></span><br><span class="line">ret = do_send_sig_info(sig, info, p, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="signal_pending_queue.png" alt="信号队列"></p><p>接下来来到了发送信号的核心函数 <code>__send_signal()</code>，函数的主要目的是把信号挂到信号的 pending 队列中去。pending 队列有两种：一种是进程组共享的 <code>task_struct-&gt;signal-&gt;shared_pending</code>，发送给线程组的信号会挂载到该队列；另一种是进程私有队列 <code>task_struct-&gt;pending</code>，发送给进程的信号会挂载到该队列。</p><p>从下面的代码中，我们可以看到在创建线程时，线程组贡献信号队列 <code>task_struct-&gt;signal-&gt;shared_pending</code> 是怎么实现的。</p><ul><li>kernel/fork.c:</li><li>do_fork() -&gt; copy_process() -&gt; copy_signal()/copy_sighand()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// (1)复制父进程current的task_struct结构体到新进程p；</span></span><br><span class="line"><span class="comment">// 这里已经包含做了signal的复制动作:p-&gt;signal=current-&gt;signal</span></span><br><span class="line">p = dup_task_struct(current);</span><br><span class="line">...</span><br><span class="line">retval = copy_sighand(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line"><span class="comment">// (2)如果是创建线程(CLONE_THREAD被置位)，那么新进程和父进程共享tsk-&gt;signal结构，</span></span><br><span class="line"><span class="comment">// 不会分配新的tsk-&gt;signal结构空间</span></span><br><span class="line">retval = copy_signal(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_signal</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.1)如果是创建线程(CLONE_THREAD被置位)，不分配新的tsk-&gt;signal空间直接返回</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);</span><br><span class="line">tsk-&gt;signal = sig;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_sighand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.2)同样，也可以用CLONE_SIGHAND标志来控制是否共享tsk-&gt;sighand</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">atomic_inc(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);</span><br><span class="line">rcu_assign_pointer(tsk-&gt;sighand, sig);</span><br><span class="line"><span class="keyword">if</span> (!sig)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">atomic_set(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="keyword">sizeof</span>(sig-&gt;action));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续来看 <code>__send_signal()</code> 的具体实现：</p><ul><li>kernel/signal.c:</li><li>-&gt; <code>__send_signal()</code> -&gt; <code>prepare_signal()</code>/<code>complete_signal()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span><br><span class="line"><span class="keyword">int</span> group, <span class="keyword">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="keyword">int</span> override_rlimit;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">result = TRACE_SIGNAL_IGNORED;</span><br><span class="line"><span class="comment">// (1)判断是否可以忽略信号</span></span><br><span class="line"><span class="keyword">if</span> (!prepare_signal(sig, t,</span><br><span class="line">from_ancestor_ns || (info == SEND_SIG_FORCED)))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)选择信号pending队列</span></span><br><span class="line"><span class="comment">// 线程组共享队列(t-&gt;signal-&gt;shared_pending) or 进程私有队列(t-&gt;pending)</span></span><br><span class="line">pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment"> * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment"> * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line"><span class="comment">// (3)如果信号是常规信号(regular signal)，且已经在pending队列中，则忽略重复信号；</span></span><br><span class="line"><span class="comment">// 另外一方面也说明了，如果是实时信号，尽管信号重复，但还是要加入pending队列；</span></span><br><span class="line"><span class="comment">// 实时信号的多个信号都需要能被接收到。</span></span><br><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fast-pathed signals for kernel-internal things like SIGSTOP</span></span><br><span class="line"><span class="comment"> * or SIGKILL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4)如果是强制信号(SEND_SIG_FORCED)，不走挂载pending队列的流程，直接快速路径优先处理。</span></span><br><span class="line"><span class="keyword">if</span> (info == SEND_SIG_FORCED)</span><br><span class="line"><span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment"> * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment"> * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment"> * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment"> * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment"> * make sure at least one signal gets delivered and don't</span></span><br><span class="line"><span class="comment"> * pass on the info struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (5)符合条件的特殊信号可以突破siganl pending队列的大小限制(rlimit)</span></span><br><span class="line"><span class="comment">// 否则在队列满的情况下，丢弃信号</span></span><br><span class="line"><span class="comment">// signal pending队列大小rlimit的值可以通过命令"ulimit -i"查看</span></span><br><span class="line"><span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6)没有ignore的信号，加入到pending队列中。</span></span><br><span class="line">q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,</span><br><span class="line">override_rlimit);</span><br><span class="line"><span class="keyword">if</span> (q) &#123;</span><br><span class="line">list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_USER;</span><br><span class="line">q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">task_active_pid_ns(t));</span><br><span class="line">q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line"><span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userns_fixup_signal_uid(&amp;q-&gt;info, t);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info)) &#123;</span><br><span class="line"><span class="keyword">if</span> (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment"> * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment"> * other than kill().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_OVERFLOW_FAIL;</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment"> * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_LOSE_INFO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">signalfd_notify(t, sig);</span><br><span class="line"><span class="comment">// (7)更新pending-&gt;signal信号集合中对应的bit</span></span><br><span class="line">sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line"><span class="comment">// (8)选择合适的进程来响应信号，如果需要并唤醒对应的进程</span></span><br><span class="line">complete_signal(sig, t, group);</span><br><span class="line">ret:</span><br><span class="line">trace_signal_generate(sig, info, t, group, result);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">prepare_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">p</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> flush;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) &#123;</span><br><span class="line"><span class="comment">// (1.1)如果进程正在处于SIGNAL_GROUP_COREDUMP，则当前信号被忽略</span></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_GROUP_COREDUMP) &#123;</span><br><span class="line">pr_debug(<span class="string">"[%d:%s] is in the middle of doing coredump so skip sig %d\n"</span>, p-&gt;pid, p-&gt;comm, sig);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The process is in the middle of dying, nothing to do.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sig_kernel_stop(sig)) &#123;</span><br><span class="line"><span class="comment">// (1.2)如果当前是stop信号，则移除线程组所有线程pending队列中的SIGCONT信号</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a stop signal.  Remove SIGCONT from all queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">siginitset(&amp;flush, sigmask(SIGCONT));</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;signal-&gt;shared_pending);</span><br><span class="line">for_each_thread(p, t)</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;t-&gt;pending);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGCONT) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> why;</span><br><span class="line"><span class="comment">// (1.3)如果当前是SIGCONT信号，则移除线程组所有线程pending队列中的stop信号，并唤醒stop进程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove all stop signals from all queues, wake all threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">siginitset(&amp;flush, SIG_KERNEL_STOP_MASK);</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;signal-&gt;shared_pending);</span><br><span class="line">for_each_thread(p, t) &#123;</span><br><span class="line">flush_sigqueue_mask(&amp;flush, &amp;t-&gt;pending);</span><br><span class="line">task_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);</span><br><span class="line"><span class="keyword">if</span> (likely(!(t-&gt;ptrace &amp; PT_SEIZED)))</span><br><span class="line">wake_up_state(t, __TASK_STOPPED);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ptrace_trap_notify(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notify the parent with CLD_CONTINUED if we were stopped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If we were in the middle of a group stop, we pretend it</span></span><br><span class="line"><span class="comment"> * was already finished, and then continued. Since SIGCHLD</span></span><br><span class="line"><span class="comment"> * doesn't queue we report only CLD_STOPPED, as if the next</span></span><br><span class="line"><span class="comment"> * CLD_CONTINUED was dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">why = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_STOP_STOPPED)</span><br><span class="line">why |= SIGNAL_CLD_CONTINUED;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (signal-&gt;group_stop_count)</span><br><span class="line">why |= SIGNAL_CLD_STOPPED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (why) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The first thread which returns from do_signal_stop()</span></span><br><span class="line"><span class="comment"> * will take -&gt;siglock, notice SIGNAL_CLD_MASK, and</span></span><br><span class="line"><span class="comment"> * notify its parent. See get_signal_to_deliver().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">signal-&gt;flags = why | SIGNAL_STOP_CONTINUED;</span><br><span class="line">signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">signal-&gt;group_exit_code = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4)进一步判断信号是否会被忽略</span></span><br><span class="line"><span class="keyword">return</span> !sig_ignored(p, sig, force);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sig_ignored</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> sig, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Blocked signals are never ignored, since the</span></span><br><span class="line"><span class="comment"> * signal handler may change by the time it is</span></span><br><span class="line"><span class="comment"> * unblocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1.4.1)如果信号被blocked，不会被忽略</span></span><br><span class="line"><span class="keyword">if</span> (sigismember(&amp;t-&gt;blocked, sig) || sigismember(&amp;t-&gt;real_blocked, sig))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2)进一步判断信号的忽略条件</span></span><br><span class="line"><span class="keyword">if</span> (!sig_task_ignored(t, sig, force))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tracers may want to know about even ignored signals.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1.4.3)信号符合忽略条件，且没有被trace，则信号被忽略</span></span><br><span class="line"><span class="keyword">return</span> !t-&gt;ptrace;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sig_task_ignored</span><span class="params">(struct task_struct *t, <span class="keyword">int</span> sig, <span class="keyword">bool</span> force)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2.1)提取信号的操作函数</span></span><br><span class="line">handler = sig_handler(t, sig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2.2)如果符合条件，信号被忽略</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">handler == SIG_DFL &amp;&amp; !force)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1.4.2.3)</span></span><br><span class="line"><span class="keyword">return</span> sig_handler_ignored(handler, sig);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sig_handler_ignored</span><span class="params">(<span class="keyword">void</span> __user *handler, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Is it explicitly or implicitly ignored? */</span></span><br><span class="line"><span class="comment">// (1.4.2.3.1)如果信号操作函数是忽略SIG_IGN，或者操作函数是默认SIG_DFL但是默认动作是忽略</span></span><br><span class="line"><span class="comment">// 默认动作是忽略的信号包括：</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_IGNORE_MASK (\</span></span><br><span class="line"><span class="comment">//    rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \</span></span><br><span class="line"><span class="comment">//    rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )</span></span><br><span class="line"><span class="comment">// 忽略这一类信号</span></span><br><span class="line"><span class="keyword">return</span> handler == SIG_IGN ||</span><br><span class="line">(handler == SIG_DFL &amp;&amp; sig_kernel_ignore(sig));</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">p</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now find a thread we can wake up to take the signal off the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the main thread wants the signal, it gets first crack.</span></span><br><span class="line"><span class="comment"> * Probably the least surprising to the average bear.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.1)判断当前线程是否符合响应信号的条件</span></span><br><span class="line"><span class="keyword">if</span> (wants_signal(sig, p))</span><br><span class="line">t = p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!group || thread_group_empty(p))</span><br><span class="line"><span class="comment">// (8.2)如果信号是发给单线程的，直接返回</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There is just one thread and it does not need to be woken.</span></span><br><span class="line"><span class="comment"> * It will dequeue unblocked signals before it runs again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Otherwise try to find a suitable thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.3)在当前线程组中挑出一个符合响应信号条件的线程</span></span><br><span class="line"><span class="comment">// 从signal-&gt;curr_target线程开始查找</span></span><br><span class="line">t = signal-&gt;curr_target;</span><br><span class="line"><span class="keyword">while</span> (!wants_signal(sig, t)) &#123;</span><br><span class="line">t = next_thread(t);</span><br><span class="line"><span class="keyword">if</span> (t == signal-&gt;curr_target)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No thread needs to be woken.</span></span><br><span class="line"><span class="comment"> * Any eligible threads will see</span></span><br><span class="line"><span class="comment"> * the signal in the queue soon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">signal-&gt;curr_target = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Found a killable thread.  If the signal will be fatal,</span></span><br><span class="line"><span class="comment"> * then start taking the whole group down immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig_fatal(p, sig) &amp;&amp;</span><br><span class="line">    !(signal-&gt;flags &amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;&amp;</span><br><span class="line">    !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;</span><br><span class="line">    (sig == SIGKILL || !t-&gt;ptrace)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This signal will be fatal to the whole group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!sig_kernel_coredump(sig)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start a group exit and wake everybody up.</span></span><br><span class="line"><span class="comment"> * This way we don't have other threads</span></span><br><span class="line"><span class="comment"> * running and doing things after a slower</span></span><br><span class="line"><span class="comment"> * thread has the fatal signal pending.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">signal-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">signal-&gt;group_exit_code = sig;</span><br><span class="line">signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">t = p;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);</span><br><span class="line">sigaddset(&amp;t-&gt;pending.signal, SIGKILL);</span><br><span class="line">signal_wake_up(t, <span class="number">1</span>);</span><br><span class="line">&#125; while_each_thread(p, t);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The signal is already in the shared-pending queue.</span></span><br><span class="line"><span class="comment"> * Tell the chosen thread to wake up and dequeue it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.4)唤醒挑选出的响应信号的线程</span></span><br><span class="line">signal_wake_up(t, sig == SIGKILL);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ptrace_signal_wake_up</span><span class="params">(struct task_struct *t, <span class="keyword">bool</span> resume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal_wake_up_state(t, resume ? __TASK_TRACED : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_wake_up_state</span><span class="params">(struct task_struct *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// (8.4.1)设置thread_info-&gt;flags中的TIF_SIGPENDING标志</span></span><br><span class="line"><span class="comment">// ret_to_user()时会根据此标志来调用do_notify_resume()</span></span><br><span class="line">set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TASK_WAKEKILL also means wake it up in the stopped/traced/killable</span></span><br><span class="line"><span class="comment"> * case. We don't check t-&gt;state here because there is a race with it</span></span><br><span class="line"><span class="comment"> * executing another processor and just now entering stopped state.</span></span><br><span class="line"><span class="comment"> * By using wake_up_state, we ensure the process will wake up and</span></span><br><span class="line"><span class="comment"> * handle its death signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (8.4.2)唤醒阻塞状态为TASK_INTERRUPTIBLE的信号响应线程</span></span><br><span class="line"><span class="keyword">if</span> (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-tkill"><a href="#3-2-tkill" class="headerlink" title="3.2 tkill()"></a>3.2 <code>tkill()</code></h3><p><code>kill()</code> 是向进程组发一个信号，而 <code>tkill()</code> 是向某一个进程发送信号。</p><p><img src="signal_tkill.png" alt="tkill 调用"></p><ul><li>kernel/signal.c:</li><li>tkill() -&gt; do_tkill() -&gt; do_send_specific() -&gt; send_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(tkill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is only valid for single tasks */</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_tkill(<span class="number">0</span>, pid, sig);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_tkill</span><span class="params">(<span class="keyword">pid_t</span> tgid, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span> = &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_TKILL;</span><br><span class="line">info.si_pid = task_tgid_vnr(current);</span><br><span class="line">info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_send_specific(tgid, pid, sig, &amp;info);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">do_send_specific(<span class="keyword">pid_t</span> tgid, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, struct siginfo *info)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> error = -ESRCH;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">p = find_task_by_vpid(pid);</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; (tgid &lt;= <span class="number">0</span> || task_tgid_vnr(p) == tgid)) &#123;</span><br><span class="line"><span class="comment">// (1)tkill()符合条件1：tgid=0</span></span><br><span class="line"><span class="comment">// tgkill()需要符合条件2：tgid指定的线程组 == p所在的线程组</span></span><br><span class="line">error = check_kill_permission(sig, info, p);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The null signal is a permissions and process existence</span></span><br><span class="line"><span class="comment"> * probe.  No signal is actually delivered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; sig) &#123;</span><br><span class="line"><span class="comment">// (2)参数group=false，信号发送给单个进程组</span></span><br><span class="line">error = do_send_sig_info(sig, info, p, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If lock_task_sighand() failed we pretend the task</span></span><br><span class="line"><span class="comment"> * dies after receiving the signal. The window is tiny,</span></span><br><span class="line"><span class="comment"> * and the signal is private anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(error == -ESRCH))</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-tgkill"><a href="#3-3-tgkill" class="headerlink" title="3.3 tgkill()"></a>3.3 <code>tgkill()</code></h3><p><code>tgkill()</code> 是向特定线程组中的进程发送信号。</p><p><img src="signal_tgkill.png" alt="tgkill 调用"></p><ul><li>kernel/signal.c:</li><li>tkill() -&gt; do_tkill() -&gt; do_send_specific() -&gt; send_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(tgkill, <span class="keyword">pid_t</span>, tgid, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* This is only valid for single tasks */</span></span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span> || tgid &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_tkill(tgid, pid, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-signal"><a href="#3-4-signal" class="headerlink" title="3.4 signal()"></a>3.4 signal()</h3><p><code>signal()</code>/<code>sigaction()</code> 注册用户自定义的信号处理函数。</p><ul><li>kernel/signal.c:</li><li>signal() -&gt; do_sigaction()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(signal, <span class="keyword">int</span>, sig, <span class="keyword">__sighandler_t</span>, handler)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">new_sa</span>, <span class="title">old_sa</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">new_sa.sa.sa_handler = handler;</span><br><span class="line">new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;</span><br><span class="line">sigemptyset(&amp;new_sa.sa.sa_mask);</span><br><span class="line"></span><br><span class="line">ret = do_sigaction(sig, &amp;new_sa, &amp;old_sa);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret ? ret : (<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_sa.sa.sa_handler;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sigaction</span><span class="params">(<span class="keyword">int</span> sig, struct k_sigaction *act, struct k_sigaction *oact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> = <span class="title">current</span>, *<span class="title">t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">k</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!valid_signal(sig) || sig &lt; <span class="number">1</span> || (act &amp;&amp; sig_kernel_only(sig)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">k = &amp;p-&gt;sighand-&gt;action[sig<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock);</span><br><span class="line"><span class="keyword">if</span> (oact)</span><br><span class="line">*oact = *k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (act) &#123;</span><br><span class="line">sigdelsetmask(&amp;act-&gt;sa.sa_mask,</span><br><span class="line">      sigmask(SIGKILL) | sigmask(SIGSTOP));</span><br><span class="line"><span class="comment">// (1)将信号处理函数sighand-&gt;action[sig-1]替换成用户函数</span></span><br><span class="line">*k = *act;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * POSIX 3.3.1.3:</span></span><br><span class="line"><span class="comment"> *  "Setting a signal action to SIG_IGN for a signal that is</span></span><br><span class="line"><span class="comment"> *   pending shall cause the pending signal to be discarded,</span></span><br><span class="line"><span class="comment"> *   whether or not it is blocked."</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  "Setting a signal action to SIG_DFL for a signal that is</span></span><br><span class="line"><span class="comment"> *   pending and whose default action is to ignore the signal</span></span><br><span class="line"><span class="comment"> *   (for example, SIGCHLD), shall cause the pending signal to</span></span><br><span class="line"><span class="comment"> *   be discarded, whether or not it is blocked"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig_handler_ignored(sig_handler(p, sig), sig)) &#123;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line">sigaddset(&amp;mask, sig);</span><br><span class="line">flush_sigqueue_mask(&amp;mask, &amp;p-&gt;signal-&gt;shared_pending);</span><br><span class="line">for_each_thread(p, t)</span><br><span class="line">flush_sigqueue_mask(&amp;mask, &amp;t-&gt;pending);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-sigprocmask"><a href="#3-5-sigprocmask" class="headerlink" title="3.5 sigprocmask()"></a>3.5 <code>sigprocmask()</code></h3><p><code>sigprocmask()</code> 用来设置进程对信号是否阻塞。阻塞以后，信号继续挂载到信号 pending 队列，但是信号处理时不响应信号。<code>SIG_BLOCK</code> 命令阻塞信号，<code>SIG_UNBLOCK</code> 命令解除阻塞信号。</p><ul><li>kernel/signal.c:</li><li>sigprocmask() -&gt; set_current_blocked()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(sigprocmask, <span class="keyword">int</span>, how, <span class="keyword">old_sigset_t</span> __user *, nset,</span><br><span class="line"><span class="keyword">old_sigset_t</span> __user *, oset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">old_sigset_t</span> old_set, new_set;</span><br><span class="line"><span class="keyword">sigset_t</span> new_blocked;</span><br><span class="line"></span><br><span class="line">old_set = current-&gt;blocked.sig[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nset) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;new_set, nset, <span class="keyword">sizeof</span>(*nset)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">new_blocked = current-&gt;blocked;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (how) &#123;</span><br><span class="line"><span class="keyword">case</span> SIG_BLOCK:</span><br><span class="line">sigaddsetmask(&amp;new_blocked, new_set);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SIG_UNBLOCK:</span><br><span class="line">sigdelsetmask(&amp;new_blocked, new_set);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SIG_SETMASK:</span><br><span class="line">new_blocked.sig[<span class="number">0</span>] = new_set;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1)根据SIG_BLOCK/SIG_UNBLOCK命令来重新设计阻塞信号set current-&gt;blocked。</span></span><br><span class="line">set_current_blocked(&amp;new_blocked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oset) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(oset, &amp;old_set, <span class="keyword">sizeof</span>(*oset)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于信号阻塞 <code>current-&gt;blocked</code> 的使用在信号处理函数 <code>get_signal()</code> 中使用。</p><ul><li>arch/arm64/kernel/signal.c:</li><li>do_signal() -&gt; get_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue_signal</span><span class="params">(struct task_struct *tsk, <span class="keyword">sigset_t</span> *mask, <span class="keyword">siginfo_t</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> signr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We only dequeue private signals from ourselves, we don't let</span></span><br><span class="line"><span class="comment"> * signalfd steal them</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">signr = __dequeue_signal(&amp;tsk-&gt;pending, mask, info);</span><br><span class="line"><span class="keyword">if</span> (!signr) &#123;</span><br><span class="line">signr = __dequeue_signal(&amp;tsk-&gt;signal-&gt;shared_pending,</span><br><span class="line"> mask, info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dequeue_signal(struct sigpending *pending, <span class="keyword">sigset_t</span> *mask,</span><br><span class="line"><span class="keyword">siginfo_t</span> *info)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (1)对于pending被设置的阻塞信号，信号处理时不予响应。</span></span><br><span class="line"><span class="keyword">int</span> sig = next_signal(pending, mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sig) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;notifier) &#123;</span><br><span class="line"><span class="keyword">if</span> (sigismember(current-&gt;notifier_mask, sig)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;notifier)(current-&gt;notifier_data)) &#123;</span><br><span class="line">clear_thread_flag(TIF_SIGPENDING);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collect_signal(sig, pending, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-信号的处理"><a href="#4-信号的处理" class="headerlink" title="4.信号的处理"></a>4.信号的处理</h2><ul><li>系统对信号的处理有三种方式：</li></ul><div class="table-container"><table><thead><tr><th>信号响应</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>忽略</td><td style="text-align:center">ignore</td></tr><tr><td>调用用户态注册的处理函数</td><td style="text-align:center">如果用户有注册信号处理函数，调用 sighand-&gt;action[signr-1] 中对应的注册函数</td></tr><tr><td>调用默认的内核态处理函数</td><td style="text-align:center">如果用户没有注册对应的处理函数，调用默认的内核处理</td></tr></tbody></table></div><ul><li>默认的内核态处理，进一步可以细分为几种：</li></ul><div class="table-container"><table><thead><tr><th>信号默认内核处理类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Terminate</td><td style="text-align:center">进程被中止(杀死)。</td></tr><tr><td>Dump</td><td style="text-align:center">进程被中止(杀死)，并且输出 dump 文件。</td></tr><tr><td>Ignore</td><td style="text-align:center">信号被忽略。</td></tr><tr><td>Stop</td><td style="text-align:center">进程被停止，把进程设置为 TASK_STOPPED 状态。</td></tr><tr><td>Continue</td><td style="text-align:center">如果进程被停止（TASK_STOPPED），把它设置成 TASK_RUNNING 状态。</td></tr></tbody></table></div><h3 id="4-1-do-signal"><a href="#4-1-do-signal" class="headerlink" title="4.1 do_signal()"></a>4.1 <code>do_signal()</code></h3><p>信号处理的核心函数就是 <code>do_signal()</code>，下面我们来详细分析一下具体实现。</p><ul><li>arch/arm64/kernel/signal.c:</li><li>-&gt; ret_to_user() -&gt; do_notify_resume() -&gt; do_signal() -&gt; get_signal()/handle_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> continue_addr = <span class="number">0</span>, restart_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> syscall = (<span class="keyword">int</span>)regs-&gt;syscallno;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we were from a system call, check for system call restarting...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1)如果是 system call 被信号中断，判断是否需要重启 system call</span></span><br><span class="line"><span class="keyword">if</span> (syscall &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">continue_addr = regs-&gt;pc;</span><br><span class="line">restart_addr = continue_addr - (compat_thumb_mode(regs) ? <span class="number">2</span> : <span class="number">4</span>);</span><br><span class="line">retval = regs-&gt;regs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Avoid additional syscall restarting via ret_to_user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">regs-&gt;syscallno = ~<span class="number">0U</span>L;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prepare for system call restart. We do this here so that a</span></span><br><span class="line"><span class="comment"> * debugger will see the already changed PC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (retval) &#123;</span><br><span class="line"><span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line"><span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line"><span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line"><span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">regs-&gt;regs[<span class="number">0</span>] = regs-&gt;orig_x0;</span><br><span class="line">regs-&gt;pc = restart_addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the signal to deliver. When running under ptrace, at this point</span></span><br><span class="line"><span class="comment"> * the debugger may change all of our registers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2) 从线程的信号 pending 队列中取出信号，</span></span><br><span class="line"><span class="comment">// 如果没有对应的用户自定义处理函数，则执行默认的内核态处理函数</span></span><br><span class="line"><span class="keyword">if</span> (get_signal(&amp;ksig)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Depending on the signal settings, we may need to revert the</span></span><br><span class="line"><span class="comment"> * decision to restart the system call, but skip this if a</span></span><br><span class="line"><span class="comment"> * debugger has chosen to restart at a different PC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (regs-&gt;pc == restart_addr &amp;&amp;</span><br><span class="line">    (retval == -ERESTARTNOHAND ||</span><br><span class="line">     retval == -ERESTART_RESTARTBLOCK ||</span><br><span class="line">     (retval == -ERESTARTSYS &amp;&amp;</span><br><span class="line">      !(ksig.ka.sa.sa_flags &amp; SA_RESTART)))) &#123;</span><br><span class="line">regs-&gt;regs[<span class="number">0</span>] = -EINTR;</span><br><span class="line">regs-&gt;pc = continue_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3)如果有对应的用户自定义处理函数，则执行用户态处理函数</span></span><br><span class="line">handle_signal(&amp;ksig, regs);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle restarting a different system call. As above, if a debugger</span></span><br><span class="line"><span class="comment"> * has chosen to restart at a different PC, ignore the restart.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (4)重启被中断的system call</span></span><br><span class="line"><span class="keyword">if</span> (syscall &gt;= <span class="number">0</span> &amp;&amp; regs-&gt;pc == restart_addr) &#123;</span><br><span class="line"><span class="keyword">if</span> (retval == -ERESTART_RESTARTBLOCK)</span><br><span class="line">setup_restart_syscall(regs);</span><br><span class="line">user_rewind_single_step(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restore_saved_sigmask();</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> = <span class="title">current</span>-&gt;<span class="title">sighand</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">current</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line"><span class="keyword">int</span> signr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.1)执行task work机制中的work</span></span><br><span class="line"><span class="comment">// 这是和信号无关的机制，属于搭便车在ret_to_user时刻去执行的机制</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">task_work_run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(uprobe_deny_signal()))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do this once, we can't return to user-mode if freezing() == T.</span></span><br><span class="line"><span class="comment"> * do_signal_stop() and ptrace_stop() do freezable_schedule() and</span></span><br><span class="line"><span class="comment"> * thus do not need another check after return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.2)第二个搭便车的机制freeze，</span></span><br><span class="line"><span class="comment">// 系统在suspend时会调用suspend_freeze_processes()来freeze线程</span></span><br><span class="line"><span class="comment">// 实际上也是唤醒线程，让线程在ret_to_user时刻去freeze自己</span></span><br><span class="line">try_to_freeze();</span><br><span class="line"></span><br><span class="line">relock:</span><br><span class="line">spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every stopped thread goes here after wakeup. Check to see if</span></span><br><span class="line"><span class="comment"> * we should notify the parent, prepare_signal(SIGCONT) encodes</span></span><br><span class="line"><span class="comment"> * the CLD_ si_code into SIGNAL_CLD_MASK bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.3)在子进程状态变化的情况下，发送SIGCHLD信号通知父进程</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line"><span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">why = CLD_CONTINUED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notify the parent that we're continuing.  This event is</span></span><br><span class="line"><span class="comment"> * always per-process and doesn't make whole lot of sense</span></span><br><span class="line"><span class="comment"> * for ptracers, who shouldn't consume the state via</span></span><br><span class="line"><span class="comment"> * wait(2) either, but, for backward compatibility, notify</span></span><br><span class="line"><span class="comment"> * the ptracer of the group leader too unless it's gonna be</span></span><br><span class="line"><span class="comment"> * a duplicate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line"><span class="literal">true</span>, why);</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_STOP_PENDING) &amp;&amp;</span><br><span class="line">    do_signal_stop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_TRAP_MASK)) &#123;</span><br><span class="line">do_jobctl_trap();</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.4)从信号pending队列中，取出优先级最好的信号</span></span><br><span class="line">signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;ptrace) &amp;&amp; signr != SIGKILL) &#123;</span><br><span class="line">signr = ptrace_signal(signr, &amp;ksig-&gt;info);</span><br><span class="line"><span class="keyword">if</span> (!signr)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.5)从信号处理数组sighand中，取出信号对应的处理函数</span></span><br><span class="line">ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Trace actually delivered signals. */</span></span><br><span class="line">trace_signal_deliver(signr, &amp;ksig-&gt;info, ka);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.1)信号处理的第1种方法：忽略</span></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// (2.6.2)信号处理的第2种方法：调用用户态注册的处理函数</span></span><br><span class="line"><span class="comment">// 获取到用户态的处理函数指针，返回调用handle_signal()来执行</span></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line"><span class="comment">/* Run the handler.  */</span></span><br><span class="line">ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.3)信号处理的第3种方法：调用默认的内核态处理函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now we are doing the default action for this signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.6.3.1)SIG_KERNEL_IGNORE_MASK信号的默认处理方法Ignore：忽略</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_IGNORE_MASK (\</span></span><br><span class="line"><span class="comment">//        rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Global init gets no signals it doesn't want.</span></span><br><span class="line"><span class="comment"> * Container-init gets no signals it doesn't want from same</span></span><br><span class="line"><span class="comment"> * container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if global/container-init sees a sig_kernel_only()</span></span><br><span class="line"><span class="comment"> * signal here, the signal must have been generated internally</span></span><br><span class="line"><span class="comment"> * or must have come from an ancestor namespace. In either</span></span><br><span class="line"><span class="comment"> * case, the signal cannot be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">!sig_kernel_only(signr))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.3.2)SIG_KERNEL_STOP_MASK信号的默认处理方法Stop：do_signal_stop()</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_STOP_MASK (\</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_stop(signr)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The default action is to stop all threads in</span></span><br><span class="line"><span class="comment"> * the thread group.  The job control signals</span></span><br><span class="line"><span class="comment"> * do nothing in an orphaned pgrp, but SIGSTOP</span></span><br><span class="line"><span class="comment"> * always works.  Note that siglock needs to be</span></span><br><span class="line"><span class="comment"> * dropped during the call to is_orphaned_pgrp()</span></span><br><span class="line"><span class="comment"> * because of lock ordering with tasklist_lock.</span></span><br><span class="line"><span class="comment"> * This allows an intervening SIGCONT to be posted.</span></span><br><span class="line"><span class="comment"> * We need to check for that and bail out if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (signr != SIGSTOP) &#123;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signals can be posted during this window */</span></span><br><span class="line"><span class="comment">// 不是SIGSTOP信号，且是孤儿进程组</span></span><br><span class="line"><span class="keyword">if</span> (is_current_pgrp_orphaned())</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123;</span><br><span class="line"><span class="comment">/* It released the siglock.  */</span></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We didn't actually stop, due to a race</span></span><br><span class="line"><span class="comment"> * with SIGCONT or something like that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Anything else is fatal, maybe with a core dump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">current-&gt;flags |= PF_SIGNALED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2.6.3.3)SIG_KERNEL_COREDUMP_MASK信号的默认处理方法Dump：do_coredump() &amp; do_group_exit()</span></span><br><span class="line"><span class="comment">// #define SIG_KERNEL_COREDUMP_MASK (\</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \</span></span><br><span class="line"><span class="comment">// rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \</span></span><br><span class="line"><span class="comment">//         rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \</span></span><br><span class="line"><span class="comment">// SIGEMT_MASK       )</span></span><br><span class="line"><span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">proc_coredump_connector(current);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it was able to dump core, this kills all</span></span><br><span class="line"><span class="comment"> * other threads in the group and synchronizes with</span></span><br><span class="line"><span class="comment"> * their demise.  If we lost the race with another</span></span><br><span class="line"><span class="comment"> * thread getting here, it set group_exit_code</span></span><br><span class="line"><span class="comment"> * first and our do_group_exit call below will use</span></span><br><span class="line"><span class="comment"> * that value and ignore the one we pass it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Death signals, no core dump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (2.6.3.4)Death signals信号的默认处理方法Terminate：do_group_exit()</span></span><br><span class="line">do_group_exit(ksig-&gt;info.si_signo);</span><br><span class="line"><span class="comment">/* NOTREACHED */</span></span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">ksig-&gt;sig = signr;</span><br><span class="line"><span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户没有注册信号处理函数，默认的内核处理函数在 <code>get_signal()</code> 函数中执行完了。对于用户有注册处理函数的信号，但是因为这些处理函数都是用户态的，所以内核使用了一个技巧：先构造堆栈，返回用户态去执行自定义信号处理函数，再返回内核态继续被信号打断的返回用户态的动作。</p><p><img src="signal_handle_signal.png" alt="信号处理"></p><p>我们来看 <code>handle_signal()</code> 函数中的具体实现。</p><ul><li>arch/arm64/kernel/signal.c:</li><li>-&gt; ret_to_user() -&gt; do_notify_resume() -&gt; do_signal() -&gt; handle_signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(struct ksignal *ksig, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">thread</span> = <span class="title">current_thread_info</span>();</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> *oldset = sigmask_to_save();</span><br><span class="line"><span class="keyword">int</span> usig = ksig-&gt;sig;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * translate the signal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (usig &lt; <span class="number">32</span> &amp;&amp; thread-&gt;exec_domain &amp;&amp; thread-&gt;exec_domain-&gt;signal_invmap)</span><br><span class="line">usig = thread-&gt;exec_domain-&gt;signal_invmap[usig];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the stack frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (1)构造返回堆栈，将用户态返回地址替换成用户注册的信号处理函数&amp;ksig-&gt;ka</span></span><br><span class="line"><span class="keyword">if</span> (is_compat_task()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO)</span><br><span class="line">ret = compat_setup_rt_frame(usig, ksig, oldset, regs);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = compat_setup_frame(usig, ksig, oldset, regs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = setup_rt_frame(usig, ksig, oldset, regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that the resulting registers are actually sane.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret |= !valid_user_regs(&amp;regs-&gt;user_regs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fast forward the stepping logic so we step into the signal</span></span><br><span class="line"><span class="comment"> * handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">user_fastforward_single_step(tsk);</span><br><span class="line"></span><br><span class="line">signal_setup_done(ret, ksig, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_ULK"><sup>ULK</sup>. <a href="http://shop.oreilly.com/product/9780596000028.do" target="_blank" rel="noopener">Understanding the Linux Kernel</a><a href="#reffn_ULK" title="Jump back to footnote [ULK] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 进程管理与通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signal </tag>
            
            <tag> Linux 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析 Android M 锁屏密码存储方式</title>
      <link href="/2016/06/25//lockcreen-password.html/"/>
      <url>/2016/06/25//lockcreen-password.html/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-M-之前锁屏密码的存储"><a href="#Android-M-之前锁屏密码的存储" class="headerlink" title="Android M 之前锁屏密码的存储"></a>Android M 之前锁屏密码的存储</h2><p>在 Android M 之前，锁屏密码的存储格式很简单，其使用了 64 位随机数作为 salt 值，此 salt 值被存储在 SQLite 数据库 <code>/data/system/locksettings.db</code> 中。密码在存储的时候，会将输入的密码加上此随机数组成新的字符串。然后对新的字符串分别进行 SHA-1 和 MD5 加密，将加密后的密文通过 MD5 + SHA-1 的方式进行字符串拼接，组成新的密文存储在 <code>/data/system/password.key</code> 中，共有 72 位。其加密后的形式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data<span class="built_in">/system </span># cat password.key</span><br><span class="line">B40C2F6FE4E89F3386D4E689B135304410D64951914FB35770FDAC58B694177B29297A80</span><br></pre></td></tr></table></figure><p>而密码的详细信息，存储在 <code>/data/system/device_policies.xml</code> 中，内容类似如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/system # cat device_policies.xml</span><br><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">policies</span> <span class="attr">setup-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">active-password</span> <span class="attr">quality</span>=<span class="string">"196608"</span> <span class="attr">length</span>=<span class="string">"4"</span> <span class="attr">uppercase</span>=<span class="string">"0"</span> <span class="attr">lowercase</span>=<span class="string">"0"</span> <span class="attr">letters</span>=<span class="string">"0"</span> <span class="attr">numeric</span>=<span class="string">"4"</span> <span class="attr">symbols</span>=<span class="string">"0"</span> <span class="attr">nonletter</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中主要用到的两个字段 quality 是密码的类型，简单密码和复杂密码的值不同，length 是密码的长度，其他字段存储密码中各种字符的数量。</p><h2 id="Android-M-中锁屏密码的存储"><a href="#Android-M-中锁屏密码的存储" class="headerlink" title="Android M 中锁屏密码的存储"></a>Android M 中锁屏密码的存储</h2><p>在 Android M 中，锁屏密码的存储格式发生了变化，其默认的存储格式在 <code>/system/gatekeeper/include/gatekeeper/password_handle.h</code> 中描述如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> <span class="keyword">secure_id_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> <span class="keyword">salt_t</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * structure for easy serialization</span></span><br><span class="line"><span class="comment"> * and deserialization of password handles.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> HANDLE_VERSION = <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">password_handle_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// fields included in signature</span></span><br><span class="line">    <span class="keyword">uint8_t</span> version;</span><br><span class="line">    <span class="keyword">secure_id_t</span> user_id;</span><br><span class="line">    <span class="keyword">uint64_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields not included in signature</span></span><br><span class="line">    <span class="keyword">salt_t</span> salt;</span><br><span class="line">    <span class="keyword">uint8_t</span> signature[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hardware_backed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 version 默认是 2，user_id 是 Android 用户 id ，signature 存储的便是密文，hardware_backed 存储的是加密方式，0 表示密文是软件加密，而 1 表示密文是通过 TEE 环境进行加密得到的。</p><p>密码加密后默认以 <code>password_handle_t</code> 格式存储在 <code>/data/system/gatekeeper.password.key</code> 中。密码的生成和校验，在 HAL 层是通过 <code>system/core/gatekeeperd/gatekeeperd.cpp</code> 中的函数实现的。其在系统启动时被注册为 gatekeeperd 服务，服务在启动的时候会调用 <code>GateKeeperProxy()</code> 对象，此类的构造函数会去查找 TEE module，如果找到，则通过 TEE 设备进行加解密，如果没有找到，则通过一个软件设备进行加解密。</p><p>这里主要分析下通过软甲设备解密的逻辑。解密时，会调用到 <code>system/core/gatekeeperd/gatekeeperd.cpp</code> 中的以下函数：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> verify(<span class="built_in">uint</span>32_t uid, <span class="keyword">const</span> <span class="built_in">uint</span>8_t *enrolled_password_handle,</span><br><span class="line">            <span class="built_in">uint</span>32_t enrolled_password_handle_length,</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">uint</span>8_t *provided_password, <span class="built_in">uint</span>32_t provided_password_length,</span><br><span class="line">            <span class="built_in">bool</span> *request_reenroll)</span><br></pre></td></tr></table></figure><p>在此函数中，由于没有使用 TEE，所以会调用到软件设备验证 <code>system/core/gatekeeperd/SoftGateKeeperDevice.cpp</code> 中的：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> SoftGateKeeperDevice::verify(<span class="built_in">uint</span>32_t uid,</span><br><span class="line"><span class="built_in">uint</span>64_t challenge, <span class="keyword">const</span> <span class="built_in">uint</span>8_t *enrolled_password_handle,</span><br><span class="line"><span class="built_in">uint</span>32_t enrolled_password_handle_length, <span class="keyword">const</span> <span class="built_in">uint</span>8_t *provided_password,</span><br><span class="line"><span class="built_in">uint</span>32_t provided_password_length, <span class="built_in">uint</span>8_t **auth_token, <span class="built_in">uint</span>32_t *auth_token_length,</span><br><span class="line"><span class="built_in">bool</span> *request_reenroll)</span><br></pre></td></tr></table></figure><p>函数进行校验，此函数对传进来的信息进行处理后交到 <code>system/gatekeeper/gatekeeper.cpp</code> 中的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void GateKeeper::<span class="constructor">Verify(<span class="params">const</span> VerifyRequest &amp;<span class="params">request</span>, VerifyResponse <span class="operator">*</span><span class="params">response</span>)</span></span><br></pre></td></tr></table></figure><p>进行处理，在这里对参数进行一系列处理和重新组织后再交给</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> GateKeeper::<span class="constructor">DoVerify(<span class="params">const</span> <span class="params">password_handle_t</span> <span class="operator">*</span><span class="params">expected_handle</span>, <span class="params">const</span> SizedBuffer &amp;<span class="params">password</span>)</span></span><br></pre></td></tr></table></figure><p>进行校验，在此函数中，再调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GateKeeper::CreatePasswordHandle</span><span class="params">(SizedBuffer *password_handle_buffer, <span class="keyword">salt_t</span> salt,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">secure_id_t</span> user_id, <span class="keyword">uint64_t</span> flags, <span class="keyword">uint8_t</span> handle_version, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *password,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint32_t</span> password_length)</span></span></span><br></pre></td></tr></table></figure><p>将上面提到的 <code>/data/system/gatekeeper.password.key</code> 文件中存储的信息进行解析，然后调用</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ComputePasswordSignature(<span class="name">password_handle-&gt;signature</span>, sizeof(<span class="name">password_handle-&gt;signature</span>),</span><br><span class="line">            password_key, password_key_length, to_sign, sizeof(<span class="name">to_sign</span>), salt)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>函数将输入的密码进行加密，从这里可以看到，输入的密码要加密成密文只需要用到存储的密码中的 salt 值，此函数在 <code>system/core/gatekeeperd/SoftGateKeeper.h</code> 中，其调用 crypto 库中的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crypto_scrypt(password, password_length, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;(&amp;salt),</span><br><span class="line"><span class="keyword">sizeof</span>(salt), N, r, p, signature, signature_length);</span><br></pre></td></tr></table></figure><p>将输入的密码存储在 signature 中并返回。此函数最终会通过 SHA256 进行加密，参数中的 N, r, p 默认为如下值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">const</span> <span class="built_in">uint</span>64_t N = <span class="number">16384</span>;</span><br><span class="line">static <span class="keyword">const</span> <span class="built_in">uint</span>32_t r = <span class="number">8</span>;</span><br><span class="line">static <span class="keyword">const</span> <span class="built_in">uint</span>32_t p = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>通过以上处理后对输入的密码加密后得到的密文与手机中存储的密文进行比较后返回校验结果，从而判断输入的密码的正确与否。</p><p>在 Android M 中，改变了之前直接在 Java 层进行密码校验的方式，将密码的校验通过 HAL 层的服务进行处理，同时加入对 TEE 的支持，使得锁屏密码的安全性大大提升，同时也可以方便的支持其他的安全特性，提升了整个系统的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> lockcreen </tag>
            
            <tag> 锁屏 </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球面拟合算法</title>
      <link href="/2016/06/18//nonlinear-regression.html/"/>
      <url>/2016/06/18//nonlinear-regression.html/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在传感器数据融合以及工业测量中，常常需要对已知的数据或者是已知的结构的特征参数进行检测，来评估数据的信噪比或者结构的质量是否符合产品的需求。一般的，可以通过记录大量数据或者通过结构的离散点，来反解出它的特征参数。<br>以球面为例，这些特征参数可以是球的半径，或者是球心等。对于球体拟合算法，通常有代数拟合和几何拟合。在本例中，以一般的代数拟合方法为主进行介绍。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>以下图的数据为例，我们可以明显看出这些数据“可能”是一个球体，那么我们应该如何来得到这个球体的半径以及球心？</p><p><img src="pic1.png" alt="拟合前示意图"></p><p>从如此多的数据中很明显可以看到，最后的执行方程组肯定是超定方程组。正常来看，超定方程组是没有解的，但在数值计算领域我们可以以最优解的形式来获得我们想要的参数。正所谓，有总比没有好，迟到总比不到好，是吧。</p><p>话不多说，原始数据经过剔除异常点以及滤波之后，我们假设这些离散点为</p><p>Pi = (Xi,Yi,Zi), i = 1，2，…，n</p><p>假如球的球心m为 (a,b,c)，球的半径为 r，则球的标准方程为</p><p>(x-a)^2 + (y-b)^2 + (z-c)^2 = r^2</p><p>以 Di 表示离散点 Pi 到 m 的距离，即</p><p>Di^2 = (Xi-a)^2 + (Yi-b)^2 + (Zi-c)^2, i = 1，2，…，n。</p><p>令残差平方和 S = <img src="chart.png" alt=""><br>其中 i = 1，2，…，n。</p><p>为了选取最合适的让该等式”尽量成立”，只需要让 S 为最小值即可。也就是说，b` = argmin(S)。而且很明显，S 肯定存在大于或等于 0 的极小值。由逼近算法可以罗列出超定方程组，在这里，我们将球的标准方程展开然后代入 S 中，将 S 对其中的未知数求偏导，令偏导为 0，得到极值点，比较之后即可得到最小值。由于解方程是比较基础的内容，本例中就不罗列出来了。</p><p>这个时候，就可以将 b` 中的数据直接代入球的标准方程，看看是否得到了我们想要的球面。一般的，可以直接得到比较好的球面了。</p><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>这个时候还没有结束，我们还需要对我们所得到的球面进行评定，看看是否误差在允许的范围之内，这个范围取决于个人或者组织对产品的定义。我们可以将所得到的最优解 b` 以及离散点Pi的均方误差作为评定的参考，假如均方误差不在允许范围之内，可以再次进行剔除异常值还有滤波，一直迭代，直到数据满足要求。</p><h2 id="原理扩展"><a href="#原理扩展" class="headerlink" title="原理扩展"></a>原理扩展</h2><p>从上述例子中，我们可以知道，该算法不仅可以从大量已知数据得出最优解，也可以从四个不共面的点来确定一球面，甚至可以通过结构的球冠来得到最匹配的球面。</p><p>下图是经过剔除异常值并且滤波之后，由上述逼近算法拟合得到的最优解。</p><p><img src="pic2.png" alt="最优解拟合图"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个案例还比较容易，因为仅有 4 个未知量，而且也不需要考虑三维空间旋转。如果大伙搞懂了这个，下次再来给大伙讲讲二次曲面/椭球拟合算法（结合三维空间旋转，大概 10 个未知数）或者扩展卡尔曼滤波结合四元数进行姿态解算。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《概率论与数理统计》（第 4 版）盛骤</p>]]></content>
      
      
      <categories>
          
          <category> 传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> sensors </tag>
            
            <tag> 球面拟合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机系统综述 —— ISP</title>
      <link href="/2016/06/04//camera-isp-intro.html/"/>
      <url>/2016/06/04//camera-isp-intro.html/</url>
      
        <content type="html"><![CDATA[<p>ISP(Image Signal Processor)，即图像信号处理器，用于处理图像信号传感器输出的图像信号。它在相机系统中占有核心主导的地位，是构成相机的重要设备。</p><h2 id="主要内部构成"><a href="#主要内部构成" class="headerlink" title="主要内部构成"></a>主要内部构成</h2><p>如下图所示，ISP 内部包含 CPU、SUP IP、IF 等设备，事实上，可以认为 ISP 是一个 SOC，可以运行各种算法程序，实时处理图像信号。<br><img src="isp_archi.PNG" alt="ISP 架构"></p><ul><li><p>CPU</p><p>CPU 即中央处理器，可以运行 AF、LSC 等各种图像处理算法，控制外围设备。现代的 ISP 内部的 CPU 一般都是 ARM Cortex-A 系列的，例如 Cortex-A5、Cortex-A7。</p></li><li><p>SUB IP</p><p>SUB IP 是各种功能模块的通称，对图像进行各自专业的处理。常见的 SUB IP 如 DIS、CSC、VRA 等。</p></li><li><p>图像传输接口</p><p>图像传输接口主要分两种，并口 ITU 和串口 CSI。CSI 是 MIPI CSI 的简称，鉴于 MIPI CSI 的诸多优点，在手机相机领域，已经广泛使用 MIPI-CSI 接口传输图像数据和各种自定义数据。外置 ISP 一般包含 MIPI-CSIS 和 MIPI-CSIM 两个接口。内置 ISP 一般只需要 MIPI-CSIS 接口。</p></li><li><p>通用外围设备</p><p>通用外围设备指 I2C、SPI、PWM、UART、WATCHDOG 等。ISP 中包含 I2C 控制器，用于读取 OTP 信息，控制 VCM 等。对于外置 ISP，ISP 本身还是 I2C 从设备。AP 可以通过 I2C 控制 ISP 的工作模式，获取其工作状态等。</p></li></ul><h2 id="主要功能特性"><a href="#主要功能特性" class="headerlink" title="主要功能特性"></a>主要功能特性</h2><p>ISP 作为图像处理的核心器件，拥有十分重要的功能，下图展示了 ISP 处理图像数据的基本流程。</p><p><img src="isp_process.jpg" alt="ISP 处理流程"></p><p>下面针对 ISP 的主要功能特性进行下介绍。</p><ul><li><p>DEMOSAIC</p><p>DEMOSAIC 是 ISP 的主要功能之一。SENSOR 的像素点上覆盖着 CFA，光线通过 CFA 后照射到像素上。CFA 由 R、G、B 三种颜色的遮光罩组成，每种遮光罩只允许一种颜色通过，因此每个像素输出的信号只包含 R、G、B 三者中的一种颜色信息。SENSOR 输出的这种数据就是 BAYER 数据，即通常所说的 RAW 数据。显而易见，RAW 数据所反映的颜色信息不是真实的颜色信息。DEMOSAIC 就是通过插值算法将将每个像素所代表的真实颜色计算出来。</p></li><li><p>FOCUS</p><p>根据光学知识，景物在传感器上成像最清晰时处于合焦平面上。通过更改 LENS 的位置，使得景物在传感器上清晰的成像，是 ISP FOCUS 功能所需要完成的任务。FOCUS 分为手动和自动两种模式。ISP 可以运行 CONTRAST AF、PDAF、LASER AF 等算法实现自动对焦。</p></li><li><p>EXPOSURE</p><p>曝光。EXPOSURE 主要影响图像的明暗程度。ISP 需要实现 AE 功能，通过控制曝光程度，使得图像亮度适宜。</p></li><li><p>WB</p><p>白平衡。白平衡与色温相关，用于衡量图像的色彩真实性和准确性。ISP需要实现 AWB 功能，力求在各种复杂场景下都能精确的还原物体本来的颜色。</p></li><li><p>LSC</p><p>用于消除图像周边和图片中心的不一致性，包含亮度和色度两方面。ISP 需要借助 OTP 中的校准数据完成 LSC 功能。</p></li><li><p>GAMMA CORRECTION</p><p>伽玛校正。传感器对光线的响应和人眼对光线的响应是不同的。伽玛校正就是使得图像看起来符合人眼的特性。</p></li><li><p>CROP/RESIZE</p><p>图像剪裁，即改变图像的尺寸。可用于输出不同分辨率的图像。</p></li><li><p>VRA</p><p>视觉识别。用于识别特定的景物，例如人脸识别，车牌识别。ISP 通过各种 VRA 算法，准确的识别特定的景物。</p></li><li><p>DRC</p><p>动态范围校正。动态范围即图像的明暗区间。DRC 可以使得暗处的景物不至于欠曝，而亮处的景物不至于过曝。ISP 需要支持 DRC 功能。</p></li><li><p>CSC</p><p>颜色空间转换。例如，ISP 会将 RGB 信号转化为 YUV 信号输出。</p></li><li><p>IS</p><p>图像稳定。IS 的主要作用是使得图像不要因为手持时轻微的抖动而模糊不清。IS 有很多种，例如 OIS、DIS、EIS。ISP 可以实现 DIS 和 EIS。</p></li></ul><p>事实上，ISP 除了上面提到的主要功能外，还需要支持 DENOISE、CONTRAST、SATURATION、SHARPNESS 等调整功能。</p><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><p>这里所说的控制方式是 AP 对 ISP 的操控方式。</p><ul><li><p>I2C/SPI</p><p>这一般是外置 ISP 的做法。SPI 一般用于下载固件、I2C 一般用于寄存器控制。在内核的 ISP 驱动中，外置 ISP 一般是实现为 I2C 设备，然后封装成 V4L2-SUBDEV。</p></li><li><p>MEM MAP</p><p>这一般是内置 ISP 的做法。将 ISP 内部的寄存器地址空间映射到内核地址空间，</p></li><li><p>MEM SHARE</p><p>这也是内置 ISP 的做法。AP 这边分配内存，然后将内存地址传给 ISP，二者实际上共享同一块内存。因此 AP 对这段共享内存的操作会实时反馈到 ISP 端。</p></li></ul><h2 id="ISP-架构方案"><a href="#ISP-架构方案" class="headerlink" title="ISP 架构方案"></a>ISP 架构方案</h2><p>上文多次提到外置 ISP 和内置 ISP，这实际上是 ISP 的架构方案。</p><h3 id="外置-ISP-架构"><a href="#外置-ISP-架构" class="headerlink" title="外置 ISP 架构"></a>外置 ISP 架构</h3><p>外置 ISP 架构是指在 AP 外部单独布置 ISP 芯片用于图像信号处理。外置 ISP 的架构图一般如下所示：</p><p><img src="isp_ext.PNG" alt="外置 ISP 架构图"></p><p>外置 ISP 架构的优点主要有：</p><ul><li><p>能够提供更优秀的图像质量</p><p>在激烈的市场竞争下，能够存活到现在的外置 ISP 生产厂商在此领域一般都有很深的造诣，积累了丰富的影像质量调试经验，能够提供比内置 ISP 更优秀的性能和效果。因此，选用优质的外置 ISP 能提供专业而且优秀的图像质量。</p></li><li><p>能够支援更丰富的设计规划</p><p>外置 ISP 的选型基本不受 AP 的影响，因此魅族可以从各个优秀 ISP 芯片供应商的众多产品中甄选最合适的器件，从而设计出更多优秀的产品。</p></li><li><p>能够实现产品的差异化</p><p>内置 ISP 是封装在 AP 内部的，是和 AP 紧密的联系在一起，如果 AP 相同，那么 ISP 也就是一样的。因此基于同样 AP 生产出来的手机，其 ISP 的性能也是一样的，可供调教的条件也是固定的，这样就不利于实现产品的差异化。而如果选择外置 ISP，那么同一颗 AP，可以搭配不同型号的 ISP，这样可以实现产品的差异化，为给用户提供更丰富和优质的产品。</p></li></ul><p>外置 ISP 架构的缺点主要有：</p><ul><li><p>成本价格高</p><p>外置 ISP 需要单独购买，其售价往往不菲，而且某些特殊功能还需要额外支付费用。使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件。</p></li><li><p>开发周期长</p><p>外置 ISP 驱动的设计需要多费精力和时间。使用外置 ISP 时，AP 供应商提供的 ISP 驱动就无法使用，需要额外设计编写外置 ISP 驱动。另外，为了和 AP 进行完美的搭配，将效果最大化，也往往需要付出更多的调试精力。上文也提到，使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件，这也是需要花费时间进行处理的。</p></li></ul><h3 id="内置-ISP-架构"><a href="#内置-ISP-架构" class="headerlink" title="内置 ISP 架构"></a>内置 ISP 架构</h3><p>内置 ISP 架构是指在 AP 内部嵌入了 ISP IP，直接使用 AP 内部的 ISP 进行图像信号处理。<br>内置 ISP 的架构图一般如下所示：</p><p><img src="isp_int.PNG" alt="内置 ISP 架构图"></p><p>内置 ISP 架构的优点主要有：</p><ul><li><p>能降低成本价格</p><p>内置 ISP 内嵌在 AP 内部，因此无需像外置 ISP 一样需要额外购买，且不占 PCB 空间，无需单独为其设计外围电路，这样就能节省 BOM，降低成本。鉴于大多数用户在选购手机时会将价格因素放在重要的位置，因此降低成本能有效的降低终端成品价格，有利于占领市场。</p></li><li><p>能提高产品的上市速度</p><p>内置 ISP 和 AP 紧密结合，无需进行原理图设计和 LAYOUT 设计，因此可以减小开发周期，加快产品上市的速度。</p></li><li><p>能降低开发难度</p><p>如果使用内置 ISP，那么 AP 供应商能在前期提供相关资料，驱动开发人员可以有充足的时间熟悉相关资料，而且不会存在软件版本适配问题，也不存在平台架构兼容性问题。但是，如果使用外置 ISP，那么 ISP 供应商往往都不能提供针对某个平台的代码/资料，而且一般都存在软件版本兼容问题，这就需要驱动开发人员付出额的经历和时间。</p></li></ul><p>使用内置 ISP 当然也有相应的不足之处，具体见上文的分析，这里就不赘述了。</p><p>事实上，鉴于 ISP 的重要性，为了推广其 AP，提高其 AP 竞争力，现在 AP 内置的 ISP 也越来越强大，其性能足以满足手机市场的需求。再加上其一系列优点，现在使用内置 ISP 方案的手机越来越多。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ISP 是相机系统中重要的组成部分，要了解相机系统，就不能不熟悉 ISP。本文从 ISP 内部构成、功能特性、操控方式等角度介绍了 ISP 的各方面知识。另外，本文还详细的分析了两种架构的 ISP 方案的优缺点，希望能有所裨益。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://source.android.com/devices/camera/index.html" target="_blank" rel="noopener">Google Camera</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPUIDLE 之低功耗定时器</title>
      <link href="/2016/05/27//cpuidle.html/"/>
      <url>/2016/05/27//cpuidle.html/</url>
      
        <content type="html"><![CDATA[<p>在 Linux 操作系统中，Idle 进程（又叫 Swapper 进程）的 pid 号是 0，是所有进程的祖先，它是在 Linux 初始化阶段从无到有创建的一个内核线程。<code>stark_kernel()</code> 函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程 1 的内核线程（init 进程）。新创建内核线程的 PID 为 1，并与进程 0 共享进程所有的内核数据结构。创建 init 进程后，进程 0 执行无限循环， <code>cpu_idle_loop()</code> 函数，只有当没有其它进程处于 TASK_RUNNING 状态时，调度器才会选择进程 0，也就是执行 Idle 线程，让 CPU 进入 Idle 模式。</p><p>当 CPU 进入比较深层次的 Idle 模式时，为了达到最大程度的节省功耗，CPU 会把系统时钟给关闭掉。那么怎么保证 CPU 从 Idle 模式重新进入工作模式，从而保证系统正常运行呢？本文主要探讨低功耗定时器在该情况下扮演什么样的角色。</p><h2 id="Idle的执行流程"><a href="#Idle的执行流程" class="headerlink" title="Idle的执行流程"></a>Idle的执行流程</h2><p>这里先大概的列出 Idle 进程的执行流程，怎么执行到让 CPU 进入各级 Idle 模式。详细的分析会在以后的文章中补上。</p><h3 id="Idle-进程创建"><a href="#Idle-进程创建" class="headerlink" title="Idle 进程创建"></a>Idle 进程创建</h3><p>Linux Kernel 会在系统启动完成后，在 Idle 进程中，处理 CPUIdle 相关的事情。在多核系统中，CPU 启动的过程是，先启动主 CPU，启动过程和传统的单核系统类似。其函数调用关系如下：</p><p>stext —&gt; start_kernel —&gt; rest_init —&gt; cpu_startup_entry</p><p>而启动其它 CPU，可以有多种方式，例如 CPU hotplug 等，启动过程：</p><p>secondary_startup —&gt; __secondary_switched —&gt; secondary_start_kernel —&gt; cpu_startup_entry</p><p>无论是上述的哪种启动，最终都会运行至 cpu_startup_entry 函数，在这个函数中，最终程序会掉进无限循环里 cpu_idle_loop。到此，Idle 进程创建完成，以下是 Idle 进程的代码实现（参考的是 linux-3.18 版本）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static void cpu<span class="constructor">_idle_loop(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="constructor">__current_set_polling()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭周期 tick，CONFIG_NO_HZ_IDLE 必须打开 */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果系统当前不需要调度，执行后续的动作 */</span></span><br><span class="line"><span class="keyword">while</span> (!need<span class="constructor">_resched()</span>) &#123;</span><br><span class="line">check<span class="constructor">_pgt_cache()</span>;</span><br><span class="line">rmb<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu<span class="constructor">_is_offline(<span class="params">smp_processor_id</span>()</span>)) &#123;</span><br><span class="line">tick<span class="constructor">_set_cpu_plugoff_flag(1)</span>;</span><br><span class="line">arch<span class="constructor">_cpu_idle_dead()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 irq 中断 */</span></span><br><span class="line">local<span class="constructor">_irq_disable()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* arch 相关的 cpuidle enter, 主要执行注册到 idle 的 notify callback */</span></span><br><span class="line">arch<span class="constructor">_cpu_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu_idle_force_poll<span class="operator"> || </span>tick<span class="constructor">_check_broadcast_expired()</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* idle poll，这时先不分析 */</span></span><br><span class="line">cpu<span class="constructor">_idle_poll()</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进入 CPU 的 Idle 模式，进行省电 */</span></span><br><span class="line">cpuidle<span class="constructor">_idle_call()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Idle 退出, 主要执行注册到 idle 的 notify callback */</span></span><br><span class="line">arch<span class="constructor">_cpu_idle_exit()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果系统当前需要调度，则退出 Idle 进程 */</span></span><br><span class="line">preempt<span class="constructor">_set_need_resched()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开周期 tick */</span></span><br><span class="line">tick<span class="constructor">_nohz_idle_exit()</span>;</span><br><span class="line"><span class="constructor">__current_clr_polling()</span>;</span><br><span class="line"></span><br><span class="line">smp<span class="constructor">_mb__after_atomic()</span>;</span><br><span class="line"></span><br><span class="line">sched<span class="constructor">_ttwu_pending()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 让出 cpu，使调度器调度其它优化级更高的进程 */</span></span><br><span class="line">schedule<span class="constructor">_preempt_disabled()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tickless-和-CPUIdle-的关系"><a href="#Tickless-和-CPUIdle-的关系" class="headerlink" title="Tickless 和 CPUIdle 的关系"></a>Tickless 和 CPUIdle 的关系</h2><p>Tickless 是指动态时钟，即系统的周期 Tick 可动态地关闭和打开。这个功能可通过内核配置项 CONFIG_NO_HZ 打开，而 Idle 正是使用了这项技术，使系统尽量长时间处于空闲状态，从而尽可能地节省功耗.</p><p>打开内核配置项 CONFIG_NO_HZ_IDLE，即可让系统在 Idle 前关闭周期 Tick，退出 Idle 时重新打开周期 Tick。</p><p>那么在关闭了周期 Tick 之后，系统何时被唤醒呢？</p><p>在关闭周期 Tick 时，同时会根据时钟子系统计算下一个时钟中断到来的时间，以这个时间为基准来设置一个 hrtimer 用于唤醒系统（高精度时钟框架），而这个时间的计算方法也很简单，即在所有注册到时钟框架的定时器中找到离此时最近的那一个的时间点作为这个时间。当然，用什么定时器来唤醒系统还要根据 CPU Idle 的深度来决定，后面会介绍。</p><h2 id="不同层级的-CPU-Idle-对唤醒时钟源的处理"><a href="#不同层级的-CPU-Idle-对唤醒时钟源的处理" class="headerlink" title="不同层级的 CPU Idle 对唤醒时钟源的处理"></a>不同层级的 CPU Idle 对唤醒时钟源的处理</h2><p>前面提到了，系统关闭周期 Tick 的同时，会计算出下一个时钟中断到来的时间，以这个时间为基准来设置一个 hrtimer 用于唤醒系统。那么，如果有些 CPU 进入的层级比较深，关闭了 CPU 中的 hrtimer，系统将无法再次被唤醒。针对这种情况，则需要低功耗 Timer 去唤醒系统，这里先以 MTK 平台为例，在 CPU 进入 dpidle 和 soidle （两种 Idle 模式）时都会关闭 hrtimer ，另外起用一个 GPT Timer，而这个 GPT Timer 的超时时间直接从被关闭的 hrtimer 中的寄存器获取。这样就保证时间的延续性。因为 GPT Timer 是以 32K 晶振作为时钟源，所以在 CPU 进入 dpidle 时可以把 26M 的主时钟源给关闭，从而达到最大程度的省电。</p><p>以下我们通过源码探讨一下 MTK 的 CPU Idle 的实现，到底哪里设置 GPT Timer。其实很多平台为了实现 CPU 达到最省电的效果，都是使用这种做法。</p><p>MTK 的 CPU 一般有以下几种 Idle 模式</p><ul><li>rgidle，浅度 Idle 模式，即 WFI</li><li>soidle，亮屏 Idle 模式</li><li>dpidle，灭屏 Idle 模式</li></ul><p>先以 dpidle 模式为例子分析 CPU 如何在关闭所有系统时钟的情况下保证 Idle 和系统正常运行。</p><p>CPU 进入 dpidle 的实现接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dpidle_enter</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = IDLE_TYPE_DP;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 记录 dpidle 的开始时间 */</span></span><br><span class="line">idle_ratio_calc_start(IDLE_TYPE_DP, cpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭一些与平台相关的定时器，hps，thermal */</span></span><br><span class="line">dpidle_pre_handler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进入 dpidle */</span></span><br><span class="line">spm_go_to_dpidle(slp_spm_deepidle_flags, (u32)cpu, dpidle_dump_log);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开一些与平台相关的定时器，hps，thermal */</span></span><br><span class="line">dpidle_post_handler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 记录 dpidle 的退出时间，从而计算出 CPU 进入 dpidle 的总时间 */</span></span><br><span class="line">idle_ratio_calc_stop(IDLE_TYPE_DP, cpu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">idle_warn_log(<span class="string">"DP:timer_left=%d, timer_left2=%d, delta=%d\n"</span>,</span><br><span class="line">dpidle_timer_left, dpidle_timer_left2, dpidle_timer_left-dpidle_timer_left2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For test */</span></span><br><span class="line"><span class="keyword">if</span> (dpidle_run_once)</span><br><span class="line">idle_switch[IDLE_TYPE_DP] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正进入 dpidle 的实现在 spm_go_to_dpidle 函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">wake_reason_t spm<span class="constructor">_go_to_dpidle(<span class="params">u32</span> <span class="params">spm_flags</span>, <span class="params">u32</span> <span class="params">spm_data</span>, <span class="params">u32</span> <span class="params">dump_log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新 spm 的标志 */</span></span><br><span class="line">update<span class="constructor">_pwrctrl_pcm_flags(&amp;<span class="params">spm_flags</span>)</span>;</span><br><span class="line"><span class="comment">/* 设置 spm 标志位 */</span></span><br><span class="line">set<span class="constructor">_pwrctrl_pcm_flags(<span class="params">pwrctrl</span>, <span class="params">spm_flags</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 GPT4 定时器，超时时间为下一个 Timer 的唤醒时间，并开启 GPT4 定时器 */</span></span><br><span class="line">spm<span class="constructor">_dpidle_before_wfi(<span class="params">cpu</span>)</span>;</span><br><span class="line"></span><br><span class="line">lockdep<span class="constructor">_off()</span>;</span><br><span class="line">spin<span class="constructor">_lock_irqsave(&amp;<span class="params">__spm_lock</span>, <span class="params">flags</span>)</span>;</span><br><span class="line"><span class="comment">/* 屏蔽 GIC 控制器中的所有中断 */</span></span><br><span class="line">mt<span class="constructor">_irq_mask_all(&amp;<span class="params">mask</span>)</span>;</span><br><span class="line"><span class="comment">/* 打开 GIC 中 SPM_IRQ0_ID 号中断，用于唤醒 */</span></span><br><span class="line">mt<span class="constructor">_irq_unmask_for_sleep(SPM_IRQ0_ID)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (request<span class="constructor">_uart_to_sleep()</span>) &#123;</span><br><span class="line">wr = WR_UART_BUSY;</span><br><span class="line">goto RESTORE_IRQ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭系统时钟 */</span></span><br><span class="line">spm<span class="constructor">_dpidle_pre_process()</span>;</span><br><span class="line"><span class="comment">/* 进入 Idle */</span></span><br><span class="line">spm<span class="constructor">_trigger_wfi_for_dpidle(<span class="params">pwrctrl</span>)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">RESTORE_IRQ:</span><br><span class="line">mt<span class="constructor">_irq_mask_restore(&amp;<span class="params">mask</span>)</span>;</span><br><span class="line">spin<span class="constructor">_unlock_irqrestore(&amp;<span class="params">__spm_lock</span>, <span class="params">flags</span>)</span>;</span><br><span class="line">lockdep<span class="constructor">_on()</span>;</span><br><span class="line">spm<span class="constructor">_dpidle_after_wfi(<span class="params">cpu</span>, <span class="params">wakesta</span>.<span class="params">debug_flag</span>)</span>;</span><br><span class="line"></span><br><span class="line">return wr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 spm_dpidle_before_wfi 函数中会去设置 GPT Timer 的定时时间，并且开启这个 Timer，设置完毕后关闭 GIC 的所有中断，只打开 GPT Timer IRQ，保证 CPU 在定时时间到期时被 GPT Timer 唤醒。最后调用 spm_dpidle_pre_process 和 spm_trigger_wfi_for_dpidle 函数关闭系统时钟并进入 dpidle。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void spm<span class="constructor">_dpidle_before_wfi(<span class="params">int</span> <span class="params">cpu</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">bus<span class="constructor">_dcm_enable()</span>;</span><br><span class="line">faudintbus<span class="constructor">_pll2sq()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 localtimer 中获取定时器计数 */</span></span><br><span class="line">dpidle_timer_left2 = localtimer<span class="constructor">_get_counter()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">int</span>)dpidle_timer_left2 &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* Trigger GPT4 Timeout imediately */</span></span><br><span class="line">gpt<span class="constructor">_set_cmp(<span class="params">idle_gpt</span>, 1)</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 把从 localtimer 中获取到的定时器计数设置到 GPT Timer 中 */</span></span><br><span class="line">gpt<span class="constructor">_set_cmp(<span class="params">idle_gpt</span>, <span class="params">dpidle_timer_left2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动 GPT Timer */</span></span><br><span class="line">start<span class="constructor">_gpt(<span class="params">idle_gpt</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>localtimer_get_counter 函数中其实就是读取 hrtimer 的定时器里的剩下计数 count，然后把 count 设置到 GPT Timer 中，这种做法非常简便和巧妙。这样就能保障系统的正常运行又能达到最省电的效果了。</p>]]></content>
      
      
      <categories>
          
          <category> 电源管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> cpuidle </tag>
            
            <tag> hrtimer </tag>
            
            <tag> tickless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zram 简介</title>
      <link href="/2016/05/20//zram-introduction.html/"/>
      <url>/2016/05/20//zram-introduction.html/</url>
      
        <content type="html"><![CDATA[<h2 id="zram-技术的由来"><a href="#zram-技术的由来" class="headerlink" title="zram 技术的由来"></a>zram 技术的由来</h2><p>zram<sup><a href="#fn_zram_tech" id="reffn_zram_tech">zram_tech</a></sup>（也称为 zRAM，先前称为 compcache）是 Linux 内核的一项功能，可提供虚拟内存压缩。zram 通过在 RAM 内的压缩块设备上分页，直到必须使用硬盘上的交换空间，以避免在磁盘上进行分页，从而提高性能。由于 zram 可以用内存替代硬盘为系统提供交换空间的功能，zram 可以在需要交换 / 分页时让 Linux 更好利用 RAM ，在物理内存较少的旧电脑上尤其如此。</p><p>即使 RAM 的价格相对较低，zram 仍有利于嵌入式设备、上网本和其它相似的低端硬件设备。这些设备通常使用固态存储，它们由于其固有性质而寿命有限，因而避免以其提供交换空间可防止其迅速磨损。此外，使用 zRAM 还可显著降低 Linux 系统用于交换的 I/O 。</p><p>zram 在 2009 年的时候就进了 kernel 的 staging 目录，并于 2014 年 3 月 30 日发布的 3.14 版本正式合并入 Linux 内核主线。在 2014 年 6 月 8 日发布的 3.15 版本的 Linux 内核中，zram 已可支持 LZ4 压缩算法，而 LZO 仍然作为默认的压缩后端。内核 3.15 中的修改还改进了性能，以及经由 sysfs 切换压缩算法的能力。</p><p>Lubuntu 于 13.10 开始使用 zram 。截至 2012 年 12 月，Ubuntu 考虑为小内存的计算机默认启用 zram 。 Google 在 Chrome OS 中使用 zram，它也成为了 Android 4.4 及以后版本设备的一个选项。</p><p>本文主要介绍在 Android 设备上使用的 zram swap，它可以让小内存的设备在多任务的情况下切换自如，提高用户体验。</p><p>zram swap 主要原理就是从内存分配一块区域出来用作 swap 分区，每次如果内存空间不够了，不是把应用程序杀掉，而是把应用程序所占用的内存数据复制到 swap 分区，等切换回来的时候就可以直接把这部分数据恢复到内存当中，节省重新开启所需的时间。而被放到 swap 分区的应用程序，所占用的内存都是被压缩过的，比如，微信在普通内存中占用 50 MB 的空间，如果压缩率为 0.4，则放到 swap 分区里面的数据只需要 20 MB 的空间，这样 swap 分区里面就可以存放更多后台临时不用的应用程序，变相扩展了内存的大小。</p><h2 id="zram-配置步骤"><a href="#zram-配置步骤" class="headerlink" title="zram 配置步骤"></a>zram 配置步骤</h2><h3 id="1-内核配置zram-doc"><a href="#1-内核配置zram-doc" class="headerlink" title="1. 内核配置zram_doc"></a>1. 内核配置<sup><a href="#fn_zram_doc" id="reffn_zram_doc">zram_doc</a></sup></h3><ul><li><p>3.15 之前版本的 kernel</p><p>Device Drivers -&gt; Staging drivers (STAGING [=y])</p></li><li><p>3.15 及之后版本的 kernel</p><p>Device Drivers -&gt; [*] Block devices -&gt; <M> Compressed RAM block device support</p></li><li><p>具体的配置项如下：</p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_RESOURCE_COUNTERS</span>=y</span><br><span class="line"><span class="attr">CONFIG_MEMCG</span>=y</span><br><span class="line"><span class="attr">CONFIG_MEMCG_SWAP</span>=y</span><br><span class="line"><span class="attr">CONFIG_MEMCG_SWAP_ENABLED</span>=y</span><br><span class="line"><span class="attr">CONFIG_MEMCG_KMEM</span>=y</span><br><span class="line"><span class="attr">CONFIG_ZRAM</span>=y</span><br><span class="line"><span class="attr">CONFIG_TOI_ZRAM_SUPPORT</span>=y</span><br><span class="line"><span class="attr">CONFIG_ZRAM_DEBUG</span>=y</span><br></pre></td></tr></table></figure><h3 id="2-zram-块设备个数设定"><a href="#2-zram-块设备个数设定" class="headerlink" title="2. zram 块设备个数设定:"></a>2. zram 块设备个数设定:</h3><ul><li>如果是将 zram 编译成模块，则可以使用下面命令动态加载，这个命令会创建 4 个设备 /dev/zram{0,1,2,3}</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe zram <span class="attribute">num_devices</span>=4</span><br></pre></td></tr></table></figure><ul><li>如果是直接将 zram 编译到内核，那只能在代码里面直接修改 num_devices，3.15 之前的版本代码路径是 drivers/staging/zram/zram_drv.c，3.15 及之后的版本代码路径是  ./drivers/block/zram/zram_drv.c ，默认 zram 设备个数是一个。</li></ul><h3 id="3-压缩流的最大个数设定"><a href="#3-压缩流的最大个数设定" class="headerlink" title="3. 压缩流的最大个数设定"></a>3. 压缩流的最大个数设定</h3><p>这个是 3.15 版本及以后的 kernel 新加入的功能，3.15 版本之前的 zram 压缩都是使用一个压缩流（缓存 buffer 和算法私有部分）实现，每个写（压缩）操作都会独享压缩流，但是单压缩流如果出现数据奔溃或者卡住的现象，所有的写（压缩）操作将一直处于等待状态，这样效率非常低；而多压缩流的架构会让写（压缩）操作可以并行去执行，大大提高了压缩的效率和稳定性。</p><ul><li>查看压缩流的最大个数，默认是 1</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>block<span class="regexp">/zram0/m</span>ax_comp_streams</span><br></pre></td></tr></table></figure><ul><li>设定压缩流的最大个数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/sys/</span>block<span class="regexp">/zram0/m</span>ax_comp_streams</span><br></pre></td></tr></table></figure><h3 id="4-压缩算法选择"><a href="#4-压缩算法选择" class="headerlink" title="4. 压缩算法选择"></a>4. 压缩算法选择</h3><ul><li>查看目前支持的压缩算法</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/sys/</span>block<span class="regexp">/zram0/</span>comp_algorithm</span><br><span class="line">lzo [lz4]</span><br></pre></td></tr></table></figure><ul><li>修改压缩算法</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo lzo &gt; <span class="regexp">/sys/</span>block<span class="regexp">/zram0/</span>comp_algorithm</span><br></pre></td></tr></table></figure><h3 id="5-zram-内存大小设定"><a href="#5-zram-内存大小设定" class="headerlink" title="5. zram 内存大小设定"></a>5. zram 内存大小设定</h3><p>分配部分内存作为 zram ，大小建议为总内存的 10%-25% 。</p><ul><li>可以使用数值直接设置内存大小，单位是 bytes</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $((<span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>)) &gt; /sys/block/zram0/disksize</span><br></pre></td></tr></table></figure><ul><li>也可以使用带内存单位作为后缀的方式设置内存大小</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">256</span>K &gt; <span class="regexp">/sys/</span>block<span class="regexp">/zram0/</span>disksize</span><br><span class="line">echo <span class="number">512</span>M &gt; <span class="regexp">/sys/</span>block<span class="regexp">/zram0/</span>disksize</span><br><span class="line">echo <span class="number">1</span>G &gt; <span class="regexp">/sys/</span>block<span class="regexp">/zram0/</span>disksize</span><br></pre></td></tr></table></figure><h3 id="6-启用-zram-设备为-swap"><a href="#6-启用-zram-设备为-swap" class="headerlink" title="6. 启用 zram 设备为 swap"></a>6. 启用 zram 设备为 swap</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap <span class="regexp">/dev/</span>zram0</span><br><span class="line">swapon <span class="regexp">/dev/</span>zram0</span><br></pre></td></tr></table></figure><h3 id="7-具体的-zram-相关对外接口说明"><a href="#7-具体的-zram-相关对外接口说明" class="headerlink" title="7. 具体的 zram 相关对外接口说明"></a>7. 具体的 zram 相关对外接口说明</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:center">Access</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">disksize</td><td style="text-align:center">RW</td><td style="text-align:left">显示和设置该块设备的内存大小</td></tr><tr><td style="text-align:left">initstate</td><td style="text-align:center">RO</td><td style="text-align:left">显示设备的初始化状态</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:center">WO</td><td style="text-align:left">重置设备</td></tr><tr><td style="text-align:left">num_reads</td><td style="text-align:center">RO</td><td style="text-align:left">读数据的个数</td></tr><tr><td style="text-align:left">failed_reads</td><td style="text-align:center">RO</td><td style="text-align:left">读数据失败的个数</td></tr><tr><td style="text-align:left">num_write</td><td style="text-align:center">RO</td><td style="text-align:left">写数据的个数</td></tr><tr><td style="text-align:left">failed_writes</td><td style="text-align:center">RO</td><td style="text-align:left">写数据失败的个数</td></tr><tr><td style="text-align:left">invalid_io</td><td style="text-align:center">RO</td><td style="text-align:left">非页面大小对齐的I/O请求的个数</td></tr><tr><td style="text-align:left">max_comp_streams</td><td style="text-align:center">RW</td><td style="text-align:left">最大可能同时执行压缩操作的个数</td></tr><tr><td style="text-align:left">comp_algorithm</td><td style="text-align:center">RW</td><td style="text-align:left">显示和设置压缩算法</td></tr><tr><td style="text-align:left">notify_free</td><td style="text-align:center">RO</td><td style="text-align:left">空闲内存的通知个数</td></tr><tr><td style="text-align:left">zero_pages</td><td style="text-align:center">RO</td><td style="text-align:left">写入该块设备的全为的页面的个数</td></tr><tr><td style="text-align:left">orig_data_size</td><td style="text-align:center">RO</td><td style="text-align:left">保存在该块设备中没有被压缩的数据的大小</td></tr><tr><td style="text-align:left">compr_data_size</td><td style="text-align:center">RO</td><td style="text-align:left">保存在该块设备中已被压缩的数据的大小</td></tr><tr><td style="text-align:left">mem_used_total</td><td style="text-align:center">RO</td><td style="text-align:left">分配给该块设备的总内存大小</td></tr><tr><td style="text-align:left">mem_used_max</td><td style="text-align:center">RW</td><td style="text-align:left">该块设备已用的内存大小，可以写 1 重置这个计数参数到当前真实的统计值</td></tr><tr><td style="text-align:left">mem_limit</td><td style="text-align:center">RW</td><td style="text-align:left">zram 可以用来保存压缩数据的最大内存</td></tr><tr><td style="text-align:left">pages_compacted</td><td style="text-align:center">RO</td><td style="text-align:left">在压缩过程中可用的空闲页面的个数</td></tr><tr><td style="text-align:left">compact</td><td style="text-align:center">WO</td><td style="text-align:left">触发内存压缩</td></tr></tbody></table></div><h3 id="8-系统运行之后的内存统计情况"><a href="#8-系统运行之后的内存统计情况" class="headerlink" title="8. 系统运行之后的内存统计情况"></a>8. 系统运行之后的内存统计情况</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br><span class="line"><span class="number">1</span>  MemTotal:        <span class="number">1958596</span> kB</span><br><span class="line"><span class="number">2</span>  MemFree:           <span class="number">40364</span> kB</span><br><span class="line"><span class="number">3</span>  Buffers:            <span class="number">3472</span> kB</span><br><span class="line"><span class="number">4</span>  Cached:           <span class="number">328080</span> kB</span><br><span class="line"><span class="number">5</span>  SwapCached:         <span class="number">1908</span> kB</span><br><span class="line"><span class="number">6</span>  Active:           <span class="number">906752</span> kB</span><br><span class="line"><span class="number">7</span>  Inactive:         <span class="number">426648</span> kB</span><br><span class="line"><span class="number">8</span>  Active(anon):     <span class="number">752824</span> kB</span><br><span class="line"><span class="number">9</span>  Inactive(anon):   <span class="number">252756</span> kB</span><br><span class="line"><span class="number">10</span> Active(file):     <span class="number">153928</span> kB</span><br><span class="line"><span class="number">11</span> Inactive(file):   <span class="number">173892</span> kB</span><br><span class="line"><span class="number">12</span> Unevictable:        <span class="number">2516</span> kB</span><br><span class="line"><span class="number">13</span> Mlocked:               <span class="number">0</span> kB</span><br><span class="line"><span class="number">14</span> SwapTotal:        <span class="number">524284</span> kB</span><br><span class="line"><span class="number">15</span> SwapFree:         <span class="number">378320</span> kB</span><br><span class="line"><span class="number">16</span> Dirty:               <span class="number">480</span> kB</span><br><span class="line"><span class="number">17</span> Writeback:             <span class="number">0</span> kB</span><br><span class="line"><span class="number">18</span> AnonPages:       <span class="number">1003452</span> kB</span><br><span class="line"><span class="number">19</span> Mapped:           <span class="number">167052</span> kB</span><br><span class="line"><span class="number">20</span> Shmem:              <span class="number">1184</span> kB</span><br><span class="line"><span class="number">21</span> Slab:              <span class="number">83104</span> kB</span><br><span class="line"><span class="number">22</span> SReclaimable:      <span class="number">24368</span> kB</span><br><span class="line"><span class="number">23</span> SUnreclaim:        <span class="number">58736</span> kB</span><br><span class="line"><span class="number">24</span> KernelStack:       <span class="number">48736</span> kB</span><br><span class="line"><span class="number">25</span> PageTables:        <span class="number">41908</span> kB</span><br><span class="line"><span class="number">26</span> NFS_Unstable:          <span class="number">0</span> kB</span><br><span class="line"><span class="number">27</span> Bounce:                <span class="number">0</span> kB</span><br><span class="line"><span class="number">28</span> WritebackTmp:          <span class="number">0</span> kB</span><br><span class="line"><span class="number">29</span> CommitLimit:     <span class="number">1503580</span> kB</span><br><span class="line"><span class="number">30</span> Committed_AS:   <span class="number">94718220</span> kB</span><br><span class="line"><span class="number">31</span> VmallocTotal:  <span class="number">251658176</span> kB</span><br><span class="line"><span class="number">32</span> VmallocUsed:      <span class="number">181352</span> kB</span><br><span class="line"><span class="number">33</span> VmallocChunk:  <span class="number">251373156</span> kB</span><br></pre></td></tr></table></figure><p>从 Line 14,15 可以看到 swap 相关的统计信息，SwapTotal 的大小就是 zram 设备的大小，当系统开启了一段时间之后，就会将后台的一些优先级低的应用数据（匿名页面）压缩存放到 swap 区，然后再重新打开这些应用的时候，再从 swap 区将它们的数据解压出来。在 Android KitKat 版本之前，Android 设备因为没有 zram，所以查看 /proc/meinfo 看到的 swap 分区的大小和统计数据都会是零。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>Total RAM: <span class="number">1958596</span> kB (status normal)</span><br><span class="line"><span class="symbol">2 </span> Free RAM: <span class="number">724527</span> kB (<span class="number">504283</span> cached pss + <span class="number">183244</span> cached kernel + <span class="number">37000</span> free)</span><br><span class="line"><span class="symbol">3 </span> Used RAM: <span class="number">1014008</span> kB (<span class="number">656204</span> used pss + <span class="number">357804</span> kernel)</span><br><span class="line"><span class="symbol">4 </span> Lost RAM: <span class="number">220061</span> kB</span><br><span class="line"><span class="symbol">5 </span>     ZRAM: <span class="number">27296</span> kB physical used <span class="keyword">for</span> <span class="number">145952</span> kB in <span class="keyword">swap</span> (<span class="number">524284</span> kB total <span class="keyword">swap</span>)</span><br><span class="line"><span class="symbol">6 </span>   Tuning: <span class="number">256</span> (large <span class="number">512</span>), oom <span class="number">286720</span> kB, <span class="keyword">restore</span> limit <span class="number">95573</span> kB (high-<span class="keyword">end</span>-gfx)</span><br></pre></td></tr></table></figure><p>Line 5 也可以看到 swap 相关的统计信息，如果需要查看具体某个进程使用了多少 swap 空间，可以通过 <code>dumpsys meminfo pid</code>（该进程的 id 号）查看。</p><h2 id="zram-具体原理分析"><a href="#zram-具体原理分析" class="headerlink" title="zram 具体原理分析"></a>zram 具体原理分析</h2><p>zram 本质是就是一个块设备，所以下面先简单介绍一下块设备的一些基础知识。</p><h3 id="1-块设备基础概念"><a href="#1-块设备基础概念" class="headerlink" title="1. 块设备基础概念"></a>1. 块设备基础概念</h3><ul><li><p>块设备（block device）</p><p>块设备是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。</p></li><li><p>扇区 (Sectors)</p><p>块设备中最小的可寻址单元，大小一般都是 2 的整数倍，最常见的是 512 字节。</p></li><li><p>块 (Blocks)</p><p>块是文件系统的一种抽象，只能基于块来访问文件系统，块必须是扇区大小的 2 的整数倍，并且要小于页面的大小，所以通常块的大小是 512 字节、1 KB 或 4 KB 。</p></li><li><p>段 (Segments)</p><p>由若干个相邻的块组成，是 Linux 内存管理机制中一个内存页或者内存页的一部分。</p></li><li><p>页面 (Page)</p><p>物理页是 Linux 内存管理的基本单位，一般一个页面是 4KB 或者 64 KB。</p><p><img src="Sectors_block_segment.gif" alt="Sectors Block Segment"></p></li></ul><h3 id="2-块设备驱动整体框架block-device"><a href="#2-块设备驱动整体框架block-device" class="headerlink" title="2. 块设备驱动整体框架block_device"></a>2. 块设备驱动整体框架<sup><a href="#fn_block_device" id="reffn_block_device">block_device</a></sup></h3><p>  <img src="block_device_arch.gif" alt="Block Device ARCH"></p><h3 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3. 相关数据结构"></a>3. 相关数据结构</h3><ul><li><p>block_device</p><p>描述一个分区或整个磁盘对内核的一个块设备实例。</p></li><li><p>gendisk</p><p>描述一个通用硬盘（generic hard disk）对象。</p></li><li><p>hd_struct</p><p>描述分区应有的分区信息。</p></li><li><p>bio</p><p>描述块数据传送时怎样完成填充或读取块给 driver，既描述了磁盘的位置，又描述了内存的位置。</p></li><li><p>bio_vec</p><p>描述 bio 中的每个段。</p></li><li><p>request</p><p>描述向内核请求一个列表准备做队列处理。</p></li><li><p>request_queue</p><p>描述内核申请 request 资源建立请求链表并填写 bio 形成队列。</p></li></ul><h3 id="4-zram-架构"><a href="#4-zram-架构" class="headerlink" title="4. zram 架构"></a>4. zram 架构</h3><p>zram 从架构上可以分为三部分：</p><ul><li><p>驱动部分</p><p>该部分创建了一个块设备，然后提供了处理 IO 请求的接口；</p></li><li><p>数据流操作部分</p><p>该部分主要提供串行或者并行的压缩和解压操作；</p></li><li><p>解压缩算法部分</p><p>该部分主要是一个个压缩和解压算法，每个算法都提供统一的压缩和解压接口给数据流操作部分调用。</p></li></ul><h3 id="5-zram-驱动部分代码分析"><a href="#5-zram-驱动部分代码分析" class="headerlink" title="5. zram 驱动部分代码分析"></a>5. zram 驱动部分代码分析</h3><ul><li><p>zram_init</p><p>首先调用 register_blkdev 注册块设备驱动到内核中，然后再根据 num_devices 调用 create_device 来创建相应个数的块设备，<br>这里默认是创建一个块设备。</p></li><li><p>create_device</p><p>对于 flash、 RAM 等完全随机访问的非机械设备，并不需要进行复杂的 I/O 调度，所以这里直接调用 blk_alloc_queue 分配一个 “请求队列”，然后使用 blk_queue_make_request 函数绑定分配好的 “请求队列” 和 “请求处理”函数 zram_make_request。接着初始化块设备的操作函数集 zram_devops 及设备容量、名字、队列等其他属性，最后调用 add_disk 将该块设备真正添加到内核中。</p></li><li><p>disksize_store</p><p>zram 使用了 Zsmalloc 分配器来管理它的内存空间，Zsmalloc 分配器尝试将多个相同大小的对象存放在组合页（称为 zspage）中，这个组合页不要求物理连续，从而提高内存的使用率。</p><p>首先会根据 zram 的内存中页面的个数，创建相应个数的 zram table，每个 zram table 都对应一个页面；然后会调用 zs_create_pool 创建一个 zsmalloc 的内存池，以后所有的页面申请和释放都是通过 zs_malloc 和 zs_free 来分配和释放相对应的对象。</p></li><li><p>zram_make_request</p><p>在整个块设备的 I/O 操作中，贯穿于始终的就是“请求”，块设备的 I/O 操作会排队和整合。块设备驱动的任务就是处理请求，对请求的排队和整合则是由 I/O 调度算法解决，因此，zram 块设备驱动的核心这个请求处理函数，所有的 zram I/O 请求都是通过这个请求处理函数来处理的。</p><p>首先它判断这个 I/O 请求是否是有效的，即检测请求是否在 zram 逻辑块的范围以内，且是否对齐。然后调用 __zram_make_request 遍历 bio 中的每个段 bio_vec，根据 bio 的传输方向选择执行写 (zram_bvec_write) 或者读 (zram_bvec_read) 操作。</p></li><li><p>zram_bvec_write</p><p>在写数据之前，首先使用 GFP_NOIO 标志创建一个不允许任何 I/O 初始化的页面，然后将 zram_data 对应的数据先解压出来放到该创建的页面中。接着去调用 zcomp_strm_find 找到一个压缩操作流，如果是单压缩流，则实际调用的是 zcomp_strm_single_find，如果是多压缩流，则实际调用的是 zcomp_strm_multi_find。</p><p>然后，将段 bio_vec 中的页面临时映射到高端地址，并将高端地址空间页面的内容复制到已保存好 zram_data 压缩后的数据的页面。调用 zs_malloc 申请一个 zram table，使 zcomp_compress 压缩内容并将压缩后的内容存放到新申请的 zram table。最后调用 zram_free_page 删除旧内容所占用的 zram table。</p><p>zcomp_decompress 会根据 struct zcomp_backend 初始化时设定的压缩算法来调用相应的解压接口，lzo 压缩算法的解压接口是 lzo_compress ，而 lz4 压缩算法的解压接口是 zcomp_lz4_compress ，该接口还调用了压缩操作流，以此执行串行或者并行写操作。</p></li><li><p>zram_bvec_read</p><p>读操作首先将段 bio_vec 中的页面临时映射到高端地址，然后再调用 zram_decompress_page 将 zram_meta 所对应的数据解压到这块映射的高端内存空间，解压的接口是 zcomp_decompress，它会根据 struct zcomp_backend 初始化时设定的压缩算法来调用相应的解压接口，lzo 压缩算法的解压接口是 lzo_decompress ，而 lz4 压缩算法的解压接口是 zcomp_lz4_decompress 。</p></li></ul><h3 id="6-数据流操作部分代码分析"><a href="#6-数据流操作部分代码分析" class="headerlink" title="6. 数据流操作部分代码分析"></a>6. 数据流操作部分代码分析</h3><ul><li><p>zcomp_create</p><p>若最大可能同时执行压缩操作的个数来调用为一，则调用 zcomp_strm_single_create 来创建一个压缩流，而若最大可能同时执行压缩操作的个数来调用大于一，则调用 zcomp_strm_multi_create 先创建一个压缩流，然后创建一个压缩流链表，并将创建好的压缩流加到压缩流链表中，后面再根据需求来动态创建更多的压缩流。</p></li><li><p>zcomp_strm_multi_find</p><p>单压缩流非常简单，如果前一个压缩操作已经持有 strm_lock 锁，那么下一个压缩操作必须等待前一个压缩操作调用 zcomp_strm_single_release 释放该锁才可以接着执行。</p></li><li><p>zcomp_strm_multi_find</p><p>多压缩流就相对复杂一点，只要压缩流的个数没有达到最大的个数，那么压缩操作都可以分配到一个压缩流，并会加到压缩流链表中，当压缩流的个数达到最大限制之后，那么下一个压缩操作只能睡眠等待链表中有空闲的压缩流出现。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_zram_tech"><sup>zram_tech</sup>. <a href="https://lwn.net/Articles/545244/" target="_blank" rel="noopener">In-kernel memory compression</a><a href="#reffn_zram_tech" title="Jump back to footnote [zram_tech] in the text."> &#8617;</a></blockquote><blockquote id="fn_zram_doc"><sup>zram_doc</sup>. <a href="https://www.kernel.org/doc/Documentation/blockdev/zram.txt" target="_blank" rel="noopener">内核zram说明文档</a><a href="#reffn_zram_doc" title="Jump back to footnote [zram_doc] in the text."> &#8617;</a></blockquote><blockquote id="fn_block_device"><sup>block_device</sup>. <a href="http://blog.csdn.net/jianchi88/article/details/7212370" target="_blank" rel="noopener">inux设备驱动—块设备（一）之概念和框架</a><a href="#reffn_block_device" title="Jump back to footnote [block_device] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zram </tag>
            
            <tag> compcache </tag>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Sensor Framework 概览</title>
      <link href="/2016/05/17//android-sensor-framework.html/"/>
      <url>/2016/05/17//android-sensor-framework.html/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>Android Sensor Framework 的整体架构如图 1 所示:</p><p><img src="android_sensor_framework_1.png" alt="图片 1"></p><p>Android Sensor Framework 可以分为 3 大部分，各个部分的主要功能如下：</p><p><strong>SDK</strong><br>    这一部分主要功能是为 Application 提供 Java API 接口，以便 Application 可以开启所需的 Sensor 并获取数据。</p><p><strong>Framework</strong><br>    这一部分主要有 Sensor Service 构成，主要实现了 Sensor 数据流和控制流。</p><p><strong>Libraries</strong><br>    这一部分是 Sensor 的硬件抽象层（HAL），它实现了 Sensor 的具体操作和数据获取功能。同时，它还进行虚拟 Sensor，电子罗盘等相关的算法处理过程。此模块通常以一个动态链接库的形式提供。</p><h2 id="2-Android-Sensor-Framework-类图"><a href="#2-Android-Sensor-Framework-类图" class="headerlink" title="2. Android Sensor Framework 类图"></a>2. Android Sensor Framework 类图</h2><p><img src="android_sensor_framework_2.png" alt="图片 2"></p><h2 id="3-Android-Sensor-SDK"><a href="#3-Android-Sensor-SDK" class="headerlink" title="3. Android Sensor SDK"></a>3. Android Sensor SDK</h2><p>图片 2 中的 Client 部分内容即为 Android Sensor SDK 的主要构成。主要类的主要功能如下：</p><p><strong>SensorManager</strong><br>该类主要封装了 Sensor 相关的 API ，提供给 Application 使用。<br>文件路径：frameworks/base/core/java/android/hardware/SensorManager.java</p><p><strong>SystemSensorManager</strong><br>该类主要实现 SensorManager 控制和数据获取的逻辑。<br>文件路径：frameworks/base/core/java/android/hardware/SystemSensorManager.java</p><p><strong>android_hardware_SensorManager.cpp</strong><br>该文件负责 jave 层和 native 层通信的 JNI 实现，上层的 Java 代码通过 JNI 调用 Native 层提供的服务。<br>文件路径：frameworks/base/core/jni/android_hardware_SensorManager.cpp</p><p><strong>SensorManager.cpp</strong><br>Sensor 在 Native 层的客户端，负责与服务端 SensorService.cpp 的通信<br>文件路径：frameworks/native/libs/gui/SensorManager.cpp</p><h2 id="4-Android-Sensor-Native-Framework"><a href="#4-Android-Sensor-Native-Framework" class="headerlink" title="4. Android Sensor Native Framework"></a>4. Android Sensor Native Framework</h2><p>图片 2 中的 Server 部分内容即为 Android Sensor Native Framwork 的主要构成。主要类的主要功能如下：</p><p><strong>SensorService.cpp</strong><br>SensorService 是 Android Sensor Framework 最核心的模块，它实现了主要的 Sensor控制流和数据流逻辑，完成 Sensor 参数配置，数据分发，Client 请求处理等功能。<br>文件路径：frameworks/native/services/sensorservice/SensorService.cpp</p><p><strong>BinderService</strong><br>BinderService 是 Android Service 框架的主要类，它提供了 Service 的生命周期管理、进程间通信、请求响应处理等功能。Android 中的绝大部分 Service 都会继承此类。<br>文件路径：frameworks/native/include/binder/BinderService.h</p><p><strong>BnSensorServer</strong><br>该类提供类 Sensor 信息获取以及 SensorEventConnection 创建的功能。<br>文件路径：frameworks/native/include/gui/ISensorServer.h</p><p><strong>SensorEventConnection</strong><br>SensorEventConnection 是 Sensor 数据的传输通道，当 Client 开始监听某一个 Sensor 是，一个对应的 SensorEventConnection 将会被创建，Server 端在接收到 Sensor 数据后，通过写入到 SensorEventConnection 传递给 Client 端。<br>文件路径：frameworks/native/libs/gui/ISensorEventConnection.cpp</p><p><strong>Bittube</strong><br>该类为单向字节管道，提供进程间单向数据通信功能。SensorEventConnection 是基于 Bittube 实现的。<br>文件路径：frameworks/native/libs/gui/BitTube.cpp</p><p><strong>SensorDevice</strong><br>该类负责管理和维护系统中的所有 Sensor，封装了 Sensor 的使能、配置、数据读取等功能。<br>文件路径：frameworks/native/services/sensorservice/SensorDevice.cpp</p><h2 id="5-Android-Sensor-HAL"><a href="#5-Android-Sensor-HAL" class="headerlink" title="5. Android Sensor HAL"></a>5. Android Sensor HAL</h2><p>Android 定义了一系列 Sensor HAL 接口，实际的 Sensor HAL 库需要实现这些接口，主要的接口如下:</p><h3 id="5-1-SensorList"><a href="#5-1-SensorList" class="headerlink" title="5.1. SensorList"></a>5.1. SensorList</h3><p>SensorList 定义了 HAL 层提供的 Sensor，提供 Sensor 类型、供应商、功耗等信息。同时，HAL 层需要实现获取 SensorList 的回调接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sensor_t</span> <span class="title">SensorList</span>[] = &#123;</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name                   = <span class="string">"LTR559 Ambient Light Sensor"</span>,</span><br><span class="line">                .vendor                 = <span class="string">"LITE-ON TECHNOLOGY CORP."</span>,</span><br><span class="line">                .version                = <span class="number">0</span>,</span><br><span class="line">                .handle                 = SENSOR_HANDLE_LIGHT,</span><br><span class="line">                .type                   = SENSOR_TYPE_LIGHT,</span><br><span class="line">                .maxRange               = <span class="number">32767</span>,</span><br><span class="line">                .resolution             = <span class="number">1</span>,</span><br><span class="line">                .power                  = <span class="number">0.1f</span>, <span class="comment">/* 100 uA */</span></span><br><span class="line">                .minDelay               = <span class="number">0</span>,</span><br><span class="line">                .fifoReservedEventCount = <span class="number">0</span>,</span><br><span class="line">                .fifoMaxEventCount      = <span class="number">0</span>,</span><br><span class="line">                .stringType             = SENSOR_STRING_TYPE_LIGHT,</span><br><span class="line">                .requiredPermission     = <span class="string">""</span>,</span><br><span class="line">                .maxDelay               = <span class="number">500</span>,</span><br><span class="line">                .flags                  = SENSOR_FLAG_ON_CHANGE_MODE,</span><br><span class="line">                .reserved[<span class="number">0</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">                .reserved[<span class="number">1</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name                   = <span class="string">"LTR559 Proximity Sensor"</span>,</span><br><span class="line">                .vendor                 = <span class="string">"LITE-ON TECHNOLOGY CORP."</span>,</span><br><span class="line">                .version                = <span class="number">0</span>,</span><br><span class="line">                .handle                 = SENSOR_HANDLE_PROXIMITY,</span><br><span class="line">                .type                   = SENSOR_TYPE_PROXIMITY,</span><br><span class="line">                .maxRange               = <span class="number">4</span>,</span><br><span class="line">                .resolution             = <span class="number">4</span>,</span><br><span class="line">                .power                  = <span class="number">0.15f</span>, <span class="comment">/* 150 uA */</span></span><br><span class="line">                .minDelay               = <span class="number">0</span>,</span><br><span class="line">                .fifoReservedEventCount = <span class="number">0</span>,</span><br><span class="line">                .fifoMaxEventCount      = <span class="number">0</span>,</span><br><span class="line">                .stringType             = SENSOR_STRING_TYPE_PROXIMITY,</span><br><span class="line">                .requiredPermission     = <span class="string">""</span>,</span><br><span class="line">                .maxDelay               = <span class="number">100</span>,</span><br><span class="line">                .flags                  = SENSOR_FLAG_ON_CHANGE_MODE,</span><br><span class="line">                .reserved[<span class="number">0</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">                .reserved[<span class="number">1</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .name                   = <span class="string">"LTR559 Proximity Sensor [Wake Up]"</span>,</span><br><span class="line">                .vendor                 = <span class="string">"LITE-ON TECHNOLOGY CORP."</span>,</span><br><span class="line">                .version                = <span class="number">0</span>,</span><br><span class="line">                .handle                 = SENSOR_HANDLE_PROXIMITY_WAKE_UP,</span><br><span class="line">                .type                   = SENSOR_TYPE_PROXIMITY,</span><br><span class="line">                .maxRange               = <span class="number">4</span>,</span><br><span class="line">                .resolution             = <span class="number">4</span>,</span><br><span class="line">                .power                  = <span class="number">0.15f</span>, <span class="comment">/* 150 uA */</span></span><br><span class="line">                .minDelay               = <span class="number">0</span>,</span><br><span class="line">                .fifoReservedEventCount = <span class="number">0</span>,</span><br><span class="line">                .fifoMaxEventCount      = <span class="number">0</span>,</span><br><span class="line">                .stringType             = SENSOR_STRING_TYPE_PROXIMITY,</span><br><span class="line">                .requiredPermission     = <span class="string">""</span>,</span><br><span class="line">                .maxDelay               = <span class="number">100</span>,</span><br><span class="line">                .flags                  = SENSOR_FLAG_ON_CHANGE_MODE | SENSOR_FLAG_WAKE_UP,</span><br><span class="line">                .reserved[<span class="number">0</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">                .reserved[<span class="number">1</span>]            = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sensor_hal_get_sensors_list</span><span class="params">(struct <span class="keyword">sensors_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     struct <span class="keyword">sensor_t</span> <span class="keyword">const</span>** <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        *<span class="built_in">list</span> = SensorList;</span><br><span class="line">        <span class="keyword">return</span> ARRAY_SIZE(SensorList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-sensors-module-t"><a href="#5-2-sensors-module-t" class="headerlink" title="5.2. sensors_module_t"></a>5.2. sensors_module_t</h3><p>HAL 层需要定义一个 sensors_module_t，供系统在启动时加载 Sensor HAL 动态库。sensors_module_t 向上层注册获取 SensorList 和获取 Sensor 控制接口的相关回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_sensors</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* hw_module, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">hw_device_t</span>** hw_device_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">        <span class="keyword">sensors_poll_context_t</span> *dev = <span class="keyword">new</span> <span class="keyword">sensors_poll_context_t</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;dev-&gt;device, <span class="number">0</span>, <span class="keyword">sizeof</span>(sensors_poll_device_1));</span><br><span class="line"></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version = SENSORS_DEVICE_API_VERSION_1_3;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(hw_module);</span><br><span class="line">        dev-&gt;device.common.<span class="built_in">close</span> = device__close;</span><br><span class="line">        dev-&gt;device.activate = device__activate;</span><br><span class="line">        dev-&gt;device.setDelay = device__setDelay;</span><br><span class="line">        dev-&gt;device.poll = device__poll;</span><br><span class="line">        dev-&gt;device.batch = device__batch;</span><br><span class="line">        dev-&gt;device.<span class="built_in">flush</span> = device__flush;</span><br><span class="line"></span><br><span class="line">        *hw_device_out = &amp;dev-&gt;device.common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">sensors_module_methods</span> = &#123;</span></span><br><span class="line">        .<span class="built_in">open</span> = open_sensors</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensors_module_t</span> <span class="title">HAL_MODULE_INFO_SYM</span> = &#123;</span></span><br><span class="line">        .common = &#123;</span><br><span class="line">                .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">                .module_api_version = <span class="number">1</span>,</span><br><span class="line">                .hal_api_version = <span class="number">0</span>,</span><br><span class="line">                .id = SENSORS_HARDWARE_MODULE_ID,</span><br><span class="line">                .name = <span class="string">"ALS PS Sensor module"</span>,</span><br><span class="line">                .author = <span class="string">"Meizu Telecom Equipment Co., Ltd."</span>,</span><br><span class="line">                .methods = &amp;sensors_module_methods,</span><br><span class="line">        &#125;,</span><br><span class="line">        .get_sensors_list = sensor_hal_get_sensors_list,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-Sensor-控制和数据获取接口"><a href="#5-3-Sensor-控制和数据获取接口" class="headerlink" title="5.3. Sensor 控制和数据获取接口"></a>5.3. Sensor 控制和数据获取接口</h3><p>HAL 层还需要提供实际控制和获取 Sensor 数据的接口，SensorService 中对 Sensor 的控制和数据的获取最终会调用到这些接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extends a sensors_poll_device_1 by including all the sub-module's devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensors_poll_context_t</span> &#123;</span></span><br><span class="line">    sensors_poll_device_1 device; <span class="comment">// must be first</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">activate</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">int</span> enabled)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setDelay</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">int64_t</span> ns)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">sensors_event_t</span>* data, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">batch</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">int</span> flags, <span class="keyword">int64_t</span> period_ns, <span class="keyword">int64_t</span> timeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">int</span> handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__close</span><span class="params">(struct <span class="keyword">hw_device_t</span> *dev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">if</span> (ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval = ctx-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">delete</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__activate</span><span class="params">(struct <span class="keyword">sensors_poll_device_t</span> *dev, <span class="keyword">int</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;activate(handle, enabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__setDelay</span><span class="params">(struct <span class="keyword">sensors_poll_device_t</span> *dev, <span class="keyword">int</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int64_t</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;setDelay(handle, ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__poll</span><span class="params">(struct <span class="keyword">sensors_poll_device_t</span> *dev, <span class="keyword">sensors_event_t</span>* data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;poll(data, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__batch</span><span class="params">(struct sensors_poll_device_1 *dev, <span class="keyword">int</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, <span class="keyword">int64_t</span> period_ns, <span class="keyword">int64_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;batch(handle, flags, period_ns, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">device__flush</span><span class="params">(struct sensors_poll_device_1 *dev, <span class="keyword">int</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sensors_poll_context_t</span>* ctx = (<span class="keyword">sensors_poll_context_t</span>*) dev;</span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;<span class="built_in">flush</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Android-Sensor-Framework的初始化流程"><a href="#6-Android-Sensor-Framework的初始化流程" class="headerlink" title="6. Android Sensor Framework的初始化流程"></a>6. Android Sensor Framework的初始化流程</h2><h3 id="6-1-Android-Sensor-Service-初始化"><a href="#6-1-Android-Sensor-Service-初始化" class="headerlink" title="6.1. Android Sensor Service 初始化"></a>6.1. Android Sensor Service 初始化</h3><p><img src="android_sensor_framework_3.png" alt="图片 3"></p><p>Kernel 在启动完成后，会执行 init 程序，该程序接着解析 init.rc 文件，启动 zygote，最终会执行 Zyoteinit.java 中的 main 函数。</p><p>在 Zygoteinit 的main 函数执行过程中，会调用 startSystemServer 接口，该接口最终会调用 native 层的 nativeforkSystemServer 接口，进而启动 SystemServer ，调用其 main 函数。</p><p>在 SystemServer 的 main 函数中，会调用对应的 nativeInit 接口。在 nativeInit 中，会创建第一个 SensorService 实例。当 SensorService 第一个实例创建时，其 onFirstRef 接口将会被调用。</p><p><img src="android_sensor_framework_4.png" alt="图片 4"></p><p>在 SensorService 的 onFirstRef 接口中，会创建 SensorDevice 的实例。在 SensorDevice 的构造函数中，会调用 hw_get_module 接口加载 Sensor HAL 的动态库，接着调用 Sensor HAL 提供的 open 接口，执行 Sensor HAL 的初始化。<br>接着 SensorService 通过 SensorDevice，调用 Sensor HAL 提供的 get_sensors_list 接口，获取所支持的 Sensor 信息。<br>而后，SensorService 会创建一个 Looper 和 SensorEventAckReceiver。其中 Looper 用于 enable sensor 后，进行数据的接收；而 SensorEventAckReceiver 则用于在 dispatch wake up sensor event 给上层后，接收上层返回的确认 ACK。<br>至此，SensorService 初始化完毕。</p><h3 id="6-2-Android-Sensor-HAL-加载"><a href="#6-2-Android-Sensor-HAL-加载" class="headerlink" title="6.2. Android Sensor HAL 加载"></a>6.2. Android Sensor HAL 加载</h3><p>在 SensorService 创建 SensorDevice 时，会调用 hw_get_module 接口加载 SensorHAL 的动态库文件。<br>在64位的系统中，hw_get_module 接口会在 /vendor/lib64/hw 和 /system/lib64/hw 目录下搜索 SensorHAL 动态库文件，前者的优先级高。<br>hw_get_module 会获取依次获取 “ro.hardware.sensors”，”ro.hardware”，”ro.product.board”，”ro.board.platform”，”ro.arch” property 的值作为 subname，并以 sensors.subname.so 作为 SensorHAL 动态库的文件名，在上述两个目录中搜索文件是否存在，如果都没有搜索到，那么最后会用 sensors.default.so 作为文件名，进行搜索。<br>当搜索到 SensorHAL 的动态库文件后，就会调用 load 接口进行加载操作。<br>具体的流程可以查看下面的源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hw_module_exists</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">size_t</span> path_len, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span> *subname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH2, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH1, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> prop_name[PATH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst)</span><br><span class="line">        <span class="built_in">snprintf</span>(name, PATH_MAX, <span class="string">"%s.%s"</span>, class_id, inst);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        strlcpy(name, class_id, PATH_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Here we rely on the fact that calling dlopen multiple times on</span></span><br><span class="line"><span class="comment">     * the same .so will simply increment a refcount (and not load</span></span><br><span class="line"><span class="comment">     * a new copy of the library).</span></span><br><span class="line"><span class="comment">     * We also assume that dlopen() is thread-safe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try a property specific to the class and possibly instance */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(prop_name, <span class="keyword">sizeof</span>(prop_name), <span class="string">"ro.hardware.%s"</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (property_get(prop_name, prop, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing found, try the default */</span></span><br><span class="line">    <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, <span class="string">"default"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">/* load the module, if this fails, we're doomed, and we should not try</span></span><br><span class="line"><span class="comment">     * to load a different variant. */</span></span><br><span class="line">    <span class="keyword">return</span> load(class_id, path, <span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, <span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENSORS_HARDWARE_MODULE_ID <span class="meta-string">"sensors"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SensorDevice::SensorDevice()</span><br><span class="line">    :  mSensorDevice(<span class="number">0</span>),</span><br><span class="line">       mSensorModule(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = hw_get_module(SENSORS_HARDWARE_MODULE_ID,</span><br><span class="line">            (<span class="keyword">hw_module_t</span> <span class="keyword">const</span>**)&amp;mSensorModule);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Android-Sensor-Manager-初始化"><a href="#6-3-Android-Sensor-Manager-初始化" class="headerlink" title="6.3. Android Sensor Manager 初始化"></a>6.3. Android Sensor Manager 初始化</h3><p><img src="android_sensor_framework_5.png" alt="图片 5"></p><p>APP 在获取 Sensor 数据前，需要获取一个 SensorManager 对象。而在其构造函数中，会先调用 nativeClassInit 和 nativeGetNextSensor 获取系统支持的所有 Sensor 的参数（注，nativeClassInit 只会调用一次），包括名称、类型等参数。后续的相关接口，会用到这些参数。</p><h2 id="7-Android-Sensor-Framework的数据流程分析"><a href="#7-Android-Sensor-Framework的数据流程分析" class="headerlink" title="7. Android Sensor Framework的数据流程分析"></a>7. Android Sensor Framework的数据流程分析</h2><p><img src="android_sensor_framework_6.png" alt="图片 6"></p><p>当上层调用 registerListener 接口时，相应的 sensor 就会被 enable。SensorService 在调用 HAL 提供的 enable 接口前，会先调用 batch 接口，对 sensor 的采样率、数据上报频率等进行配置。另外，如果 sensor 已经被 enable 了，那么 SensorService 就只调用 batch 和 flush 接口。<br>SensorService 在 onFirstRef 时创建了一个 Looper，该 Looper 的执行线程会调用 poll 接口，并阻塞在 sensor 的数据管道，当 sensor 有数据返回时，SensorService 会通过 SensorEventQueue 发送到上层，并最终分发到各个 listener。</p>]]></content>
      
      
      <categories>
          
          <category> 传感器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAB 分配器和 kmalloc</title>
      <link href="/2016/05/08//slab-allocator-and-kmalloc.html/"/>
      <url>/2016/05/08//slab-allocator-and-kmalloc.html/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要有-SLAB"><a href="#为什么要有-SLAB" class="headerlink" title="为什么要有 SLAB"></a>为什么要有 SLAB</h2><p>一般来说，一个新东西的产生总是为了解决某一个现有的问题的。那么，slab 是为了解决什么问题呢？我们知道，在 Linux 内核中的内存管理是使用伙伴系统 (Buddy System)，但是这个系统有一个问题就是，它的最小单位是页，即 PAGE_SIZE ，在 x86 架构中这个常数一般是 4k 。但是很多情况下我们要分配的单元大小是远远小于 4k 的，如果使用伙伴系统的话，必定是会产生很大的浪费的。所以，一个粒度更加小的分配器呼之欲出，SLAB 就是为了解决这个小粒度内存分配的问题的。</p><h2 id="如何解决以及结构组织"><a href="#如何解决以及结构组织" class="headerlink" title="如何解决以及结构组织"></a>如何解决以及结构组织</h2><p>既然 SLAB 分配器已经定下了这样的一个目标，那么它的策略是什么呢？ 答曰，SLAB 分配器是基于所谓“面向对象”的思想，当然，这里的“面向对象”跟 C++ 和 Java 等的“面向对象”是不一样的。这里的“面向对象”更加确切的说法是“面向对象类型”，不同的类型使用不同的 SLAB ，一个 SLAB 只分配一种类型。而且，SLAB 为了提高内核中一些十分频繁进行分配释放的“对象”的分配效率， SLAB 的做法是：每次释放掉某个对象之后，不是立即将其返回给伙伴系统（SLAB 分配器是建立在伙伴系统之上的），而是存放在一个叫 array_cache 的结构中，下次要分配的时候就可以直接从这里分配，从而加快了速度。</p><p>这里必须明确几个概念，说明如下：</p><ul><li><p>缓存(cache) : 这里的缓存只是一个叫法而已，其实就是一个管理结构头，它控制了每个 SLAB 的布局，具体的结构体是 struct kmem_cache 。（注意，虽然现在几乎所有的书或者博客都将这一个结构称为“缓存”，不过我觉得在这里称为“管理结构头”是更为合适的，所以下文中统一将“缓存（cache）”称为“管理结构头”。）</p></li><li><p>SLAB: 从伙伴系统分配的 2^order 个物理页就组成了一个 SLAB ，而后续的操作就是在这个 SLAB 上在进行细分的，具体的结构体是 struct slab 。</p></li><li><p>对象(object) : 上面说到，每一个 SLAB 都只针对一个数据类型，这个数据类型就被称为该 SLAB 的“对象”，将该对象进行对齐之后的大小就是该“对象”的大小，依照该大小将上面的 SLAB 进行切分，从而实现了我们想要的细粒度内存分配。</p></li><li><p>per-CPU 缓存：这个就是上面提到的 array_cache ，这个是为了加快分配，预先从 SLAB 中分配部分对象内存以加快速度。具体的结构体是 struct array_cache，包含在　struct kmem_cache　中。</p></li></ul><p>还有，我们在用户态编程的时候，需要分配内存的时候，一般都是使用 malloc() 函数来实现。那么在内核态编程中，如果我们要分配内存，而且又没有必要使用上面的基于某个特定对象的，内核给我们提供了一个类似 malloc() 的接口—— kmalloc() 。值得注意的是，其实 kmalloc() 也是基于 SLAB 分配器的，只不过它所需要的管理结构头已经按照 2^n 的大小排列事先准备好了而已，这个管理结构体数组是 struct cache_sizes malloc_sizes[] 。</p><p>还有，每个“对象”的缓存被组织成一个链表——cache_chain，然后每个缓存的 SLAB 被组织了三个不同的链表——slab_full，slab_partial 和 slab_free，这三个链表有何不同应该可以见名知意，就不赘述了。</p><p>然后，你可能就会发现了，在<strong>对象</strong>那一点，很可能出现一种情况，那就是 SLAB 的大小跟 object 的大小不整除，也就是说有不足于一个 object 的大小的空间剩余，怎么办，浪费掉吗？肯定不是！内核很好地利用了这些剩余的空间，提出了“缓存染色(cache coloring)”的概念。当然，这里的<strong>染色</strong>不是真的去染成红绿蓝等颜色，这只是一种说法而已。具体地将，就是让每个缓存的 SLAB 在页的起始位置有不同的偏移，以缓解<strong>缓存过热</strong>的问题。注意，这里提到的“缓存过热”中的“缓存”是真的 CPU 的物理缓存。具体的我后面会详细说明，这里只是综述一下。</p><h2 id="初始化——-kmem-cache-init"><a href="#初始化——-kmem-cache-init" class="headerlink" title="初始化—— kmem_cache_init()"></a>初始化—— kmem_cache_init()</h2><p>想要让 SLAB 分配器工作起来，必须进行一系列的初始化。不过这里存在一个“鸡生蛋蛋生鸡”的问题。我们前面说过，每个缓存需要一个管理结构头，而建立缓存的实质就是分配一个管理结构头 struct kmem_cache 来描述 SLAB 的布局，以指导后续的分配行为，这个建立缓存的过程是用函数 kmem_cache_create() 来实现的，这里只是点一下，下面会详细说明。很明显这个管理结构头的大小小于一页，那么是十分适合使用 SLAB 分配器进行分配的，但是问题是此时 SLAB 分配器还没有初始化完成，怎么办？内核的做法是直接静态分配一个 struct kmem_cache 类型的变量——cache_cache（不得不说，这个变量名起得真好！），然后呢，整个初始化的过程分为六步：</p><ol><li><p>初始化 struct kmem_cache 变量 cache_cache 。该变量之所以重要，是因为<strong>它是以后所有的对象的管理结构头的管理结构头，专业一点的话可以称作是“元管理结构头”</strong>，然后上面提到的 array_cache 和三个链表 kmem_list3 都是这个结构体里面的成员，初始化也都是静态分配的，对应的静态变量分别是 initarray_cache 和 initkmem_list3 。</p></li><li><p>建立 kmalloc() 的 struct array_cache 对应大小的管理结构头。为什么要进行这一步呢，因为下面的步骤是要完整地建立其 kmalloc() 支持的所有 2^n 大小的管理结构头，完成这一步就相当于 kmalloc() 完全可用了。但是每个管理结构头都必须要 struct array_cache 和 struct kmem_list3 这两个辅助管理结构头，就必须要建立这两个对应大小的 kmalloc() 的管理结构头以便能够使用 kmalloc() <strong>动态分配</strong>！这里之所以要提到<strong>动态分配</strong>是因为在给 struct array_cache 对应大小建立 kmalloc() 的管理结构头的时候，其自己的 struct array_cache 和 struct kmem_list3 也是静态分配的，所以后续将会把它们使用动态分配的空间替换掉。</p></li><li><p>建立 kmalloc() 的 struct kmem_list3 对应大小的管理结构头以及剩下的 2^n 对应大小的管理结构头。第二点已经说明过了，就不重复了。</p></li><li><p>（其实包括第五步）此时 kmalloc() 已经可用了，所以如上面所说要使用 kmalloc() 分配的动态内存去替代前面所有的静态内存，需要替换的对象有：cache_cache 的 struct array_cache ，struct array_cache 对应大小的 kmalloc() 的管理结构头的 struct array_cache 和 struct kmem_list3，以及 struct kmem_list3 对应大小的 kmalloc() 的管理结构头的 struct kmem_list3 。</p></li><li><p>重新调整各个管理结构体的 struct array_cache 中的 entry[] 的数目。</p></li></ol><p>然后这里有一个问题就是，内核是如何知道当前是属于哪一个阶段呢？为了解决这个问题，内核使用了一个枚举变量 g_cpucache_up ，其接受的变量范围有：NULL , PARTIAL_AC , PARTIAL_L3，PEARLY , FULL 。当第二步完成的时候，标记为 PARTIAL_AC ，此时意味着以后的 struct array_cache 都可以使用 kmalloc() 分配了；当第三步完成的时候，标记为 PARTIAL_L3 ，此时意味着以后的 struct kmem_l3 都可以使用；当第四和第五步完成的时候，标记为 PARTIAL_EARLY ，此时意味着 kmalloc() 已经支持所有其支持的 2^n 大小的内存分配了。</p><p>然后有一个很重要的点就是，如果你读过 mm/slab.c 的源代码，你就会发现，在建立 struct array_cache 的管理结构头和为 kmalloc() 各个管理结构头的 struct array_cache 的时候，<strong>内核使用的是 struct arraycache_init 而不是 struct array_cache </strong>，这究竟是怎么一回事？其实这是很有讲究的，且听我慢慢到来。</p><p>其实 struct initarray_cache 的完整结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arraycache_init</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> <span class="title">cache</span>;</span></span><br><span class="line"><span class="keyword">void</span> *entry[BOOT_CPUCACHE_ENTRIES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的结构可以看出，struct arraycache_init 就只是比 struct array_cache 多了一个 void * 的数组而已，这个究竟有什么区别呢？诶，别着急，我们再来看一下 struct array_cache 的结构就清楚了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> avail;</span><br><span class="line">unsighed <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> touched;</span><br><span class="line"><span class="keyword">spinlock_t</span> lock;</span><br><span class="line"><span class="keyword">void</span> *entry[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>联系上文我提到 Per-CPU 的时候说过，为了加快速度将 SLAB 的一部分内存分配到 array_cache ，而事实上就上面我们看到的 struct array_cache 的结构，只是有一个 void * 的数组而已，而且是个伪数组，并没有数组项。其实细想这是一种十分优美的实现方法。因为各个管理结构头所需要的“一部分内存”是不一样的，这样就保证了一个通用性，每次要访问 array_cache 里面的内存的时候，只需要进行 array_cache-&gt;entry[下标] 就可以了。然后我们再来解决上面提到的 struct arraycache_init 的问题。内核静态分配了这样的一个 struct arraycache_init 的静态变量：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static struct <span class="built_in">array</span>cache_init initarray_cache __initdata =</span><br><span class="line">&#123; &#123;<span class="number">0</span>, BOOT_CPUCACHE_ENTRIES, <span class="number">1</span>, <span class="number">0</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>对照结构体的成员我们发现，struct array_cache 的 batchcount 被被赋值为 BOOT_CPUCACHE_ENTRIES ，这个 batchcount 是什么来头呢？这个变量就是控制着我们上面提到的“一部分内存”的具体量了。更重要的是，我们可以看到，struct arraycache_init 多出来的那个 void <em> 数组的个数，就是 BOOT_CPUCACHE_ENTRIES 。也就是说，<em>*struct array_cache 的管理结构头的 struct array_cache 里面的 entry 的真正空间就在这里了。</em></em></p><p>提到这里的话，那么初始化的第六步就可以彻底地理解了：为每个 kmalloc() 的管理结构头的 array_cache 重新调整 entry 的个数，具体的函数调用是 enable_cpucache()-&gt;do_tune_cpucache()-&gt;alloc_arraycache() 。</p><h2 id="创建管理结构头——-kmem-cache-create"><a href="#创建管理结构头——-kmem-cache-create" class="headerlink" title="创建管理结构头—— kmem_cache_create()"></a>创建管理结构头—— kmem_cache_create()</h2><p>因为在初始化的过程中已经静态分配了管理结构头的管理结构头—— cache_cache，所以可以直接使用 kmem_cache_alloc() 给提供的对象建立其自己的管理结构头 struct kmem_cache ，而这个函数的作用也是如此。除了如此外，这个函数还有一个十分重要的功能就是创建 SLAB 的布局，即—— 应该占用页帧的阶数，SLAB 管理头应该在页内还是页外，剩余空间是多少，染色的个数，染色的大小（这两个说法在这里可能有点奇怪，不过等我们提到“染色”的时候就清楚了）等，具体的函数调用是 calculate_slab_order()-&gt;cache_estimate() ，过程比较简单，就不提了。</p><p>最后调用 enable_cpu_cache() 配置 struct array_cache 和 struct kmem_list3 ，这一步类似于我们在初始化那一节提到的第六步，也就不在重复了。</p><p>最后建立的管理结构头加入到 cache_chain 这个链表。</p><h2 id="分配内存——-kmem-cache-alloc"><a href="#分配内存——-kmem-cache-alloc" class="headerlink" title="分配内存—— kmem_cache_alloc()"></a>分配内存—— kmem_cache_alloc()</h2><p>kmem_cache_alloc() 这个函数进过多层的封装，最终调用的是 ____cache_alloc() ，kmalloc() 也是如此。我们先来看一下这个函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static inline void<span class="operator"> * </span><span class="constructor">____cache_alloc(<span class="params">struct</span> <span class="params">kmem_cache</span> <span class="operator">*</span><span class="params">cachep</span>, <span class="params">gfp_t</span> <span class="params">flags</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">void *objp;</span><br><span class="line"><span class="keyword">struct</span> array_cache *ac;</span><br><span class="line"></span><br><span class="line">check<span class="constructor">_irq_off()</span>;</span><br><span class="line"></span><br><span class="line">ac = cpu<span class="constructor">_cache_get(<span class="params">cachep</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (likely(ac-&gt;avail)) &#123;</span><br><span class="line"><span class="constructor">STATS_INC_ALLOCHIT(<span class="params">cachep</span>)</span>;</span><br><span class="line">ac-&gt;touched = <span class="number">1</span>;</span><br><span class="line">objp = ac-&gt;entry<span class="literal">[--<span class="identifier">ac</span>-&gt;<span class="identifier">avail</span>]</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="constructor">STATS_INC_ALLOCMISS(<span class="params">cachep</span>)</span>;</span><br><span class="line">objp = cache<span class="constructor">_alloc_refill(<span class="params">cachep</span>, <span class="params">flags</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kmemleak<span class="constructor">_erase(&amp;<span class="params">ac</span>-&gt;<span class="params">entry</span>[<span class="params">ac</span>-&gt;<span class="params">avail</span>])</span>;</span><br><span class="line">return objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先涉及到我当初一直困惑的一个点：在使用 kmem_cache_create() 建立相关的管理结构之后，究竟有没有分配真正的内存空间呢？在通读了相关的代码之后，我得到了答案：<strong>没有，也没必要。因为存在这么一种情况：如果使用 kmem_cache_create() 之后还分配了真正的内存空间之后，如果该 SLAB 一直不使用，那么岂不是浪费了很多宝贵的内存了吗？</strong></p><p>解决上面的这一个疑惑之后，我们就可以知道在上面的代码中，第一次我们是走 else 那个分支了，也就是调用了 cache_alloc_refill() 来分配空间：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void *cache_alloc_refill(<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span></span> *cachep, gfp_t flags)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (batchcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span> *entry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span></span>　*slabp;</span><br><span class="line"></span><br><span class="line">entry = l3-&gt;slabs_partial.next;</span><br><span class="line"><span class="keyword">if</span> (entry == &amp;l3-&gt;slabs_partial) &#123;</span><br><span class="line">l3-&gt;free_touched = <span class="number">1</span>;</span><br><span class="line">entry = l3-&gt;slabs_free.next;</span><br><span class="line"><span class="keyword">if</span> (entry == &amp;l3-&gt;slabs_free)</span><br><span class="line">goto must_grow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我再插一句：在 Linux 内核中的链表的实现是十分简洁优美的，它只有两个指针，并不存在数据域。这么做是为了通用性，即任何结构都可以组织自己的链表，然后在结构体中嵌入 struct list_head 即可。然后可能有人会问了，如果我有一个 struct list_head ，那么如何才能访问到该链表的起始结构呢？内核十分贴心的给我们准备了一个宏：<strong>container_of</strong>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(<span class="name">ptr</span>, type, member) (&#123; \</span><br><span class="line">const typeof((<span class="name">type</span> *)0-&gt;member)*__mptr = (<span class="name">ptr</span>)<span class="comment">;  \</span></span><br><span class="line">(<span class="name">type</span> *)((char *)__mptr - offsetof(<span class="name">type</span>, member)) \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单来说，这个宏的作用就是：<strong>我有一个类型为 (type *)-&gt;member 的变量，想要得到包含该变量的 type 类型变量的地址。</strong></p><p>所以在这里，如前面所说，这里 l3 的三个链表都是连接 struct SLAB 类型的，而这个类型就是内存空间的真正所在，也就是我们前面所说的 2^order 个物理页组成的 SLAB。</p><p>在 kmem_cache_create() 的过程中，在分配 struct kmem_list3 的时候调用了 kmem_list3_init() (line 3844) 将 l3 的三个链表全都置为首尾相连的空链表，所以上面的函数在初次运行的时候最终将跳转到 must_grow 这个标签：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">must_grow:</span><br><span class="line"><span class="function"><span class="title">l3</span>-&gt;</span><span class="function"><span class="title">free_objects</span> -= ac-&gt;</span>avail;</span><br><span class="line">alloc_done:</span><br><span class="line"><span class="function"><span class="title">spin_unlock</span>(&amp;l3-&gt;</span>list_lock);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (unlikely(!ac-&gt;</span>avail)) &#123;</span><br><span class="line">int x;</span><br><span class="line">x = cache_grow(cachep, flag | THISNODE, node, NULL);</span><br><span class="line"></span><br><span class="line">ac = cpu_cache_get(cachep);</span><br><span class="line"><span class="function"><span class="title">if</span> (!x &amp;&amp; ac-&gt;</span>avail)</span><br><span class="line">return NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (!ac-&gt;</span>avail)</span><br><span class="line">goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，函数将调用 cache_grow() 来进行真正的内存分配：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int cache_grow(struct kmem_cache *cachep,</span><br><span class="line">gfp_t flags, int nodeid, void *objp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">offset</span> = l3-&gt;</span>colour_next;</span><br><span class="line"><span class="function"><span class="title">l3</span>-&gt;</span>colour_next++;</span><br><span class="line"><span class="function"><span class="title">if</span> (l3-&gt;</span><span class="function"><span class="title">colour_next</span> &gt;= cachep-&gt;</span>colour)</span><br><span class="line"><span class="function"><span class="title">l3</span>-&gt;</span>colour = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">offset</span> *= cachep-&gt;</span>colur_off;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，到这里，总算可以说到前面铺垫了很久的所谓的“缓存着色”了，不过我觉得我得先简单地提一下 CPU cache 的工作原理才行：</p><p>CPU cache 就是我们常看到的一级缓存，二级缓存，三级缓存啊，引入这些缓存是因为内存 RAM 的速度相较于 CPU 的速度而言，是在是太慢了，所以为了提高速度， CPU 制造商提供了速度接近于 CPU 的小容量缓存，以便加速 CPU 与 RAM 的数据交换。具体的策略是：</p><p>每块 cache 会被分为更小的 cache line ，每个 cache line 的容量是一样的，然后 CPU 将虚拟地址分成三部分—— data, index, tag　，其中 data 长度是 cache line 的长度，index 的长度是 cache 的长度减去 data 的长度，最后 tag 的长度是虚拟地址的长度减去 data+index 的长度。举个例子，在 x86 的机器中，虚拟地址的地址空间是 32bit=2^32 ，假设我们的一级缓存有 4MB=2^22，cache line 的长度是 64bit=2^6 ，所以，data 就是 6 位，index 就是 (22-6) = 12 位，tag 就是 32-22=10 位。然后得到这些位之后，CPU 的每一个虚拟地址，将其分成上面的三部分之后，将按照 index 作为索引存入到 cache 中，然后在看需要的内容是否在 cache 中，这回比较需要的虚拟地址的 tag 与 cache 对应索引 index 的 tag 是否一致，如果一致说明 cache hit ，否则说明 cache miss 。</p><p>有点啰嗦，不过这些知识准备是必须的，然后我们就可以来具体阐述了。</p><p>我们在前面提到，SLAB 利用剩余的不足一个 object 的空间来进行缓存染色。具体说来，就是以平台的 cache line 的长度（存储在 cachep-&gt;colour_off）为偏移值（<strong>这一点非常重要！</strong>），计算出剩余的空间有多少个偏移值 cachep-&gt;colour ，然后就从 0 到 cachep-&gt;colour - 1（这个值是 l3-&gt;colour_next），每次就偏移 colour_next * colour_off 。这样，根据我们上面的叙述，每个 SLAB 将最终被放到不同的 cache line ，从而缓解了缓存过热的问题。</p><p>不过，如果你细心一点的话，你也可以发现，其实这个方法并不是特别的有效，因为它的有效范围只有 colour 个，也就是说，colour 个之后，还是会发生覆盖的问题，所以我在上面才用了<strong>缓解</strong>一词。</p><p>总之，上面的代码就计算了下一个偏移值 offset ，那么真正的偏移在那里呢？请看后面的代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!objp)</span><br><span class="line">objp = kmem_getpages(<span class="name">cachep</span>, local_flags, nodeid)<span class="comment">;</span></span><br><span class="line">if (!objp)</span><br><span class="line">goto failed<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">slabp = alloc_slabmgmt(<span class="name">cachep</span>, objp, offset,</span><br><span class="line">local_flags &amp; ~GFP_CONSTRAINT_MASK, nodeid)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>真正的页分配就在这里了—— kmem_getpages() ，而真正的偏移就在 alloc_slabmgmt() 这个函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab</span></span> *alloc_slabmgmt(<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span></span> *cachep, void *objp,</span><br><span class="line">int colour_off, gfp_t local_flags,</span><br><span class="line">int nodeid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span></span> *slabp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (OFF_SLAB(cachep)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">slabp = objp + colour_off;</span><br><span class="line">colour_off += cachep-&gt;slab_size;</span><br><span class="line">&#125;</span><br><span class="line">slabp-&gt;inuse = <span class="number">0</span>;</span><br><span class="line">slabp-&gt;colouroff = colour_off;</span><br><span class="line">slabp-&gt;s_mem = objp + colour_off;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，这里就可以很明显的看出来了整个 SLAB 的布局了：在连续页 objp 的起始，先是 colour_off 的偏移，然后是 SLAB 的一些管理头（管理头的大小是 cachep-&gt;slab_size），最后就是 object 的起始地址 slab-&gt;s_mem 了。</p><p>接下来的具体工作就是设置 SLAB 的 bufctl 控制数组，这里简单地提一下：slab 控制头有一个成员是 slabp-&gt;free ，意义是当前可用的 object 的索引，而 bufctl 控制的则是当前可用的下一个 object 的索引。</p><p>然后，新建立的 SLAB 加入到 l3 的 slabs_free 链表（这很重要！）。然后 cache_grow() 函数结束，返回 cache_alloc_refill() ，注意，此时我们只是分配了一个新的 SLAB ，还没有分配出去。具体就是在 goto retry 重新回到 cache_alloc_refill() 那里重新分配，因为此时我们的 slabs_free 已经不是空的了，所以函数接下来将 batchcount 个 object 移到 array_cache 中，然后修改 SLAB 的 bufctl 数组。最后，看 SLAB 是否所有 object 都分配完了，如果是，则移到 l3-&gt;slabs_full，否则则移到 l3-&gt;slabs_partial 。</p><p>然后，在后续的操作中，如果 array_cache 中有空间，则从其直接分配，否则就看 slabs_partial　或者是 slabs_free 是否有足够的 object ，在不然，就再次重复上面分配 SLAB 的操作了。</p><h2 id="释放内存——-kmem-cache-free"><a href="#释放内存——-kmem-cache-free" class="headerlink" title="释放内存—— kmem_cache_free()"></a>释放内存—— kmem_cache_free()</h2><p>有了上面已经十分详细的阐述之后，释放内存和后面的销毁就显得简单许多了，就是从 array_cache 移回 SLAB 并且修改 bufctl 控制数组而已。就不赘述了。</p><h2 id="销毁内存——-kmem-cache-destroy"><a href="#销毁内存——-kmem-cache-destroy" class="headerlink" title="销毁内存—— kmem_cache_destroy()"></a>销毁内存—— kmem_cache_destroy()</h2><p>同样不赘述了。</p><p>好了，整个 SLAB 分配器我大概就简单地说到这里。下面我说一下我自己的看法。我们可以发现，SLAB 为了加快分配速度，使用了很多的管理结构，其中花销最大的就是那个 bufctl 数组，所以如果是分配小的 object 的话，那么这个 bufctl 数组占用的空间还是相当可观的。这也是它的一个主要的缺点。而后来的 SLUB，就是针对这个缺点进行了有效的改进，而这，我在后面的博客中，将会详细讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SLAB </tag>
            
            <tag> SLUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 5.1 上的 MTK GPS</title>
      <link href="/2016/05/01//gps-introduction.html/"/>
      <url>/2016/05/01//gps-introduction.html/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍手机上几种常见的定位技术，以及 Android 5.1 上的 MTK GPS。</p><h2 id="几种常见的定位技术介绍"><a href="#几种常见的定位技术介绍" class="headerlink" title="几种常见的定位技术介绍"></a>几种常见的定位技术介绍</h2><h3 id="纯-GPS-定位"><a href="#纯-GPS-定位" class="headerlink" title="纯 GPS 定位"></a>纯 GPS 定位</h3><p>数据直接来源于卫星，即搜星，然后下载卫星数据。通过卫星的位置（从卫星上接收），卫星到接收机的距离来测算接收机的位置</p><p>在无辅助信息的条件下用 GPS 定位，需捕获到至少四颗卫星（因为卫星和接收机都有时间差，4 个未知数需 4 个方程才能解）</p><h3 id="蜂窝基站-WIFI定位"><a href="#蜂窝基站-WIFI定位" class="headerlink" title="蜂窝基站 / WIFI定位"></a>蜂窝基站 / WIFI定位</h3><p>蜂窝基站定位原理：根据 CellID (基站 ID )，去对应的数据库搜索已经标识好了的经纬度，然后根据经纬度去地图供应商查询对应的地图和地址描述</p><p>WIFI 定位原理：扫描周围所有的 AP，获取 AP 的 MAC Address (说明下，不是 IP Address 哦)，在连网前提下，就可以去地图服务器（比如 Baidu 地图服务器，有这些 MAC Address 的经纬度）查询这些 MAC Address 的座标，并结合每个 AP 的信号强弱，计算出手机的大致地理位置并返回给用户（ Baidu 地图），从而完成定位</p><h3 id="AGPS定位"><a href="#AGPS定位" class="headerlink" title="AGPS定位"></a>AGPS定位</h3><p>AGPS 是标准的在线辅助手段，简单点说就是 GPS + 辅助数据，需要额外的辅助服务器支持。</p><p>原理：通过网络连接到 AGPS SERVER，从 AGPS SERVER 获取辅助数据（包括参考时间，参考位置，星历和历书），从而缩小 TTFF （Time To First Fix，首次定位时间）</p><p>如图： <img src="agps.png" alt="AGPS"></p><h3 id="离线辅助定位"><a href="#离线辅助定位" class="headerlink" title="离线辅助定位"></a>离线辅助定位</h3><p>通过预测技术，将未来 N 天所有 GPS 卫星的 ephemeris （星历数据）放到 XX 服务器，然后手机端可以从该 XX 服务器下载，这样，在没有 A-GPS 去 supl 服务器下载卫星星历数据的情况下，也可以实现快速定位。<br>其存在目的就是缩小TTFF，提高定位速度。</p><p>比如 MTK EPO 原理：通过预测技术，将未来 30 天所有 GPS 卫星的 ephemeris 放到 mtk 服务器（epo.mediatek.com），当打开 GPS 和网络时，就会去下载预测的未来 30 天内所有卫星星历，15 天后只要在打开 GPS 和网络前提下就会自动去同步一下。</p><p>如图：<img src="epo.png" alt="epo"></p><h2 id="Android5-1-上的-MTK-GPSandroid-book"><a href="#Android5-1-上的-MTK-GPSandroid-book" class="headerlink" title="Android5.1 上的 MTK GPSandroid_book"></a>Android5.1 上的 MTK GPS<sup><a href="#fn_android_book" id="reffn_android_book">android_book</a></sup></h2><p>下图是 Android 5.1 上 GPS 代码框架图：</p><p><img src="gps_introduction.png" alt="Android5.1 上的 MTK GPS"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_android_book"><sup>android_book</sup>. 《深入理解 Android：Wi-Fi，NFC 和 GPS》第九章 深入理解 GPS<a href="#reffn_android_book" title="Jump back to footnote [android_book] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 无线通讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gps </tag>
            
            <tag> 定位技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WrapFS 简介</title>
      <link href="/2016/04/14//intro-wrapfs.html/"/>
      <url>/2016/04/14//intro-wrapfs.html/</url>
      
        <content type="html"><![CDATA[<h2 id="初识-WrapFS"><a href="#初识-WrapFS" class="headerlink" title="初识 WrapFS"></a>初识 WrapFS</h2><p>WrapFS 是一种堆栈式文件系统，堆栈式文件系统的一个基本功能就是把操作和参数转换成底层文件系统的操作和参数。这就意味着我们会在 WrapFS 层上创建一个文件对象后会在底层文件对应着创建一个对象，要说明的是，WrapFS 层的这个文件对象只保存在内存里面，断电后会消失，真正文件里面的数据保存在底层文件系统里面。</p><p><img src="wrapfs.gif" alt="wrapfs"></p><h2 id="WrapFS-的意义"><a href="#WrapFS-的意义" class="headerlink" title="WrapFS 的意义"></a>WrapFS 的意义</h2><p>从 WrapFS 的发明者有这样的回答：</p><ul><li>WrapFS 是一种理想的小模板，可以修改，逐步改造出新的文件系统功能。</li><li>WrapFS 可以当作一种方法，用于测试 Linux VFS 超强的堆叠能力。</li><li>WrapFS 可以当作学习 VFS，或学习如何写新的 Linux 文件系统的一个好工具。</li><li>在 Android 里面，采用的是 FUSE 文件系统，FUSE 文件系统的最终实现是在用户空间，这样导致一个文件操作会两次跨越用户空间和内核空间，导致效率降低，但是 WrapFS 不会有这个问题，其性能接近底层文件系统的实际性能.</li></ul><p><img src="wrapfs-layer.gif" alt="wrapfs-layer"></p><h2 id="继承角度看-WrapFS"><a href="#继承角度看-WrapFS" class="headerlink" title="继承角度看 WrapFS"></a>继承角度看 WrapFS</h2><p>从面向对象的角度来看，WrapFS 继承自底层文件系统，并且新增加了一下类成员，重写了一些 VFS 层的方法。</p><h2 id="文件系统-mount"><a href="#文件系统-mount" class="headerlink" title="文件系统 mount"></a>文件系统 mount</h2><p>WrapFS 的 mount 方法为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t wrapfs <span class="regexp">/some/</span>lower<span class="regexp">/path /m</span>nt<span class="regexp">/wrapfs</span></span><br></pre></td></tr></table></figure><p>这里 <code>/some/lower/path</code> 就是底层的文件系统的路径, <code>/mnt/wrapfs</code> 是挂载点的路径，在内核里面可以通过 <code>kern_path()</code> 获取路径所对应的 <code>sturct path</code> 结构，<code>path</code> 结构里面包含了文件系统 mount 时的 vfsmount 信息和挂载点路径的 dentry 信息，<code>struct path</code> 定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>struct vfsmount</code> 里面包含了底层文件系统的挂载点的 dentry 和 super block。通过 super block 和 dentry 结构，我们能获得操作底层文件系统的方法。这里来关注下填充 <code>struct super_block</code> 的方法，只列出了主要的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wrapfs_read_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *raw_data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">lower_sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">lower_path</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* raw_data 就是挂载点的路径 */</span></span><br><span class="line"><span class="keyword">char</span> *dev_name = (<span class="keyword">char</span> *) raw_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过kern_path获取挂载点的 path 结构 */</span></span><br><span class="line">err = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY,</span><br><span class="line">&amp;lower_path);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取底层文件系统的超级块，并绑定到 wrapfs 的超级块里面 */</span></span><br><span class="line">lower_sb = lower_path.dentry-&gt;d_sb;</span><br><span class="line">wrapfs_set_lower_super(sb, lower_sb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置超级块的方法 */</span></span><br><span class="line">sb-&gt;s_op = &amp;wrapfs_sops;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取根 inode 和 dentry，并绑定对应底层目录的 inode ，后面会详细介绍 */</span></span><br><span class="line">inode = wrapfs_iget(sb, lower_path.dentry-&gt;d_inode);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(inode)) &#123;</span><br><span class="line">err = PTR_ERR(inode);</span><br><span class="line"><span class="keyword">goto</span> out_sput;</span><br><span class="line">&#125;</span><br><span class="line">sb-&gt;s_root = d_alloc_root(inode);</span><br><span class="line"><span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_iput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WrapFS-VFS-操作的一般方法"><a href="#WrapFS-VFS-操作的一般方法" class="headerlink" title="WrapFS VFS 操作的一般方法"></a>WrapFS VFS 操作的一般方法</h2><p>堆栈操作有两种类型：创建新 VFS 对象和不创建新 VFS 对象。</p><ul><li>下面是不创建 VFS 的方法.</li></ul><p>不创建 VFS 文件对象的方法仅仅传递 VFS 对象到底层，并返回可能的错误信息给 VFS ,比如 link 和 ulink 方法，下面是不创建新对象的代码，这个代码比较简单，就是调用 <code>get_lower_dentry()</code> 获取底层目录的 inode 对象，然后调用底层目录的 inode 对象的 unlink 方法解除 link。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> wrapfs<span class="constructor">_unlink(<span class="params">struct</span> <span class="params">inode</span> <span class="operator">*</span><span class="params">dir</span>, <span class="params">struct</span> <span class="params">dentry</span> <span class="operator">*</span><span class="params">dentry</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> err;</span><br><span class="line"><span class="keyword">struct</span> inode *lower_dir;</span><br><span class="line"><span class="keyword">struct</span> dentry *lower_dentry;</span><br><span class="line">lower_dir = get<span class="constructor">_lower_inode(<span class="params">dir</span>)</span>;</span><br><span class="line">lower_dentry = get<span class="constructor">_lower_dentry(<span class="params">dentry</span>)</span>;</span><br><span class="line">err = lower_dir-&gt;i_op-&gt;unlink(lower_dir, lower_dentry);</span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面代码展现的是重新创建新 VFS 对象的方法 create。</li></ul><p>主要流程就是先调用 <code>vfs_create</code> 创建底层文件系统对象，再调用 <code>wrapfs_interpose()</code> 创建自已的文件系统对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> wrapfs<span class="constructor">_create(<span class="params">struct</span> <span class="params">inode</span> <span class="operator">*</span><span class="params">dir</span>, <span class="params">struct</span> <span class="params">dentry</span> <span class="operator">*</span><span class="params">dentry</span>, <span class="params">int</span> <span class="params">mode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> err;</span><br><span class="line"><span class="keyword">struct</span> dentry *lower_dentry;</span><br><span class="line"><span class="keyword">struct</span> inode *lower_dir;</span><br><span class="line">lower_dir = wrapfs<span class="constructor">_lower_inode(<span class="params">dir</span>)</span>;</span><br><span class="line">lower_dentry = wrapfs<span class="constructor">_lower_dentry(<span class="params">dentry</span>)</span>;</span><br><span class="line">err = vfs<span class="constructor">_create(<span class="params">lower_dir</span>, <span class="params">lower_dentry</span>, <span class="params">mode</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">err = wrapfs<span class="constructor">_interpose(<span class="params">dentry</span>, <span class="params">dir</span>-&gt;<span class="params">i_sb</span>)</span>;</span><br><span class="line">return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数调用 <code>wrapfs_lower_inode()</code> 来获取底层 dir 的 inode，下面是该函数的实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline <span class="keyword">struct</span> inode *wrapfs<span class="constructor">_lower_inode(<span class="params">const</span> <span class="params">struct</span> <span class="params">inode</span> <span class="operator">*</span><span class="params">i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return wrapfs<span class="constructor">_I(<span class="params">i</span>)</span>-&gt;lower_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wrapfs_I(i)</code> 是一个宏，定义如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline <span class="keyword">struct</span> wrapfs_inode_info *wrapfs<span class="constructor">_I(<span class="params">const</span> <span class="params">struct</span> <span class="params">inode</span> <span class="operator">*</span><span class="params">inode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">return container<span class="constructor">_of(<span class="params">inode</span>, <span class="params">struct</span> <span class="params">wrapfs_inode_info</span>, <span class="params">vfs_inode</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 <code>struct wrapfs_inode_info</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wrapfs_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">lower_inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lower_inode</code> 是 WrapFS 层文件对应的底层文件的 inode，vfs_inode 是 WrapFS 层的 inode。那 lower_inode 是什么时候设置的?在后面会看到 WrapFS 在创建文件的时候会设置文件对应的 lower_inode。那么 WrapFS 的根目录的 lower_inode 是在什么时候设置的呢？前面有提到过 mount 的时候会获取 mount 点的 dentry 方法，其实根目录的 lower_inode 也是在 mount 时设定的。获取到底层文件系统的 inode 结构后，我们就可以在底层文件系统上创建文件了。这个时候底层的文件时创建好了，但是 WrapFS 层的文件还没有创建好，<code>wrapfs_interpose()</code> 就是做这个事情的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int wrapfs_interpose(<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span></span> *dentry, <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span> *sb,</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span></span> *lower_path)</span><br><span class="line">&#123;</span><br><span class="line">int err = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span> *inode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span> *lower_inode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span> *lower_sb;</span><br><span class="line"></span><br><span class="line">lower_inode = lower_path-&gt;dentry-&gt;d_inode;</span><br><span class="line">lower_sb = wrapfs_lower_super(sb);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数创建 WrapFS 的 inode */</span></span><br><span class="line">inode = wrapfs_iget(sb, lower_inode);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(inode)) &#123;</span><br><span class="line">err = PTR_ERR(inode);</span><br><span class="line">goto out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把 inode 和 dentry 绑定 */</span></span><br><span class="line">d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wrapfs_iget()</code> 创建 WrapFS 层的 inode，并绑定对应的底层文件的 inode;</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct inode *wrapfs_iget(struct super_block *sb, struct inode*lower_inode)</span><br><span class="line">&#123;</span><br><span class="line">struct wrapfs_inode_info *info;</span><br><span class="line">struct inode *inode; <span class="comment">/* the new inode to return */</span></span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建 WrapFS 的 inode，该函数会调用 super_ops 的 alloc_inode 方法即</span></span><br><span class="line"><span class="comment"> * wrapfs_alloc_in() 生成 struct wrapfs_inode_info 结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode = iget5_locked(sb, <span class="comment">/* our superblock */</span></span><br><span class="line"><span class="function"><span class="title">lower_inode</span>-&gt;</span>i_ino, <span class="comment">/* hashval */</span></span><br><span class="line">wrapfs_inode_test, <span class="comment">/* inode comparison function */</span></span><br><span class="line">wrapfs_inode_set, <span class="comment">/* inode init function */</span></span><br><span class="line">lower_inode); <span class="comment">/* data passed to test+set fxns */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定底层文件的 inode 到 struct WrapFS_inode_info 结构 */</span></span><br><span class="line">wrapfs_set_lower_inode(inode, lower_inode);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span>i_version++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据不同的文件类型设定不同的 inode 方法和 file_operation */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (S_ISDIR(lower_inode-&gt;</span>i_mode))</span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span>i_op = &amp;wrapfs_dir_iops;</span><br><span class="line"><span class="function"><span class="title">else</span> <span class="keyword">if</span> (S_ISLNK(lower_inode-&gt;</span>i_mode))</span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span>i_op = &amp;wrapfs_symlink_iops;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span>i_op = &amp;wrapfs_main_iops;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use different set of file ops for directories */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (S_ISDIR(lower_inode-&gt;</span>i_mode))</span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span>i_fop = &amp;wrapfs_dir_fops;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span>i_fop = &amp;wrapfs_main_fops;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_mapping</span>-&gt;</span>a_ops = &amp;wrapfs_aops;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化特殊的文件，比如 fifo，块设备文件，字符设备文件，socket 文件等，</span></span><br><span class="line"><span class="comment"> * 这些文件对应子模块有相关接口，所以直接调用内核提高的接口初始化就好了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">if</span> (S_ISBLK(lower_inode-&gt;</span><span class="function"><span class="title">i_mode</span>) || S_ISCHR(lower_inode-&gt;</span>i_mode) ||</span><br><span class="line">S_ISFIFO(<span class="function"><span class="title">lower_inode</span>-&gt;</span><span class="function"><span class="title">i_mode</span>) || S_ISSOCK(lower_inode-&gt;</span>i_mode))</span><br><span class="line"><span class="function"><span class="title">init_special_inode</span>(inode, lower_inode-&gt;</span>i_mode,</span><br><span class="line"><span class="function"><span class="title">lower_inode</span>-&gt;</span>i_rdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝底层文件的属性到 WrapFS 层文件，主要是创建时间，访问时间，文件大小等 */</span></span><br><span class="line">fsstack_copy_attr_all(inode, lower_inode);</span><br><span class="line">fsstack_copy_inode_size(inode, lower_inode);</span><br><span class="line"></span><br><span class="line">unlock_new_inode(inode);</span><br><span class="line">return inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WrapFS 创建文件的过程就是分别在底层文件系统和本层创建一个文件，然后重新设置一下本层文件的 inode 属性以及 inode 的方法和 <code>file_operation</code> 等方法，其它文件操作的方法和上面介绍的两种方法类似，就不一一介绍了。</p><h2 id="WrapFS-和链接的区别"><a href="#WrapFS-和链接的区别" class="headerlink" title="WrapFS 和链接的区别"></a>WrapFS 和链接的区别</h2><p>WrapFS 和链接是有很大区别的，WrapFS 是一种文件系统，有自己的 VFS 数据结构，他的数据结构保存在底层文件系统的某个路径，他把底层的文件系统改造一番后提供给用户，把用户创建的文件改造一番后写到底层文件系统上面。而硬链接是两个文件对于着同一个 inode 以及数据 block；软链接则只是一个文件，有着自己的数据块和 inode，文件数据里面存放着被链接文件的路径。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://wrapfs.filesystems.org" target="_blank" rel="noopener">WrapFS 官方网站</a></li><li><a href="http://blog.csdn.net/fybon/article/details/22789295" target="_blank" rel="noopener">WrapFS: a stackable file system（一种堆栈式文件系统）</a></li><li><a href="http://www.ithao123.cn/content-565293.html" target="_blank" rel="noopener">Android SDCard 存储方案（基于 FUSE 文件系统）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> WrapFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于调度器的 CPU 调频机制</title>
      <link href="/2016/04/07//cpufreq-sched.html/"/>
      <url>/2016/04/07//cpufreq-sched.html/</url>
      
        <content type="html"><![CDATA[<p>最近由于 Linaro 和 ARM 主导的 EAS(Energy Aware Scheduler) 日渐完善，属于 EAS 一部分的基于调度器的调频技术也获得了很多关注。本文主要介绍基于调度器的 CPU 调频策略的原理，以及当前上游社区在这一方面最新的进展。</p><h2 id="传统-CPU-调频策略"><a href="#传统-CPU-调频策略" class="headerlink" title="传统 CPU 调频策略"></a>传统 CPU 调频策略</h2><p>传统 CPU 调频模块主要分为 3 块：CPUFreq 核心模块、CPUFreq 驱动和 CPUFreq Governor。核心模块主要是一些公共的逻辑和 API，CPUFreq 驱动是处理和平台相关的逻辑，比如设置 CPU 的频率和电压。而 Governor 就是我们今天要讲的主角，CPU 调频的策略。CPU 在什么样负载，什么样的场景下应该跑多少频率，都是通过 CPUFreq Governor 采取一定策略来决定的，然后调用 <code>cpufreq_driver-&gt;target()</code> 来设置要调整的频率。</p><p>那么传统 CPUFreq Governor 是如何选择当前 CPU 的频率的呢？performance 和 powersave 这两个 governor 就不说了，一个是让 CPU 一直跑在最高频率，另外一个是让 CPU 跑在最低频率，所有的动作都在初始化的时候做了，本身也没有什么策略。userspace 只是实现了 scaling_setspeed 节点，主要策略在用户态，也没什么可讲的。而 ondemand 和 conservation 两个 governor 则是开启一个 timer，定期去计算各个 CPU 的负载。当 CPU 负载超过 80% 时，ondemand 就会把 CPU 频率调到最高，其他情况则会根据当前负载按比例计算频率。而对于 conservation 而言，CPU 负载超过 80% 时，默认会以 5% 的步伐递增；当 CPU 负载少于 20% 的时候，默认会以 5% 的步伐递减<sup><a href="#fn_cpufreq_source" id="reffn_cpufreq_source">cpufreq_source</a></sup>。</p><p>Interactive governor 并没有合入到 mainline，它是在 Android 中引入的。现在几乎所有的 Android 手机用的都在用这个 governor。所不同的是，它在每一个 CPU 上都注册了一个 idle notifier。当 CPU 退出 idle 状态时，interactive 就会缩减采样频率，从而可以快速响应负载变化。其他情况下，会根据当前 CPU 负载调整频率，这一点和 ondemand 类似<sup><a href="#fn_interactive" id="reffn_interactive">interactive</a></sup>。</p><p>总结起来，对于像 ondemand，conservation，interactive 含有调频逻辑的 governor，都包含一个共同的部分 - 负载采样，需要每隔一定时间就计算一次 CPU 负载。而这个共同点，就是今天这篇文章的关键。有些人认为，对于 CPU 的负载，没有谁比调度器还清楚的了。所以 cpufreq governor 完全没必要自己去做负载采样，应该从内核调度器那里获取。而基于调度器的 cpufreq governor 就是这样引出来的。</p><h2 id="基于调度器的-CPU-调频策略"><a href="#基于调度器的-CPU-调频策略" class="headerlink" title="基于调度器的 CPU 调频策略"></a>基于调度器的 CPU 调频策略</h2><p>内核调度器中的 CFS 调度类是通过 PELT(per entity load tracking) 来统计各个 Task 的负载（capacity），并映射到 0 ~ 1024（最大值可在编译时指定）。内核当中的负载均衡就是通过这些统计值来平衡各个 CPU 之间的任务。而基于调度器的 cpufreq governor 的主要原理就是把各个 CPU 的 capacity 映射到 CPU 频率，来完成调频动作，capacity 越高，当前 CPU 负载越高，所以频率也调的很高。</p><p>而当前内核社区中，已经有两个成形的方案。一个是 ARM 和 Linaro 主导的项目 - cpufreq_sched，属于 EAS 的一部分。而另外一个 Intel 主导的项目 - schedutil。</p><h3 id="cpufreq-sched"><a href="#cpufreq-sched" class="headerlink" title="cpufreq_sched"></a>cpufreq_sched</h3><p>cpufreq_sched<sup><a href="#fn_sched_freq" id="reffn_sched_freq">sched_freq</a></sup> 本身逻辑比较简单，当 cfs, rt, deadline 3 个调度类中的 capacity 出现变化的时候，就调用 <code>update_cpu_capacity_request()</code> 来更新当前 policy 下 CPU 的频率。cpufreq 中的 policy 有可能包含多个 CPU，所以这里要选择其中最大的 capacity 来代表整个 policy 的负载。capacity 到 CPU 频率，是通过如下代码按比例转换的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">freq_new</span> = capacity * policy-&gt;max &gt;&gt; SCHED_CAPACITY_SHIFT</span><br></pre></td></tr></table></figure><p><code>SCHED_CAPACITY_SHIFT</code> 一般是 10，即 capacity 的最大值 1024。假定当前 policy 允许的最大 CPU 频率是 1.2GHz，capacity 为 500，那么对应的频率是 586Mhz。如果我们直接把 CPU 设置在这个频率上，会导致一些性能上的下降。所以 cpufreq_sched 会在最终的 capacity 基础上，乘上 1.25，相当于在当前 capacity 的基础上增加 20%。</p><p>从 cpufreq_sched 的实现，我们可以看到整个调频动作，都是从调度器中直接设置下来的，cpufreq_sched 自身并没有去统计各个 CPU 的负载。而这种做法也让 CPU 的频率可以快速的响应负载变化，理论上讲，当前平台的 cpufreq 驱动最小调频间隔是多少，那么 cpufreq_sched 就可以做到多少。相比于 interactive 20ms 的调频间隔，cpufreq_sched 不到 1ms 的调频间隔简直是天壤之别。下图分别是 interactive 和 sched 在不同负载下 CPU 频率图：</p><ul><li>Interactive: <img src="interactive.png" alt="Interactive"></li><li>Cpufreq_sched: <img src="sched.png" alt="Sched"></li></ul><p>响应速度快，调频间隔短，固然是 cpufreq_sched 的优势，但是把整个调频动作都放到调度器里做，无疑会增加调度器的负担。调度器代码路径变长，也会增加调度器的延时。如果某个平台的 cpufreq 驱动在设置 CPU 频率的时候会导致系统睡眠，那么 cpufreq_sched 还需要在每一个 CPU 上额外开启一个线程，防止对调度器造成影响。</p><h3 id="schedutil"><a href="#schedutil" class="headerlink" title="schedutil"></a>schedutil</h3><p>在介绍 schedutil 之前，我们首先得介绍一个内核社区最近出现的新机制 - utilization update callback<sup><a href="#fn_capacity_callback" id="reffn_capacity_callback">capacity_callback</a></sup>。其实就是一个各个 CPU 使用率变化时的一种回调机制。通过 <code>cpufreq_set_update_util_data()</code> 来注册回调函数，当 cfs, rt, deadline 3 个调度类的 capacity 出现变化时，调用 <code>cpufreq_update_util()</code> 来触发 hook，实现类似 notifier 的效果。</p><p>而 schedutil<sup><a href="#fn_schedutil" id="reffn_schedutil">schedutil</a></sup> 就是利用这个负载变化回调机制，通过 <code>cpufreq_add_update_util_hook()</code> 注册回调函数，当 CPU 负载出现变化的时候，就会触发 schedutil <code>sugov_update</code> 进行调频动作。而剩下的调频实现，其实跟 cpufreq_sched 大同小异。</p><p>目前来看，cpufreq_sched 好像已经被放弃，而 schedutil 有望在 Linux kenrel 4.7 版本中合入，到时候，内核 Cpufreq Governor 又要新添一名成员了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_cpufreq_source"><sup>cpufreq_source</sup>. <a href="http://lxr.free-electrons.com/source/drivers/cpufreq/" target="_blank" rel="noopener">Cpufreq Governor 内核源码</a><a href="#reffn_cpufreq_source" title="Jump back to footnote [cpufreq_source] in the text."> &#8617;</a></blockquote><blockquote id="fn_interactive"><sup>interactive</sup>. <a href="https://lwn.net/Articles/662209/" target="_blank" rel="noopener">New ‘interactive’ governor</a><a href="#reffn_interactive" title="Jump back to footnote [interactive] in the text."> &#8617;</a></blockquote><blockquote id="fn_sched_freq"><sup>sched_freq</sup>. <a href="https://lkml.org/lkml/2016/2/22/1037" target="_blank" rel="noopener">Cpufreq_sched 补丁</a><a href="#reffn_sched_freq" title="Jump back to footnote [sched_freq] in the text."> &#8617;</a></blockquote><blockquote id="fn_capacity_callback"><sup>capacity_callback</sup>. <a href="https://lkml.org/lkml/2016/2/15/734" target="_blank" rel="noopener">utilization update callback</a><a href="#reffn_capacity_callback" title="Jump back to footnote [capacity_callback] in the text."> &#8617;</a></blockquote><blockquote id="fn_schedutil"><sup>schedutil</sup>. <a href="https://lkml.org/lkml/2016/3/29/1041" target="_blank" rel="noopener">Schedutil 补丁</a><a href="#reffn_schedutil" title="Jump back to footnote [schedutil] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 调度器 </category>
          
          <category> 电源管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpufreq </tag>
            
            <tag> schedutil </tag>
            
            <tag> EAS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
