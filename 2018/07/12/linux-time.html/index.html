<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="一个有内涵的技术分享平台">
    <meta name="keyword"  content="meizu,kernel,魅族">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Linux Time - 魅族内核团队
        
    </title>

    <link rel="canonical" href="https://kernel.meizu.com/2018/07/12//linux-time.html/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#hrtimer" title="hrtimer">hrtimer</a>
                            
                              <a class="tag" href="/tags/#tickless" title="tickless">tickless</a>
                            
                              <a class="tag" href="/tags/#clocksource" title="clocksource">clocksource</a>
                            
                              <a class="tag" href="/tags/#timekeeper" title="timekeeper">timekeeper</a>
                            
                              <a class="tag" href="/tags/#clockevent" title="clockevent">clockevent</a>
                            
                              <a class="tag" href="/tags/#noHZ" title="noHZ">noHZ</a>
                            
                              <a class="tag" href="/tags/#lowres timer" title="lowres timer">lowres timer</a>
                            
                              <a class="tag" href="/tags/#wall time" title="wall time">wall time</a>
                            
                              <a class="tag" href="/tags/#xtime" title="xtime">xtime</a>
                            
                              <a class="tag" href="/tags/#monotonic time" title="monotonic time">monotonic time</a>
                            
                              <a class="tag" href="/tags/#boottime" title="boottime">boottime</a>
                            
                        </div>
                        <h1>Linux Time</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Peng Weilin on
                            2018-07-12
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">魅族内核团队</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="1、Linux时钟框架"><a href="#1、Linux时钟框架" class="headerlink" title="1、Linux时钟框架"></a>1、Linux时钟框架</h2><p><img src="/images/posts/2017/10/linux_time_profile.png" alt="image"><sup><a href="#fn_DroidPhoneo" id="reffn_DroidPhoneo">DroidPhoneo</a></sup></p>
<p>上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。</p>
<p>1、定时Timer</p>
<ul>
<li>这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对应的是SPI（Shared Peripheral Interrupt，即多个cpu共享同一个中断。</li>
<li>这类timer一般是32bit宽度count，最重要的它会频繁的溢出并产生timer到期中断。</li>
<li>这类timer服务于tick timer(低精度)或者hrtimer(高精度)。</li>
<li>低精度模式，local timer工作在PERIODIC模式。即timer以tick时间(1/HZ)周期性的产生中断。在tick timer中处理任务调度tick、低精度timer、其他时间更新和统计profile。在这种模式下，所有利用时间的进行的运算，精度都是以tick(1/HZ)为单位的，精度较低。比如HZ=1000，那么tick=1ms。</li>
<li>高精度模式，local timer工作在ONESHOT模式。即系统可以支持hrtimer(high resolution)高精度timer，精度为local timer的计数clk达到ns级别。这种情况下把tick timer也转换成一种hrtimer。</li>
</ul>
<p>2、时间戳Timer</p>
<ul>
<li>这类timer一个系统多个cpu共享一个，称为global timer。</li>
<li>这类timer一般是32bit/64bit宽度count，一般不会溢出产生中断，系统实时的去读取count的值来计算当前的时间戳。</li>
<li>这类timer服务于clocksource/timekeeper。</li>
</ul>
<blockquote>
<p>本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”</p>
</blockquote>
<h3 id="1-1、Exynos-MCT-Multi-Core-Timer"><a href="#1-1、Exynos-MCT-Multi-Core-Timer" class="headerlink" title="1.1、Exynos MCT(Multi-Core Timer)"></a>1.1、Exynos MCT(Multi-Core Timer)</h3><p>我们以samsung exynos架构为例来说明linux对timer的使用。</p>
<p><img src="/images/posts/2017/10/exynos_timer.png" alt="image"></p>
<p>从上图可以看到，exynos有1个64bit global timer用来做时间戳timer，有8个31bit localtimer用来做定时timer，每个cpu拥有一个localtimer。</p>
<p><img src="/images/posts/2017/10/exynos_mct_initflow.png" alt="image"></p>
<p>上图是exynos driver的初始化流程，mct_init_dt()中包含了主要的初始化流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __init mct_init_dt(struct device_node *np, unsigned int int_type)</span><br><span class="line">&#123;</span><br><span class="line">	exynos4_timer_resources(np, of_iomap(np, 0)); &#x2F;&#x2F;(1)初始化localtimer，并将其注册成clockevent</span><br><span class="line">	exynos4_clocksource_init(); &#x2F;&#x2F;(2)初始化globaltimer，并将其注册成clocksource</span><br><span class="line">	exynos4_clockevent_init(); &#x2F;&#x2F;(3)将globaltimer的comparator 0注册成一个clockevent，一般不会使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面结合clocksource和clockevent的子系统的解析，再来详细描述exynos系统的具体实现。</p>
<h2 id="2、clocksource-amp-timekeeper"><a href="#2、clocksource-amp-timekeeper" class="headerlink" title="2、clocksource &amp; timekeeper"></a>2、clocksource &amp; timekeeper</h2><p><img src="/images/posts/2017/10/clocksource_timekeeper.png" alt="image"></p>
<p>上图描述的是clocksource和timekeeper的关系：</p>
<ul>
<li>一个global timer对应注册一个clocksource。</li>
<li>一个系统中可以有多个clocksource，timekeeper选择精度最高的那个来使用。</li>
<li>用户使用timekeeper提供的接口来获取系统的时间戳。</li>
<li>为了避免无人主动获取时间clocksource定时器的溢出，timekeeper需要定期的去获取clocksource的值来更新系统时间，一般是在tick处理中更新。</li>
</ul>
<h3 id="2-1、clocksource"><a href="#2-1、clocksource" class="headerlink" title="2.1、clocksource"></a>2.1、clocksource</h3><p>下面来看一看clocksource的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct clocksource mct_frc &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;mct-frc&quot;,</span><br><span class="line">	&#x2F;* (1) .rating &#x3D; 精度，数值越大越好，</span><br><span class="line">       select_best会选择精度最大的clocksource给timekeeper使用 *&#x2F;</span><br><span class="line">	.rating		&#x3D; 400,  </span><br><span class="line">	&#x2F;* (2) .read &#x3D; 读取clocksource的timer当前计数 *&#x2F;</span><br><span class="line">	.read		&#x3D; exynos4_frc_read,</span><br><span class="line">	&#x2F;* (3) .mask &#x3D; timer的位宽 *&#x2F;</span><br><span class="line">	.mask		&#x3D; CLOCKSOURCE_MASK(32),</span><br><span class="line">	.flags		&#x3D; CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">	.resume		&#x3D; exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看一下clocksource的注册过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">static void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 启动global timer</span><br><span class="line">	exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册timer_delay</span><br><span class="line">	exynos4_delay_timer.read_current_timer &#x3D; &amp;exynos4_read_current_timer;</span><br><span class="line">	exynos4_delay_timer.freq &#x3D; clk_rate;</span><br><span class="line">	register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; (1) 注册clocksource</span><br><span class="line">	if (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">		panic(&quot;%s: can&#39;t register clocksource\n&quot;, mct_frc.name);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注册sched_clock</span><br><span class="line">	sched_clock_register(exynos4_read_sched_clock, 32, clk_rate);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)</span><br><span class="line">&#123;</span><br><span class="line">	return __clocksource_register_scale(cs, 1, hz);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize mult&#x2F;shift and max_idle_ns *&#x2F;</span><br><span class="line">	&#x2F;* (1.1) 根据timer的频率freq，计算cs-&gt;mult、cs-&gt;shift</span><br><span class="line">	    这两个字段是用来把timer的计数转换成实际时间单位ns</span><br><span class="line">	    ns &#x3D; (count * cs-&gt;mult) &gt;&gt; cs-&gt;shift *&#x2F;</span><br><span class="line">	__clocksource_update_freq_scale(cs, scale, freq);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Add clocksource to the clocksource list *&#x2F;</span><br><span class="line">	mutex_lock(&amp;clocksource_mutex);</span><br><span class="line">	&#x2F;* (1.2) 将新的clocksource加入全局链表 *&#x2F;</span><br><span class="line">	clocksource_enqueue(cs);</span><br><span class="line">	clocksource_enqueue_watchdog(cs);</span><br><span class="line">	&#x2F;* (1.3) 从全局链表中重新选择一个best</span><br><span class="line">	    clocksource给timekeeper使用 *&#x2F;</span><br><span class="line">	clocksource_select();</span><br><span class="line">	clocksource_select_watchdog(false);</span><br><span class="line">	mutex_unlock(&amp;clocksource_mutex);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 sec;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Default clocksources are *special* and self-define their mult&#x2F;shift.</span><br><span class="line">	 * But, you&#39;re not special, so you should specify a freq value.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (freq) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Calc the maximum number of seconds which we can run before</span><br><span class="line">		 * wrapping around. For clocksources which have a mask &gt; 32-bit</span><br><span class="line">		 * we need to limit the max sleep time to have a good</span><br><span class="line">		 * conversion precision. 10 minutes is still a reasonable</span><br><span class="line">		 * amount. That results in a shift value of 24 for a</span><br><span class="line">		 * clocksource with mask &gt;&#x3D; 40-bit and f &gt;&#x3D; 4GHz. That maps to</span><br><span class="line">		 * ~ 0.06ppm granularity for NTP.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		&#x2F;* (1.1.1) 计算timer计数器到溢出，</span><br><span class="line">		    最大能计数多少秒 &#x3D; sec *&#x2F;</span><br><span class="line">		sec &#x3D; cs-&gt;mask;</span><br><span class="line">		do_div(sec, freq);</span><br><span class="line">		do_div(sec, scale);</span><br><span class="line">		if (!sec)</span><br><span class="line">			sec &#x3D; 1;</span><br><span class="line">		else if (sec &gt; 600 &amp;&amp; cs-&gt;mask &gt; UINT_MAX)</span><br><span class="line">			sec &#x3D; 600;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1.1.2) 根据1s内的频率数freq，和1s内的ns数NSEC_PER_SEC</span><br><span class="line">            计算freq和ns之间的转换公式：</span><br><span class="line">            ns &#x3D; (freq * cs-&gt;mult) &gt;&gt; cs-&gt;shift </span><br><span class="line">            目的是把mult和shift算到最大值，最大可能的保留精度 *&#x2F;</span><br><span class="line">		clocks_calc_mult_shift(&amp;cs-&gt;mult, &amp;cs-&gt;shift, freq,</span><br><span class="line">				       NSEC_PER_SEC &#x2F; scale, sec * scale);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Ensure clocksources that have large &#39;mult&#39; values don&#39;t overflow</span><br><span class="line">	 * when adjusted.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cs-&gt;maxadj &#x3D; clocksource_max_adjustment(cs);</span><br><span class="line">	while (freq &amp;&amp; ((cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult)</span><br><span class="line">		|| (cs-&gt;mult - cs-&gt;maxadj &gt; cs-&gt;mult))) &#123;</span><br><span class="line">		cs-&gt;mult &gt;&gt;&#x3D; 1;</span><br><span class="line">		cs-&gt;shift--;</span><br><span class="line">		cs-&gt;maxadj &#x3D; clocksource_max_adjustment(cs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Only warn for *special* clocksources that self-define</span><br><span class="line">	 * their mult&#x2F;shift values and don&#39;t specify a freq.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	WARN_ONCE(cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult,</span><br><span class="line">		&quot;timekeeping: Clocksource %s might overflow on 11%% adjustment\n&quot;,</span><br><span class="line">		cs-&gt;name);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1.3) 根据mult和shift的值，计算最大能进入idle的时间max_idle_ns</span><br><span class="line">        才能保证idle时timer不会溢出*&#x2F;</span><br><span class="line">	clocksource_update_max_deferment(cs);</span><br><span class="line"></span><br><span class="line">	pr_info(&quot;%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n&quot;,</span><br><span class="line">		cs-&gt;name, cs-&gt;mask, cs-&gt;max_cycles, cs-&gt;max_idle_ns);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">static void clocksource_select(void)</span><br><span class="line">&#123;</span><br><span class="line">	__clocksource_select(false);</span><br><span class="line">&#125;</span><br><span class="line">static void __clocksource_select(bool skipcur)</span><br><span class="line">&#123;</span><br><span class="line">	bool oneshot &#x3D; tick_oneshot_mode_active();</span><br><span class="line">	struct clocksource *best, *cs;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Find the best suitable clocksource *&#x2F;</span><br><span class="line">	&#x2F;* (1.3.1) 选择best clocksource *&#x2F;</span><br><span class="line">	best &#x3D; clocksource_find_best(oneshot, skipcur);</span><br><span class="line">	if (!best)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Check for the override clocksource. *&#x2F;</span><br><span class="line">	list_for_each_entry(cs, &amp;clocksource_list, list) &#123;</span><br><span class="line">		if (skipcur &amp;&amp; cs &#x3D;&#x3D; curr_clocksource)</span><br><span class="line">			continue;</span><br><span class="line">		if (strcmp(cs-&gt;name, override_name) !&#x3D; 0)</span><br><span class="line">			continue;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Check to make sure we don&#39;t switch to a non-highres</span><br><span class="line">		 * capable clocksource if the tick code is in oneshot</span><br><span class="line">		 * mode (highres or nohz)</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (!(cs-&gt;flags &amp; CLOCK_SOURCE_VALID_FOR_HRES) &amp;&amp; oneshot) &#123;</span><br><span class="line">			&#x2F;* Override clocksource cannot be used. *&#x2F;</span><br><span class="line">			pr_warn(&quot;Override clocksource %s is not HRT compatible - cannot switch while in HRT&#x2F;NOHZ mode\n&quot;,</span><br><span class="line">				cs-&gt;name);</span><br><span class="line">			override_name[0] &#x3D; 0;</span><br><span class="line">		&#125; else</span><br><span class="line">			&#x2F;* Override clocksource can be used. *&#x2F;</span><br><span class="line">			best &#x3D; cs;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.3.2) 通知timekeeper更新clocksource，tick-sched更新 *&#x2F;</span><br><span class="line">	if (curr_clocksource !&#x3D; best &amp;&amp; !timekeeping_notify(best)) &#123;</span><br><span class="line">		pr_info(&quot;Switched to clocksource %s\n&quot;, best-&gt;name);</span><br><span class="line">		curr_clocksource &#x3D; best;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">||||→</span><br><span class="line">int timekeeping_notify(struct clocksource *clock)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line"></span><br><span class="line">	if (tk-&gt;tkr_mono.clock &#x3D;&#x3D; clock)</span><br><span class="line">		return 0;</span><br><span class="line">	stop_machine(change_clocksource, clock, NULL);</span><br><span class="line">	tick_clock_notify();</span><br><span class="line">	return tk-&gt;tkr_mono.clock &#x3D;&#x3D; clock ? 0 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1、exynos4-clocksource-init"><a href="#2-1-1、exynos4-clocksource-init" class="headerlink" title="2.1.1、exynos4_clocksource_init()"></a>2.1.1、exynos4_clocksource_init()</h4><p>exynos将global timer注册成clocksource，虽然global timer拥有64bit的位宽，但是注册的时候把其当成32bit的clocksource注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static u32 notrace exynos4_read_count_32(void)</span><br><span class="line">&#123;</span><br><span class="line">	return readl_relaxed(reg_base + EXYNOS4_MCT_G_CNT_L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static cycle_t exynos4_frc_read(struct clocksource *cs)</span><br><span class="line">&#123;</span><br><span class="line">	return exynos4_read_count_32();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct clocksource mct_frc &#x3D; &#123;</span><br><span class="line">	.name		&#x3D; &quot;mct-frc&quot;,</span><br><span class="line">	.rating		&#x3D; 400,</span><br><span class="line">	.read		&#x3D; exynos4_frc_read,</span><br><span class="line">	.mask		&#x3D; CLOCKSOURCE_MASK(32),</span><br><span class="line">	.flags		&#x3D; CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">	.resume		&#x3D; exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">	exynos4_delay_timer.read_current_timer &#x3D; &amp;exynos4_read_current_timer;</span><br><span class="line">	exynos4_delay_timer.freq &#x3D; clk_rate;</span><br><span class="line">	register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) exynos将global timer注册成clocksource *&#x2F;</span><br><span class="line">	if (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">		panic(&quot;%s: can&#39;t register clocksource\n&quot;, mct_frc.name);</span><br><span class="line"></span><br><span class="line">	sched_clock_register(exynos4_read_sched_clock, 32, clk_rate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、timekeeper"><a href="#2-2、timekeeper" class="headerlink" title="2.2、timekeeper"></a>2.2、timekeeper</h3><p>timerkeeper提供了几种时间：xtime、monotonic time、raw monotonic time、boot time。</p>
<ul>
<li><strong>xtime</strong> 即是wall time，和RTC时间一样可以表示当前的时刻，它的起始时间是公元0世纪0秒，精度大于RTC时间；</li>
<li><strong>monotonic time</strong> 从系统开机后到现在的累计时间，不过不计算系统休眠的时间；</li>
<li><strong>raw monotonic time</strong> 和monotonic time含义一样，不过更纯粹，不会受到NTP时间调整的影响；</li>
<li><strong>boot time</strong> 在monotonic time的基础上加上了系统休眠的时间，它代表着系统上电后的总时间。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>时间种类</th>
<th>精度（统计单位）</th>
<th>访问速度</th>
<th>累计休眠时间</th>
<th>受NTP调整的影响</th>
<th>获取函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTC</td>
<td>低</td>
<td>慢</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>xtime</td>
<td>高</td>
<td>快</td>
<td>Yes</td>
<td>Yes</td>
<td>do_gettimeofday()、ktime_get_real_ts()、ktime_get_real()</td>
</tr>
<tr>
<td>monotonic</td>
<td>高</td>
<td>快</td>
<td>No</td>
<td>Yes</td>
<td>ktime_get()、ktime_get_ts64()</td>
</tr>
<tr>
<td>raw monotonic</td>
<td>高</td>
<td>快</td>
<td>No</td>
<td>No</td>
<td>ktime_get_raw()、getrawmonotonic64()</td>
</tr>
<tr>
<td>boot time</td>
<td>高</td>
<td>快</td>
<td>Yes</td>
<td>Yes</td>
<td>ktime_get_boottime()</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2-1、timekeeper的定义"><a href="#2-2-1、timekeeper的定义" class="headerlink" title="2.2.1、timekeeper的定义"></a>2.2.1、timekeeper的定义</h4><p>虽然clocksource定时器只有一个，但是timekeeper提供了xtime、monotonic time、raw time、boot time等几种时间，所以timekeeper结构体中定义了多个变量来记住这些差值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct timekeeper - Structure holding internal timekeeping values.</span><br><span class="line"> * @tkr_mono:		The readout base structure for CLOCK_MONOTONIC</span><br><span class="line"> * @tkr_raw:		The readout base structure for CLOCK_MONOTONIC_RAW</span><br><span class="line"> * @xtime_sec:		Current CLOCK_REALTIME time in seconds</span><br><span class="line"> * @ktime_sec:		Current CLOCK_MONOTONIC time in seconds</span><br><span class="line"> * @wall_to_monotonic:	CLOCK_REALTIME to CLOCK_MONOTONIC offset</span><br><span class="line"> * @offs_real:		Offset clock monotonic -&gt; clock realtime</span><br><span class="line"> * @offs_boot:		Offset clock monotonic -&gt; clock boottime</span><br><span class="line"> * @offs_tai:		Offset clock monotonic -&gt; clock tai</span><br><span class="line"> * @tai_offset:		The current UTC to TAI offset in seconds</span><br><span class="line"> * @clock_was_set_seq:	The sequence number of clock was set events</span><br><span class="line"> * @next_leap_ktime:	CLOCK_MONOTONIC time value of a pending leap-second</span><br><span class="line"> * @raw_time:		Monotonic raw base time in timespec64 format</span><br><span class="line"> * @cycle_interval:	Number of clock cycles in one NTP interval</span><br><span class="line"> * @xtime_interval:	Number of clock shifted nano seconds in one NTP</span><br><span class="line"> *			interval.</span><br><span class="line"> * @xtime_remainder:	Shifted nano seconds left over when rounding</span><br><span class="line"> *			@cycle_interval</span><br><span class="line"> * @raw_interval:	Raw nano seconds accumulated per NTP interval.</span><br><span class="line"> * @ntp_error:		Difference between accumulated time and NTP time in ntp</span><br><span class="line"> *			shifted nano seconds.</span><br><span class="line"> * @ntp_error_shift:	Shift conversion between clock shifted nano seconds and</span><br><span class="line"> *			ntp shifted nano seconds.</span><br><span class="line"> * @last_warning:	Warning ratelimiter (DEBUG_TIMEKEEPING)</span><br><span class="line"> * @underflow_seen:	Underflow warning flag (DEBUG_TIMEKEEPING)</span><br><span class="line"> * @overflow_seen:	Overflow warning flag (DEBUG_TIMEKEEPING)</span><br><span class="line"> *</span><br><span class="line"> * Note: For timespec(64) based interfaces wall_to_monotonic is what</span><br><span class="line"> * we need to add to xtime (or xtime corrected for sub jiffie times)</span><br><span class="line"> * to get to monotonic time.  Monotonic is pegged at zero at system</span><br><span class="line"> * boot time, so wall_to_monotonic will be negative, however, we will</span><br><span class="line"> * ALWAYS keep the tv_nsec part positive so we can use the usual</span><br><span class="line"> * normalization.</span><br><span class="line"> *</span><br><span class="line"> * wall_to_monotonic is moved after resume from suspend for the</span><br><span class="line"> * monotonic time not to jump. We need to add total_sleep_time to</span><br><span class="line"> * wall_to_monotonic to get the real boot based time offset.</span><br><span class="line"> *</span><br><span class="line"> * wall_to_monotonic is no longer the boot time, getboottime must be</span><br><span class="line"> * used instead.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct timekeeper &#123;</span><br><span class="line">	struct tk_read_base	tkr_mono;   </span><br><span class="line">                &#x2F;&#x2F; tkr_mono.xtime_nsec：xtime&#x2F;monotonic time 的ns</span><br><span class="line">                &#x2F;&#x2F; tkr_mono.base：monotonic time的base部分</span><br><span class="line">	struct tk_read_base	tkr_raw;</span><br><span class="line">                &#x2F;&#x2F; tkr_mono.base：raw time的base部分</span><br><span class="line">	u64			xtime_sec;              &#x2F;&#x2F; xtime的sec</span><br><span class="line">	unsigned long		ktime_sec;      &#x2F;&#x2F; monotonic time 的整sec</span><br><span class="line">	struct timespec64	wall_to_monotonic;  &#x2F;&#x2F; xtime + wall_to_monotonic &#x3D; monotonic time</span><br><span class="line">	ktime_t			offs_real;  &#x2F;&#x2F;  monotonic time + offs_real &#x3D; xtime，</span><br><span class="line">                                &#x2F;&#x2F; 和wall_to_monotonic是相反的值</span><br><span class="line">	ktime_t			offs_boot;  &#x2F;&#x2F;  monotonic time + offs_boot &#x3D; boot time</span><br><span class="line">	ktime_t			offs_tai;</span><br><span class="line">	s32			tai_offset;</span><br><span class="line">	unsigned int		clock_was_set_seq;</span><br><span class="line">	ktime_t			next_leap_ktime;</span><br><span class="line">	struct timespec64	raw_time;   &#x2F;&#x2F; raw time</span><br><span class="line"></span><br><span class="line">	&#x2F;* The following members are for timekeeping internal use *&#x2F;</span><br><span class="line">	cycle_t			cycle_interval;</span><br><span class="line">	u64			xtime_interval;</span><br><span class="line">	s64			xtime_remainder;</span><br><span class="line">	u32			raw_interval;</span><br><span class="line">	&#x2F;* The ntp_tick_length() value currently being used.</span><br><span class="line">	 * This cached copy ensures we consistently apply the tick</span><br><span class="line">	 * length for an entire tick, as ntp_tick_length may change</span><br><span class="line">	 * mid-tick, and we don&#39;t want to apply that new value to</span><br><span class="line">	 * the tick in progress.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	u64			ntp_tick;</span><br><span class="line">	&#x2F;* Difference between accumulated time and NTP time in ntp</span><br><span class="line">	 * shifted nano seconds. *&#x2F;</span><br><span class="line">	s64			ntp_error;</span><br><span class="line">	u32			ntp_error_shift;</span><br><span class="line">	u32			ntp_err_mult;</span><br><span class="line">#ifdef CONFIG_DEBUG_TIMEKEEPING</span><br><span class="line">	long			last_warning;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * These simple flag variables are managed</span><br><span class="line">	 * without locks, which is racy, but they are</span><br><span class="line">	 * ok since we don&#39;t really care about being</span><br><span class="line">	 * super precise about how many events were</span><br><span class="line">	 * seen, just that a problem was observed.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int			underflow_seen;</span><br><span class="line">	int			overflow_seen;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2、timekeeper的初始化"><a href="#2-2-2、timekeeper的初始化" class="headerlink" title="2.2.2、timekeeper的初始化"></a>2.2.2、timekeeper的初始化</h4><p>timekeeper在初始化的过程中，读取当前的RTC值和clocksource的值，来初始化xtime、monotonic time、raw time、boot time，以及各种offset。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void __init timekeeping_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	struct clocksource *clock;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64 now, boot, tmp;</span><br><span class="line"></span><br><span class="line">	read_persistent_clock64(&amp;now);</span><br><span class="line">	if (!timespec64_valid_strict(&amp;now)) &#123;</span><br><span class="line">		pr_warn(&quot;WARNING: Persistent clock returned invalid value!\n&quot;</span><br><span class="line">			&quot;         Check your CMOS&#x2F;BIOS settings.\n&quot;);</span><br><span class="line">		now.tv_sec &#x3D; 0;</span><br><span class="line">		now.tv_nsec &#x3D; 0;</span><br><span class="line">	&#125; else if (now.tv_sec || now.tv_nsec)</span><br><span class="line">		persistent_clock_exists &#x3D; true;</span><br><span class="line"></span><br><span class="line">	read_boot_clock64(&amp;boot);</span><br><span class="line">	if (!timespec64_valid_strict(&amp;boot)) &#123;</span><br><span class="line">		pr_warn(&quot;WARNING: Boot clock returned invalid value!\n&quot;</span><br><span class="line">			&quot;         Check your CMOS&#x2F;BIOS settings.\n&quot;);</span><br><span class="line">		boot.tv_sec &#x3D; 0;</span><br><span class="line">		boot.tv_nsec &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	ntp_init();</span><br><span class="line"></span><br><span class="line">	clock &#x3D; clocksource_default_clock();</span><br><span class="line">	if (clock-&gt;enable)</span><br><span class="line">		clock-&gt;enable(clock);</span><br><span class="line">	tk_setup_internals(tk, clock);</span><br><span class="line"></span><br><span class="line">	tk_set_xtime(tk, &amp;now);</span><br><span class="line">	tk-&gt;raw_time.tv_sec &#x3D; 0;</span><br><span class="line">	tk-&gt;raw_time.tv_nsec &#x3D; 0;</span><br><span class="line">	if (boot.tv_sec &#x3D;&#x3D; 0 &amp;&amp; boot.tv_nsec &#x3D;&#x3D; 0)</span><br><span class="line">		boot &#x3D; tk_xtime(tk);</span><br><span class="line"></span><br><span class="line">	set_normalized_timespec64(&amp;tmp, -boot.tv_sec, -boot.tv_nsec);</span><br><span class="line">	tk_set_wall_to_mono(tk, tmp);</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timekeeper原理上的初始化是在timekeeping_init()函数中完成的，但是read_persistent_clock64()、read_boot_clock64()都是空函数，所以实际上的初始化是另外的路径：rtc_hctosys() -&gt; do_settimeofday64()，rtc初始化的时候重新配置timekeeper。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">static int __init rtc_hctosys(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err &#x3D; -ENODEV;</span><br><span class="line">	struct rtc_time tm;</span><br><span class="line">	struct timespec64 tv64 &#x3D; &#123;</span><br><span class="line">		.tv_nsec &#x3D; NSEC_PER_SEC &gt;&gt; 1,</span><br><span class="line">	&#125;;</span><br><span class="line">	struct rtc_device *rtc &#x3D; rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line"></span><br><span class="line">	if (rtc &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		pr_info(&quot;unable to open rtc device (%s)\n&quot;,</span><br><span class="line">			CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line">		goto err_open;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 读取当前的rtc时间 *&#x2F;</span><br><span class="line">	err &#x3D; rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	if (err) &#123;</span><br><span class="line">		dev_err(rtc-&gt;dev.parent,</span><br><span class="line">			&quot;hctosys: unable to read the hardware clock\n&quot;);</span><br><span class="line">		goto err_read;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tv64.tv_sec &#x3D; rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	tv64.tv_nsec &#x3D; tm.tm_cnt * (1000000000 &#x2F; 32768);</span><br><span class="line">	</span><br><span class="line">	&#x2F;* (2) 根据rtc时间配置xtime *&#x2F;</span><br><span class="line">	err &#x3D; do_settimeofday64(&amp;tv64);</span><br><span class="line"></span><br><span class="line">	dev_info(rtc-&gt;dev.parent,</span><br><span class="line">		&quot;setting system clock to &quot;</span><br><span class="line">		&quot;%d-%02d-%02d %02d:%02d:%02d UTC (%lld)\n&quot;,</span><br><span class="line">		tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,</span><br><span class="line">		tm.tm_hour, tm.tm_min, tm.tm_sec,</span><br><span class="line">		(long long) tv64.tv_sec);</span><br><span class="line"></span><br><span class="line">err_read:</span><br><span class="line">	rtc_class_close(rtc);</span><br><span class="line"></span><br><span class="line">err_open:</span><br><span class="line">	rtc_hctosys_ret &#x3D; err;</span><br><span class="line"></span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">int do_settimeofday64(const struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	struct timespec64 ts_delta, xt;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (!timespec64_valid_strict(ts))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 读取当前的xtime，计算rtc time和xtime之间的差值  *&#x2F;</span><br><span class="line">	xt &#x3D; tk_xtime(tk);</span><br><span class="line">	ts_delta.tv_sec &#x3D; ts-&gt;tv_sec - xt.tv_sec;</span><br><span class="line">	ts_delta.tv_nsec &#x3D; ts-&gt;tv_nsec - xt.tv_nsec;</span><br><span class="line"></span><br><span class="line">	if (timespec64_compare(&amp;tk-&gt;wall_to_monotonic, &amp;ts_delta) &gt; 0) &#123;</span><br><span class="line">		ret &#x3D; -EINVAL;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2) 将差值追加到offset；tk-&gt;wall_to_monotonic、tk-&gt;offs_real *&#x2F;</span><br><span class="line">	tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, ts_delta));</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.3) 更新xtime *&#x2F;</span><br><span class="line">	tk_set_xtime(tk, ts);</span><br><span class="line">out:</span><br><span class="line">	timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	&#x2F;* signal hrtimers about time change *&#x2F;</span><br><span class="line">	clock_was_set();</span><br><span class="line">	notify_time_update();</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3、timekeeper的update"><a href="#2-2-3、timekeeper的update" class="headerlink" title="2.2.3、timekeeper的update"></a>2.2.3、timekeeper的update</h4><p>clocksource定时器的值要定时的读出来，并且把增量加到timekeeper中，不然clocksource定时器会溢出。这个定时更新的时间一般是1 tick，调用的函数是update_wall_time()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">void update_wall_time(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *real_tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;shadow_timekeeper;</span><br><span class="line">	cycle_t offset;</span><br><span class="line">	int shift &#x3D; 0, maxshift;</span><br><span class="line">	unsigned int clock_set &#x3D; 0;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Make sure we&#39;re fully resumed: *&#x2F;</span><br><span class="line">	if (unlikely(timekeeping_suspended))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span><br><span class="line">	offset &#x3D; real_tk-&gt;cycle_interval;</span><br><span class="line">#else</span><br><span class="line">    &#x2F;* (1) 获取clocksource和上一次update之间的offset *&#x2F;</span><br><span class="line">	offset &#x3D; clocksource_delta(tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock),</span><br><span class="line">				   tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;* Check if there&#39;s really nothing to do *&#x2F;</span><br><span class="line">	if (offset &lt; real_tk-&gt;cycle_interval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Do some additional sanity checking *&#x2F;</span><br><span class="line">	timekeeping_check_update(real_tk, offset);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * With NO_HZ we may have to accumulate many cycle_intervals</span><br><span class="line">	 * (think &quot;ticks&quot;) worth of time at once. To do this efficiently,</span><br><span class="line">	 * we calculate the largest doubling multiple of cycle_intervals</span><br><span class="line">	 * that is smaller than the offset.  We then accumulate that</span><br><span class="line">	 * chunk in one go, and then try to consume the next smaller</span><br><span class="line">	 * doubled multiple.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	shift &#x3D; ilog2(offset) - ilog2(tk-&gt;cycle_interval);</span><br><span class="line">	shift &#x3D; max(0, shift);</span><br><span class="line">	&#x2F;* Bound shift to one less than what overflows tick_length *&#x2F;</span><br><span class="line">	maxshift &#x3D; (64 - (ilog2(ntp_tick_length())+1)) - 1;</span><br><span class="line">	shift &#x3D; min(shift, maxshift);</span><br><span class="line">	&#x2F;* (2) 如果offset的值是多个cycle_interval，</span><br><span class="line">	    不要一次update，使用2的n次方cycle_interval的方式逐个update。</span><br><span class="line">	    tk-&gt;cycle_interval的值在tk_setup_internals()时被赋值，默认为1 tick *&#x2F;</span><br><span class="line">	while (offset &gt;&#x3D; tk-&gt;cycle_interval) &#123;</span><br><span class="line">	    &#x2F;* (3) 将offset更新到timekeeper中 *&#x2F;</span><br><span class="line">		offset &#x3D; logarithmic_accumulation(tk, offset, shift,</span><br><span class="line">							&amp;clock_set);</span><br><span class="line">		if (offset &lt; tk-&gt;cycle_interval&lt;&lt;shift)</span><br><span class="line">			shift--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* correct the clock when NTP error is too big *&#x2F;</span><br><span class="line">	timekeeping_adjust(tk, offset);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * XXX This can be killed once everyone converts</span><br><span class="line">	 * to the new update_vsyscall.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	old_vsyscall_fixup(tk);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Finally, make sure that after the rounding</span><br><span class="line">	 * xtime_nsec isn&#39;t larger than NSEC_PER_SEC</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	clock_set |&#x3D; accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Update the real timekeeper.</span><br><span class="line">	 *</span><br><span class="line">	 * We could avoid this memcpy by switching pointers, but that</span><br><span class="line">	 * requires changes to all other timekeeper usage sites as</span><br><span class="line">	 * well, i.e. move the timekeeper pointer getter into the</span><br><span class="line">	 * spinlocked&#x2F;seqcount protected sections. And we trade this</span><br><span class="line">	 * memcpy under the tk_core.seq against one before we start</span><br><span class="line">	 * updating.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (4)  *&#x2F;</span><br><span class="line">	timekeeping_update(tk, clock_set);</span><br><span class="line">	memcpy(real_tk, tk, sizeof(*tk));</span><br><span class="line">	&#x2F;* The memcpy must come last. Do not put anything here! *&#x2F;</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">	if (clock_set)</span><br><span class="line">		&#x2F;* Have to call _delayed version, since in irq context*&#x2F;</span><br><span class="line">		clock_was_set_delayed();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static cycle_t logarithmic_accumulation(struct timekeeper *tk, cycle_t offset,</span><br><span class="line">						u32 shift,</span><br><span class="line">						unsigned int *clock_set)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t interval &#x3D; tk-&gt;cycle_interval &lt;&lt; shift;</span><br><span class="line">	u64 raw_nsecs;</span><br><span class="line"></span><br><span class="line">	&#x2F;* If the offset is smaller than a shifted interval, do nothing *&#x2F;</span><br><span class="line">	if (offset &lt; interval)</span><br><span class="line">		return offset;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Accumulate one shifted interval *&#x2F;</span><br><span class="line">	offset -&#x3D; interval;</span><br><span class="line">	&#x2F;* (3.1) 更新cycle_last *&#x2F;</span><br><span class="line">	tk-&gt;tkr_mono.cycle_last +&#x3D; interval;</span><br><span class="line">	tk-&gt;tkr_raw.cycle_last  +&#x3D; interval;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (3.2) 更新xtime：</span><br><span class="line">        tk-&gt;tkr_mono.xtime_nsec</span><br><span class="line">        tk-&gt;xtime_sec   *&#x2F;</span><br><span class="line">	tk-&gt;tkr_mono.xtime_nsec +&#x3D; tk-&gt;xtime_interval &lt;&lt; shift;</span><br><span class="line">	*clock_set |&#x3D; accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Accumulate raw time *&#x2F;</span><br><span class="line">	&#x2F;* (3.3) 更新raw time：</span><br><span class="line">	   tk-&gt;raw_time.tv_nsec</span><br><span class="line">	   tk-&gt;raw_time.tv_sec *&#x2F;</span><br><span class="line">	raw_nsecs &#x3D; (u64)tk-&gt;raw_interval &lt;&lt; shift;</span><br><span class="line">	raw_nsecs +&#x3D; tk-&gt;raw_time.tv_nsec;</span><br><span class="line">	if (raw_nsecs &gt;&#x3D; NSEC_PER_SEC) &#123;</span><br><span class="line">		u64 raw_secs &#x3D; raw_nsecs;</span><br><span class="line">		raw_nsecs &#x3D; do_div(raw_secs, NSEC_PER_SEC);</span><br><span class="line">		tk-&gt;raw_time.tv_sec +&#x3D; raw_secs;</span><br><span class="line">	&#125;</span><br><span class="line">	tk-&gt;raw_time.tv_nsec &#x3D; raw_nsecs;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Accumulate error between NTP and clock interval *&#x2F;</span><br><span class="line">	tk-&gt;ntp_error +&#x3D; tk-&gt;ntp_tick &lt;&lt; shift;</span><br><span class="line">	tk-&gt;ntp_error -&#x3D; (tk-&gt;xtime_interval + tk-&gt;xtime_remainder) &lt;&lt;</span><br><span class="line">						(tk-&gt;ntp_error_shift + shift);</span><br><span class="line"></span><br><span class="line">	return offset;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void timekeeping_update(struct timekeeper *tk, unsigned int action)</span><br><span class="line">&#123;</span><br><span class="line">	if (action &amp; TK_CLEAR_NTP) &#123;</span><br><span class="line">		tk-&gt;ntp_error &#x3D; 0;</span><br><span class="line">		ntp_clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tk_update_leap_state(tk);</span><br><span class="line">	&#x2F;* (4.1) update monotonic time *&#x2F;</span><br><span class="line">	tk_update_ktime_data(tk);</span><br><span class="line"></span><br><span class="line">	update_vsyscall(tk);</span><br><span class="line">	update_pvclock_gtod(tk, action &amp; TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	update_fast_timekeeper(&amp;tk-&gt;tkr_mono, &amp;tk_fast_mono);</span><br><span class="line">	update_fast_timekeeper(&amp;tk-&gt;tkr_raw,  &amp;tk_fast_raw);</span><br><span class="line"></span><br><span class="line">	if (action &amp; TK_CLOCK_WAS_SET)</span><br><span class="line">		tk-&gt;clock_was_set_seq++;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The mirroring of the data to the shadow-timekeeper needs</span><br><span class="line">	 * to happen last here to ensure we don&#39;t over-write the</span><br><span class="line">	 * timekeeper structure on the next update with stale data</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (action &amp; TK_MIRROR)</span><br><span class="line">		memcpy(&amp;shadow_timekeeper, &amp;tk_core.timekeeper,</span><br><span class="line">		       sizeof(tk_core.timekeeper));</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline void tk_update_ktime_data(struct timekeeper *tk)</span><br><span class="line">&#123;</span><br><span class="line">	u64 seconds;</span><br><span class="line">	u32 nsec;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The xtime based monotonic readout is:</span><br><span class="line">	 *	nsec &#x3D; (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();</span><br><span class="line">	 * The ktime based monotonic readout is:</span><br><span class="line">	 *	nsec &#x3D; base_mono + now();</span><br><span class="line">	 * &#x3D;&#x3D;&gt; base_mono &#x3D; (xtime_sec + wtm_sec) * 1e9 + wtm_nsec</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (4.1.1) update tk-&gt;tkr_mono.base的值，</span><br><span class="line">	   &#x3D; tk-&gt;xtime_sec +  tk-&gt;wall_to_monotonic,</span><br><span class="line">	   tk-&gt;tkr_mono.xtime_nsec 没有计算到base中 *&#x2F;</span><br><span class="line">	seconds &#x3D; (u64)(tk-&gt;xtime_sec + tk-&gt;wall_to_monotonic.tv_sec);</span><br><span class="line">	nsec &#x3D; (u32) tk-&gt;wall_to_monotonic.tv_nsec;</span><br><span class="line">	tk-&gt;tkr_mono.base &#x3D; ns_to_ktime(seconds * NSEC_PER_SEC + nsec);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Update the monotonic raw base *&#x2F;</span><br><span class="line">	&#x2F;* (4.1.2) update tk-&gt;tkr_raw.base的值，</span><br><span class="line">	   直接转换tk-&gt;raw_time *&#x2F;</span><br><span class="line">	tk-&gt;tkr_raw.base &#x3D; timespec64_to_ktime(tk-&gt;raw_time);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The sum of the nanoseconds portions of xtime and</span><br><span class="line">	 * wall_to_monotonic can be greater&#x2F;equal one second. Take</span><br><span class="line">	 * this into account before updating tk-&gt;ktime_sec.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (4.1.3) update tk-&gt;ktime_sec的值</span><br><span class="line">	nsec +&#x3D; (u32)(tk-&gt;tkr_mono.xtime_nsec &gt;&gt; tk-&gt;tkr_mono.shift);</span><br><span class="line">	if (nsec &gt;&#x3D; NSEC_PER_SEC)</span><br><span class="line">		seconds++;</span><br><span class="line">	tk-&gt;ktime_sec &#x3D; seconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4、timekeeper的获取"><a href="#2-2-4、timekeeper的获取" class="headerlink" title="2.2.4、timekeeper的获取"></a>2.2.4、timekeeper的获取</h4><ul>
<li><strong>xtime/wall time 的获取:</strong></li>
</ul>
<p>do_gettimeofday()、ktime_get_real_ts()最后调用的getnstimeofday64() -&gt; __getnstimeofday64()获取到xtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">int __getnstimeofday64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long seq;</span><br><span class="line">	s64 nsecs &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) sec直接从变量tk-&gt;xtime_sec获取到，</span><br><span class="line">            即上一tick更新的值 *&#x2F;</span><br><span class="line">		ts-&gt;tv_sec &#x3D; tk-&gt;xtime_sec;</span><br><span class="line">		</span><br><span class="line">		&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">		nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	ts-&gt;tv_nsec &#x3D; 0;</span><br><span class="line">	timespec64_add_ns(ts, nsecs);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Do not bail out early, in case there were callers still using</span><br><span class="line">	 * the value, even in the face of the WARN_ON.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(timekeeping_suspended))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t delta;</span><br><span class="line">	s64 nsec;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 获取距离上一次tick更新，timer的delta值  *&#x2F;</span><br><span class="line">	delta &#x3D; timekeeping_get_delta(tkr);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2) delta加上上一次的nsec tkr-&gt;xtime_nsec，</span><br><span class="line">        即为最新的ns值 *&#x2F;</span><br><span class="line">	nsec &#x3D; (delta * tkr-&gt;mult + tkr-&gt;xtime_nsec) &gt;&gt; tkr-&gt;shift;</span><br><span class="line"></span><br><span class="line">	&#x2F;* If arch requires, add in get_arch_timeoffset() *&#x2F;</span><br><span class="line">	return nsec + arch_gettimeoffset();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline cycle_t timekeeping_get_delta(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	cycle_t now, last, mask, max, delta;</span><br><span class="line">	unsigned int seq;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Since we&#39;re called holding a seqlock, the data may shift</span><br><span class="line">	 * under us while we&#39;re doing the calculation. This can cause</span><br><span class="line">	 * false positives, since we&#39;d note a problem but throw the</span><br><span class="line">	 * results away. So nest another seqlock here to atomically</span><br><span class="line">	 * grab the points we are checking with.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		&#x2F;* (2.1.1) 使用read函数读取当前timer的计数 *&#x2F;</span><br><span class="line">		now &#x3D; tkr-&gt;read(tkr-&gt;clock);</span><br><span class="line">		last &#x3D; tkr-&gt;cycle_last;</span><br><span class="line">		mask &#x3D; tkr-&gt;mask;</span><br><span class="line">		max &#x3D; tkr-&gt;clock-&gt;max_cycles;</span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1.2) 使用公式：(now - last) &amp; mask，</span><br><span class="line">        计算delta值 *&#x2F;</span><br><span class="line">	delta &#x3D; clocksource_delta(now, last, mask);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Try to catch underflows by checking if we are seeing small</span><br><span class="line">	 * mask-relative negative values.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely((~delta &amp; mask) &lt; (mask &gt;&gt; 3))) &#123;</span><br><span class="line">		tk-&gt;underflow_seen &#x3D; 1;</span><br><span class="line">		delta &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Cap delta value to the max_cycles values to avoid mult overflows *&#x2F;</span><br><span class="line">	if (unlikely(delta &gt; max)) &#123;</span><br><span class="line">		tk-&gt;overflow_seen &#x3D; 1;</span><br><span class="line">		delta &#x3D; tkr-&gt;clock-&gt;max_cycles;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ktime_get_real()使用monotonic time再加上差值timekeeper.offs_real的方法来获取xtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime_get_real(void)</span><br><span class="line">&#123;</span><br><span class="line">	return ktime_get_with_offset(TK_OFFS_REAL);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static ktime_t *offsets[TK_OFFS_MAX] &#x3D; &#123;</span><br><span class="line">	[TK_OFFS_REAL]	&#x3D; &amp;tk_core.timekeeper.offs_real,</span><br><span class="line">	[TK_OFFS_BOOT]	&#x3D; &amp;tk_core.timekeeper.offs_boot,</span><br><span class="line">	[TK_OFFS_TAI]	&#x3D; &amp;tk_core.timekeeper.offs_tai,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ktime_t ktime_get_with_offset(enum tk_offsets offs)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base, *offset &#x3D; offsets[offs];</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		&#x2F;* (1) monotonic time &#x3D; tk-&gt;tkr_mono.base，</span><br><span class="line">		   offset &#x3D; timekeeper.offs_real *&#x2F;</span><br><span class="line">		base &#x3D; ktime_add(tk-&gt;tkr_mono.base, *offset);</span><br><span class="line">		&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">		nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>monotonic time 的获取；</strong></li>
</ul>
<p>ktime_get()直接获取monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime_get(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		&#x2F;* (1) monotonic time &#x3D; tk-&gt;tkr_mono.base *&#x2F;</span><br><span class="line">		base &#x3D; tk-&gt;tkr_mono.base;</span><br><span class="line">		&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">		nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ktime_get_ts64()通过xtime加上差值tk-&gt;wall_to_monotonic的方法来获取monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ktime_get_ts64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	struct timespec64 tomono;</span><br><span class="line">	s64 nsec;</span><br><span class="line">	unsigned int seq;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		&#x2F;* (1) 获取xtime *&#x2F;</span><br><span class="line">		ts-&gt;tv_sec &#x3D; tk-&gt;xtime_sec;</span><br><span class="line">		nsec &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line">		&#x2F;* (2) 加上xtime和monotonic之间的差值tk-&gt;wall_to_monotonic *&#x2F;</span><br><span class="line">		tomono &#x3D; tk-&gt;wall_to_monotonic;</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	ts-&gt;tv_sec +&#x3D; tomono.tv_sec;</span><br><span class="line">	ts-&gt;tv_nsec &#x3D; 0;</span><br><span class="line">	timespec64_add_ns(ts, nsec + tomono.tv_nsec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>raw monotonic time 的获取；</strong></li>
</ul>
<p>ktime_get_raw()通过tk-&gt;tkr_raw.base获取raw monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime_get_raw(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		&#x2F;* (1) raw monotonic time &#x3D; tk-&gt;tkr_raw.base *&#x2F;</span><br><span class="line">		base &#x3D; tk-&gt;tkr_raw.base;</span><br><span class="line">		&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_raw.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">		nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_raw);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getrawmonotonic64()通过tk-&gt;raw_time获取raw monotonic time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void getrawmonotonic64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	struct timespec64 ts64;</span><br><span class="line">	unsigned long seq;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_raw);</span><br><span class="line">		ts64 &#x3D; tk-&gt;raw_time;</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	timespec64_add_ns(&amp;ts64, nsecs);</span><br><span class="line">	*ts &#x3D; ts64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>boot time 的获取；</strong></li>
</ul>
<p>ktime_get_boottime()使用monotonic time再加上差值timekeeper.offs_boot的方法来获取boot time：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime_get_boottime(void)</span><br><span class="line">&#123;</span><br><span class="line">	return ktime_get_with_offset(TK_OFFS_BOOT);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static ktime_t *offsets[TK_OFFS_MAX] &#x3D; &#123;</span><br><span class="line">	[TK_OFFS_REAL]	&#x3D; &amp;tk_core.timekeeper.offs_real,</span><br><span class="line">	[TK_OFFS_BOOT]	&#x3D; &amp;tk_core.timekeeper.offs_boot,</span><br><span class="line">	[TK_OFFS_TAI]	&#x3D; &amp;tk_core.timekeeper.offs_tai,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ktime_t ktime_get_with_offset(enum tk_offsets offs)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned int seq;</span><br><span class="line">	ktime_t base, *offset &#x3D; offsets[offs];</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		&#x2F;* (1) monotonic time &#x3D; tk-&gt;tkr_mono.base，</span><br><span class="line">		   offset &#x3D; timekeeper.offs_boot *&#x2F;</span><br><span class="line">		base &#x3D; ktime_add(tk-&gt;tkr_mono.base, *offset);</span><br><span class="line">		&#x2F;* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span><br><span class="line">		    delta是距离上一次tick更新的差值 *&#x2F;</span><br><span class="line">		nsecs &#x3D; timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; while (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	return ktime_add_ns(base, nsecs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5、timekeeper-suspend"><a href="#2-2-5、timekeeper-suspend" class="headerlink" title="2.2.5、timekeeper suspend"></a>2.2.5、timekeeper suspend</h4><p>系统在进入suspend以后，clocksource不会再工作，这部分时间会计入xtime和boot time，但是不会计入monotonic time。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">void timekeeping_resume(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	struct clocksource *clock &#x3D; tk-&gt;tkr_mono.clock;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64 ts_new, ts_delta;</span><br><span class="line">	cycle_t cycle_now, cycle_delta;</span><br><span class="line"></span><br><span class="line">	sleeptime_injected &#x3D; false;</span><br><span class="line">	read_persistent_clock64(&amp;ts_new);</span><br><span class="line"></span><br><span class="line">	clockevents_resume();</span><br><span class="line">	clocksource_resume();</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * After system resumes, we need to calculate the suspended time and</span><br><span class="line">	 * compensate it for the OS time. There are 3 sources that could be</span><br><span class="line">	 * used: Nonstop clocksource during suspend, persistent clock and rtc</span><br><span class="line">	 * device.</span><br><span class="line">	 *</span><br><span class="line">	 * One specific platform may have 1 or 2 or all of them, and the</span><br><span class="line">	 * preference will be:</span><br><span class="line">	 *	suspend-nonstop clocksource -&gt; persistent clock -&gt; rtc</span><br><span class="line">	 * The less preferred source will only be tried if there is no better</span><br><span class="line">	 * usable source. The rtc part is handled separately in rtc core code.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cycle_now &#x3D; tk-&gt;tkr_mono.read(clock);</span><br><span class="line">	if ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;</span><br><span class="line">		cycle_now &gt; tk-&gt;tkr_mono.cycle_last) &#123;</span><br><span class="line">		u64 num, max &#x3D; ULLONG_MAX;</span><br><span class="line">		u32 mult &#x3D; clock-&gt;mult;</span><br><span class="line">		u32 shift &#x3D; clock-&gt;shift;</span><br><span class="line">		s64 nsec &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		cycle_delta &#x3D; clocksource_delta(cycle_now, tk-&gt;tkr_mono.cycle_last,</span><br><span class="line">						tk-&gt;tkr_mono.mask);</span><br><span class="line"></span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * &quot;cycle_delta * mutl&quot; may cause 64 bits overflow, if the</span><br><span class="line">		 * suspended time is too long. In that case we need do the</span><br><span class="line">		 * 64 bits math carefully</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		do_div(max, mult);</span><br><span class="line">		if (cycle_delta &gt; max) &#123;</span><br><span class="line">			num &#x3D; div64_u64(cycle_delta, max);</span><br><span class="line">			nsec &#x3D; (((u64) max * mult) &gt;&gt; shift) * num;</span><br><span class="line">			cycle_delta -&#x3D; num * max;</span><br><span class="line">		&#125;</span><br><span class="line">		nsec +&#x3D; ((u64) cycle_delta * mult) &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">		ts_delta &#x3D; ns_to_timespec64(nsec);</span><br><span class="line">		sleeptime_injected &#x3D; true;</span><br><span class="line">	&#125; else if (timespec64_compare(&amp;ts_new, &amp;timekeeping_suspend_time) &gt; 0) &#123;</span><br><span class="line">		ts_delta &#x3D; timespec64_sub(ts_new, timekeeping_suspend_time);</span><br><span class="line">		sleeptime_injected &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (sleeptime_injected)</span><br><span class="line">		__timekeeping_inject_sleeptime(tk, &amp;ts_delta);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Re-base the last cycle value *&#x2F;</span><br><span class="line">	tk-&gt;tkr_mono.cycle_last &#x3D; cycle_now;</span><br><span class="line">	tk-&gt;tkr_raw.cycle_last  &#x3D; cycle_now;</span><br><span class="line"></span><br><span class="line">	tk-&gt;ntp_error &#x3D; 0;</span><br><span class="line">	timekeeping_suspended &#x3D; 0;</span><br><span class="line">	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	touch_softlockup_watchdog();</span><br><span class="line"></span><br><span class="line">	tick_resume();</span><br><span class="line">	hrtimers_resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int timekeeping_suspend(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64		delta, delta_delta;</span><br><span class="line">	static struct timespec64	old_delta;</span><br><span class="line"></span><br><span class="line">	read_persistent_clock64(&amp;timekeeping_suspend_time);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * On some systems the persistent_clock can not be detected at</span><br><span class="line">	 * timekeeping_init by its return value, so if we see a valid</span><br><span class="line">	 * value returned, update the persistent_clock_exists flag.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)</span><br><span class="line">		persistent_clock_exists &#x3D; true;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line">	timekeeping_suspended &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	if (persistent_clock_exists) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * To avoid drift caused by repeated suspend&#x2F;resumes,</span><br><span class="line">		 * which each can add ~1 second drift error,</span><br><span class="line">		 * try to compensate so the difference in system time</span><br><span class="line">		 * and persistent_clock time stays close to constant.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		delta &#x3D; timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);</span><br><span class="line">		delta_delta &#x3D; timespec64_sub(delta, old_delta);</span><br><span class="line">		if (abs(delta_delta.tv_sec) &gt;&#x3D; 2) &#123;</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * if delta_delta is too large, assume time correction</span><br><span class="line">			 * has occurred and set old_delta to the current delta.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			old_delta &#x3D; delta;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;* Otherwise try to adjust old_system to compensate *&#x2F;</span><br><span class="line">			timekeeping_suspend_time &#x3D;</span><br><span class="line">				timespec64_add(timekeeping_suspend_time, delta_delta);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_MIRROR);</span><br><span class="line">	halt_fast_timekeeper(tk);</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	tick_suspend();</span><br><span class="line">	clocksource_suspend();</span><br><span class="line">	clockevents_suspend();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* sysfs resume&#x2F;suspend bits for timekeeping *&#x2F;</span><br><span class="line">static struct syscore_ops timekeeping_syscore_ops &#x3D; &#123;</span><br><span class="line">	.resume		&#x3D; timekeeping_resume,</span><br><span class="line">	.suspend	&#x3D; timekeeping_suspend,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和初始化一样的原因，理论上timekeeper的操作在timekeeping_resume()、timekeeping_suspend()，但是实际上在rtc的操作中执行rtc_suspend()、rtc_resume()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">static int rtc_suspend(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct rtc_device	*rtc &#x3D; to_rtc_device(dev);</span><br><span class="line">	struct rtc_time		tm;</span><br><span class="line">	struct timespec64	delta, delta_delta;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (timekeeping_rtc_skipsuspend())</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) !&#x3D; 0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* snapshot the current RTC and system time at suspend*&#x2F;</span><br><span class="line">	&#x2F;* (1.1) 读取suspend时候的rtc时间 *&#x2F;</span><br><span class="line">	err &#x3D; rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	if (err &lt; 0) &#123;</span><br><span class="line">		pr_debug(&quot;%s:  fail to read rtc time\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 读取当前xtime *&#x2F;</span><br><span class="line">	getnstimeofday64(&amp;old_system);</span><br><span class="line">	old_rtc.tv_sec &#x3D; rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	old_rtc.tv_nsec &#x3D; tm.tm_cnt*(1000000000&#x2F;32768);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * To avoid drift caused by repeated suspend&#x2F;resumes,</span><br><span class="line">	 * which each can add ~1 second drift error,</span><br><span class="line">	 * try to compensate so the difference in system time</span><br><span class="line">	 * and rtc time stays close to constant.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (1.3) 如果rtc时间和xtime有偏差，尝试纠正xtime *&#x2F;</span><br><span class="line">	delta &#x3D; timespec64_sub(old_system, old_rtc);</span><br><span class="line">	delta_delta &#x3D; timespec64_sub(delta, old_delta);</span><br><span class="line">	if (delta_delta.tv_sec &lt; -2 || delta_delta.tv_sec &gt;&#x3D; 2) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * if delta_delta is too large, assume time correction</span><br><span class="line">		 * has occured and set old_delta to the current delta.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		old_delta &#x3D; delta;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;* Otherwise try to adjust old_system to compensate *&#x2F;</span><br><span class="line">		old_system &#x3D; timespec64_sub(old_system, delta_delta);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int rtc_resume(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct rtc_device	*rtc &#x3D; to_rtc_device(dev);</span><br><span class="line">	struct rtc_time		tm;</span><br><span class="line">	struct timespec64	new_system, new_rtc;</span><br><span class="line">	struct timespec64	sleep_time;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	if (timekeeping_rtc_skipresume())</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	rtc_hctosys_ret &#x3D; -ENODEV;</span><br><span class="line">	if (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) !&#x3D; 0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* snapshot the current rtc and system time at resume *&#x2F;</span><br><span class="line">	&#x2F;* (2.1) 读取resume后的rtc时间和xtime *&#x2F;</span><br><span class="line">	getnstimeofday64(&amp;new_system);</span><br><span class="line">	err &#x3D; rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	if (err &lt; 0) &#123;</span><br><span class="line">		pr_debug(&quot;%s:  fail to read rtc time\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_rtc.tv_sec &#x3D; rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	new_rtc.tv_nsec &#x3D; tm.tm_cnt*(1000000000&#x2F;32768);</span><br><span class="line"></span><br><span class="line">	if (new_rtc.tv_sec &lt; old_rtc.tv_sec) &#123;</span><br><span class="line">		pr_debug(&quot;%s:  time travel!\n&quot;, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* calculate the RTC time delta (sleep time)*&#x2F;</span><br><span class="line">	&#x2F;* (2.2) 计算suspend和resume之间rtc的差值 *&#x2F;</span><br><span class="line">	sleep_time &#x3D; timespec64_sub(new_rtc, old_rtc);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Since these RTC suspend&#x2F;resume handlers are not called</span><br><span class="line">	 * at the very end of suspend or the start of resume,</span><br><span class="line">	 * some run-time may pass on either sides of the sleep time</span><br><span class="line">	 * so subtract kernel run-time between rtc_suspend to rtc_resume</span><br><span class="line">	 * to keep things accurate.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (2.3) 使用上一步的差值，再减去，suspend和resume之间xtime的差值</span><br><span class="line">	        得到实际的sleep时间*&#x2F;</span><br><span class="line">	sleep_time &#x3D; timespec64_sub(sleep_time,</span><br><span class="line">			timespec64_sub(new_system, old_system));</span><br><span class="line"></span><br><span class="line">	if (sleep_time.tv_sec &gt;&#x3D; 0)</span><br><span class="line">	    &#x2F;* (2.4) 将计算得到的sleep时间，加入到timekeeper中 *&#x2F;</span><br><span class="line">		timekeeping_inject_sleeptime64(&amp;sleep_time);</span><br><span class="line">	rtc_hctosys_ret &#x3D; 0;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void timekeeping_inject_sleeptime64(struct timespec64 *delta)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk &#x3D; &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">	__timekeeping_inject_sleeptime(tk, delta);</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	&#x2F;* signal hrtimers about time change *&#x2F;</span><br><span class="line">	clock_was_set();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static void __timekeeping_inject_sleeptime(struct timekeeper *tk,</span><br><span class="line">					   struct timespec64 *delta)</span><br><span class="line">&#123;</span><br><span class="line">	if (!timespec64_valid_strict(delta)) &#123;</span><br><span class="line">		printk_deferred(KERN_WARNING</span><br><span class="line">				&quot;__timekeeping_inject_sleeptime: Invalid &quot;</span><br><span class="line">				&quot;sleep delta value!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;* (2.4.1) 更新xtime *&#x2F;</span><br><span class="line">	tk_xtime_add(tk, delta);</span><br><span class="line">	&#x2F;* (2.4.2) 更新tk-&gt;wall_to_monotonic、tk-&gt;offs_real *&#x2F;</span><br><span class="line">	tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, *delta));</span><br><span class="line">	&#x2F;* (2.4.3) 更新tk-&gt;offs_boot *&#x2F;</span><br><span class="line">	tk_update_sleep_time(tk, timespec64_to_ktime(*delta));</span><br><span class="line">	tk_debug_account_sleep_time(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、clock-event"><a href="#3、clock-event" class="headerlink" title="3、clock_event"></a>3、clock_event</h2><p><img src="/images/posts/2017/10/clockevent.png" alt="image"></p>
<p>clock_event其实就是对local timer的使用，每个cpu对应一个本地local timer。global timer启动后不需要主动做任何事情，只需要等待timekepper的读取就可以了。而local timer需要触发中断，它的主要价值就体现在定时中断处理了，中断的时间可以是固定的(period mode)也或者是不固定的(oneshot mode)。</p>
<h3 id="3-1、clock-event的注册"><a href="#3-1、clock-event的注册" class="headerlink" title="3.1、clock_event的注册"></a>3.1、clock_event的注册</h3><h4 id="3-1-1、exynos-clock-event的注册"><a href="#3-1-1、exynos-clock-event的注册" class="headerlink" title="3.1.1、exynos clock_event的注册"></a>3.1.1、exynos clock_event的注册</h4><p>exynos clock_event的注册分为两部分：</p>
<ul>
<li>第一部分：localtimer中断的注册：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)</span><br><span class="line">&#123;</span><br><span class="line">	int err, cpu;</span><br><span class="line">	struct mct_clock_event_device *mevt &#x3D; this_cpu_ptr(&amp;percpu_mct_tick);</span><br><span class="line">	struct clk *mct_clk, *tick_clk;</span><br><span class="line"></span><br><span class="line">	tick_clk &#x3D; np ? of_clk_get_by_name(np, &quot;fin_pll&quot;) :</span><br><span class="line">				clk_get(NULL, &quot;fin_pll&quot;);</span><br><span class="line">	if (IS_ERR(tick_clk))</span><br><span class="line">		panic(&quot;%s: unable to determine tick clock rate\n&quot;, __func__);</span><br><span class="line">	clk_rate &#x3D; clk_get_rate(tick_clk);</span><br><span class="line"></span><br><span class="line">	mct_clk &#x3D; np ? of_clk_get_by_name(np, &quot;mct&quot;) : clk_get(NULL, &quot;mct&quot;);</span><br><span class="line">	if (IS_ERR(mct_clk))</span><br><span class="line">		panic(&quot;%s: unable to retrieve mct clock instance\n&quot;, __func__);</span><br><span class="line">	clk_prepare_enable(mct_clk);</span><br><span class="line"></span><br><span class="line">	reg_base &#x3D; base;</span><br><span class="line">	if (!reg_base)</span><br><span class="line">		panic(&quot;%s: unable to ioremap mct address space\n&quot;, __func__);</span><br><span class="line"></span><br><span class="line">	if (mct_int_type &#x3D;&#x3D; MCT_INT_PPI) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) 大部分的localtimer是PPI模式，</span><br><span class="line">            注册中断处理函数：exynos4_mct_tick_isr() *&#x2F;</span><br><span class="line">		err &#x3D; request_percpu_irq(mct_irqs[MCT_L0_IRQ],</span><br><span class="line">					 exynos4_mct_tick_isr, &quot;MCT&quot;,</span><br><span class="line">					 &amp;percpu_mct_tick);</span><br><span class="line">		WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,</span><br><span class="line">		     mct_irqs[MCT_L0_IRQ], err);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			int mct_irq &#x3D; mct_irqs[MCT_L0_IRQ + cpu];</span><br><span class="line">			struct mct_clock_event_device *pcpu_mevt &#x3D;</span><br><span class="line">				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span><br><span class="line"></span><br><span class="line">			pcpu_mevt-&gt;evt.irq &#x3D; -1;</span><br><span class="line"></span><br><span class="line">			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span><br><span class="line">			if (request_irq(mct_irq,</span><br><span class="line">					exynos4_mct_tick_isr,</span><br><span class="line">					IRQF_TIMER | IRQF_NOBALANCING,</span><br><span class="line">					pcpu_mevt-&gt;name, pcpu_mevt)) &#123;</span><br><span class="line">				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span><br><span class="line">									cpu);</span><br><span class="line"></span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			pcpu_mevt-&gt;evt.irq &#x3D; mct_irq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 注册cpu hotplug的notifier，</span><br><span class="line">        在其他cpu up时调用exynos4_local_timer_setup()注册clock_event *&#x2F;</span><br><span class="line">	err &#x3D; register_cpu_notifier(&amp;exynos4_mct_cpu_nb);</span><br><span class="line">	if (err)</span><br><span class="line">		goto out_irq;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Immediately configure the timer on the boot CPU *&#x2F;</span><br><span class="line">	&#x2F;* (3) 注册本cpu的clock_event *&#x2F;</span><br><span class="line">	exynos4_local_timer_setup(mevt);</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">out_irq:</span><br><span class="line">	free_percpu_irq(mct_irqs[MCT_L0_IRQ], &amp;percpu_mct_tick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static irqreturn_t exynos4_mct_tick_isr(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct mct_clock_event_device *mevt &#x3D; dev_id;</span><br><span class="line">	struct clock_event_device *evt &#x3D; &amp;mevt-&gt;evt;</span><br><span class="line"></span><br><span class="line">	exynos4_mct_tick_clear(mevt);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (4) localtimer中断处理函数是固定的也是非常简单的，</span><br><span class="line">        调用本cpu clock_event_device的handler函数：evt-&gt;event_handler(evt) *&#x2F;</span><br><span class="line">	evt-&gt;event_handler(evt);</span><br><span class="line"></span><br><span class="line">	return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二部分：clock_event_device注册：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int exynos4_local_timer_setup(struct mct_clock_event_device *mevt)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *evt &#x3D; &amp;mevt-&gt;evt;</span><br><span class="line">	unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">	mevt-&gt;base &#x3D; EXYNOS4_MCT_L_BASE(cpu);</span><br><span class="line">	snprintf(mevt-&gt;name, sizeof(mevt-&gt;name), &quot;mct_tick%d&quot;, cpu);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 初始化clock_event_device *&#x2F;</span><br><span class="line">	evt-&gt;name &#x3D; mevt-&gt;name;</span><br><span class="line">	evt-&gt;cpumask &#x3D; cpumask_of(cpu);         &#x2F;&#x2F; 本clock_event_device只服务于一个cpu</span><br><span class="line">	evt-&gt;set_next_event &#x3D; exynos4_tick_set_next_event;</span><br><span class="line">	evt-&gt;set_state_periodic &#x3D; set_state_periodic;</span><br><span class="line">	evt-&gt;set_state_shutdown &#x3D; set_state_shutdown;</span><br><span class="line">	evt-&gt;set_state_oneshot &#x3D; set_state_shutdown;</span><br><span class="line">	evt-&gt;tick_resume &#x3D; set_state_shutdown;</span><br><span class="line">	evt-&gt;features &#x3D; CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;</span><br><span class="line">	evt-&gt;rating &#x3D; 450;</span><br><span class="line"></span><br><span class="line">	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);</span><br><span class="line"></span><br><span class="line">	if (mct_int_type &#x3D;&#x3D; MCT_INT_SPI) &#123;</span><br><span class="line"></span><br><span class="line">		if (evt-&gt;irq &#x3D;&#x3D; -1)</span><br><span class="line">			return -EIO;</span><br><span class="line"></span><br><span class="line">		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span><br><span class="line">		enable_irq(evt-&gt;irq);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;* (2) 配置并注册clockevent *&#x2F;</span><br><span class="line">	clockevents_config_and_register(evt, clk_rate &#x2F; (TICK_BASE_CNT + 1),</span><br><span class="line">					0xf, 0x7fffffff);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2、clock-event-device的注册"><a href="#3-1-2、clock-event-device的注册" class="headerlink" title="3.1.2、clock_event_device的注册"></a>3.1.2、clock_event_device的注册</h4><p>我们来分析一下clock_event_device的注册过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">void clockevents_config_and_register(struct clock_event_device *dev,</span><br><span class="line">				     u32 freq, unsigned long min_delta,</span><br><span class="line">				     unsigned long max_delta)</span><br><span class="line">&#123;</span><br><span class="line">	dev-&gt;min_delta_ticks &#x3D; min_delta;   &#x2F;&#x2F; localtimer可配置的最小定时值</span><br><span class="line">	dev-&gt;max_delta_ticks &#x3D; max_delta;   &#x2F;&#x2F; localtimer可配置的最大定时值，</span><br><span class="line">	                                    &#x2F;&#x2F; 比如exynos是31bit的localtimer，最大值就是0x7fffffff</span><br><span class="line">	&#x2F;* (1) 根据localtimer的freq，计算clock_event_device对应的mult、shift，</span><br><span class="line">	    mult、shift的作用是用来做ns到localtimer cycle之间的转换，</span><br><span class="line">	    与之相反的是，在clocksource中mult、shift用来转换localtimer cycle到ns *&#x2F;</span><br><span class="line">	clockevents_config(dev, freq);</span><br><span class="line">	&#x2F;* (2) 继续注册clock_event_device *&#x2F;</span><br><span class="line">	clockevents_register_device(dev);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_config(struct clock_event_device *dev, u32 freq)</span><br><span class="line">&#123;</span><br><span class="line">	u64 sec;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1) 如果不支持oneshot模式，只是period模式，</span><br><span class="line">        定时周期是固定的，不需要动态计算ns到cycle的转换 *&#x2F;</span><br><span class="line">	if (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Calculate the maximum number of seconds we can sleep. Limit</span><br><span class="line">	 * to 10 minutes for hardware which can program more than</span><br><span class="line">	 * 32bit ticks so we still get reasonable conversion values.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	sec &#x3D; dev-&gt;max_delta_ticks;</span><br><span class="line">	do_div(sec, freq);</span><br><span class="line">	if (!sec)</span><br><span class="line">		sec &#x3D; 1;</span><br><span class="line">	else if (sec &gt; 600 &amp;&amp; dev-&gt;max_delta_ticks &gt; UINT_MAX)</span><br><span class="line">		sec &#x3D; 600;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 根据localtimer的freq，计算clock_event_device对应的mult、shift *&#x2F;</span><br><span class="line">	clockevents_calc_mult_shift(dev, freq, sec);</span><br><span class="line">	&#x2F;* (1.3) 转换min、max的cycle到ns *&#x2F;</span><br><span class="line">	dev-&gt;min_delta_ns &#x3D; cev_delta2ns(dev-&gt;min_delta_ticks, dev, false);</span><br><span class="line">	dev-&gt;max_delta_ns &#x3D; cev_delta2ns(dev-&gt;max_delta_ticks, dev, true);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_register_device(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize state to DETACHED *&#x2F;</span><br><span class="line">	clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line"></span><br><span class="line">	if (!dev-&gt;cpumask) &#123;</span><br><span class="line">		WARN_ON(num_possible_cpus() &gt; 1);</span><br><span class="line">		dev-&gt;cpumask &#x3D; cpumask_of(smp_processor_id());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;clockevents_lock, flags);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.1) 将clock_event_device加入到全局链表clockevent_devices中 *&#x2F;</span><br><span class="line">	list_add(&amp;dev-&gt;list, &amp;clockevent_devices);</span><br><span class="line">	&#x2F;* (2.2) 继续尝试向本cpu的tick_device中注册clock_event_device *&#x2F;</span><br><span class="line">	tick_check_new_device(dev);</span><br><span class="line">	clockevents_notify_released();</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">void tick_check_new_device(struct clock_event_device *newdev)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *curdev;</span><br><span class="line">	struct tick_device *td;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	cpu &#x3D; smp_processor_id();</span><br><span class="line">	td &#x3D; &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class="line">	curdev &#x3D; td-&gt;evtdev;</span><br><span class="line"></span><br><span class="line">	&#x2F;* cpu local device ? *&#x2F;</span><br><span class="line">	&#x2F;* (2.2.1) 新的clock_event_device是否支持本cpu？  *&#x2F;</span><br><span class="line">	if (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class="line">		goto out_bc;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Preference decision *&#x2F;</span><br><span class="line">	&#x2F;* (2.2.2) 新的clock_event_device是否比当前clock_event_device更适合？</span><br><span class="line">	   1.如果curdev已经是oneshot模式，而newdev不支持oneshot，则切换</span><br><span class="line">	   2.newdev的精度要大于curdev，精度 &#x3D; dev-&gt;rating *&#x2F;</span><br><span class="line">	if (!tick_check_preferred(curdev, newdev))</span><br><span class="line">		goto out_bc;</span><br><span class="line"></span><br><span class="line">	if (!try_module_get(newdev-&gt;owner))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Replace the eventually existing device by the new</span><br><span class="line">	 * device. If the current device is the broadcast device, do</span><br><span class="line">	 * not give it back to the clockevents layer !</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (tick_is_broadcast_device(curdev)) &#123;</span><br><span class="line">		clockevents_shutdown(curdev);</span><br><span class="line">		curdev &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;* (2.2.3) 关闭curdev、newdev *&#x2F;</span><br><span class="line">	clockevents_exchange_device(curdev, newdev);</span><br><span class="line">	&#x2F;* (2.2.4) 继续clock_event_device注册 *&#x2F;</span><br><span class="line">	tick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class="line">	if (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class="line">		tick_oneshot_notify();</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">out_bc:</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Can the new device be used as a broadcast device ?</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (2.2.5) 如果newdev不适合注册成本cpu的td-&gt;evtdev,</span><br><span class="line">	    尝试将其注册成broadcast clockevent *&#x2F;</span><br><span class="line">	tick_install_broadcast_device(newdev);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">static void tick_setup_device(struct tick_device *td,</span><br><span class="line">			      struct clock_event_device *newdev, int cpu,</span><br><span class="line">			      const struct cpumask *cpumask)</span><br><span class="line">&#123;</span><br><span class="line">	ktime_t next_event;</span><br><span class="line">	void (*handler)(struct clock_event_device *) &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * First device setup ?</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!td-&gt;evtdev) &#123;</span><br><span class="line">	    &#x2F;* (2.2.4.1) 如果是tick_do_timer_cpu没有被设置，且没有使能tick_nohz_full_cpu</span><br><span class="line">	        把tick_do_timer_cpu设置成本cpu，</span><br><span class="line">	        tick_do_timer_cpu负责在tick中update jiffies、update_wall_time  *&#x2F;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * If no cpu took the do_timer update, assign it to</span><br><span class="line">		 * this cpu:</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (tick_do_timer_cpu &#x3D;&#x3D; TICK_DO_TIMER_BOOT) &#123;</span><br><span class="line">			if (!tick_nohz_full_cpu(cpu))</span><br><span class="line">				tick_do_timer_cpu &#x3D; cpu;</span><br><span class="line">			else</span><br><span class="line">				tick_do_timer_cpu &#x3D; TICK_DO_TIMER_NONE;</span><br><span class="line">			tick_next_period &#x3D; ktime_get();</span><br><span class="line">			tick_period &#x3D; ktime_set(0, NSEC_PER_SEC &#x2F; HZ);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Startup in periodic mode first.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		&#x2F;* (2.2.4.2) 如果tick_device是第一次设置clock_event_device,</span><br><span class="line">		    把tick_device设置成period模式 *&#x2F;</span><br><span class="line">		td-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	    &#x2F;* (2.2.4.3) 如果tick_device不是第一次设置clock_event_device,</span><br><span class="line">		    备份原clock_event_deviced的event_handler和next_event *&#x2F;</span><br><span class="line">		handler &#x3D; td-&gt;evtdev-&gt;event_handler;</span><br><span class="line">		next_event &#x3D; td-&gt;evtdev-&gt;next_event;</span><br><span class="line">		td-&gt;evtdev-&gt;event_handler &#x3D; clockevents_handle_noop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.4.4) 更新tick_device-&gt;evtdev到new clock_event_deviced  *&#x2F;</span><br><span class="line">	td-&gt;evtdev &#x3D; newdev;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * When the device is not per cpu, pin the interrupt to the</span><br><span class="line">	 * current cpu:</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!cpumask_equal(newdev-&gt;cpumask, cpumask))</span><br><span class="line">		irq_set_affinity(newdev-&gt;irq, cpumask);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * When global broadcasting is active, check if the current</span><br><span class="line">	 * device is registered as a placeholder for broadcast mode.</span><br><span class="line">	 * This allows us to handle this x86 misfeature in a generic</span><br><span class="line">	 * way. This function also returns !&#x3D;0 when we keep the</span><br><span class="line">	 * current active broadcast state for this CPU.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (2.2.4.5) 如果全局的brodcast clockevent服务已经启动，</span><br><span class="line">	    本cpu的clockevent注册需要向brodcas服务，</span><br><span class="line">	    这是为了解决x86的一个失误(misfeature)，其他架构不需要？ *&#x2F;</span><br><span class="line">	if (tick_device_uses_broadcast(newdev, cpu))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.2.4.6) 根据td-&gt;mode安装clock_event_deviced的event_handler,并启动 *&#x2F;</span><br><span class="line">	if (td-&gt;mode &#x3D;&#x3D; TICKDEV_MODE_PERIODIC)</span><br><span class="line">	    &#x2F;* (2.2.4.7) period模式 *&#x2F;</span><br><span class="line">		tick_setup_periodic(newdev, 0);</span><br><span class="line">	else</span><br><span class="line">	    &#x2F;* (2.2.4.8) oneshot模式 *&#x2F;</span><br><span class="line">		tick_setup_oneshot(newdev, handler, next_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2、tick-device的period-mode"><a href="#3-2、tick-device的period-mode" class="headerlink" title="3.2、tick_device的period mode"></a>3.2、tick_device的period mode</h3><p>接上节，在cpu第一次注册clock_event_deviced的时候，td-&gt;mode默认被设置成period模式。event_handler会被初始化成tick_handle_periodic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void tick_setup_periodic(struct clock_event_device *dev, int broadcast)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1) 设置period模式下的event_handler *&#x2F;</span><br><span class="line">	tick_set_periodic_handler(dev, broadcast);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Broadcast setup ? *&#x2F;</span><br><span class="line">	if (!tick_device_is_functional(dev))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 如果dev支持period模式，则硬件上启动period模式:</span><br><span class="line">        tick_device-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC</span><br><span class="line">        clock_event_device-&gt;state_use_accessors &#x3D; CLOCK_EVT_STATE_PERIODIC *&#x2F;</span><br><span class="line">	if ((dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC) &amp;&amp;</span><br><span class="line">	    !tick_broadcast_oneshot_active()) &#123;</span><br><span class="line">		clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		unsigned long seq;</span><br><span class="line">		ktime_t next;</span><br><span class="line"></span><br><span class="line">		do &#123;</span><br><span class="line">			seq &#x3D; read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">			next &#x3D; tick_next_period;</span><br><span class="line">		&#125; while (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line"></span><br><span class="line">        &#x2F;* (3) 如果dev不支持period模式只支持oneshot模式，则硬件上启动one shot模式，</span><br><span class="line">            使用oneshot模式来模拟period模式：</span><br><span class="line">            tick_device-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC</span><br><span class="line">            clock_event_device-&gt;state_use_accessors &#x3D; CLOCK_EVT_STATE_ONESHOT *&#x2F;</span><br><span class="line">		clockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);</span><br><span class="line"></span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			if (!clockevents_program_event(dev, next, false))</span><br><span class="line">				return;</span><br><span class="line">			next &#x3D; ktime_add(next, tick_period);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)</span><br><span class="line">&#123;</span><br><span class="line">	if (!broadcast)</span><br><span class="line">	    &#x2F;* (1.1) 设置period模式下的event_handler *&#x2F;</span><br><span class="line">		dev-&gt;event_handler &#x3D; tick_handle_periodic;</span><br><span class="line">	else</span><br><span class="line">		dev-&gt;event_handler &#x3D; tick_handle_periodic_broadcast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细分析一下tick_handle_periodic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void tick_handle_periodic(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu &#x3D; smp_processor_id();</span><br><span class="line">	ktime_t next &#x3D; dev-&gt;next_event;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 周期性的tick任务 *&#x2F;</span><br><span class="line">	tick_periodic(cpu);</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The cpu might have transitioned to HIGHRES or NOHZ mode via</span><br><span class="line">	 * update_process_times() -&gt; run_local_timers() -&gt;</span><br><span class="line">	 * hrtimer_run_queues().</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (dev-&gt;event_handler !&#x3D; tick_handle_periodic)</span><br><span class="line">		return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (!clockevent_state_oneshot(dev))</span><br><span class="line">		return;</span><br><span class="line">	&#x2F;* (2) 如果tick_device是period mode，而clockevent是oneshot模式,</span><br><span class="line">	    编程oneshot模式clockevent在下一周期触发：</span><br><span class="line">        tick_device-&gt;mode &#x3D; TICKDEV_MODE_PERIODIC</span><br><span class="line">        clock_event_device-&gt;state_use_accessors &#x3D; CLOCK_EVT_STATE_ONESHOT *&#x2F;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Setup the next period for devices, which do not have</span><br><span class="line">		 * periodic mode:</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		next &#x3D; ktime_add(next, tick_period);</span><br><span class="line"></span><br><span class="line">		if (!clockevents_program_event(dev, next, false))</span><br><span class="line">			return;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Have to be careful here. If we&#39;re in oneshot mode,</span><br><span class="line">		 * before we call tick_periodic() in a loop, we need</span><br><span class="line">		 * to be sure we&#39;re using a real hardware clocksource.</span><br><span class="line">		 * Otherwise we could get trapped in an infinite</span><br><span class="line">		 * loop, as the tick_periodic() increments jiffies,</span><br><span class="line">		 * which then will increment time, possibly causing</span><br><span class="line">		 * the loop to trigger again and again.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (timekeeping_valid_for_hres())</span><br><span class="line">			tick_periodic(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void tick_periodic(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* (1.1) 如果本cpu是tick_do_timer_cpu，更新全局时间戳类型的任务，</span><br><span class="line">	        包括update jiffies、update_wall_time  *&#x2F;</span><br><span class="line">	if (tick_do_timer_cpu &#x3D;&#x3D; cpu) &#123;</span><br><span class="line">		write_seqlock(&amp;jiffies_lock);</span><br><span class="line"></span><br><span class="line">		&#x2F;* Keep track of the next tick event *&#x2F;</span><br><span class="line">		tick_next_period &#x3D; ktime_add(tick_next_period, tick_period);</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1.1.1) 更新jiffies *&#x2F;</span><br><span class="line">		do_timer(1);</span><br><span class="line">		write_sequnlock(&amp;jiffies_lock);</span><br><span class="line">		&#x2F;* (1.1.2) 读取clocksource来更新timekeeper *&#x2F;</span><br><span class="line">		update_wall_time();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.2) 运行软件timer(run_local_timers())和运行调度tick任务(scheduler_tick()) *&#x2F;</span><br><span class="line">	update_process_times(user_mode(get_irq_regs()));</span><br><span class="line">	profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3、运行Mode"><a href="#3-3、运行Mode" class="headerlink" title="3.3、运行Mode"></a>3.3、运行Mode</h3><p>关于mode，有几个结构涉及到：tick_device、clock_event_device、tick_sched、hrtimer_cpu_base、。组合起来有以下几种情况：</p>
<p><img src="/images/posts/2017/10/clockevent_mode.png" alt="image"></p>
<p>其实归结起来就3种mode：NOHZ_MODE_INACTIVE、NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。下面来逐个解析一下。</p>
<h4 id="3-3-1、NOHZ-MODE-INACTIVE"><a href="#3-3-1、NOHZ-MODE-INACTIVE" class="headerlink" title="3.3.1、NOHZ_MODE_INACTIVE"></a>3.3.1、NOHZ_MODE_INACTIVE</h4><p>NOHZ_MODE_INACTIVE就是系统初始化时的状态：“td=period模式, dev=period/oneshot模式, hrtimer=low res, noHz=dis”。</p>
<p><img src="/images/posts/2017/10/clockevent_NOHZ_MODE_INACTIVE.png" alt="image"></p>
<p>NOHZ_MODE_INACTIVE模式：</p>
<ul>
<li>tick_device工作在period模式，HW local timer工作在period/oneshot模式；</li>
<li>noHZ没有使能，进入idle会被tick timer中断打断；</li>
<li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li>
</ul>
<h4 id="3-3-2、NOHZ-MODE-LOWRES"><a href="#3-3-2、NOHZ-MODE-LOWRES" class="headerlink" title="3.3.2、NOHZ_MODE_LOWRES"></a>3.3.2、NOHZ_MODE_LOWRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，但是hrtimer高精度不能使能，即进入NOHZ_MODE_LOWRES模式：“td=period模式, dev=oneshot模式, hrtimer=low res, noHz=en”。</p>
<p><img src="/images/posts/2017/10/clockevent_NOHZ_MODE_LOWRES.png" alt="image"></p>
<p>NOHZ_MODE_LOWRES模式：</p>
<ul>
<li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li>
<li>noHZ使能，进入idle不会被tick timer中断打断；</li>
<li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li>
</ul>
<p>为了支持noHZ，tick_device必须切换成oneshot模式，在进入idle时停掉tick timer(tick_nohz_idle_enter() -&gt;　__tick_nohz_idle_enter() -&gt; tick_nohz_stop_sched_tick())，在离开idle时恢复tick timer(tick_nohz_idle_exit() -&gt; tick_nohz_restart_sched_tick())，这样idle过程就不会被tick中断。就实现了noHZ模式(tickless)。</p>
<p>NOHZ_MODE_LOWRES模式下，没有进入idle时tick_device还是以固定周期工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void tick_nohz_handler(struct clock_event_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	struct pt_regs *regs &#x3D; get_irq_regs();</span><br><span class="line">	ktime_t now &#x3D; ktime_get();</span><br><span class="line"></span><br><span class="line">	dev-&gt;next_event.tv64 &#x3D; KTIME_MAX;</span><br><span class="line"></span><br><span class="line">	tick_sched_do_timer(now);</span><br><span class="line">	tick_sched_handle(ts, regs);</span><br><span class="line"></span><br><span class="line">	&#x2F;* No need to reprogram if we are running tickless  *&#x2F;</span><br><span class="line">	if (unlikely(ts-&gt;tick_stopped))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) HW local timer还是以固定周期发生中断 *&#x2F;</span><br><span class="line">	hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line">	tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3、NOHZ-MODE-HIGHRES"><a href="#3-3-3、NOHZ-MODE-HIGHRES" class="headerlink" title="3.3.3、NOHZ_MODE_HIGHRES"></a>3.3.3、NOHZ_MODE_HIGHRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，hrtimer高精度可以使能，即进入NOHZ_MODE_HIGHRES模式：“td=period模式, dev=oneshot模式, hrtimer=high res, noHz=en”。</p>
<p><img src="/images/posts/2017/10/clockevent_NOHZ_MODE_HIGHRES.png" alt="image"></p>
<p>NOHZ_MODE_HIGHRES：</p>
<ul>
<li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li>
<li>noHZ使能，进入idle不会被tick timer中断打断；</li>
<li>hrtimer工作在高精度模式，和硬件定时器(HWlocal timer)的精度一样，远大于低精度定时器tick精度；</li>
</ul>
<p>为了支持hrtimer的高精度模式，hrtimer必须直接使用tick_device的oneshot模式，而常规的tick timer转换成hrtimer的一个子timer。</p>
<p><img src="/images/posts/2017/10/ftrace_NOHZ_MODE_HIGHRES.png" alt="image"></p>
<p>上图是NOHZ_MODE_HIGHRES模式下，用ftrace抓取HW timer硬件中断和tick任务的执行情况：</p>
<ul>
<li>tick任务是以固定周期4ms固定执行的；</li>
<li>遇到tick任务超过4ms的间隔，这时就是进入了idle状态，且发生了noHZ(tickless)；</li>
<li>硬件timer中断的发生周期是不固定的，是和hrtimer绑定的；</li>
<li>发生tick的时候肯定发生了timer硬中断，因为tick是其中一个hrtimer；</li>
</ul>
<h4 id="3-3-4、Mode切换"><a href="#3-3-4、Mode切换" class="headerlink" title="3.3.4、Mode切换"></a>3.3.4、Mode切换</h4><p>系统初始状态工作在NOHZ_MODE_INACTIVE模式时，会动态检测是否可以进入更高级别的模式NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。这个检测工作是在这个路径中做的：tick_device工作在period模式：tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer_run_queues(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct hrtimer_cpu_base *cpu_base &#x3D; this_cpu_ptr(&amp;hrtimer_bases);</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (3) 如果hrtimer已经切换到高精度模式，</span><br><span class="line">        则不会从run_local_timers()低精度定时器路径来运行hrtimer *&#x2F;</span><br><span class="line">	if (__hrtimer_hres_active(cpu_base))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * This _is_ ugly: We have to check periodically, whether we</span><br><span class="line">	 * can switch to highres and &#x2F; or nohz mode. The clocksource</span><br><span class="line">	 * switch happens with xtime_lock held. Notification from</span><br><span class="line">	 * there only sets the check bit in the tick_oneshot code,</span><br><span class="line">	 * otherwise we might deadlock vs. xtime_lock.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	</span><br><span class="line">	&#x2F;* (1) 如果hrtimer没有使能、noHZ使能，</span><br><span class="line">	    则调用：tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz()，</span><br><span class="line">	    切换到NOHZ_MODE_LOWRES模式 *&#x2F;</span><br><span class="line">	if (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) &#123;</span><br><span class="line">	</span><br><span class="line">	    &#x2F;* (2) 如果hrtimer使能、noHZ使能，</span><br><span class="line">    	    则调用：hrtimer_switch_to_hres()，</span><br><span class="line">    	    切换到NOHZ_MODE_HIGHRES模式 *&#x2F;</span><br><span class="line">		hrtimer_switch_to_hres();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;cpu_base-&gt;lock);</span><br><span class="line">	now &#x3D; hrtimer_update_base(cpu_base);</span><br><span class="line">	&#x2F;* (4) 低精度hrtimer的运行函数 *&#x2F;</span><br><span class="line">	__hrtimer_run_queues(cpu_base, now);</span><br><span class="line">	raw_spin_unlock(&amp;cpu_base-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、noHZ"><a href="#4、noHZ" class="headerlink" title="4、noHZ"></a>4、noHZ</h2><p>系统在NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES两种模式下支持noHZ。noHZ是一个功耗优化的feature，在系统负载比较轻的时候没有任务需要调度cpu会进入idle状态，但是系统的tick任务(update_process_times())默认会以固定周期执行，这种固定周期会打断idle状态让系统恢复成正常耗电状态。</p>
<p>tick任务这种不管有没有任务都是固定周期运行的特性是需要改进的，noHZ就是为了解决这一问题而产生的：如果在idle状态的过程中tick任务没有到期需要处理的低精度timer和高精度timer，tick任务可以继续保持睡眠，直到真正有timer到期。</p>
<p>idle进程的主要执行序列如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) 进入idle前,noHZ的处理 *&#x2F;</span><br><span class="line">		tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">		while (!need_resched()) &#123;</span><br><span class="line">			check_pgt_cache();</span><br><span class="line">			rmb();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (2) cpu hotplug之cpu_down()的处理 *&#x2F;</span><br><span class="line">			if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line"></span><br><span class="line">				arch_cpu_idle_dead();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			local_irq_disable();</span><br><span class="line">			arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (3) cpu idle的进入 *&#x2F;</span><br><span class="line">			if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line">				cpu_idle_poll();</span><br><span class="line">			else</span><br><span class="line">				cpuidle_idle_call();</span><br><span class="line"></span><br><span class="line">			arch_cpu_idle_exit();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (4) 退出idle后,noHZ的处理 *&#x2F;</span><br><span class="line">		tick_nohz_idle_exit();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其中的关键在tick_nohz_idle_enter()/tick_nohz_idle_exit()函数。</p>
<h3 id="4-1、tick-nohz-idle-enter-exit"><a href="#4-1、tick-nohz-idle-enter-exit" class="headerlink" title="4.1、tick_nohz_idle_enter/exit()"></a>4.1、tick_nohz_idle_enter/exit()</h3><p>tick_nohz_idle_enter()的解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	ts-&gt;inidle &#x3D; 1;</span><br><span class="line">	__tick_nohz_idle_enter(ts);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class="line">&#123;</span><br><span class="line">	ktime_t now, expires;</span><br><span class="line">	int cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">	now &#x3D; tick_nohz_start_idle(ts);</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 判断当前能否stop tick任务 *&#x2F;</span><br><span class="line">	if (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class="line">		int was_stopped &#x3D; ts-&gt;tick_stopped;</span><br><span class="line"></span><br><span class="line">		ts-&gt;idle_calls++;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (2) 尝试stop tick任务 *&#x2F;</span><br><span class="line">		expires &#x3D; tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class="line">		if (expires.tv64 &gt; 0LL) &#123;</span><br><span class="line">			ts-&gt;idle_sleeps++;</span><br><span class="line">			ts-&gt;idle_expires &#x3D; expires;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!was_stopped &amp;&amp; ts-&gt;tick_stopped)</span><br><span class="line">			ts-&gt;idle_jiffies &#x3D; ts-&gt;last_jiffies;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span><br><span class="line">					 ktime_t now, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *dev &#x3D; __this_cpu_read(tick_cpu_device.evtdev);</span><br><span class="line">	u64 basemono, next_tick, next_tmr, next_rcu, delta, expires;</span><br><span class="line">	unsigned long seq, basejiff;</span><br><span class="line">	ktime_t	tick;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Read jiffies and the time when jiffies were updated last *&#x2F;</span><br><span class="line">	do &#123;</span><br><span class="line">		seq &#x3D; read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">		basemono &#x3D; last_jiffies_update.tv64;</span><br><span class="line">		basejiff &#x3D; jiffies;</span><br><span class="line">	&#125; while (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line">	ts-&gt;last_jiffies &#x3D; basejiff;</span><br><span class="line"></span><br><span class="line">	if (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span><br><span class="line">	    arch_needs_cpu() || irq_work_needs_cpu()) &#123;</span><br><span class="line">		next_tick &#x3D; basemono + TICK_NSEC;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Get the next pending timer. If high resolution</span><br><span class="line">		 * timers are enabled this only takes the timer wheel</span><br><span class="line">		 * timers into account. If high resolution timers are</span><br><span class="line">		 * disabled this also looks at the next expiring</span><br><span class="line">		 * hrtimer.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		&#x2F;* (2.1) 获取下一个timer的到期时间(包括低精度和高精度timer) *&#x2F;</span><br><span class="line">		next_tmr &#x3D; get_next_timer_interrupt(basejiff, basemono);</span><br><span class="line">		ts-&gt;next_timer &#x3D; next_tmr;</span><br><span class="line">		&#x2F;* Take the next rcu event into account *&#x2F;</span><br><span class="line">		next_tick &#x3D; next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If the tick is due in the next period, keep it ticking or</span><br><span class="line">	 * restart it proper.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (2.2) 如果差距小于一个tick，不需要进入noHZ模式 *&#x2F;</span><br><span class="line">	delta &#x3D; next_tick - basemono;</span><br><span class="line">	if (delta &lt;&#x3D; (u64)TICK_NSEC) &#123;</span><br><span class="line">		tick.tv64 &#x3D; 0;</span><br><span class="line">		if (!ts-&gt;tick_stopped)</span><br><span class="line">			goto out;</span><br><span class="line">		if (delta &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			&#x2F;* Tick is stopped, but required now. Enforce it *&#x2F;</span><br><span class="line">			tick_nohz_restart(ts, now);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If this cpu is the one which updates jiffies, then give up</span><br><span class="line">	 * the assignment and let it be taken by the cpu which runs</span><br><span class="line">	 * the tick timer next, which might be this cpu as well. If we</span><br><span class="line">	 * don&#39;t drop this here the jiffies might be stale and</span><br><span class="line">	 * do_timer() never invoked. Keep track of the fact that it</span><br><span class="line">	 * was the one which had the do_timer() duty last. If this cpu</span><br><span class="line">	 * is the one which had the do_timer() duty last, we limit the</span><br><span class="line">	 * sleep time to the timekeeping max_deferement value.</span><br><span class="line">	 * Otherwise we can sleep as long as we want.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;* (2.3) 根据timekeeper的可能溢出的位宽，得到的idle最大值 *&#x2F;</span><br><span class="line">	delta &#x3D; timekeeping_max_deferment();</span><br><span class="line">	if (cpu &#x3D;&#x3D; tick_do_timer_cpu) &#123;</span><br><span class="line">		tick_do_timer_cpu &#x3D; TICK_DO_TIMER_NONE;</span><br><span class="line">		ts-&gt;do_timer_last &#x3D; 1;</span><br><span class="line">	&#125; else if (tick_do_timer_cpu !&#x3D; TICK_DO_TIMER_NONE) &#123;</span><br><span class="line">		delta &#x3D; KTIME_MAX;</span><br><span class="line">		ts-&gt;do_timer_last &#x3D; 0;</span><br><span class="line">	&#125; else if (!ts-&gt;do_timer_last) &#123;</span><br><span class="line">		delta &#x3D; KTIME_MAX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_FULL</span><br><span class="line">	&#x2F;* Limit the tick delta to the maximum scheduler deferment *&#x2F;</span><br><span class="line">	if (!ts-&gt;inidle)</span><br><span class="line">		delta &#x3D; min(delta, scheduler_tick_max_deferment());</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;* Calculate the next expiry time *&#x2F;</span><br><span class="line">	if (delta &lt; (KTIME_MAX - basemono))</span><br><span class="line">		expires &#x3D; basemono + delta;</span><br><span class="line">	else</span><br><span class="line">		expires &#x3D; KTIME_MAX;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.4) 综合上面条件，得到合理的stop tick的时间 *&#x2F;</span><br><span class="line">	expires &#x3D; min_t(u64, expires, next_tick);</span><br><span class="line">	tick.tv64 &#x3D; expires;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Skip reprogram of event if its not changed *&#x2F;</span><br><span class="line">	if (ts-&gt;tick_stopped &amp;&amp; (expires &#x3D;&#x3D; dev-&gt;next_event.tv64))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * nohz_stop_sched_tick can be called several times before</span><br><span class="line">	 * the nohz_restart_sched_tick is called. This happens when</span><br><span class="line">	 * interrupts arrive which do not cause a reschedule. In the</span><br><span class="line">	 * first call we save the current tick time, so we can restart</span><br><span class="line">	 * the scheduler tick in nohz_restart_sched_tick.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!ts-&gt;tick_stopped) &#123;</span><br><span class="line">		nohz_balance_enter_idle(cpu);</span><br><span class="line">		calc_load_enter_idle();</span><br><span class="line"></span><br><span class="line">		ts-&gt;last_tick &#x3D; hrtimer_get_expires(&amp;ts-&gt;sched_timer);</span><br><span class="line">		ts-&gt;tick_stopped &#x3D; 1;</span><br><span class="line">		trace_tick_stop(1, &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If the expiration time &#x3D;&#x3D; KTIME_MAX, then we simply stop</span><br><span class="line">	 * the tick timer.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(expires &#x3D;&#x3D; KTIME_MAX)) &#123;</span><br><span class="line">		if (ts-&gt;nohz_mode &#x3D;&#x3D; NOHZ_MODE_HIGHRES)</span><br><span class="line">			hrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2.5) 实际的stop tick动作：</span><br><span class="line">      将local timer的周期改为大于一个tick的时间，将idle时间延长  *&#x2F;</span><br><span class="line">	if (ts-&gt;nohz_mode &#x3D;&#x3D; NOHZ_MODE_HIGHRES)</span><br><span class="line">		hrtimer_start(&amp;ts-&gt;sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">	else</span><br><span class="line">		tick_program_event(tick, 1);</span><br><span class="line">out:</span><br><span class="line">	&#x2F;* Update the estimated sleep length *&#x2F;</span><br><span class="line">	ts-&gt;sleep_length &#x3D; ktime_sub(dev-&gt;next_event, now);</span><br><span class="line">	return tick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick_nohz_idle_exit()的解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!ts-&gt;inidle);</span><br><span class="line"></span><br><span class="line">	ts-&gt;inidle &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;idle_active || ts-&gt;tick_stopped)</span><br><span class="line">		now &#x3D; ktime_get();</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;idle_active)</span><br><span class="line">		tick_nohz_stop_idle(ts, now);</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;tick_stopped) &#123;</span><br><span class="line">	    &#x2F;* (1) 重启tick任务 *&#x2F;</span><br><span class="line">		tick_nohz_restart_sched_tick(ts, now);</span><br><span class="line">		tick_nohz_account_idle_ticks(ts);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Update jiffies first *&#x2F;</span><br><span class="line">	tick_do_update_jiffies64(now);</span><br><span class="line">	update_cpu_load_nohz();</span><br><span class="line"></span><br><span class="line">	calc_load_exit_idle();</span><br><span class="line">	touch_softlockup_watchdog();</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Cancel the scheduled timer and restore the tick</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	ts-&gt;tick_stopped  &#x3D; 0;</span><br><span class="line">	ts-&gt;idle_exittime &#x3D; now;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1.1) 重启local timer *&#x2F;</span><br><span class="line">	tick_nohz_restart(ts, now);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)</span><br><span class="line">&#123;</span><br><span class="line">	hrtimer_cancel(&amp;ts-&gt;sched_timer);</span><br><span class="line">	hrtimer_set_expires(&amp;ts-&gt;sched_timer, ts-&gt;last_tick);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Forward the time to expire in the future *&#x2F;</span><br><span class="line">	hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;nohz_mode &#x3D;&#x3D; NOHZ_MODE_HIGHRES)</span><br><span class="line">		hrtimer_start_expires(&amp;ts-&gt;sched_timer, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">	else</span><br><span class="line">		tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-tick-nohz-irq-enter-exit"><a href="#4-2-tick-nohz-irq-enter-exit" class="headerlink" title="4.2 tick_nohz_irq_enter/exit()"></a>4.2 tick_nohz_irq_enter/exit()</h3><p>因为在idle退出执行完本tick需要处理的timer后又需要重新关闭tick，系统设计了tick_nohz_irq_enter()/tick_nohz_irq_exit()来处理这种操作。在本次中断处理完timer后，在tick_nohz_irq_exit()中判断是否重新关闭tick任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (1) 关闭tick *&#x2F;</span><br><span class="line">		tick_nohz_idle_enter();</span><br><span class="line"></span><br><span class="line">		while (!need_resched()) &#123;</span><br><span class="line">			check_pgt_cache();</span><br><span class="line">			rmb();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (2) cpu hotplug之cpu_down()的处理 *&#x2F;</span><br><span class="line">			if (cpu_is_offline(smp_processor_id())) &#123;</span><br><span class="line"></span><br><span class="line">				arch_cpu_idle_dead();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;* (3) 关中断 *&#x2F;</span><br><span class="line">			local_irq_disable();</span><br><span class="line">			arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">            &#x2F;* (4) 进入idle，</span><br><span class="line">                cpu进入暂停状态 *&#x2F;</span><br><span class="line">			if (cpu_idle_force_poll || tick_check_broadcast_expired())</span><br><span class="line">				cpu_idle_poll();</span><br><span class="line">			else</span><br><span class="line">				cpuidle_idle_call();</span><br><span class="line">		    &#x2F;* (5) cpu被local timer中断唤醒退出idle状态，继续执行；</span><br><span class="line">		        但是因为irq是disable状态，中断服务程序并不能马上得到执行*&#x2F;</span><br><span class="line">			&#x2F;* (5.1) 退出idle，并且开中断 *&#x2F;	</span><br><span class="line">			</span><br><span class="line">                    &#x2F;* (6) 中断打开后，被阻塞的local timer中断服务得到执行，到期的软件timer得到执行；*&#x2F;</span><br><span class="line">                    &#x2F;* (6.1) 退出中断时调用tick_nohz_irq_exit()，重新计算一个tick可以被stop的值 *&#x2F;</span><br><span class="line">            </span><br><span class="line">			arch_cpu_idle_exit();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (7) 重启tick *&#x2F;</span><br><span class="line">		tick_nohz_idle_exit();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick_nohz_irq_enter()/tick_nohz_irq_exit()的代码解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick_nohz_irq_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	if (!ts-&gt;idle_active &amp;&amp; !ts-&gt;tick_stopped)</span><br><span class="line">		return;</span><br><span class="line">	now &#x3D; ktime_get();</span><br><span class="line">	if (ts-&gt;idle_active)</span><br><span class="line">		tick_nohz_stop_idle(ts, now);</span><br><span class="line">		</span><br><span class="line">	&#x2F;* (1) 基本就是空操作 *&#x2F;</span><br><span class="line">	if (ts-&gt;tick_stopped) &#123;</span><br><span class="line">		tick_nohz_update_jiffies(now);</span><br><span class="line">		tick_nohz_kick_tick(ts, now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick_nohz_irq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts &#x3D; this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line"></span><br><span class="line">	if (ts-&gt;inidle)</span><br><span class="line">	    &#x2F;* (2) 重新判断stop tick任务 *&#x2F;</span><br><span class="line">		__tick_nohz_idle_enter(ts);</span><br><span class="line">	else</span><br><span class="line">		tick_nohz_full_update_tick(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3、local-timer时钟被关闭时的处理"><a href="#4-3、local-timer时钟被关闭时的处理" class="headerlink" title="4.3、local timer时钟被关闭时的处理"></a>4.3、local timer时钟被关闭时的处理</h3><p>还有一种情况需要考虑，在系统进入深层次的idle状态时，local timer本身的时钟可能会被关闭。比如MTK平台进入soidle状态时，local timer本身会被停止，这时会用一个GPT timer来替代local timer继续工作。</p>
<p>核心函数是timer_setting_before_wfi()/timer_setting_after_wfi()：</p>
<ul>
<li>timer_setting_before_wfi()在进入idle前被调用，读出local timer的剩余值并配置到GPT timer中；</li>
<li>timer_setting_after_wfi()在退出idle后被调用，读出GPT timer的值来重新恢复local timer；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void timer_setting_before_wfi(bool f26m_off)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef USING_STD_TIMER_OPS</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	unsigned int timer_left &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* (1) 读出local timer的剩余值 *&#x2F;</span><br><span class="line">	timer_left &#x3D; localtimer_get_counter();</span><br><span class="line"></span><br><span class="line">    &#x2F;* (2) 根据GPT timer在不同状态下的频率，把剩余值配置到GPT中 *&#x2F;</span><br><span class="line">	if ((int)timer_left &lt;&#x3D; 0)</span><br><span class="line">		gpt_set_cmp(IDLE_GPT, 1); &#x2F;* Trigger idle_gpt Timeout imediately *&#x2F;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (f26m_off)</span><br><span class="line">			gpt_set_cmp(IDLE_GPT, div_u64(timer_left, 406.25));</span><br><span class="line">	else</span><br><span class="line">		gpt_set_cmp(IDLE_GPT, timer_left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (f26m_off)</span><br><span class="line">		gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_RTC, GPT_CLK_DIV_1);</span><br><span class="line"></span><br><span class="line">	start_gpt(IDLE_GPT);</span><br><span class="line">#else</span><br><span class="line">	gpt_get_cnt(GPT1, &amp;timer_left);</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void timer_setting_after_wfi(bool f26m_off)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef USING_STD_TIMER_OPS</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">    &#x2F;* (3) 判断当前退出idle状态是否是因为GPT到期引起的 *&#x2F;</span><br><span class="line">	if (gpt_check_and_ack_irq(IDLE_GPT)) &#123;</span><br><span class="line">	    &#x2F;* (3.1) 如果GPT时间已经到期，证明local timer也已经到期，</span><br><span class="line">	        触发local timer在下一时钟执行 *&#x2F;</span><br><span class="line">		localtimer_set_next_event(1);</span><br><span class="line">		if (f26m_off)</span><br><span class="line">			gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	&#x2F;* (4) 退出idle是因为GPT以外的中断源唤醒的 *&#x2F;</span><br><span class="line">		&#x2F;* waked up by other wakeup source *&#x2F;</span><br><span class="line">		unsigned int cnt, cmp;</span><br><span class="line"></span><br><span class="line">        &#x2F;* (4.1) 读出GPT中的剩余到期值，重新配置到local timer中 *&#x2F;</span><br><span class="line">		idle_gpt_get_cnt(IDLE_GPT, &amp;cnt);</span><br><span class="line">		idle_gpt_get_cmp(IDLE_GPT, &amp;cmp);</span><br><span class="line">		if (unlikely(cmp &lt; cnt)) &#123;</span><br><span class="line">			idle_err(&quot;[%s]GPT%d: counter &#x3D; %10u, compare &#x3D; %10u\n&quot;,</span><br><span class="line">					__func__, IDLE_GPT + 1, cnt, cmp);</span><br><span class="line">			&#x2F;* BUG(); *&#x2F;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (f26m_off) &#123;</span><br><span class="line">			localtimer_set_next_event((cmp - cnt) * 1625 &#x2F; 4);</span><br><span class="line">			gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		localtimer_set_next_event(cmp - cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		stop_gpt(IDLE_GPT);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别说明的是，这种GPT timer全局只有一个，进入soidle的状态时cpu也只有一个在线，所以能正常的工作。</p>
<h2 id="5、hrtimer"><a href="#5、hrtimer" class="headerlink" title="5、hrtimer"></a>5、hrtimer</h2><h3 id="5-1、hrtimer的组织"><a href="#5-1、hrtimer的组织" class="headerlink" title="5.1、hrtimer的组织"></a>5.1、hrtimer的组织</h3><p>hrtimer的组织相对来说还是比较简单的，每个cpu对应一个hrtimer_cpu_base，每个hrtimer_cpu_base中有4类clock_base代表4种时间类型(HRTIMER_BASE_REALTIME、HRTIMER_BASE_MONOTONIC、HRTIMER_BASE_BOOTTIME、HRTIMER_BASE_TAI)的hrtimer，每个clock_base是以红黑树来组织同一类型的hrtimer的：</p>
<p><img src="/images/posts/2017/10/hrtimer.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">	.lock &#x3D; __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),</span><br><span class="line">	.seq &#x3D; SEQCNT_ZERO(hrtimer_bases.seq),</span><br><span class="line">	.clock_base &#x3D;</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			.index &#x3D; HRTIMER_BASE_MONOTONIC,</span><br><span class="line">			.clockid &#x3D; CLOCK_MONOTONIC,</span><br><span class="line">			.get_time &#x3D; &amp;ktime_get,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			.index &#x3D; HRTIMER_BASE_REALTIME,</span><br><span class="line">			.clockid &#x3D; CLOCK_REALTIME,</span><br><span class="line">			.get_time &#x3D; &amp;ktime_get_real,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			.index &#x3D; HRTIMER_BASE_BOOTTIME,</span><br><span class="line">			.clockid &#x3D; CLOCK_BOOTTIME,</span><br><span class="line">			.get_time &#x3D; &amp;ktime_get_boottime,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			.index &#x3D; HRTIMER_BASE_TAI,</span><br><span class="line">			.clockid &#x3D; CLOCK_TAI,</span><br><span class="line">			.get_time &#x3D; &amp;ktime_get_clocktai,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES"><a href="#5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES" class="headerlink" title="5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)"></a>5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)</h3><p>前面几章已经详细描述了执行路径，在低精度模式下hrtimer的实际精度和低精度定时器是一样的，都是基于tick精度的。他的执行路径如下。</p>
<p>NOHZ_MODE_INACTIVE模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic()</span><br><span class="line">    ↓</span><br><span class="line">tick_periodic()</span><br><span class="line">    ↓</span><br><span class="line">update_process_times()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">hrtimer_run_queues()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<p>NOHZ_MODE_LOWRES模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tick_nohz_handler()</span><br><span class="line">    ↓</span><br><span class="line">tick_sched_handle()</span><br><span class="line">    ↓</span><br><span class="line">update_process_times()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">hrtimer_run_queues()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<h3 id="5-3、高精度模式-NOHZ-MODE-HIGHRES"><a href="#5-3、高精度模式-NOHZ-MODE-HIGHRES" class="headerlink" title="5.3、高精度模式(NOHZ_MODE_HIGHRES)"></a>5.3、高精度模式(NOHZ_MODE_HIGHRES)</h3><p>在高精度模式下hrtimer才能发挥出真正的精度，他的可以精确定时到小于一个tick，精度依赖于硬件local timer。</p>
<p>NOHZ_MODE_LOWRES模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_interrupt()</span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<h2 id="6、低精度timer-lowres-timer"><a href="#6、低精度timer-lowres-timer" class="headerlink" title="6、低精度timer(lowres timer)"></a>6、低精度timer(lowres timer)</h2><p>低精度timer在系统中的应用范围更广，若非特别声明是hrtimer其他都是使用低精度timer，类如schedule_timeout()、msleep()。他有以下特点：</p>
<ul>
<li>精度低，以tick为单位计时；</li>
<li>执行上下文，低精度timer执行时是在softirq中，而hrtimer的实际执行是在中断当中。所以低精度的执行精度更小于hrtimer；</li>
<li>对系统的实时影响小，softirq比irq对系统的实时性影响更小；</li>
</ul>
<h3 id="6-1、低精度timer的组织"><a href="#6-1、低精度timer的组织" class="headerlink" title="6.1、低精度timer的组织"></a>6.1、低精度timer的组织</h3><p>低精度timer的组织形式和hrtimer类似，只是timer的链接不是采用红黑树，而是采用tv1 - tv5等一系列的链表。</p>
<p><img src="/images/posts/2017/10/lowres_timer.png" alt="image"></p>
<p>tv1 - tv5中保留着一系列槽位，每个槽位代表一个超时时间，把相同超时时间的低精度timer链接到同一槽位当中。</p>
<h3 id="6-2、低精度timer的执行路径"><a href="#6-2、低精度timer的执行路径" class="headerlink" title="6.2、低精度timer的执行路径"></a>6.2、低精度timer的执行路径</h3><p>低精度timer的实际执行时在softirq中执行的，在中断中的动作只是简单触发softirq。</p>
<p>中断中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic()&#x2F;tick_nohz_handler()&#x2F;hrtimer_interrupt()</span><br><span class="line">    ↓</span><br><span class="line">run_local_timers()</span><br><span class="line">    ↓</span><br><span class="line">raise_softirq(TIMER_SOFTIRQ);</span><br></pre></td></tr></table></figure>
<p>软中断中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softirq()</span><br><span class="line">    ↓</span><br><span class="line">__run_timers()</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_DroidPhoneo">
<sup>DroidPhoneo</sup>. <a href="http://blog.csdn.net/DroidPhone/article/category/1263459" target="_blank" rel="noopener">Linux 时间子系统</a><a href="#reffn_DroidPhoneo" title="Jump back to footnote [DroidPhoneo] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_wowo">
<sup>wowo</sup>. <a href="http://www.wowotech.net/timer_subsystem/time_subsystem_index.html" target="_blank" rel="noopener">wowotech time subsystem</a><a href="#reffn_wowo" title="Jump back to footnote [wowo] in the text."> &#8617;</a>
</blockquote>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/07/12//android-p-fbe.html/" data-toggle="tooltip" data-placement="top" title="Android FBE">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/03/21//device-tree.html/" data-toggle="tooltip" data-placement="top" title="Device Tree 详解">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                
<link rel="stylesheet" href="/css/music-player/fonts/iconfont.css">


<link rel="stylesheet" href="/css/music-player/css/reset.css">


<link rel="stylesheet" href="/css/music-player/css/player.css">


<div class="music-player">
    <audio class="music-player__audio" ></audio>
    <div class="music-player__main">
        <div class="music-player__blur"></div>
        <div class="music-player__disc">
            <div class="music-player__image">
                <img width="100%" src="" alt="">
            </div>
            <div class="music-player__pointer"><img width="100%" src="/img/cd_tou.png" alt=""></div>
        </div>
        <div class="music-player__controls">
            <div class="music__info">
                <h3 class="music__info--title">...</h3>
                <p class="music__info--singer">...</p>
            </div>
            <div class="player-control">
                <div class="player-control__content">
                    <div class="player-control__btns">
                        <div class="player-control__btn player-control__btn--prev"><i class="iconfont icon-prev"></i></div>
                        <div class="player-control__btn player-control__btn--play"><i class="iconfont icon-play"></i></div>
                        <div class="player-control__btn player-control__btn--next"><i class="iconfont icon-next"></i></div>
                        <div class="player-control__btn player-control__btn--mode"><i class="iconfont icon-loop"></i></div>
                    </div>
                    <div class="player-control__volume">
                        <div class="control__volume--icon player-control__btn"><i class="iconfont icon-volume"></i></div>
                        <div class="control__volume--progress player_progress"></div>
                    </div>
                </div>
                <div class="player-control__content">
                    <div class="player__song--progress player_progress"></div>
                    <div class="player__song--timeProgess nowTime">00:00</div>
                    <div class="player__song--timeProgess totalTime">00:00</div>
                </div>
            </div>
        </div>
    </div>
</div>


<script src="/js/music-player/utill.js"></script>


<script src="/js/music-player/jquery.min.js"></script>

<!-- netease; qqkg -->
<!--
<script src="/js/music-player/player.js?library=config.music.library.js"></script>
-->
<script src="../../../../js/music-player/player.js?library=netease&music=https://kg.qq.com/node/play?s=7deFpz7Z26Jmv7di&g_f=share_html"></script>
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#hrtimer" title="hrtimer">hrtimer</a>
                        
                          <a class="tag" href="/tags/#tickless" title="tickless">tickless</a>
                        
                          <a class="tag" href="/tags/#clocksource" title="clocksource">clocksource</a>
                        
                          <a class="tag" href="/tags/#timekeeper" title="timekeeper">timekeeper</a>
                        
                          <a class="tag" href="/tags/#clockevent" title="clockevent">clockevent</a>
                        
                          <a class="tag" href="/tags/#noHZ" title="noHZ">noHZ</a>
                        
                          <a class="tag" href="/tags/#lowres timer" title="lowres timer">lowres timer</a>
                        
                          <a class="tag" href="/tags/#wall time" title="wall time">wall time</a>
                        
                          <a class="tag" href="/tags/#xtime" title="xtime">xtime</a>
                        
                          <a class="tag" href="/tags/#monotonic time" title="monotonic time">monotonic time</a>
                        
                          <a class="tag" href="/tags/#boottime" title="boottime">boottime</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; meizu 2023 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://kernel.meizu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
