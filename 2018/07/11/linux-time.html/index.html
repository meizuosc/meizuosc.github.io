<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="一个有内涵的技术分享平台">
    <meta name="keyword"  content="meizu,kernel,魅族">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Linux Time - 魅族内核团队
        
    </title>

    <link rel="canonical" href="https://kernel.meizu.com/2018/07/11//linux-time.html/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="../../../../../css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="../../../../../css/dusign-light.css">

        
<link rel="stylesheet" href="../../../../../css/dusign-common-light.css">

        
<link rel="stylesheet" href="../../../../../css/font-awesome.css">

        
<link rel="stylesheet" href="../../../../../css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="../../../../../css/highlight.css">


    
<link rel="stylesheet" href="../../../../../css/widget.css">


    
<link rel="stylesheet" href="../../../../../css/rocket.css">


    
<link rel="stylesheet" href="../../../../../css/signature.css">


    
<link rel="stylesheet" href="../../../../../css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="../../../../../css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#hrtimer" title="hrtimer">hrtimer</a>
                            
                              <a class="tag" href="/tags/#tickless" title="tickless">tickless</a>
                            
                              <a class="tag" href="/tags/#monotonic time" title="monotonic time">monotonic time</a>
                            
                              <a class="tag" href="/tags/#timekeeper" title="timekeeper">timekeeper</a>
                            
                              <a class="tag" href="/tags/#clocksource" title="clocksource">clocksource</a>
                            
                              <a class="tag" href="/tags/#clockevent" title="clockevent">clockevent</a>
                            
                              <a class="tag" href="/tags/#noHZ" title="noHZ">noHZ</a>
                            
                              <a class="tag" href="/tags/#lowres timer" title="lowres timer">lowres timer</a>
                            
                              <a class="tag" href="/tags/#wall time" title="wall time">wall time</a>
                            
                              <a class="tag" href="/tags/#xtime" title="xtime">xtime</a>
                            
                              <a class="tag" href="/tags/#boottime" title="boottime">boottime</a>
                            
                        </div>
                        <h1>Linux Time</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Peng Weilin on
                            2018-07-11
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">魅族内核团队</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="1、Linux时钟框架"><a href="#1、Linux时钟框架" class="headerlink" title="1、Linux时钟框架"></a>1、Linux时钟框架</h2><p><img src="linux_time_profile.png" alt="image"><sup><a href="#fn_DroidPhoneo" id="reffn_DroidPhoneo">DroidPhoneo</a></sup></p>
<p>上图是linux时钟框架一个经典的描述。本质上linux各种时钟架构和服务是基于硬件提供的两种timer而构建的。</p>
<p>1、定时Timer</p>
<ul>
<li>这类timer每个cpu都有一个独立的，称为local timer。这类timer的中断一般都是PPI（Private Peripheral Interrupt）类型，即每个cpu都有独立一份中断。 与PPI对应的是SPI（Shared Peripheral Interrupt，即多个cpu共享同一个中断。</li>
<li>这类timer一般是32bit宽度count，最重要的它会频繁的溢出并产生timer到期中断。</li>
<li>这类timer服务于tick timer(低精度)或者hrtimer(高精度)。</li>
<li>低精度模式，local timer工作在PERIODIC模式。即timer以tick时间(1/HZ)周期性的产生中断。在tick timer中处理任务调度tick、低精度timer、其他时间更新和统计profile。在这种模式下，所有利用时间的进行的运算，精度都是以tick(1/HZ)为单位的，精度较低。比如HZ=1000，那么tick=1ms。</li>
<li>高精度模式，local timer工作在ONESHOT模式。即系统可以支持hrtimer(high resolution)高精度timer，精度为local timer的计数clk达到ns级别。这种情况下把tick timer也转换成一种hrtimer。</li>
</ul>
<p>2、时间戳Timer</p>
<ul>
<li>这类timer一个系统多个cpu共享一个，称为global timer。</li>
<li>这类timer一般是32bit/64bit宽度count，一般不会溢出产生中断，系统实时的去读取count的值来计算当前的时间戳。</li>
<li>这类timer服务于clocksource/timekeeper。</li>
</ul>
<blockquote>
<p>本文的代码分析基于linux kernel 4.4.22，最好的学习方法还是”RTFSC”</p>
</blockquote>
<h3 id="1-1、Exynos-MCT-Multi-Core-Timer"><a href="#1-1、Exynos-MCT-Multi-Core-Timer" class="headerlink" title="1.1、Exynos MCT(Multi-Core Timer)"></a>1.1、Exynos MCT(Multi-Core Timer)</h3><p>我们以samsung exynos架构为例来说明linux对timer的使用。</p>
<p><img src="exynos_timer.png" alt="image"></p>
<p>从上图可以看到，exynos有1个64bit global timer用来做时间戳timer，有8个31bit localtimer用来做定时timer，每个cpu拥有一个localtimer。</p>
<p><img src="exynos_mct_initflow.png" alt="image"></p>
<p>上图是exynos driver的初始化流程，mct_init_dt()中包含了主要的初始化流程：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __init mct<span class="constructor">_init_dt(<span class="params">struct</span> <span class="params">device_node</span> <span class="operator">*</span><span class="params">np</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">int_type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	exynos4<span class="constructor">_timer_resources(<span class="params">np</span>, <span class="params">of_iomap</span>(<span class="params">np</span>, 0)</span>); <span class="comment">//(1)初始化localtimer，并将其注册成clockevent</span></span><br><span class="line">	exynos4<span class="constructor">_clocksource_init()</span>; <span class="comment">//(2)初始化globaltimer，并将其注册成clocksource</span></span><br><span class="line">	exynos4<span class="constructor">_clockevent_init()</span>; <span class="comment">//(3)将globaltimer的comparator 0注册成一个clockevent，一般不会使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面结合clocksource和clockevent的子系统的解析，再来详细描述exynos系统的具体实现。</p>
<h2 id="2、clocksource-amp-timekeeper"><a href="#2、clocksource-amp-timekeeper" class="headerlink" title="2、clocksource &amp; timekeeper"></a>2、clocksource &amp; timekeeper</h2><p><img src="clocksource_timekeeper.png" alt="image"></p>
<p>上图描述的是clocksource和timekeeper的关系：</p>
<ul>
<li>一个global timer对应注册一个clocksource。</li>
<li>一个系统中可以有多个clocksource，timekeeper选择精度最高的那个来使用。</li>
<li>用户使用timekeeper提供的接口来获取系统的时间戳。</li>
<li>为了避免无人主动获取时间clocksource定时器的溢出，timekeeper需要定期的去获取clocksource的值来更新系统时间，一般是在tick处理中更新。</li>
</ul>
<h3 id="2-1、clocksource"><a href="#2-1、clocksource" class="headerlink" title="2.1、clocksource"></a>2.1、clocksource</h3><p>下面来看一看clocksource的定义：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct clocksource <span class="attr">mct_frc</span> = &#123;</span><br><span class="line">	.<span class="attr">name</span>		= <span class="string">"mct-frc"</span>,</span><br><span class="line">	<span class="comment">/* (1) .rating = 精度，数值越大越好，</span></span><br><span class="line"><span class="comment">       select_best会选择精度最大的clocksource给timekeeper使用 */</span></span><br><span class="line">	.<span class="attr">rating</span>		= <span class="number">400</span>,  </span><br><span class="line">	<span class="comment">/* (2) .read = 读取clocksource的timer当前计数 */</span></span><br><span class="line">	.<span class="attr">read</span>		= exynos4_frc_read,</span><br><span class="line">	<span class="comment">/* (3) .mask = timer的位宽 */</span></span><br><span class="line">	.<span class="attr">mask</span>		= CLOCKSOURCE_MASK(<span class="number">32</span>),</span><br><span class="line">	.<span class="attr">flags</span>		= CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">	.<span class="attr">resume</span>		= exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看一下clocksource的注册过程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void __init exynos4_clocksource_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动global timer</span></span><br><span class="line">	exynos4_mct_frc_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册timer_delay</span></span><br><span class="line">	exynos4_delay_timer.read_current_timer = &amp;exynos4_read_current_timer;</span><br><span class="line">	exynos4_delay_timer.freq = clk_rate;</span><br><span class="line">	register_current_timer_delay(&amp;exynos4_delay_timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) 注册clocksource</span></span><br><span class="line">	<span class="keyword">if</span> (clocksource_register_hz(&amp;mct_frc, clk_rate))</span><br><span class="line">		panic(<span class="string">"%s: can't register clocksource\n"</span>, mct_frc.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册sched_clock</span></span><br><span class="line">	sched_clock_register(exynos4_read_sched_clock, <span class="number">32</span>, clk_rate);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="keyword">static</span> inline int clocksource_register_hz(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *cs, <span class="built_in">u32</span> hz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __clocksource_register_scale(cs, <span class="number">1</span>, hz);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">int __clocksource_register_scale(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *cs, <span class="built_in">u32</span> scale, <span class="built_in">u32</span> freq)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize mult/shift and max_idle_ns */</span></span><br><span class="line">	<span class="comment">/* (1.1) 根据timer的频率freq，计算cs-&gt;mult、cs-&gt;shift</span></span><br><span class="line"><span class="comment">	    这两个字段是用来把timer的计数转换成实际时间单位ns</span></span><br><span class="line"><span class="comment">	    ns = (count * cs-&gt;mult) &gt;&gt; cs-&gt;shift */</span></span><br><span class="line">	__clocksource_update_freq_scale(cs, scale, freq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add clocksource to the clocksource list */</span></span><br><span class="line">	mutex_lock(&amp;clocksource_mutex);</span><br><span class="line">	<span class="comment">/* (1.2) 将新的clocksource加入全局链表 */</span></span><br><span class="line">	clocksource_enqueue(cs);</span><br><span class="line">	clocksource_enqueue_watchdog(cs);</span><br><span class="line">	<span class="comment">/* (1.3) 从全局链表中重新选择一个best</span></span><br><span class="line"><span class="comment">	    clocksource给timekeeper使用 */</span></span><br><span class="line">	clocksource_select();</span><br><span class="line">	clocksource_select_watchdog(<span class="literal">false</span>);</span><br><span class="line">	mutex_unlock(&amp;clocksource_mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line">void __clocksource_update_freq_scale(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *cs, <span class="built_in">u32</span> scale, <span class="built_in">u32</span> freq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">u64</span> sec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Default clocksources are *special* and self-define their mult/shift.</span></span><br><span class="line"><span class="comment">	 * But, you're not special, so you should specify a freq value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (freq) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Calc the maximum number of seconds which we can run before</span></span><br><span class="line"><span class="comment">		 * wrapping around. For clocksources which have a mask &gt; 32-bit</span></span><br><span class="line"><span class="comment">		 * we need to limit the max sleep time to have a good</span></span><br><span class="line"><span class="comment">		 * conversion precision. 10 minutes is still a reasonable</span></span><br><span class="line"><span class="comment">		 * amount. That results in a shift value of 24 for a</span></span><br><span class="line"><span class="comment">		 * clocksource with mask &gt;= 40-bit and f &gt;= 4GHz. That maps to</span></span><br><span class="line"><span class="comment">		 * ~ 0.06ppm granularity for NTP.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* (1.1.1) 计算timer计数器到溢出，</span></span><br><span class="line"><span class="comment">		    最大能计数多少秒 = sec */</span></span><br><span class="line">		sec = cs-&gt;mask;</span><br><span class="line">		do_div(sec, freq);</span><br><span class="line">		do_div(sec, scale);</span><br><span class="line">		<span class="keyword">if</span> (!sec)</span><br><span class="line">			sec = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sec &gt; <span class="number">600</span> &amp;&amp; cs-&gt;mask &gt; UINT_MAX)</span><br><span class="line">			sec = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1.1.2) 根据1s内的频率数freq，和1s内的ns数NSEC_PER_SEC</span></span><br><span class="line"><span class="comment">            计算freq和ns之间的转换公式：</span></span><br><span class="line"><span class="comment">            ns = (freq * cs-&gt;mult) &gt;&gt; cs-&gt;shift </span></span><br><span class="line"><span class="comment">            目的是把mult和shift算到最大值，最大可能的保留精度 */</span></span><br><span class="line">		clocks_calc_mult_shift(&amp;cs-&gt;mult, &amp;cs-&gt;shift, freq,</span><br><span class="line">				       NSEC_PER_SEC / scale, sec * scale);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure clocksources that have large 'mult' values don't overflow</span></span><br><span class="line"><span class="comment">	 * when adjusted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cs-&gt;maxadj = clocksource_max_adjustment(cs);</span><br><span class="line">	<span class="keyword">while</span> (freq &amp;&amp; ((cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult)</span><br><span class="line">		|| (cs-&gt;mult - cs-&gt;maxadj &gt; cs-&gt;mult))) &#123;</span><br><span class="line">		cs-&gt;mult &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		cs-&gt;shift--;</span><br><span class="line">		cs-&gt;maxadj = clocksource_max_adjustment(cs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only warn for *special* clocksources that self-define</span></span><br><span class="line"><span class="comment">	 * their mult/shift values and don't specify a freq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ONCE(cs-&gt;mult + cs-&gt;maxadj &lt; cs-&gt;mult,</span><br><span class="line">		<span class="string">"timekeeping: Clocksource %s might overflow on 11%% adjustment\n"</span>,</span><br><span class="line">		cs-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.3) 根据mult和shift的值，计算最大能进入idle的时间max_idle_ns</span></span><br><span class="line"><span class="comment">        才能保证idle时timer不会溢出*/</span></span><br><span class="line">	clocksource_update_max_deferment(cs);</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n"</span>,</span><br><span class="line">		cs-&gt;name, cs-&gt;mask, cs-&gt;max_cycles, cs-&gt;max_idle_ns);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line"><span class="keyword">static</span> void clocksource_select(void)</span><br><span class="line">&#123;</span><br><span class="line">	__clocksource_select(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> void __clocksource_select(<span class="built_in">bool</span> skipcur)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bool</span> oneshot = tick_oneshot_mode_active();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *best, *cs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find the best suitable clocksource */</span></span><br><span class="line">	<span class="comment">/* (1.3.1) 选择best clocksource */</span></span><br><span class="line">	best = clocksource_find_best(oneshot, skipcur);</span><br><span class="line">	<span class="keyword">if</span> (!best)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for the override clocksource. */</span></span><br><span class="line">	list_for_each_entry(cs, &amp;clocksource_list, list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skipcur &amp;&amp; cs == curr_clocksource)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (strcmp(cs-&gt;name, override_name) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check to make sure we don't switch to a non-highres</span></span><br><span class="line"><span class="comment">		 * capable clocksource if the tick code is in oneshot</span></span><br><span class="line"><span class="comment">		 * mode (highres or nohz)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(cs-&gt;flags &amp; CLOCK_SOURCE_VALID_FOR_HRES) &amp;&amp; oneshot) &#123;</span><br><span class="line">			<span class="comment">/* Override clocksource cannot be used. */</span></span><br><span class="line">			pr_warn(<span class="string">"Override clocksource %s is not HRT compatible - cannot switch while in HRT/NOHZ mode\n"</span>,</span><br><span class="line">				cs-&gt;name);</span><br><span class="line">			override_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="comment">/* Override clocksource can be used. */</span></span><br><span class="line">			best = cs;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.3.2) 通知timekeeper更新clocksource，tick-sched更新 */</span></span><br><span class="line">	<span class="keyword">if</span> (curr_clocksource != best &amp;&amp; !timekeeping_notify(best)) &#123;</span><br><span class="line">		pr_info(<span class="string">"Switched to clocksource %s\n"</span>, best-&gt;name);</span><br><span class="line">		curr_clocksource = best;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">||||→</span><br><span class="line">int timekeeping_notify(<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span></span> *clock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;tk_core.timekeeper;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tk-&gt;tkr_mono.clock == clock)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	stop_machine(change_clocksource, clock, NULL);</span><br><span class="line">	tick_clock_notify();</span><br><span class="line">	<span class="keyword">return</span> tk-&gt;tkr_mono.clock == clock ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1、exynos4-clocksource-init"><a href="#2-1-1、exynos4-clocksource-init" class="headerlink" title="2.1.1、exynos4_clocksource_init()"></a>2.1.1、exynos4_clocksource_init()</h4><p>exynos将global timer注册成clocksource，虽然global timer拥有64bit的位宽，但是注册的时候把其当成32bit的clocksource注册。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static u32 notrace exynos4<span class="constructor">_read_count_32(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	return readl<span class="constructor">_relaxed(<span class="params">reg_base</span> + EXYNOS4_MCT_G_CNT_L)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static cycle_t exynos4<span class="constructor">_frc_read(<span class="params">struct</span> <span class="params">clocksource</span> <span class="operator">*</span><span class="params">cs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	return exynos4<span class="constructor">_read_count_32()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">struct</span> clocksource mct_frc = &#123;</span><br><span class="line">	.name		= <span class="string">"mct-frc"</span>,</span><br><span class="line">	.rating		= <span class="number">400</span>,</span><br><span class="line">	.read		= exynos4_frc_read,</span><br><span class="line">	.mask		= <span class="constructor">CLOCKSOURCE_MASK(32)</span>,</span><br><span class="line">	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,</span><br><span class="line">	.resume		= exynos4_frc_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __init exynos4<span class="constructor">_clocksource_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	exynos4<span class="constructor">_mct_frc_start()</span>;</span><br><span class="line"></span><br><span class="line">	exynos4_delay_timer.read_current_timer = &amp;exynos4_read_current_timer;</span><br><span class="line">	exynos4_delay_timer.freq = clk_rate;</span><br><span class="line">	register<span class="constructor">_current_timer_delay(&amp;<span class="params">exynos4_delay_timer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) exynos将global timer注册成clocksource */</span></span><br><span class="line">	<span class="keyword">if</span> (clocksource<span class="constructor">_register_hz(&amp;<span class="params">mct_frc</span>, <span class="params">clk_rate</span>)</span>)</span><br><span class="line">		panic(<span class="string">"%s: can't register clocksource\n"</span>, mct_frc.name);</span><br><span class="line"></span><br><span class="line">	sched<span class="constructor">_clock_register(<span class="params">exynos4_read_sched_clock</span>, 32, <span class="params">clk_rate</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2、timekeeper"><a href="#2-2、timekeeper" class="headerlink" title="2.2、timekeeper"></a>2.2、timekeeper</h3><p>timerkeeper提供了几种时间：xtime、monotonic time、raw monotonic time、boot time。</p>
<ul>
<li><strong>xtime</strong> 即是wall time，和RTC时间一样可以表示当前的时刻，它的起始时间是公元0世纪0秒，精度大于RTC时间；</li>
<li><strong>monotonic time</strong> 从系统开机后到现在的累计时间，不过不计算系统休眠的时间；</li>
<li><strong>raw monotonic time</strong> 和monotonic time含义一样，不过更纯粹，不会受到NTP时间调整的影响；</li>
<li><strong>boot time</strong> 在monotonic time的基础上加上了系统休眠的时间，它代表着系统上电后的总时间。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>时间种类</th>
<th>精度（统计单位）</th>
<th>访问速度</th>
<th>累计休眠时间</th>
<th>受NTP调整的影响</th>
<th>获取函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTC</td>
<td>低</td>
<td>慢</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>xtime</td>
<td>高</td>
<td>快</td>
<td>Yes</td>
<td>Yes</td>
<td>do_gettimeofday()、ktime_get_real_ts()、ktime_get_real()</td>
</tr>
<tr>
<td>monotonic</td>
<td>高</td>
<td>快</td>
<td>No</td>
<td>Yes</td>
<td>ktime_get()、ktime_get_ts64()</td>
</tr>
<tr>
<td>raw monotonic</td>
<td>高</td>
<td>快</td>
<td>No</td>
<td>No</td>
<td>ktime_get_raw()、getrawmonotonic64()</td>
</tr>
<tr>
<td>boot time</td>
<td>高</td>
<td>快</td>
<td>Yes</td>
<td>Yes</td>
<td>ktime_get_boottime()</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2-1、timekeeper的定义"><a href="#2-2-1、timekeeper的定义" class="headerlink" title="2.2.1、timekeeper的定义"></a>2.2.1、timekeeper的定义</h4><p>虽然clocksource定时器只有一个，但是timekeeper提供了xtime、monotonic time、raw time、boot time等几种时间，所以timekeeper结构体中定义了多个变量来记住这些差值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>struct timekeeper - Structure holding internal timekeeping values.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@tkr<span class="emphasis">_mono:		The readout base structure for CLOCK_</span>MONOTONIC</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@tkr<span class="emphasis">_raw:		The readout base structure for CLOCK_</span>MONOTONIC_RAW</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@xtime<span class="emphasis">_sec:		Current CLOCK_</span>REALTIME time in seconds</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ktime<span class="emphasis">_sec:		Current CLOCK_</span>MONOTONIC time in seconds</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@wall<span class="emphasis">_to_</span>monotonic:	CLOCK<span class="emphasis">_REALTIME to CLOCK_</span>MONOTONIC offset</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@offs_real:		Offset clock monotonic -&gt; clock realtime</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@offs_boot:		Offset clock monotonic -&gt; clock boottime</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@offs_tai:		Offset clock monotonic -&gt; clock tai</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@tai_offset:		The current UTC to TAI offset in seconds</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@clock<span class="emphasis">_was_</span>set_seq:	The sequence number of clock was set events</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@next<span class="emphasis">_leap_</span>ktime:	CLOCK_MONOTONIC time value of </span>a<span class="markdown"> pending leap-second</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@raw_time:		Monotonic raw base time in timespec64 format</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@cycle_interval:	Number of clock cycles in one NTP interval</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@xtime_interval:	Number of clock shifted nano seconds in one NTP</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *			</span>interval.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@xtime_remainder:	Shifted nano seconds left over when rounding</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *			</span>@cycle_interval</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@raw_interval:	Raw nano seconds accumulated per NTP interval.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ntp_error:		Difference between accumulated time and NTP time in ntp</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *			</span>shifted nano seconds.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@ntp<span class="emphasis">_error_</span>shift:	Shift conversion between clock shifted nano seconds and</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *			</span>ntp shifted nano seconds.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@last<span class="emphasis">_warning:	Warning ratelimiter (DEBUG_</span>TIMEKEEPING)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@underflow<span class="emphasis">_seen:	Underflow warning flag (DEBUG_</span>TIMEKEEPING)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@overflow<span class="emphasis">_seen:	Overflow warning flag (DEBUG_</span>TIMEKEEPING)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Note: For timespec(64) based interfaces wall<span class="emphasis">_to_</span>monotonic is what</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>we need to add to xtime (or xtime corrected for sub jiffie times)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>to get to monotonic time.  Monotonic is pegged at zero at system</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>boot time, </span>so<span class="markdown"> wall<span class="emphasis">_to_</span>monotonic </span>will<span class="markdown"> be negative, however, we </span>will</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>ALWAYS keep </span>the<span class="markdown"> tv_nsec part positive </span>so<span class="markdown"> we can use </span>the<span class="markdown"> usual</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>normalization.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>wall<span class="emphasis">_to_</span>monotonic is moved after resume from suspend for </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>monotonic time not to jump. We need to add total<span class="emphasis">_sleep_</span>time to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>wall<span class="emphasis">_to_</span>monotonic to get </span>the<span class="markdown"> real boot based time offset.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>wall<span class="emphasis">_to_</span>monotonic is no longer </span>the<span class="markdown"> boot time, getboottime must be</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>used instead.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">struct timekeeper &#123;</span><br><span class="line">	struct tk_read_base	tkr_mono;   </span><br><span class="line">                <span class="comment">// tkr_mono.xtime_nsec：xtime/monotonic time 的ns</span></span><br><span class="line">                <span class="comment">// tkr_mono.base：monotonic time的base部分</span></span><br><span class="line">	struct tk_read_base	tkr_raw;</span><br><span class="line">                <span class="comment">// tkr_mono.base：raw time的base部分</span></span><br><span class="line">	u64			xtime_sec;              <span class="comment">// xtime的sec</span></span><br><span class="line">	unsigned long		ktime_sec;      <span class="comment">// monotonic time 的整sec</span></span><br><span class="line">	struct timespec64	wall_to_monotonic;  <span class="comment">// xtime + wall_to_monotonic = monotonic time</span></span><br><span class="line">	ktime_t			offs_real;  <span class="comment">//  monotonic time + offs_real = xtime，</span></span><br><span class="line">                                <span class="comment">// 和wall_to_monotonic是相反的值</span></span><br><span class="line">	ktime_t			offs_boot;  <span class="comment">//  monotonic time + offs_boot = boot time</span></span><br><span class="line">	ktime_t			offs_tai;</span><br><span class="line">	s32			tai_offset;</span><br><span class="line">	unsigned <span class="built_in">int</span>		clock_was_set_seq;</span><br><span class="line">	ktime_t			next_leap_ktime;</span><br><span class="line">	struct timespec64	raw_time;   <span class="comment">// raw time</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The following members are for timekeeping internal use */</span></span><br><span class="line">	cycle_t			cycle_interval;</span><br><span class="line">	u64			xtime_interval;</span><br><span class="line">	s64			xtime_remainder;</span><br><span class="line">	u32			raw_interval;</span><br><span class="line">	<span class="comment">/* The ntp_tick_length() value currently being used.</span></span><br><span class="line"><span class="comment">	 * This cached copy ensures we consistently apply the tick</span></span><br><span class="line"><span class="comment">	 * length for an entire tick, as ntp_tick_length may change</span></span><br><span class="line"><span class="comment">	 * mid-tick, and we don't want to apply that new value to</span></span><br><span class="line"><span class="comment">	 * the tick in progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u64			ntp_tick;</span><br><span class="line">	<span class="comment">/* Difference between accumulated time and NTP time in ntp</span></span><br><span class="line"><span class="comment">	 * shifted nano seconds. */</span></span><br><span class="line">	s64			ntp_error;</span><br><span class="line">	u32			ntp_error_shift;</span><br><span class="line">	u32			ntp_err_mult;</span><br><span class="line">#ifdef CONFIG_DEBUG_TIMEKEEPING</span><br><span class="line">	long			last_warning;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These simple flag variables are managed</span></span><br><span class="line"><span class="comment">	 * without locks, which is racy, but they are</span></span><br><span class="line"><span class="comment">	 * ok since we don't really care about being</span></span><br><span class="line"><span class="comment">	 * super precise about how many events were</span></span><br><span class="line"><span class="comment">	 * seen, just that a problem was observed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">int</span>			underflow_seen;</span><br><span class="line">	<span class="built_in">int</span>			overflow_seen;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2、timekeeper的初始化"><a href="#2-2-2、timekeeper的初始化" class="headerlink" title="2.2.2、timekeeper的初始化"></a>2.2.2、timekeeper的初始化</h4><p>timekeeper在初始化的过程中，读取当前的RTC值和clocksource的值，来初始化xtime、monotonic time、raw time、boot time，以及各种offset。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void __init timekeeping_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper <span class="comment">*tk = &amp;tk_core.timekeeper;</span></span><br><span class="line">	struct clocksource <span class="comment">*clock;</span></span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct timespec64 now, boot, tmp;</span><br><span class="line"></span><br><span class="line">	read_persistent_clock64(<span class="variable">&amp;now</span>);</span><br><span class="line">	<span class="meta">if</span> (!timespec64_valid_strict(<span class="variable">&amp;now</span>)) &#123;</span><br><span class="line">		pr_wa<span class="meta">rn(</span><span class="string">"WARNING: Persistent clock returned invalid value!\n"</span></span><br><span class="line">			<span class="string">"         Check your CMOS/BIOS settings.\n"</span>);</span><br><span class="line">		now.tv_sec = 0;</span><br><span class="line">		now.tv_nsec = 0;</span><br><span class="line">	&#125; <span class="meta">else</span> <span class="meta">if</span> (now.tv_sec || now.tv_nsec)</span><br><span class="line">		persistent_clock_exists = true;</span><br><span class="line"></span><br><span class="line">	read_boot_clock64(<span class="variable">&amp;boot</span>);</span><br><span class="line">	<span class="meta">if</span> (!timespec64_valid_strict(<span class="variable">&amp;boot</span>)) &#123;</span><br><span class="line">		pr_wa<span class="meta">rn(</span><span class="string">"WARNING: Boot clock returned invalid value!\n"</span></span><br><span class="line">			<span class="string">"         Check your CMOS/BIOS settings.\n"</span>);</span><br><span class="line">		boot.tv_sec = 0;</span><br><span class="line">		boot.tv_nsec = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(<span class="variable">&amp;timekeeper_lock</span>, flags);</span><br><span class="line">	write_seqcount_beg<span class="meta">in(</span><span class="variable">&amp;tk_core.</span>seq);</span><br><span class="line">	ntp_init();</span><br><span class="line"></span><br><span class="line">	clock = clocksource_default_clock();</span><br><span class="line">	<span class="meta">if</span> (clock-&gt;enable)</span><br><span class="line">		clock-&gt;enable(clock);</span><br><span class="line">	tk_setup_internals(tk, clock);</span><br><span class="line"></span><br><span class="line">	tk_set_<span class="meta">xtime(</span>tk, <span class="variable">&amp;now</span>);</span><br><span class="line">	tk-&gt;raw_time.tv_sec = 0;</span><br><span class="line">	tk-&gt;raw_time.tv_nsec = 0;</span><br><span class="line">	<span class="meta">if</span> (boot.tv_sec == 0 <span class="variable">&amp;&amp;</span> boot.tv_nsec == 0)</span><br><span class="line">		boot = tk_<span class="meta">xtime(</span>tk);</span><br><span class="line"></span><br><span class="line">	set_normalized_timespec64(<span class="variable">&amp;tmp</span>, -boot.tv_sec, -boot.tv_nsec);</span><br><span class="line">	tk_set_wall_to_mono(tk, tmp);</span><br><span class="line"></span><br><span class="line">	timekeeping_u<span class="meta">pdate(</span>tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(<span class="variable">&amp;tk_core.</span>seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(<span class="variable">&amp;timekeeper_lock</span>, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timekeeper原理上的初始化是在timekeeping_init()函数中完成的，但是read_persistent_clock64()、read_boot_clock64()都是空函数，所以实际上的初始化是另外的路径：rtc_hctosys() -&gt; do_settimeofday64()，rtc初始化的时候重新配置timekeeper。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">rtc_hctosys</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = -ENODEV;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">tv64</span> = &#123;</span></span><br><span class="line">		.tv_nsec = NSEC_PER_SEC &gt;&gt; <span class="number">1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> = <span class="title">rtc_class_open</span>(<span class="title">CONFIG_RTC_HCTOSYS_DEVICE</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rtc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		pr_info(<span class="string">"unable to open rtc device (%s)\n"</span>,</span><br><span class="line">			CONFIG_RTC_HCTOSYS_DEVICE);</span><br><span class="line">		<span class="keyword">goto</span> err_open;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 读取当前的rtc时间 */</span></span><br><span class="line">	err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		dev_err(rtc-&gt;dev.parent,</span><br><span class="line">			<span class="string">"hctosys: unable to read the hardware clock\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_read;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tv64.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	tv64.tv_nsec = tm.tm_cnt * (<span class="number">1000000000</span> / <span class="number">32768</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* (2) 根据rtc时间配置xtime */</span></span><br><span class="line">	err = do_settimeofday64(&amp;tv64);</span><br><span class="line"></span><br><span class="line">	dev_info(rtc-&gt;dev.parent,</span><br><span class="line">		<span class="string">"setting system clock to "</span></span><br><span class="line">		<span class="string">"%d-%02d-%02d %02d:%02d:%02d UTC (%lld)\n"</span>,</span><br><span class="line">		tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday,</span><br><span class="line">		tm.tm_hour, tm.tm_min, tm.tm_sec,</span><br><span class="line">		(<span class="keyword">long</span> <span class="keyword">long</span>) tv64.tv_sec);</span><br><span class="line"></span><br><span class="line">err_read:</span><br><span class="line">	rtc_class_close(rtc);</span><br><span class="line"></span><br><span class="line">err_open:</span><br><span class="line">	rtc_hctosys_ret = err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_settimeofday64</span><span class="params">(<span class="keyword">const</span> struct timespec64 *ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> = &amp;<span class="title">tk_core</span>.<span class="title">timekeeper</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts_delta</span>, <span class="title">xt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!timespec64_valid_strict(ts))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 读取当前的xtime，计算rtc time和xtime之间的差值  */</span></span><br><span class="line">	xt = tk_xtime(tk);</span><br><span class="line">	ts_delta.tv_sec = ts-&gt;tv_sec - xt.tv_sec;</span><br><span class="line">	ts_delta.tv_nsec = ts-&gt;tv_nsec - xt.tv_nsec;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timespec64_compare(&amp;tk-&gt;wall_to_monotonic, &amp;ts_delta) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2) 将差值追加到offset；tk-&gt;wall_to_monotonic、tk-&gt;offs_real */</span></span><br><span class="line">	tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, ts_delta));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.3) 更新xtime */</span></span><br><span class="line">	tk_set_xtime(tk, ts);</span><br><span class="line">out:</span><br><span class="line">	timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* signal hrtimers about time change */</span></span><br><span class="line">	clock_was_set();</span><br><span class="line">	notify_time_update();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3、timekeeper的update"><a href="#2-2-3、timekeeper的update" class="headerlink" title="2.2.3、timekeeper的update"></a>2.2.3、timekeeper的update</h4><p>clocksource定时器的值要定时的读出来，并且把增量加到timekeeper中，不然clocksource定时器会溢出。这个定时更新的时间一般是1 tick，调用的函数是update_wall_time()：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">void update_wall_time(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *real_tk = &amp;tk_core.timekeeper;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;shadow_timekeeper;</span><br><span class="line">	cycle_t offset;</span><br><span class="line">	int shift = <span class="number">0</span>, maxshift;</span><br><span class="line">	unsigned int clock_set = <span class="number">0</span>;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we're fully resumed: */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(timekeeping_suspended))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span><br><span class="line">	offset = real_tk-&gt;cycle_interval;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* (1) 获取clocksource和上一次update之间的offset */</span></span><br><span class="line">	offset = clocksource_delta(tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock),</span><br><span class="line">				   tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if there's really nothing to do */</span></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; real_tk-&gt;cycle_interval)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do some additional sanity checking */</span></span><br><span class="line">	timekeeping_check_update(real_tk, offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With NO_HZ we may have to accumulate many cycle_intervals</span></span><br><span class="line"><span class="comment">	 * (think "ticks") worth of time at once. To do this efficiently,</span></span><br><span class="line"><span class="comment">	 * we calculate the largest doubling multiple of cycle_intervals</span></span><br><span class="line"><span class="comment">	 * that is smaller than the offset.  We then accumulate that</span></span><br><span class="line"><span class="comment">	 * chunk in one go, and then try to consume the next smaller</span></span><br><span class="line"><span class="comment">	 * doubled multiple.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	shift = ilog2(offset) - ilog2(tk-&gt;cycle_interval);</span><br><span class="line">	shift = max(<span class="number">0</span>, shift);</span><br><span class="line">	<span class="comment">/* Bound shift to one less than what overflows tick_length */</span></span><br><span class="line">	maxshift = (<span class="number">64</span> - (ilog2(ntp_tick_length())+<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">	shift = min(shift, maxshift);</span><br><span class="line">	<span class="comment">/* (2) 如果offset的值是多个cycle_interval，</span></span><br><span class="line"><span class="comment">	    不要一次update，使用2的n次方cycle_interval的方式逐个update。</span></span><br><span class="line"><span class="comment">	    tk-&gt;cycle_interval的值在tk_setup_internals()时被赋值，默认为1 tick */</span></span><br><span class="line">	<span class="keyword">while</span> (offset &gt;= tk-&gt;cycle_interval) &#123;</span><br><span class="line">	    <span class="comment">/* (3) 将offset更新到timekeeper中 */</span></span><br><span class="line">		offset = logarithmic_accumulation(tk, offset, shift,</span><br><span class="line">							&amp;clock_set);</span><br><span class="line">		<span class="keyword">if</span> (offset &lt; tk-&gt;cycle_interval&lt;&lt;shift)</span><br><span class="line">			shift--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* correct the clock when NTP error is too big */</span></span><br><span class="line">	timekeeping_adjust(tk, offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * XXX This can be killed once everyone converts</span></span><br><span class="line"><span class="comment">	 * to the new update_vsyscall.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	old_vsyscall_fixup(tk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finally, make sure that after the rounding</span></span><br><span class="line"><span class="comment">	 * xtime_nsec isn't larger than NSEC_PER_SEC</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	clock_set |= accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update the real timekeeper.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We could avoid this memcpy by switching pointers, but that</span></span><br><span class="line"><span class="comment">	 * requires changes to all other timekeeper usage sites as</span></span><br><span class="line"><span class="comment">	 * well, i.e. move the timekeeper pointer getter into the</span></span><br><span class="line"><span class="comment">	 * spinlocked/seqcount protected sections. And we trade this</span></span><br><span class="line"><span class="comment">	 * memcpy under the tk_core.seq against one before we start</span></span><br><span class="line"><span class="comment">	 * updating.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (4)  */</span></span><br><span class="line">	timekeeping_update(tk, clock_set);</span><br><span class="line">	memcpy(real_tk, tk, sizeof(*tk));</span><br><span class="line">	<span class="comment">/* The memcpy must come last. Do not put anything here! */</span></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (clock_set)</span><br><span class="line">		<span class="comment">/* Have to call _delayed version, since in irq context*/</span></span><br><span class="line">		clock_was_set_delayed();</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="keyword">static</span> cycle_t logarithmic_accumulation(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk, cycle_t offset,</span><br><span class="line">						<span class="built_in">u32</span> shift,</span><br><span class="line">						unsigned int *clock_set)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t interval = tk-&gt;cycle_interval &lt;&lt; shift;</span><br><span class="line">	<span class="built_in">u64</span> raw_nsecs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the offset is smaller than a shifted interval, do nothing */</span></span><br><span class="line">	<span class="keyword">if</span> (offset &lt; interval)</span><br><span class="line">		<span class="keyword">return</span> offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Accumulate one shifted interval */</span></span><br><span class="line">	offset -= interval;</span><br><span class="line">	<span class="comment">/* (3.1) 更新cycle_last */</span></span><br><span class="line">	tk-&gt;tkr_mono.cycle_last += interval;</span><br><span class="line">	tk-&gt;tkr_raw.cycle_last  += interval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (3.2) 更新xtime：</span></span><br><span class="line"><span class="comment">        tk-&gt;tkr_mono.xtime_nsec</span></span><br><span class="line"><span class="comment">        tk-&gt;xtime_sec   */</span></span><br><span class="line">	tk-&gt;tkr_mono.xtime_nsec += tk-&gt;xtime_interval &lt;&lt; shift;</span><br><span class="line">	*clock_set |= accumulate_nsecs_to_secs(tk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Accumulate raw time */</span></span><br><span class="line">	<span class="comment">/* (3.3) 更新raw time：</span></span><br><span class="line"><span class="comment">	   tk-&gt;raw_time.tv_nsec</span></span><br><span class="line"><span class="comment">	   tk-&gt;raw_time.tv_sec */</span></span><br><span class="line">	raw_nsecs = (<span class="built_in">u64</span>)tk-&gt;raw_interval &lt;&lt; shift;</span><br><span class="line">	raw_nsecs += tk-&gt;raw_time.tv_nsec;</span><br><span class="line">	<span class="keyword">if</span> (raw_nsecs &gt;= NSEC_PER_SEC) &#123;</span><br><span class="line">		<span class="built_in">u64</span> raw_secs = raw_nsecs;</span><br><span class="line">		raw_nsecs = do_div(raw_secs, NSEC_PER_SEC);</span><br><span class="line">		tk-&gt;raw_time.tv_sec += raw_secs;</span><br><span class="line">	&#125;</span><br><span class="line">	tk-&gt;raw_time.tv_nsec = raw_nsecs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Accumulate error between NTP and clock interval */</span></span><br><span class="line">	tk-&gt;ntp_error += tk-&gt;ntp_tick &lt;&lt; shift;</span><br><span class="line">	tk-&gt;ntp_error -= (tk-&gt;xtime_interval + tk-&gt;xtime_remainder) &lt;&lt;</span><br><span class="line">						(tk-&gt;ntp_error_shift + shift);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line"><span class="keyword">static</span> void timekeeping_update(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk, unsigned int action)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (action &amp; TK_CLEAR_NTP) &#123;</span><br><span class="line">		tk-&gt;ntp_error = <span class="number">0</span>;</span><br><span class="line">		ntp_clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tk_update_leap_state(tk);</span><br><span class="line">	<span class="comment">/* (4.1) update monotonic time */</span></span><br><span class="line">	tk_update_ktime_data(tk);</span><br><span class="line"></span><br><span class="line">	update_vsyscall(tk);</span><br><span class="line">	update_pvclock_gtod(tk, action &amp; TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	update_fast_timekeeper(&amp;tk-&gt;tkr_mono, &amp;tk_fast_mono);</span><br><span class="line">	update_fast_timekeeper(&amp;tk-&gt;tkr_raw,  &amp;tk_fast_raw);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action &amp; TK_CLOCK_WAS_SET)</span><br><span class="line">		tk-&gt;clock_was_set_seq++;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The mirroring of the data to the shadow-timekeeper needs</span></span><br><span class="line"><span class="comment">	 * to happen last here to ensure we don't over-write the</span></span><br><span class="line"><span class="comment">	 * timekeeper structure on the next update with stale data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (action &amp; TK_MIRROR)</span><br><span class="line">		memcpy(&amp;shadow_timekeeper, &amp;tk_core.timekeeper,</span><br><span class="line">		       sizeof(tk_core.timekeeper));</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line"><span class="keyword">static</span> inline void tk_update_ktime_data(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">u64</span> seconds;</span><br><span class="line">	<span class="built_in">u32</span> nsec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The xtime based monotonic readout is:</span></span><br><span class="line"><span class="comment">	 *	nsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();</span></span><br><span class="line"><span class="comment">	 * The ktime based monotonic readout is:</span></span><br><span class="line"><span class="comment">	 *	nsec = base_mono + now();</span></span><br><span class="line"><span class="comment">	 * ==&gt; base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (4.1.1) update tk-&gt;tkr_mono.base的值，</span></span><br><span class="line"><span class="comment">	   = tk-&gt;xtime_sec +  tk-&gt;wall_to_monotonic,</span></span><br><span class="line"><span class="comment">	   tk-&gt;tkr_mono.xtime_nsec 没有计算到base中 */</span></span><br><span class="line">	seconds = (<span class="built_in">u64</span>)(tk-&gt;xtime_sec + tk-&gt;wall_to_monotonic.tv_sec);</span><br><span class="line">	nsec = (<span class="built_in">u32</span>) tk-&gt;wall_to_monotonic.tv_nsec;</span><br><span class="line">	tk-&gt;tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update the monotonic raw base */</span></span><br><span class="line">	<span class="comment">/* (4.1.2) update tk-&gt;tkr_raw.base的值，</span></span><br><span class="line"><span class="comment">	   直接转换tk-&gt;raw_time */</span></span><br><span class="line">	tk-&gt;tkr_raw.base = timespec64_to_ktime(tk-&gt;raw_time);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The sum of the nanoseconds portions of xtime and</span></span><br><span class="line"><span class="comment">	 * wall_to_monotonic can be greater/equal one second. Take</span></span><br><span class="line"><span class="comment">	 * this into account before updating tk-&gt;ktime_sec.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (4.1.3) update tk-&gt;ktime_sec的值</span></span><br><span class="line"><span class="comment">	nsec += (u32)(tk-&gt;tkr_mono.xtime_nsec &gt;&gt; tk-&gt;tkr_mono.shift);</span></span><br><span class="line"><span class="comment">	if (nsec &gt;= NSEC_PER_SEC)</span></span><br><span class="line"><span class="comment">		seconds++;</span></span><br><span class="line"><span class="comment">	tk-&gt;ktime_sec = seconds;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4、timekeeper的获取"><a href="#2-2-4、timekeeper的获取" class="headerlink" title="2.2.4、timekeeper的获取"></a>2.2.4、timekeeper的获取</h4><ul>
<li><strong>xtime/wall time 的获取:</strong></li>
</ul>
<p>do_gettimeofday()、ktime_get_real_ts()最后调用的getnstimeofday64() -&gt; __getnstimeofday64()获取到xtime：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">int __getnstimeofday64(struct timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long seq;</span><br><span class="line">	s64 nsecs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) sec直接从变量tk-&gt;xtime_sec获取到，</span></span><br><span class="line"><span class="comment">            即上一tick更新的值 */</span></span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">tv_sec</span> = tk-&gt;</span>xtime_sec;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span></span><br><span class="line"><span class="comment">		    delta是距离上一次tick更新的差值 */</span></span><br><span class="line">		<span class="function"><span class="title">nsecs</span> = timekeeping_get_ns(&amp;tk-&gt;</span>tkr_mono);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">ts</span>-&gt;</span>tv_nsec = <span class="number">0</span>;</span><br><span class="line">	timespec64_add_ns(ts, nsecs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not bail out early, in case there were callers still using</span></span><br><span class="line"><span class="comment">	 * the value, even in the face of the WARN_ON.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(timekeeping_suspended))</span><br><span class="line">		return -EAGAIN;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">	cycle_t delta;</span><br><span class="line">	s64 nsec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 获取距离上一次tick更新，timer的delta值  */</span></span><br><span class="line">	delta = timekeeping_get_delta(tkr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2) delta加上上一次的nsec tkr-&gt;xtime_nsec，</span></span><br><span class="line"><span class="comment">        即为最新的ns值 */</span></span><br><span class="line">	<span class="function"><span class="title">nsec</span> = (delta * tkr-&gt;</span><span class="function"><span class="title">mult</span> + tkr-&gt;</span><span class="function"><span class="title">xtime_nsec</span>) &gt;&gt; tkr-&gt;</span>shift;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If arch requires, add in get_arch_timeoffset() */</span></span><br><span class="line">	return nsec + arch_gettimeoffset();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static inline cycle_t timekeeping_get_delta(struct tk_read_base *tkr)</span><br><span class="line">&#123;</span><br><span class="line">	struct timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	cycle_t now, last, mask, max, delta;</span><br><span class="line">	unsigned int seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we're called holding a seqlock, the data may shift</span></span><br><span class="line"><span class="comment">	 * under us while we're doing the calculation. This can cause</span></span><br><span class="line"><span class="comment">	 * false positives, since we'd note a problem but throw the</span></span><br><span class="line"><span class="comment">	 * results away. So nest another seqlock here to atomically</span></span><br><span class="line"><span class="comment">	 * grab the points we are checking with.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		<span class="comment">/* (2.1.1) 使用read函数读取当前timer的计数 */</span></span><br><span class="line">		<span class="function"><span class="title">now</span> = tkr-&gt;</span><span class="function"><span class="title">read</span>(tkr-&gt;</span>clock);</span><br><span class="line">		<span class="function"><span class="title">last</span> = tkr-&gt;</span>cycle_last;</span><br><span class="line">		<span class="function"><span class="title">mask</span> = tkr-&gt;</span>mask;</span><br><span class="line">		<span class="function"><span class="title">max</span> = tkr-&gt;</span><span class="function"><span class="title">clock</span>-&gt;</span>max_cycles;</span><br><span class="line">	&#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1.2) 使用公式：(now - last) &amp; mask，</span></span><br><span class="line"><span class="comment">        计算delta值 */</span></span><br><span class="line">	delta = clocksource_delta(now, last, mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to catch underflows by checking if we are seeing small</span></span><br><span class="line"><span class="comment">	 * mask-relative negative values.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely((~delta &amp; mask) &lt; (mask &gt;&gt; <span class="number">3</span>))) &#123;</span><br><span class="line">		<span class="function"><span class="title">tk</span>-&gt;</span>underflow_seen = <span class="number">1</span>;</span><br><span class="line">		delta = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cap delta value to the max_cycles values to avoid mult overflows */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(delta &gt; max)) &#123;</span><br><span class="line">		<span class="function"><span class="title">tk</span>-&gt;</span>overflow_seen = <span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="title">delta</span> = tkr-&gt;</span><span class="function"><span class="title">clock</span>-&gt;</span>max_cycles;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ktime_get_real()使用monotonic time再加上差值timekeeper.offs_real的方法来获取xtime：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime<span class="constructor">_get_real(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	return ktime<span class="constructor">_get_with_offset(TK_OFFS_REAL)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static ktime<span class="constructor">_t</span> <span class="operator">*</span>offsets[<span class="constructor">TK_OFFS_MAX</span>] = &#123;</span></span><br><span class="line"><span class="pattern-match">	[<span class="constructor">TK_OFFS_REAL</span>]	= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_real</span>,</span></span><br><span class="line"><span class="pattern-match">	[<span class="constructor">TK_OFFS_BOOT</span>]	= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_boot</span>,</span></span><br><span class="line"><span class="pattern-match">	[<span class="constructor">TK_OFFS_TAI</span>]	= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_tai</span>,</span></span><br><span class="line"><span class="pattern-match">&#125;;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">ktime<span class="constructor">_t</span> ktime<span class="constructor">_get_with_offset(<span class="params">enum</span> <span class="params">tk_offsets</span> <span class="params">offs</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">struct</span> timekeeper <span class="operator">*</span>tk = &amp;tk<span class="constructor">_core</span>.timekeeper;</span></span><br><span class="line"><span class="pattern-match">	unsigned <span class="built_in">int</span> seq;</span></span><br><span class="line"><span class="pattern-match">	ktime<span class="constructor">_t</span> base, <span class="operator">*</span>offset = offsets[offs];</span></span><br><span class="line"><span class="pattern-match">	s64 nsecs;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="constructor">WARN_ON(<span class="params">timekeeping_suspended</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="pattern-match">		seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">		<span class="operator">/</span><span class="operator">*</span> (1) monotonic time = tk-&gt;tkr<span class="constructor">_mono</span>.base，</span></span><br><span class="line"><span class="pattern-match">		   offset = timekeeper.offs<span class="constructor">_real</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		base = ktime<span class="constructor">_add(<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>.<span class="params">base</span>, <span class="operator">*</span><span class="params">offset</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">		<span class="operator">/</span><span class="operator">*</span> (2) nsec需要更新最新的值：tk-&gt;tkr<span class="constructor">_mono</span>.xtime<span class="constructor">_nsec</span> + delta</span></span><br><span class="line"><span class="pattern-match">		    delta是距离上一次tick更新的差值 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>monotonic time 的获取；</strong></li>
</ul>
<p>ktime_get()直接获取monotonic time：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime<span class="constructor">_get(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned <span class="built_in">int</span> seq;</span><br><span class="line">	ktime_t base;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	<span class="constructor">WARN_ON(<span class="params">timekeeping_suspended</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span><br><span class="line">		<span class="comment">/* (1) monotonic time = tk-&gt;tkr_mono.base */</span></span><br><span class="line">		base = tk-&gt;tkr_mono.base;</span><br><span class="line">		<span class="comment">/* (2) nsec需要更新最新的值：tk-&gt;tkr_mono.xtime_nsec + delta</span></span><br><span class="line"><span class="comment">		    delta是距离上一次tick更新的差值 */</span></span><br><span class="line">		nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>)</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">	return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ktime_get_ts64()通过xtime加上差值tk-&gt;wall_to_monotonic的方法来获取monotonic time：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ktime_get_ts64(<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> *ts)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> tomono;</span><br><span class="line">	s64 nsec;</span><br><span class="line">	unsigned int seq;</span><br><span class="line"></span><br><span class="line">	WARN_ON(timekeeping_suspended);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">		<span class="comment">/* (1) 获取xtime */</span></span><br><span class="line">		ts-&gt;tv_sec = tk-&gt;xtime_sec;</span><br><span class="line">		nsec = timekeeping_get_ns(&amp;tk-&gt;tkr_mono);</span><br><span class="line">		<span class="comment">/* (2) 加上xtime和monotonic之间的差值tk-&gt;wall_to_monotonic */</span></span><br><span class="line">		tomono = tk-&gt;wall_to_monotonic;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;tk_core.seq, seq));</span><br><span class="line"></span><br><span class="line">	ts-&gt;tv_sec += tomono.tv_sec;</span><br><span class="line">	ts-&gt;tv_nsec = <span class="number">0</span>;</span><br><span class="line">	timespec64_add_ns(ts, nsec + tomono.tv_nsec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>raw monotonic time 的获取；</strong></li>
</ul>
<p>ktime_get_raw()通过tk-&gt;tkr_raw.base获取raw monotonic time：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ktime_t ktime<span class="constructor">_get_raw(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned <span class="built_in">int</span> seq;</span><br><span class="line">	ktime_t base;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span><br><span class="line">		<span class="comment">/* (1) raw monotonic time = tk-&gt;tkr_raw.base */</span></span><br><span class="line">		base = tk-&gt;tkr_raw.base;</span><br><span class="line">		<span class="comment">/* (2) nsec需要更新最新的值：tk-&gt;tkr_raw.xtime_nsec + delta</span></span><br><span class="line"><span class="comment">		    delta是距离上一次tick更新的差值 */</span></span><br><span class="line">		nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_raw</span>)</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">	return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getrawmonotonic64()通过tk-&gt;raw_time获取raw monotonic time：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void getrawmonotonic64(<span class="keyword">struct</span> timespec64 *ts)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> timekeeper *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	<span class="keyword">struct</span> timespec64 ts64;</span><br><span class="line">	unsigned long seq;</span><br><span class="line">	s64 nsecs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span><br><span class="line">		nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_raw</span>)</span>;</span><br><span class="line">		ts64 = tk-&gt;raw_time;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">	timespec64<span class="constructor">_add_ns(&amp;<span class="params">ts64</span>, <span class="params">nsecs</span>)</span>;</span><br><span class="line">	*ts = ts64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>boot time 的获取；</strong></li>
</ul>
<p>ktime_get_boottime()使用monotonic time再加上差值timekeeper.offs_boot的方法来获取boot time：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline ktime_t ktime<span class="constructor">_get_boottime(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	return ktime<span class="constructor">_get_with_offset(TK_OFFS_BOOT)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static ktime<span class="constructor">_t</span> <span class="operator">*</span>offsets[<span class="constructor">TK_OFFS_MAX</span>] = &#123;</span></span><br><span class="line"><span class="pattern-match">	[<span class="constructor">TK_OFFS_REAL</span>]	= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_real</span>,</span></span><br><span class="line"><span class="pattern-match">	[<span class="constructor">TK_OFFS_BOOT</span>]	= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_boot</span>,</span></span><br><span class="line"><span class="pattern-match">	[<span class="constructor">TK_OFFS_TAI</span>]	= &amp;tk<span class="constructor">_core</span>.timekeeper.offs<span class="constructor">_tai</span>,</span></span><br><span class="line"><span class="pattern-match">&#125;;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">ktime<span class="constructor">_t</span> ktime<span class="constructor">_get_with_offset(<span class="params">enum</span> <span class="params">tk_offsets</span> <span class="params">offs</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">struct</span> timekeeper <span class="operator">*</span>tk = &amp;tk<span class="constructor">_core</span>.timekeeper;</span></span><br><span class="line"><span class="pattern-match">	unsigned <span class="built_in">int</span> seq;</span></span><br><span class="line"><span class="pattern-match">	ktime<span class="constructor">_t</span> base, <span class="operator">*</span>offset = offsets[offs];</span></span><br><span class="line"><span class="pattern-match">	s64 nsecs;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="constructor">WARN_ON(<span class="params">timekeeping_suspended</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="pattern-match">		seq = read<span class="constructor">_seqcount_begin(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">		<span class="operator">/</span><span class="operator">*</span> (1) monotonic time = tk-&gt;tkr<span class="constructor">_mono</span>.base，</span></span><br><span class="line"><span class="pattern-match">		   offset = timekeeper.offs<span class="constructor">_boot</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		base = ktime<span class="constructor">_add(<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>.<span class="params">base</span>, <span class="operator">*</span><span class="params">offset</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">		<span class="operator">/</span><span class="operator">*</span> (2) nsec需要更新最新的值：tk-&gt;tkr<span class="constructor">_mono</span>.xtime<span class="constructor">_nsec</span> + delta</span></span><br><span class="line"><span class="pattern-match">		    delta是距离上一次tick更新的差值 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		nsecs = timekeeping<span class="constructor">_get_ns(&amp;<span class="params">tk</span>-&gt;<span class="params">tkr_mono</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	&#125; <span class="keyword">while</span> (read<span class="constructor">_seqcount_retry(&amp;<span class="params">tk_core</span>.<span class="params">seq</span>, <span class="params">seq</span>)</span>);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	return ktime<span class="constructor">_add_ns(<span class="params">base</span>, <span class="params">nsecs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-5、timekeeper-suspend"><a href="#2-2-5、timekeeper-suspend" class="headerlink" title="2.2.5、timekeeper suspend"></a>2.2.5、timekeeper suspend</h4><p>系统在进入suspend以后，clocksource不会再工作，这部分时间会计入xtime和boot time，但是不会计入monotonic time。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timekeeping_resume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> = &amp;<span class="title">tk_core</span>.<span class="title">timekeeper</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span> *<span class="title">clock</span> = <span class="title">tk</span>-&gt;<span class="title">tkr_mono</span>.<span class="title">clock</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts_new</span>, <span class="title">ts_delta</span>;</span></span><br><span class="line">	<span class="keyword">cycle_t</span> cycle_now, cycle_delta;</span><br><span class="line"></span><br><span class="line">	sleeptime_injected = <span class="literal">false</span>;</span><br><span class="line">	read_persistent_clock64(&amp;ts_new);</span><br><span class="line"></span><br><span class="line">	clockevents_resume();</span><br><span class="line">	clocksource_resume();</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * After system resumes, we need to calculate the suspended time and</span></span><br><span class="line"><span class="comment">	 * compensate it for the OS time. There are 3 sources that could be</span></span><br><span class="line"><span class="comment">	 * used: Nonstop clocksource during suspend, persistent clock and rtc</span></span><br><span class="line"><span class="comment">	 * device.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * One specific platform may have 1 or 2 or all of them, and the</span></span><br><span class="line"><span class="comment">	 * preference will be:</span></span><br><span class="line"><span class="comment">	 *	suspend-nonstop clocksource -&gt; persistent clock -&gt; rtc</span></span><br><span class="line"><span class="comment">	 * The less preferred source will only be tried if there is no better</span></span><br><span class="line"><span class="comment">	 * usable source. The rtc part is handled separately in rtc core code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cycle_now = tk-&gt;tkr_mono.<span class="built_in">read</span>(clock);</span><br><span class="line">	<span class="keyword">if</span> ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;</span><br><span class="line">		cycle_now &gt; tk-&gt;tkr_mono.cycle_last) &#123;</span><br><span class="line">		u64 num, <span class="built_in">max</span> = ULLONG_MAX;</span><br><span class="line">		u32 mult = clock-&gt;mult;</span><br><span class="line">		u32 shift = clock-&gt;shift;</span><br><span class="line">		s64 nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		cycle_delta = clocksource_delta(cycle_now, tk-&gt;tkr_mono.cycle_last,</span><br><span class="line">						tk-&gt;tkr_mono.mask);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * "cycle_delta * mutl" may cause 64 bits overflow, if the</span></span><br><span class="line"><span class="comment">		 * suspended time is too long. In that case we need do the</span></span><br><span class="line"><span class="comment">		 * 64 bits math carefully</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		do_div(<span class="built_in">max</span>, mult);</span><br><span class="line">		<span class="keyword">if</span> (cycle_delta &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">			num = div64_u64(cycle_delta, <span class="built_in">max</span>);</span><br><span class="line">			nsec = (((u64) <span class="built_in">max</span> * mult) &gt;&gt; shift) * num;</span><br><span class="line">			cycle_delta -= num * <span class="built_in">max</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nsec += ((u64) cycle_delta * mult) &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">		ts_delta = ns_to_timespec64(nsec);</span><br><span class="line">		sleeptime_injected = <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timespec64_compare(&amp;ts_new, &amp;timekeeping_suspend_time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);</span><br><span class="line">		sleeptime_injected = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sleeptime_injected)</span><br><span class="line">		__timekeeping_inject_sleeptime(tk, &amp;ts_delta);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Re-base the last cycle value */</span></span><br><span class="line">	tk-&gt;tkr_mono.cycle_last = cycle_now;</span><br><span class="line">	tk-&gt;tkr_raw.cycle_last  = cycle_now;</span><br><span class="line"></span><br><span class="line">	tk-&gt;ntp_error = <span class="number">0</span>;</span><br><span class="line">	timekeeping_suspended = <span class="number">0</span>;</span><br><span class="line">	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	touch_softlockup_watchdog();</span><br><span class="line"></span><br><span class="line">	tick_resume();</span><br><span class="line">	hrtimers_resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timekeeping_suspend</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> = &amp;<span class="title">tk_core</span>.<span class="title">timekeeper</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>		<span class="title">delta</span>, <span class="title">delta_delta</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">old_delta</span>;</span></span><br><span class="line"></span><br><span class="line">	read_persistent_clock64(&amp;timekeeping_suspend_time);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On some systems the persistent_clock can not be detected at</span></span><br><span class="line"><span class="comment">	 * timekeeping_init by its return value, so if we see a valid</span></span><br><span class="line"><span class="comment">	 * value returned, update the persistent_clock_exists flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)</span><br><span class="line">		persistent_clock_exists = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line">	timekeeping_suspended = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (persistent_clock_exists) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * To avoid drift caused by repeated suspend/resumes,</span></span><br><span class="line"><span class="comment">		 * which each can add ~1 second drift error,</span></span><br><span class="line"><span class="comment">		 * try to compensate so the difference in system time</span></span><br><span class="line"><span class="comment">		 * and persistent_clock time stays close to constant.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		delta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);</span><br><span class="line">		delta_delta = timespec64_sub(delta, old_delta);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(delta_delta.tv_sec) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * if delta_delta is too large, assume time correction</span></span><br><span class="line"><span class="comment">			 * has occurred and set old_delta to the current delta.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			old_delta = delta;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Otherwise try to adjust old_system to compensate */</span></span><br><span class="line">			timekeeping_suspend_time =</span><br><span class="line">				timespec64_add(timekeeping_suspend_time, delta_delta);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_MIRROR);</span><br><span class="line">	halt_fast_timekeeper(tk);</span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	tick_suspend();</span><br><span class="line">	clocksource_suspend();</span><br><span class="line">	clockevents_suspend();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sysfs resume/suspend bits for timekeeping */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">syscore_ops</span> <span class="title">timekeeping_syscore_ops</span> = &#123;</span></span><br><span class="line">	.resume		= timekeeping_resume,</span><br><span class="line">	.suspend	= timekeeping_suspend,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和初始化一样的原因，理论上timekeeper的操作在timekeeping_resume()、timekeeping_suspend()，但是实际上在rtc的操作中执行rtc_suspend()、rtc_resume()。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int rtc_suspend(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span></span>	*rtc = to_rtc_device(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span></span>		tm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span>	delta, delta_delta;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timekeeping_rtc_skipsuspend())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* snapshot the current RTC and system time at suspend*/</span></span><br><span class="line">	<span class="comment">/* (1.1) 读取suspend时候的rtc时间 */</span></span><br><span class="line">	err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_debug(<span class="string">"%s:  fail to read rtc time\n"</span>, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.2) 读取当前xtime */</span></span><br><span class="line">	getnstimeofday64(&amp;old_system);</span><br><span class="line">	old_rtc.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	old_rtc.tv_nsec = tm.tm_cnt*(<span class="number">1000000000</span>/<span class="number">32768</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To avoid drift caused by repeated suspend/resumes,</span></span><br><span class="line"><span class="comment">	 * which each can add ~1 second drift error,</span></span><br><span class="line"><span class="comment">	 * try to compensate so the difference in system time</span></span><br><span class="line"><span class="comment">	 * and rtc time stays close to constant.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (1.3) 如果rtc时间和xtime有偏差，尝试纠正xtime */</span></span><br><span class="line">	delta = timespec64_sub(old_system, old_rtc);</span><br><span class="line">	delta_delta = timespec64_sub(delta, old_delta);</span><br><span class="line">	<span class="keyword">if</span> (delta_delta.tv_sec &lt; -<span class="number">2</span> || delta_delta.tv_sec &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * if delta_delta is too large, assume time correction</span></span><br><span class="line"><span class="comment">		 * has occured and set old_delta to the current delta.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		old_delta = delta;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Otherwise try to adjust old_system to compensate */</span></span><br><span class="line">		old_system = timespec64_sub(old_system, delta_delta);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int rtc_resume(<span class="class"><span class="keyword">struct</span> <span class="title">device</span></span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span></span>	*rtc = to_rtc_device(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span></span>		tm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span>	new_system, new_rtc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span>	sleep_time;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timekeeping_rtc_skipresume())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rtc_hctosys_ret = -ENODEV;</span><br><span class="line">	<span class="keyword">if</span> (strcmp(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* snapshot the current rtc and system time at resume */</span></span><br><span class="line">	<span class="comment">/* (2.1) 读取resume后的rtc时间和xtime */</span></span><br><span class="line">	getnstimeofday64(&amp;new_system);</span><br><span class="line">	err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_debug(<span class="string">"%s:  fail to read rtc time\n"</span>, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_rtc.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line">	new_rtc.tv_nsec = tm.tm_cnt*(<span class="number">1000000000</span>/<span class="number">32768</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_rtc.tv_sec &lt; old_rtc.tv_sec) &#123;</span><br><span class="line">		pr_debug(<span class="string">"%s:  time travel!\n"</span>, dev_name(&amp;rtc-&gt;dev));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* calculate the RTC time delta (sleep time)*/</span></span><br><span class="line">	<span class="comment">/* (2.2) 计算suspend和resume之间rtc的差值 */</span></span><br><span class="line">	sleep_time = timespec64_sub(new_rtc, old_rtc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since these RTC suspend/resume handlers are not called</span></span><br><span class="line"><span class="comment">	 * at the very end of suspend or the start of resume,</span></span><br><span class="line"><span class="comment">	 * some run-time may pass on either sides of the sleep time</span></span><br><span class="line"><span class="comment">	 * so subtract kernel run-time between rtc_suspend to rtc_resume</span></span><br><span class="line"><span class="comment">	 * to keep things accurate.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (2.3) 使用上一步的差值，再减去，suspend和resume之间xtime的差值</span></span><br><span class="line"><span class="comment">	        得到实际的sleep时间*/</span></span><br><span class="line">	sleep_time = timespec64_sub(sleep_time,</span><br><span class="line">			timespec64_sub(new_system, old_system));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sleep_time.tv_sec &gt;= <span class="number">0</span>)</span><br><span class="line">	    <span class="comment">/* (2.4) 将计算得到的sleep时间，加入到timekeeper中 */</span></span><br><span class="line">		timekeeping_inject_sleeptime64(&amp;sleep_time);</span><br><span class="line">	rtc_hctosys_ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void timekeeping_inject_sleeptime64(<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> *delta)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk = &amp;tk_core.timekeeper;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line"></span><br><span class="line">	timekeeping_forward_now(tk);</span><br><span class="line"></span><br><span class="line">	__timekeeping_inject_sleeptime(tk, delta);</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* signal hrtimers about time change */</span></span><br><span class="line">	clock_was_set();</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line"><span class="keyword">static</span> void __timekeeping_inject_sleeptime(<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span></span> *tk,</span><br><span class="line">					   <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span></span> *delta)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!timespec64_valid_strict(delta)) &#123;</span><br><span class="line">		printk_deferred(KERN_WARNING</span><br><span class="line">				<span class="string">"__timekeeping_inject_sleeptime: Invalid "</span></span><br><span class="line">				<span class="string">"sleep delta value!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* (2.4.1) 更新xtime */</span></span><br><span class="line">	tk_xtime_add(tk, delta);</span><br><span class="line">	<span class="comment">/* (2.4.2) 更新tk-&gt;wall_to_monotonic、tk-&gt;offs_real */</span></span><br><span class="line">	tk_set_wall_to_mono(tk, timespec64_sub(tk-&gt;wall_to_monotonic, *delta));</span><br><span class="line">	<span class="comment">/* (2.4.3) 更新tk-&gt;offs_boot */</span></span><br><span class="line">	tk_update_sleep_time(tk, timespec64_to_ktime(*delta));</span><br><span class="line">	tk_debug_account_sleep_time(delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、clock-event"><a href="#3、clock-event" class="headerlink" title="3、clock_event"></a>3、clock_event</h2><p><img src="clockevent.png" alt="image"></p>
<p>clock_event其实就是对local timer的使用，每个cpu对应一个本地local timer。global timer启动后不需要主动做任何事情，只需要等待timekepper的读取就可以了。而local timer需要触发中断，它的主要价值就体现在定时中断处理了，中断的时间可以是固定的(period mode)也或者是不固定的(oneshot mode)。</p>
<h3 id="3-1、clock-event的注册"><a href="#3-1、clock-event的注册" class="headerlink" title="3.1、clock_event的注册"></a>3.1、clock_event的注册</h3><h4 id="3-1-1、exynos-clock-event的注册"><a href="#3-1-1、exynos-clock-event的注册" class="headerlink" title="3.1.1、exynos clock_event的注册"></a>3.1.1、exynos clock_event的注册</h4><p>exynos clock_event的注册分为两部分：</p>
<ul>
<li>第一部分：localtimer中断的注册：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">exynos4_timer_resources</span><span class="params">(struct device_node *np, <span class="keyword">void</span> __iomem *base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err, cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mct_clock_event_device</span> *<span class="title">mevt</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">percpu_mct_tick</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">mct_clk</span>, *<span class="title">tick_clk</span>;</span></span><br><span class="line"></span><br><span class="line">	tick_clk = np ? of_clk_get_by_name(np, <span class="string">"fin_pll"</span>) :</span><br><span class="line">				clk_get(<span class="literal">NULL</span>, <span class="string">"fin_pll"</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tick_clk))</span><br><span class="line">		panic(<span class="string">"%s: unable to determine tick clock rate\n"</span>, __func__);</span><br><span class="line">	clk_rate = clk_get_rate(tick_clk);</span><br><span class="line"></span><br><span class="line">	mct_clk = np ? of_clk_get_by_name(np, <span class="string">"mct"</span>) : clk_get(<span class="literal">NULL</span>, <span class="string">"mct"</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(mct_clk))</span><br><span class="line">		panic(<span class="string">"%s: unable to retrieve mct clock instance\n"</span>, __func__);</span><br><span class="line">	clk_prepare_enable(mct_clk);</span><br><span class="line"></span><br><span class="line">	reg_base = base;</span><br><span class="line">	<span class="keyword">if</span> (!reg_base)</span><br><span class="line">		panic(<span class="string">"%s: unable to ioremap mct address space\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mct_int_type == MCT_INT_PPI) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) 大部分的localtimer是PPI模式，</span></span><br><span class="line"><span class="comment">            注册中断处理函数：exynos4_mct_tick_isr() */</span></span><br><span class="line">		err = request_percpu_irq(mct_irqs[MCT_L0_IRQ],</span><br><span class="line">					 exynos4_mct_tick_isr, <span class="string">"MCT"</span>,</span><br><span class="line">					 &amp;percpu_mct_tick);</span><br><span class="line">		WARN(err, <span class="string">"MCT: can't request IRQ %d (%d)\n"</span>,</span><br><span class="line">		     mct_irqs[MCT_L0_IRQ], err);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="keyword">int</span> mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">mct_clock_event_device</span> *<span class="title">pcpu_mevt</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu_ptr</span>(&amp;<span class="title">percpu_mct_tick</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">			pcpu_mevt-&gt;evt.irq = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span><br><span class="line">			<span class="keyword">if</span> (request_irq(mct_irq,</span><br><span class="line">					exynos4_mct_tick_isr,</span><br><span class="line">					IRQF_TIMER | IRQF_NOBALANCING,</span><br><span class="line">					pcpu_mevt-&gt;name, pcpu_mevt)) &#123;</span><br><span class="line">				pr_err(<span class="string">"exynos-mct: cannot register IRQ (cpu%d)\n"</span>,</span><br><span class="line">									cpu);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pcpu_mevt-&gt;evt.irq = mct_irq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 注册cpu hotplug的notifier，</span></span><br><span class="line"><span class="comment">        在其他cpu up时调用exynos4_local_timer_setup()注册clock_event */</span></span><br><span class="line">	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Immediately configure the timer on the boot CPU */</span></span><br><span class="line">	<span class="comment">/* (3) 注册本cpu的clock_event */</span></span><br><span class="line">	exynos4_local_timer_setup(mevt);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">out_irq:</span><br><span class="line">	free_percpu_irq(mct_irqs[MCT_L0_IRQ], &amp;percpu_mct_tick);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">exynos4_mct_tick_isr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mct_clock_event_device</span> *<span class="title">mevt</span> = <span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">evt</span> = &amp;<span class="title">mevt</span>-&gt;<span class="title">evt</span>;</span></span><br><span class="line"></span><br><span class="line">	exynos4_mct_tick_clear(mevt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (4) localtimer中断处理函数是固定的也是非常简单的，</span></span><br><span class="line"><span class="comment">        调用本cpu clock_event_device的handler函数：evt-&gt;event_handler(evt) */</span></span><br><span class="line">	evt-&gt;event_handler(evt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二部分：clock_event_device注册：</li>
</ul>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int exynos4_local_timer_setup(struct mct_clock_event_device *mevt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">struct</span> clock_event_device *evt = &amp;mevt-&gt;</span>evt;</span><br><span class="line">	unsigned int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">mevt</span>-&gt;</span>base = EXYNOS4_MCT_L_BASE(cpu);</span><br><span class="line">	<span class="function"><span class="title">snprintf</span>(mevt-&gt;</span><span class="function"><span class="title">name</span>, sizeof(mevt-&gt;</span><span class="keyword">name</span>), <span class="string">"mct_tick%d"</span>, cpu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 初始化clock_event_device */</span></span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span><span class="function"><span class="title">name</span> = mevt-&gt;</span><span class="keyword">name</span>;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>cpumask = cpumask_of(cpu);         <span class="comment">// 本clock_event_device只服务于一个cpu</span></span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>set_next_event = exynos4_tick_set_next_event;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>set_state_periodic = set_state_periodic;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>set_state_shutdown = set_state_shutdown;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>set_state_oneshot = set_state_shutdown;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>tick_resume = set_state_shutdown;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;</span><br><span class="line">	<span class="function"><span class="title">evt</span>-&gt;</span>rating = <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">exynos4_mct_write</span>(TICK_BASE_CNT, mevt-&gt;</span>base + MCT_L_TCNTB_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mct_int_type == MCT_INT_SPI) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">if</span> (evt-&gt;</span>irq == -<span class="number">1</span>)</span><br><span class="line">			return -EIO;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">irq_force_affinity</span>(evt-&gt;</span>irq, cpumask_of(cpu));</span><br><span class="line">		<span class="function"><span class="title">enable_irq</span>(evt-&gt;</span>irq);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* (2) 配置并注册clockevent */</span></span><br><span class="line">	clockevents_config_and_register(evt, clk_rate / (TICK_BASE_CNT + <span class="number">1</span>),</span><br><span class="line">					<span class="number">0</span>xf, <span class="number">0</span>x7fffffff);</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2、clock-event-device的注册"><a href="#3-1-2、clock-event-device的注册" class="headerlink" title="3.1.2、clock_event_device的注册"></a>3.1.2、clock_event_device的注册</h4><p>我们来分析一下clock_event_device的注册过程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">void clockevents_config_and_register(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *dev,</span><br><span class="line">				     <span class="built_in">u32</span> freq, unsigned long min_delta,</span><br><span class="line">				     unsigned long max_delta)</span><br><span class="line">&#123;</span><br><span class="line">	dev-&gt;min_delta_ticks = min_delta;   <span class="comment">// localtimer可配置的最小定时值</span></span><br><span class="line">	dev-&gt;max_delta_ticks = max_delta;   <span class="comment">// localtimer可配置的最大定时值，</span></span><br><span class="line">	                                    <span class="comment">// 比如exynos是31bit的localtimer，最大值就是0x7fffffff</span></span><br><span class="line">	<span class="comment">/* (1) 根据localtimer的freq，计算clock_event_device对应的mult、shift，</span></span><br><span class="line"><span class="comment">	    mult、shift的作用是用来做ns到localtimer cycle之间的转换，</span></span><br><span class="line"><span class="comment">	    与之相反的是，在clocksource中mult、shift用来转换localtimer cycle到ns */</span></span><br><span class="line">	clockevents_config(dev, freq);</span><br><span class="line">	<span class="comment">/* (2) 继续注册clock_event_device */</span></span><br><span class="line">	clockevents_register_device(dev);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_config(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *dev, <span class="built_in">u32</span> freq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">u64</span> sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1) 如果不支持oneshot模式，只是period模式，</span></span><br><span class="line"><span class="comment">        定时周期是固定的，不需要动态计算ns到cycle的转换 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Calculate the maximum number of seconds we can sleep. Limit</span></span><br><span class="line"><span class="comment">	 * to 10 minutes for hardware which can program more than</span></span><br><span class="line"><span class="comment">	 * 32bit ticks so we still get reasonable conversion values.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sec = dev-&gt;max_delta_ticks;</span><br><span class="line">	do_div(sec, freq);</span><br><span class="line">	<span class="keyword">if</span> (!sec)</span><br><span class="line">		sec = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sec &gt; <span class="number">600</span> &amp;&amp; dev-&gt;max_delta_ticks &gt; UINT_MAX)</span><br><span class="line">		sec = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.2) 根据localtimer的freq，计算clock_event_device对应的mult、shift */</span></span><br><span class="line">	clockevents_calc_mult_shift(dev, freq, sec);</span><br><span class="line">	<span class="comment">/* (1.3) 转换min、max的cycle到ns */</span></span><br><span class="line">	dev-&gt;min_delta_ns = cev_delta2ns(dev-&gt;min_delta_ticks, dev, <span class="literal">false</span>);</span><br><span class="line">	dev-&gt;max_delta_ns = cev_delta2ns(dev-&gt;max_delta_ticks, dev, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">void clockevents_register_device(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize state to DETACHED */</span></span><br><span class="line">	clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;cpumask) &#123;</span><br><span class="line">		WARN_ON(num_possible_cpus() &gt; <span class="number">1</span>);</span><br><span class="line">		dev-&gt;cpumask = cpumask_of(smp_processor_id());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;clockevents_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1) 将clock_event_device加入到全局链表clockevent_devices中 */</span></span><br><span class="line">	list_add(&amp;dev-&gt;list, &amp;clockevent_devices);</span><br><span class="line">	<span class="comment">/* (2.2) 继续尝试向本cpu的tick_device中注册clock_event_device */</span></span><br><span class="line">	tick_check_new_device(dev);</span><br><span class="line">	clockevents_notify_released();</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">void tick_check_new_device(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *newdev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *curdev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span></span> *td;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	td = &amp;per_cpu(tick_cpu_device, cpu);</span><br><span class="line">	curdev = td-&gt;evtdev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cpu local device ? */</span></span><br><span class="line">	<span class="comment">/* (2.2.1) 新的clock_event_device是否支持本cpu？  */</span></span><br><span class="line">	<span class="keyword">if</span> (!tick_check_percpu(curdev, newdev, cpu))</span><br><span class="line">		goto out_bc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Preference decision */</span></span><br><span class="line">	<span class="comment">/* (2.2.2) 新的clock_event_device是否比当前clock_event_device更适合？</span></span><br><span class="line"><span class="comment">	   1.如果curdev已经是oneshot模式，而newdev不支持oneshot，则切换</span></span><br><span class="line"><span class="comment">	   2.newdev的精度要大于curdev，精度 = dev-&gt;rating */</span></span><br><span class="line">	<span class="keyword">if</span> (!tick_check_preferred(curdev, newdev))</span><br><span class="line">		goto out_bc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(newdev-&gt;owner))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Replace the eventually existing device by the new</span></span><br><span class="line"><span class="comment">	 * device. If the current device is the broadcast device, do</span></span><br><span class="line"><span class="comment">	 * not give it back to the clockevents layer !</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (tick_is_broadcast_device(curdev)) &#123;</span><br><span class="line">		clockevents_shutdown(curdev);</span><br><span class="line">		curdev = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* (2.2.3) 关闭curdev、newdev */</span></span><br><span class="line">	clockevents_exchange_device(curdev, newdev);</span><br><span class="line">	<span class="comment">/* (2.2.4) 继续clock_event_device注册 */</span></span><br><span class="line">	tick_setup_device(td, newdev, cpu, cpumask_of(cpu));</span><br><span class="line">	<span class="keyword">if</span> (newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)</span><br><span class="line">		tick_oneshot_notify();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">out_bc:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Can the new device be used as a broadcast device ?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (2.2.5) 如果newdev不适合注册成本cpu的td-&gt;evtdev,</span></span><br><span class="line"><span class="comment">	    尝试将其注册成broadcast clockevent */</span></span><br><span class="line">	tick_install_broadcast_device(newdev);</span><br><span class="line">&#125;</span><br><span class="line">|||→</span><br><span class="line"><span class="keyword">static</span> void tick_setup_device(<span class="class"><span class="keyword">struct</span> <span class="title">tick_device</span></span> *td,</span><br><span class="line">			      <span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *newdev, int cpu,</span><br><span class="line">			      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span></span> *cpumask)</span><br><span class="line">&#123;</span><br><span class="line">	ktime_t next_event;</span><br><span class="line">	void (*handler)(<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span></span> *) = NULL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * First device setup ?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!td-&gt;evtdev) &#123;</span><br><span class="line">	    <span class="comment">/* (2.2.4.1) 如果是tick_do_timer_cpu没有被设置，且没有使能tick_nohz_full_cpu</span></span><br><span class="line"><span class="comment">	        把tick_do_timer_cpu设置成本cpu，</span></span><br><span class="line"><span class="comment">	        tick_do_timer_cpu负责在tick中update jiffies、update_wall_time  */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If no cpu took the do_timer update, assign it to</span></span><br><span class="line"><span class="comment">		 * this cpu:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!tick_nohz_full_cpu(cpu))</span><br><span class="line">				tick_do_timer_cpu = cpu;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				tick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class="line">			tick_next_period = ktime_get();</span><br><span class="line">			tick_period = ktime_set(<span class="number">0</span>, NSEC_PER_SEC / HZ);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Startup in periodic mode first.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* (2.2.4.2) 如果tick_device是第一次设置clock_event_device,</span></span><br><span class="line"><span class="comment">		    把tick_device设置成period模式 */</span></span><br><span class="line">		td-&gt;mode = TICKDEV_MODE_PERIODIC;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">/* (2.2.4.3) 如果tick_device不是第一次设置clock_event_device,</span></span><br><span class="line"><span class="comment">		    备份原clock_event_deviced的event_handler和next_event */</span></span><br><span class="line">		handler = td-&gt;evtdev-&gt;event_handler;</span><br><span class="line">		next_event = td-&gt;evtdev-&gt;next_event;</span><br><span class="line">		td-&gt;evtdev-&gt;event_handler = clockevents_handle_noop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.4.4) 更新tick_device-&gt;evtdev到new clock_event_deviced  */</span></span><br><span class="line">	td-&gt;evtdev = newdev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When the device is not per cpu, pin the interrupt to the</span></span><br><span class="line"><span class="comment">	 * current cpu:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_equal(newdev-&gt;cpumask, cpumask))</span><br><span class="line">		irq_set_affinity(newdev-&gt;irq, cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When global broadcasting is active, check if the current</span></span><br><span class="line"><span class="comment">	 * device is registered as a placeholder for broadcast mode.</span></span><br><span class="line"><span class="comment">	 * This allows us to handle this x86 misfeature in a generic</span></span><br><span class="line"><span class="comment">	 * way. This function also returns !=0 when we keep the</span></span><br><span class="line"><span class="comment">	 * current active broadcast state for this CPU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (2.2.4.5) 如果全局的brodcast clockevent服务已经启动，</span></span><br><span class="line"><span class="comment">	    本cpu的clockevent注册需要向brodcas服务，</span></span><br><span class="line"><span class="comment">	    这是为了解决x86的一个失误(misfeature)，其他架构不需要？ */</span></span><br><span class="line">	<span class="keyword">if</span> (tick_device_uses_broadcast(newdev, cpu))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.2.4.6) 根据td-&gt;mode安装clock_event_deviced的event_handler,并启动 */</span></span><br><span class="line">	<span class="keyword">if</span> (td-&gt;mode == TICKDEV_MODE_PERIODIC)</span><br><span class="line">	    <span class="comment">/* (2.2.4.7) period模式 */</span></span><br><span class="line">		tick_setup_periodic(newdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="comment">/* (2.2.4.8) oneshot模式 */</span></span><br><span class="line">		tick_setup_oneshot(newdev, handler, next_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2、tick-device的period-mode"><a href="#3-2、tick-device的period-mode" class="headerlink" title="3.2、tick_device的period mode"></a>3.2、tick_device的period mode</h3><p>接上节，在cpu第一次注册clock_event_deviced的时候，td-&gt;mode默认被设置成period模式。event_handler会被初始化成tick_handle_periodic：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void tick<span class="constructor">_setup_periodic(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">int</span> <span class="params">broadcast</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* (1) 设置period模式下的event_handler */</span></span><br><span class="line">	tick<span class="constructor">_set_periodic_handler(<span class="params">dev</span>, <span class="params">broadcast</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Broadcast setup ? */</span></span><br><span class="line">	<span class="keyword">if</span> (!tick<span class="constructor">_device_is_functional(<span class="params">dev</span>)</span>)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 如果dev支持period模式，则硬件上启动period模式:</span></span><br><span class="line"><span class="comment">        tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span></span><br><span class="line"><span class="comment">        clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_PERIODIC */</span></span><br><span class="line">	<span class="keyword">if</span> ((dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC) &amp;&amp;</span><br><span class="line">	    !tick<span class="constructor">_broadcast_oneshot_active()</span>) &#123;</span><br><span class="line">		clockevents<span class="constructor">_switch_state(<span class="params">dev</span>, CLOCK_EVT_STATE_PERIODIC)</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		unsigned long seq;</span><br><span class="line">		ktime_t next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			seq = read<span class="constructor">_seqbegin(&amp;<span class="params">jiffies_lock</span>)</span>;</span><br><span class="line">			next = tick_next_period;</span><br><span class="line">		&#125; <span class="keyword">while</span> (read<span class="constructor">_seqretry(&amp;<span class="params">jiffies_lock</span>, <span class="params">seq</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (3) 如果dev不支持period模式只支持oneshot模式，则硬件上启动one shot模式，</span></span><br><span class="line"><span class="comment">            使用oneshot模式来模拟period模式：</span></span><br><span class="line"><span class="comment">            tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span></span><br><span class="line"><span class="comment">            clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_ONESHOT */</span></span><br><span class="line">		clockevents<span class="constructor">_switch_state(<span class="params">dev</span>, CLOCK_EVT_STATE_ONESHOT)</span>;</span><br><span class="line"></span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!clockevents<span class="constructor">_program_event(<span class="params">dev</span>, <span class="params">next</span>, <span class="params">false</span>)</span>)</span><br><span class="line">				return;</span><br><span class="line">			next = ktime<span class="constructor">_add(<span class="params">next</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">void tick<span class="constructor">_set_periodic_handler(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>, <span class="params">int</span> <span class="params">broadcast</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">if</span> (!broadcast)</span></span><br><span class="line"><span class="pattern-match">	    <span class="operator">/</span><span class="operator">*</span> (1.1) 设置period模式下的event<span class="constructor">_handler</span> <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		dev-&gt;event<span class="constructor">_handler</span> = tick<span class="constructor">_handle_periodic</span>;</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">		dev-&gt;event<span class="constructor">_handler</span> = tick<span class="constructor">_handle_periodic_broadcast</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>仔细分析一下tick_handle_periodic：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void tick<span class="constructor">_handle_periodic(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> cpu = smp<span class="constructor">_processor_id()</span>;</span><br><span class="line">	ktime_t next = dev-&gt;next_event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 周期性的tick任务 */</span></span><br><span class="line">	tick<span class="constructor">_periodic(<span class="params">cpu</span>)</span>;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_HIGH_RES_TIMERS)<span class="operator"> || </span>defined(CONFIG_NO_HZ_COMMON)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The cpu might have transitioned to HIGHRES or NOHZ mode via</span></span><br><span class="line"><span class="comment">	 * update_process_times() -&gt; run_local_timers() -&gt;</span></span><br><span class="line"><span class="comment">	 * hrtimer_run_queues().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;event_handler != tick_handle_periodic)</span><br><span class="line">		return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!clockevent<span class="constructor">_state_oneshot(<span class="params">dev</span>)</span>)</span><br><span class="line">		return;</span><br><span class="line">	<span class="comment">/* (2) 如果tick_device是period mode，而clockevent是oneshot模式,</span></span><br><span class="line"><span class="comment">	    编程oneshot模式clockevent在下一周期触发：</span></span><br><span class="line"><span class="comment">        tick_device-&gt;mode = TICKDEV_MODE_PERIODIC</span></span><br><span class="line"><span class="comment">        clock_event_device-&gt;state_use_accessors = CLOCK_EVT_STATE_ONESHOT */</span></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setup the next period for devices, which do not have</span></span><br><span class="line"><span class="comment">		 * periodic mode:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		next = ktime<span class="constructor">_add(<span class="params">next</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!clockevents<span class="constructor">_program_event(<span class="params">dev</span>, <span class="params">next</span>, <span class="params">false</span>)</span>)</span><br><span class="line">			return;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Have to be careful here. If we're in oneshot mode,</span></span><br><span class="line"><span class="comment">		 * before we call tick_periodic() in a loop, we need</span></span><br><span class="line"><span class="comment">		 * to be sure we're using a real hardware clocksource.</span></span><br><span class="line"><span class="comment">		 * Otherwise we could get trapped in an infinite</span></span><br><span class="line"><span class="comment">		 * loop, as the tick_periodic() increments jiffies,</span></span><br><span class="line"><span class="comment">		 * which then will increment time, possibly causing</span></span><br><span class="line"><span class="comment">		 * the loop to trigger again and again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (timekeeping<span class="constructor">_valid_for_hres()</span>)</span><br><span class="line">			tick<span class="constructor">_periodic(<span class="params">cpu</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static void tick<span class="constructor">_periodic(<span class="params">int</span> <span class="params">cpu</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.1) 如果本cpu是tick<span class="constructor">_do_timer_cpu</span>，更新全局时间戳类型的任务，</span></span><br><span class="line"><span class="pattern-match">	        包括update jiffies、update<span class="constructor">_wall_time</span>  <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">if</span> (tick<span class="constructor">_do_timer_cpu</span> <span class="operator">==</span> cpu) &#123;</span></span><br><span class="line"><span class="pattern-match">		write<span class="constructor">_seqlock(&amp;<span class="params">jiffies_lock</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">		<span class="operator">/</span><span class="operator">*</span> <span class="constructor">Keep</span> track <span class="keyword">of</span> the next tick event <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		tick<span class="constructor">_next_period</span> = ktime<span class="constructor">_add(<span class="params">tick_next_period</span>, <span class="params">tick_period</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">*</span> (1.1.1) 更新jiffies <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		<span class="keyword">do</span><span class="constructor">_timer(1)</span>;</span></span><br><span class="line"><span class="pattern-match">		write<span class="constructor">_sequnlock(&amp;<span class="params">jiffies_lock</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">		<span class="operator">/</span><span class="operator">*</span> (1.1.2) 读取clocksource来更新timekeeper <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">		update<span class="constructor">_wall_time()</span>;</span></span><br><span class="line"><span class="pattern-match">	&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.2) 运行软件timer(run<span class="constructor">_local_timers()</span>)和运行调度tick任务(scheduler<span class="constructor">_tick()</span>) <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	update<span class="constructor">_process_times(<span class="params">user_mode</span>(<span class="params">get_irq_regs</span>()</span>));</span></span><br><span class="line"><span class="pattern-match">	profile<span class="constructor">_tick(CPU_PROFILING)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3、运行Mode"><a href="#3-3、运行Mode" class="headerlink" title="3.3、运行Mode"></a>3.3、运行Mode</h3><p>关于mode，有几个结构涉及到：tick_device、clock_event_device、tick_sched、hrtimer_cpu_base、。组合起来有以下几种情况：</p>
<p><img src="clockevent_mode.png" alt="image"></p>
<p>其实归结起来就3种mode：NOHZ_MODE_INACTIVE、NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。下面来逐个解析一下。</p>
<h4 id="3-3-1、NOHZ-MODE-INACTIVE"><a href="#3-3-1、NOHZ-MODE-INACTIVE" class="headerlink" title="3.3.1、NOHZ_MODE_INACTIVE"></a>3.3.1、NOHZ_MODE_INACTIVE</h4><p>NOHZ_MODE_INACTIVE就是系统初始化时的状态：“td=period模式, dev=period/oneshot模式, hrtimer=low res, noHz=dis”。</p>
<p><img src="clockevent_NOHZ_MODE_INACTIVE.png" alt="image"></p>
<p>NOHZ_MODE_INACTIVE模式：</p>
<ul>
<li>tick_device工作在period模式，HW local timer工作在period/oneshot模式；</li>
<li>noHZ没有使能，进入idle会被tick timer中断打断；</li>
<li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li>
</ul>
<h4 id="3-3-2、NOHZ-MODE-LOWRES"><a href="#3-3-2、NOHZ-MODE-LOWRES" class="headerlink" title="3.3.2、NOHZ_MODE_LOWRES"></a>3.3.2、NOHZ_MODE_LOWRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，但是hrtimer高精度不能使能，即进入NOHZ_MODE_LOWRES模式：“td=period模式, dev=oneshot模式, hrtimer=low res, noHz=en”。</p>
<p><img src="clockevent_NOHZ_MODE_LOWRES.png" alt="image"></p>
<p>NOHZ_MODE_LOWRES模式：</p>
<ul>
<li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li>
<li>noHZ使能，进入idle不会被tick timer中断打断；</li>
<li>hrtimer工作在低精度模式，和低精度定时器(SW local timer)的精度一样，都是基于tick的；</li>
</ul>
<p>为了支持noHZ，tick_device必须切换成oneshot模式，在进入idle时停掉tick timer(tick_nohz_idle_enter() -&gt;　__tick_nohz_idle_enter() -&gt; tick_nohz_stop_sched_tick())，在离开idle时恢复tick timer(tick_nohz_idle_exit() -&gt; tick_nohz_restart_sched_tick())，这样idle过程就不会被tick中断。就实现了noHZ模式(tickless)。</p>
<p>NOHZ_MODE_LOWRES模式下，没有进入idle时tick_device还是以固定周期工作的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void tick<span class="constructor">_nohz_handler(<span class="params">struct</span> <span class="params">clock_event_device</span> <span class="operator">*</span><span class="params">dev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line">	<span class="keyword">struct</span> pt_regs *regs = get<span class="constructor">_irq_regs()</span>;</span><br><span class="line">	ktime_t now = ktime<span class="constructor">_get()</span>;</span><br><span class="line"></span><br><span class="line">	dev-&gt;next_event.tv64 = KTIME_MAX;</span><br><span class="line"></span><br><span class="line">	tick<span class="constructor">_sched_do_timer(<span class="params">now</span>)</span>;</span><br><span class="line">	tick<span class="constructor">_sched_handle(<span class="params">ts</span>, <span class="params">regs</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* No need to reprogram if we are running tickless  */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ts-&gt;tick_stopped))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) HW local timer还是以固定周期发生中断 */</span></span><br><span class="line">	hrtimer<span class="constructor">_forward(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, <span class="params">now</span>, <span class="params">tick_period</span>)</span>;</span><br><span class="line">	tick<span class="constructor">_program_event(<span class="params">hrtimer_get_expires</span>(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>)</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3、NOHZ-MODE-HIGHRES"><a href="#3-3-3、NOHZ-MODE-HIGHRES" class="headerlink" title="3.3.3、NOHZ_MODE_HIGHRES"></a>3.3.3、NOHZ_MODE_HIGHRES</h4><p>在系统的运行过程中系统尝试进入精度更高的模式，如果noHZ可以使能，hrtimer高精度可以使能，即进入NOHZ_MODE_HIGHRES模式：“td=period模式, dev=oneshot模式, hrtimer=high res, noHz=en”。</p>
<p><img src="clockevent_NOHZ_MODE_HIGHRES.png" alt="image"></p>
<p>NOHZ_MODE_HIGHRES：</p>
<ul>
<li>tick_device工作在oneshot模式，HW local timer工作在oneshot模式；</li>
<li>noHZ使能，进入idle不会被tick timer中断打断；</li>
<li>hrtimer工作在高精度模式，和硬件定时器(HWlocal timer)的精度一样，远大于低精度定时器tick精度；</li>
</ul>
<p>为了支持hrtimer的高精度模式，hrtimer必须直接使用tick_device的oneshot模式，而常规的tick timer转换成hrtimer的一个子timer。</p>
<p><img src="ftrace_NOHZ_MODE_HIGHRES.png" alt="image"></p>
<p>上图是NOHZ_MODE_HIGHRES模式下，用ftrace抓取HW timer硬件中断和tick任务的执行情况：</p>
<ul>
<li>tick任务是以固定周期4ms固定执行的；</li>
<li>遇到tick任务超过4ms的间隔，这时就是进入了idle状态，且发生了noHZ(tickless)；</li>
<li>硬件timer中断的发生周期是不固定的，是和hrtimer绑定的；</li>
<li>发生tick的时候肯定发生了timer硬中断，因为tick是其中一个hrtimer；</li>
</ul>
<h4 id="3-3-4、Mode切换"><a href="#3-3-4、Mode切换" class="headerlink" title="3.3.4、Mode切换"></a>3.3.4、Mode切换</h4><p>系统初始状态工作在NOHZ_MODE_INACTIVE模式时，会动态检测是否可以进入更高级别的模式NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES。这个检测工作是在这个路径中做的：tick_device工作在period模式：tick_handle_periodic() -&gt; tick_periodic() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues()</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void hrtimer<span class="constructor">_run_queues(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> hrtimer_cpu_base *cpu_base = this<span class="constructor">_cpu_ptr(&amp;<span class="params">hrtimer_bases</span>)</span>;</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (3) 如果hrtimer已经切换到高精度模式，</span></span><br><span class="line"><span class="comment">        则不会从run_local_timers()低精度定时器路径来运行hrtimer */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="constructor">__hrtimer_hres_active(<span class="params">cpu_base</span>)</span>)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This _is_ ugly: We have to check periodically, whether we</span></span><br><span class="line"><span class="comment">	 * can switch to highres and / or nohz mode. The clocksource</span></span><br><span class="line"><span class="comment">	 * switch happens with xtime_lock held. Notification from</span></span><br><span class="line"><span class="comment">	 * there only sets the check bit in the tick_oneshot code,</span></span><br><span class="line"><span class="comment">	 * otherwise we might deadlock vs. xtime_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* (1) 如果hrtimer没有使能、noHZ使能，</span></span><br><span class="line"><span class="comment">	    则调用：tick_check_oneshot_change() -&gt; tick_nohz_switch_to_nohz()，</span></span><br><span class="line"><span class="comment">	    切换到NOHZ_MODE_LOWRES模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (tick<span class="constructor">_check_oneshot_change(!<span class="params">hrtimer_is_hres_enabled</span>()</span>)) &#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/* (2) 如果hrtimer使能、noHZ使能，</span></span><br><span class="line"><span class="comment">    	    则调用：hrtimer_switch_to_hres()，</span></span><br><span class="line"><span class="comment">    	    切换到NOHZ_MODE_HIGHRES模式 */</span></span><br><span class="line">		hrtimer<span class="constructor">_switch_to_hres()</span>;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	raw<span class="constructor">_spin_lock(&amp;<span class="params">cpu_base</span>-&gt;<span class="params">lock</span>)</span>;</span><br><span class="line">	now = hrtimer<span class="constructor">_update_base(<span class="params">cpu_base</span>)</span>;</span><br><span class="line">	<span class="comment">/* (4) 低精度hrtimer的运行函数 */</span></span><br><span class="line">	<span class="constructor">__hrtimer_run_queues(<span class="params">cpu_base</span>, <span class="params">now</span>)</span>;</span><br><span class="line">	raw<span class="constructor">_spin_unlock(&amp;<span class="params">cpu_base</span>-&gt;<span class="params">lock</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、noHZ"><a href="#4、noHZ" class="headerlink" title="4、noHZ"></a>4、noHZ</h2><p>系统在NOHZ_MODE_LOWRES、NOHZ_MODE_HIGHRES两种模式下支持noHZ。noHZ是一个功耗优化的feature，在系统负载比较轻的时候没有任务需要调度cpu会进入idle状态，但是系统的tick任务(update_process_times())默认会以固定周期执行，这种固定周期会打断idle状态让系统恢复成正常耗电状态。</p>
<p>tick任务这种不管有没有任务都是固定周期运行的特性是需要改进的，noHZ就是为了解决这一问题而产生的：如果在idle状态的过程中tick任务没有到期需要处理的低精度timer和高精度timer，tick任务可以继续保持睡眠，直到真正有timer到期。</p>
<p>idle进程的主要执行序列如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void cpu<span class="constructor">_idle_loop(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) 进入idle前,noHZ的处理 */</span></span><br><span class="line">		tick<span class="constructor">_nohz_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!need<span class="constructor">_resched()</span>) &#123;</span><br><span class="line">			check<span class="constructor">_pgt_cache()</span>;</span><br><span class="line">			rmb<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (2) cpu hotplug之cpu_down()的处理 */</span></span><br><span class="line">			<span class="keyword">if</span> (cpu<span class="constructor">_is_offline(<span class="params">smp_processor_id</span>()</span>)) &#123;</span><br><span class="line"></span><br><span class="line">				arch<span class="constructor">_cpu_idle_dead()</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			local<span class="constructor">_irq_disable()</span>;</span><br><span class="line">			arch<span class="constructor">_cpu_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (3) cpu idle的进入 */</span></span><br><span class="line">			<span class="keyword">if</span> (cpu_idle_force_poll<span class="operator"> || </span>tick<span class="constructor">_check_broadcast_expired()</span>)</span><br><span class="line">				cpu<span class="constructor">_idle_poll()</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cpuidle<span class="constructor">_idle_call()</span>;</span><br><span class="line"></span><br><span class="line">			arch<span class="constructor">_cpu_idle_exit()</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (4) 退出idle后,noHZ的处理 */</span></span><br><span class="line">		tick<span class="constructor">_nohz_idle_exit()</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其中的关键在tick_nohz_idle_enter()/tick_nohz_idle_exit()函数。</p>
<h3 id="4-1、tick-nohz-idle-enter-exit"><a href="#4-1、tick-nohz-idle-enter-exit" class="headerlink" title="4.1、tick_nohz_idle_enter/exit()"></a>4.1、tick_nohz_idle_enter/exit()</h3><p>tick_nohz_idle_enter()的解析：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">void tick_nohz_idle_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct tick_sched *ts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ts = this_cpu_ptr(&amp;tick_cpu_sched);</span><br><span class="line">	<span class="function"><span class="title">ts</span>-&gt;</span>inidle = <span class="number">1</span>;</span><br><span class="line">	__tick_nohz_idle_enter(ts);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">|→</span><br><span class="line">static void __tick_nohz_idle_enter(struct tick_sched *ts)</span><br><span class="line">&#123;</span><br><span class="line">	ktime_t now, expires;</span><br><span class="line">	int cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">	now = tick_nohz_start_idle(ts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 判断当前能否stop tick任务 */</span></span><br><span class="line">	<span class="keyword">if</span> (can_stop_idle_tick(cpu, ts)) &#123;</span><br><span class="line">		<span class="function"><span class="title">int</span> was_stopped = ts-&gt;</span>tick_stopped;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span>idle_calls++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (2) 尝试stop tick任务 */</span></span><br><span class="line">		expires = tick_nohz_stop_sched_tick(ts, now, cpu);</span><br><span class="line">		<span class="keyword">if</span> (expires.tv64 &gt; <span class="number">0</span>LL) &#123;</span><br><span class="line">			<span class="function"><span class="title">ts</span>-&gt;</span>idle_sleeps++;</span><br><span class="line">			<span class="function"><span class="title">ts</span>-&gt;</span>idle_expires = expires;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">if</span> (!was_stopped &amp;&amp; ts-&gt;</span>tick_stopped)</span><br><span class="line">			<span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">idle_jiffies</span> = ts-&gt;</span>last_jiffies;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">||→</span><br><span class="line">static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span><br><span class="line">					 ktime_t now, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);</span><br><span class="line">	u64 basemono, next_tick, next_tmr, next_rcu, delta, expires;</span><br><span class="line">	unsigned long seq, basejiff;</span><br><span class="line">	ktime_t	tick;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read jiffies and the time when jiffies were updated last */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		seq = read_seqbegin(&amp;jiffies_lock);</span><br><span class="line">		basemono = last_jiffies_update.tv64;</span><br><span class="line">		basejiff = jiffies;</span><br><span class="line">	&#125; <span class="keyword">while</span> (read_seqretry(&amp;jiffies_lock, seq));</span><br><span class="line">	<span class="function"><span class="title">ts</span>-&gt;</span>last_jiffies = basejiff;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span><br><span class="line">	    arch_needs_cpu() || irq_work_needs_cpu()) &#123;</span><br><span class="line">		next_tick = basemono + TICK_NSEC;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Get the next pending timer. If high resolution</span></span><br><span class="line"><span class="comment">		 * timers are enabled this only takes the timer wheel</span></span><br><span class="line"><span class="comment">		 * timers into account. If high resolution timers are</span></span><br><span class="line"><span class="comment">		 * disabled this also looks at the next expiring</span></span><br><span class="line"><span class="comment">		 * hrtimer.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* (2.1) 获取下一个timer的到期时间(包括低精度和高精度timer) */</span></span><br><span class="line">		next_tmr = get_next_timer_interrupt(basejiff, basemono);</span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span>next_timer = next_tmr;</span><br><span class="line">		<span class="comment">/* Take the next rcu event into account */</span></span><br><span class="line">		next_tick = next_rcu &lt; next_tmr ? next_rcu : next_tmr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the tick is due in the next period, keep it ticking or</span></span><br><span class="line"><span class="comment">	 * restart it proper.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (2.2) 如果差距小于一个tick，不需要进入noHZ模式 */</span></span><br><span class="line">	delta = next_tick - basemono;</span><br><span class="line">	<span class="keyword">if</span> (delta &lt;= (u64)TICK_NSEC) &#123;</span><br><span class="line">		tick.tv64 = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">if</span> (!ts-&gt;</span>tick_stopped)</span><br><span class="line">			goto out;</span><br><span class="line">		<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* Tick is stopped, but required now. Enforce it */</span></span><br><span class="line">			tick_nohz_restart(ts, now);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this cpu is the one which updates jiffies, then give up</span></span><br><span class="line"><span class="comment">	 * the assignment and let it be taken by the cpu which runs</span></span><br><span class="line"><span class="comment">	 * the tick timer next, which might be this cpu as well. If we</span></span><br><span class="line"><span class="comment">	 * don't drop this here the jiffies might be stale and</span></span><br><span class="line"><span class="comment">	 * do_timer() never invoked. Keep track of the fact that it</span></span><br><span class="line"><span class="comment">	 * was the one which had the do_timer() duty last. If this cpu</span></span><br><span class="line"><span class="comment">	 * is the one which had the do_timer() duty last, we limit the</span></span><br><span class="line"><span class="comment">	 * sleep time to the timekeeping max_deferement value.</span></span><br><span class="line"><span class="comment">	 * Otherwise we can sleep as long as we want.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* (2.3) 根据timekeeper的可能溢出的位宽，得到的idle最大值 */</span></span><br><span class="line">	delta = timekeeping_max_deferment();</span><br><span class="line">	<span class="keyword">if</span> (cpu == tick_do_timer_cpu) &#123;</span><br><span class="line">		tick_do_timer_cpu = TICK_DO_TIMER_NONE;</span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span>do_timer_last = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tick_do_timer_cpu != TICK_DO_TIMER_NONE) &#123;</span><br><span class="line">		delta = KTIME_MAX;</span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span>do_timer_last = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (!ts-&gt;</span>do_timer_last) &#123;</span><br><span class="line">		delta = KTIME_MAX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NO_HZ_FULL</span><br><span class="line">	<span class="comment">/* Limit the tick delta to the maximum scheduler deferment */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (!ts-&gt;</span>inidle)</span><br><span class="line">		delta = min(delta, scheduler_tick_max_deferment());</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Calculate the next expiry time */</span></span><br><span class="line">	<span class="keyword">if</span> (delta &lt; (KTIME_MAX - basemono))</span><br><span class="line">		expires = basemono + delta;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		expires = KTIME_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.4) 综合上面条件，得到合理的stop tick的时间 */</span></span><br><span class="line">	expires = min_t(u64, expires, next_tick);</span><br><span class="line">	tick.tv64 = expires;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Skip reprogram of event if its not changed */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (ts-&gt;</span><span class="function"><span class="title">tick_stopped</span> &amp;&amp; (expires == dev-&gt;</span>next_event.tv64))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * nohz_stop_sched_tick can be called several times before</span></span><br><span class="line"><span class="comment">	 * the nohz_restart_sched_tick is called. This happens when</span></span><br><span class="line"><span class="comment">	 * interrupts arrive which do not cause a reschedule. In the</span></span><br><span class="line"><span class="comment">	 * first call we save the current tick time, so we can restart</span></span><br><span class="line"><span class="comment">	 * the scheduler tick in nohz_restart_sched_tick.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (!ts-&gt;</span>tick_stopped) &#123;</span><br><span class="line">		nohz_balance_enter_idle(cpu);</span><br><span class="line">		calc_load_enter_idle();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">last_tick</span> = hrtimer_get_expires(&amp;ts-&gt;</span>sched_timer);</span><br><span class="line">		<span class="function"><span class="title">ts</span>-&gt;</span>tick_stopped = <span class="number">1</span>;</span><br><span class="line">		trace_tick_stop(<span class="number">1</span>, <span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the expiration time == KTIME_MAX, then we simply stop</span></span><br><span class="line"><span class="comment">	 * the tick timer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(expires == KTIME_MAX)) &#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (ts-&gt;</span>nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line">			<span class="function"><span class="title">hrtimer_cancel</span>(&amp;ts-&gt;</span>sched_timer);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.5) 实际的stop tick动作：</span></span><br><span class="line"><span class="comment">      将local timer的周期改为大于一个tick的时间，将idle时间延长  */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (ts-&gt;</span>nohz_mode == NOHZ_MODE_HIGHRES)</span><br><span class="line">		<span class="function"><span class="title">hrtimer_start</span>(&amp;ts-&gt;</span>sched_timer, tick, HRTIMER_MODE_ABS_PINNED);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tick_program_event(tick, <span class="number">1</span>);</span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* Update the estimated sleep length */</span></span><br><span class="line">	<span class="function"><span class="title">ts</span>-&gt;</span><span class="function"><span class="title">sleep_length</span> = ktime_sub(dev-&gt;</span>next_event, now);</span><br><span class="line">	return tick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick_nohz_idle_exit()的解析：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void tick<span class="constructor">_nohz_idle_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	local<span class="constructor">_irq_disable()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="constructor">WARN_ON_ONCE(!<span class="params">ts</span>-&gt;<span class="params">inidle</span>)</span>;</span><br><span class="line"></span><br><span class="line">	ts-&gt;inidle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ts-&gt;idle_active<span class="operator"> || </span>ts-&gt;tick_stopped)</span><br><span class="line">		now = ktime<span class="constructor">_get()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ts-&gt;idle_active)</span><br><span class="line">		tick<span class="constructor">_nohz_stop_idle(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ts-&gt;tick_stopped) &#123;</span><br><span class="line">	    <span class="comment">/* (1) 重启tick任务 */</span></span><br><span class="line">		tick<span class="constructor">_nohz_restart_sched_tick(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line">		tick<span class="constructor">_nohz_account_idle_ticks(<span class="params">ts</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local<span class="constructor">_irq_enable()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="pattern-match">|→</span></span><br><span class="line"><span class="pattern-match">static void tick<span class="constructor">_nohz_restart_sched_tick(<span class="params">struct</span> <span class="params">tick_sched</span> <span class="operator">*</span><span class="params">ts</span>, <span class="params">ktime_t</span> <span class="params">now</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">*</span> <span class="constructor">Update</span> jiffies first <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	tick<span class="constructor">_do_update_jiffies64(<span class="params">now</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">	update<span class="constructor">_cpu_load_nohz()</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	calc<span class="constructor">_load_exit_idle()</span>;</span></span><br><span class="line"><span class="pattern-match">	touch<span class="constructor">_softlockup_watchdog()</span>;</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match">	 <span class="operator">*</span> <span class="constructor">Cancel</span> the scheduled timer <span class="keyword">and</span> restore the tick</span></span><br><span class="line"><span class="pattern-match">	 <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	ts-&gt;tick<span class="constructor">_stopped</span>  = 0;</span></span><br><span class="line"><span class="pattern-match">	ts-&gt;idle<span class="constructor">_exittime</span> = now;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> (1.1) 重启local timer <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	tick<span class="constructor">_nohz_restart(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">||</span>→</span></span><br><span class="line"><span class="pattern-match">static void tick<span class="constructor">_nohz_restart(<span class="params">struct</span> <span class="params">tick_sched</span> <span class="operator">*</span><span class="params">ts</span>, <span class="params">ktime_t</span> <span class="params">now</span>)</span></span></span><br><span class="line"><span class="pattern-match">&#123;</span></span><br><span class="line"><span class="pattern-match">	hrtimer<span class="constructor">_cancel(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">	hrtimer<span class="constructor">_set_expires(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, <span class="params">ts</span>-&gt;<span class="params">last_tick</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">*</span> <span class="constructor">Forward</span> the time <span class="keyword">to</span> expire <span class="keyword">in</span> the future <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">	hrtimer<span class="constructor">_forward(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, <span class="params">now</span>, <span class="params">tick_period</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">if</span> (ts-&gt;nohz<span class="constructor">_mode</span> <span class="operator">==</span> <span class="constructor">NOHZ_MODE_HIGHRES</span>)</span></span><br><span class="line"><span class="pattern-match">		hrtimer<span class="constructor">_start_expires(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>, HRTIMER_MODE_ABS_PINNED)</span>;</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">		tick<span class="constructor">_program_event(<span class="params">hrtimer_get_expires</span>(&amp;<span class="params">ts</span>-&gt;<span class="params">sched_timer</span>)</span>, 1);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-tick-nohz-irq-enter-exit"><a href="#4-2-tick-nohz-irq-enter-exit" class="headerlink" title="4.2 tick_nohz_irq_enter/exit()"></a>4.2 tick_nohz_irq_enter/exit()</h3><p>因为在idle退出执行完本tick需要处理的timer后又需要重新关闭tick，系统设计了tick_nohz_irq_enter()/tick_nohz_irq_exit()来处理这种操作。在本次中断处理完timer后，在tick_nohz_irq_exit()中判断是否重新关闭tick任务。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void cpu<span class="constructor">_idle_loop(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1) 关闭tick */</span></span><br><span class="line">		tick<span class="constructor">_nohz_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!need<span class="constructor">_resched()</span>) &#123;</span><br><span class="line">			check<span class="constructor">_pgt_cache()</span>;</span><br><span class="line">			rmb<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (2) cpu hotplug之cpu_down()的处理 */</span></span><br><span class="line">			<span class="keyword">if</span> (cpu<span class="constructor">_is_offline(<span class="params">smp_processor_id</span>()</span>)) &#123;</span><br><span class="line"></span><br><span class="line">				arch<span class="constructor">_cpu_idle_dead()</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (3) 关中断 */</span></span><br><span class="line">			local<span class="constructor">_irq_disable()</span>;</span><br><span class="line">			arch<span class="constructor">_cpu_idle_enter()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (4) 进入idle，</span></span><br><span class="line"><span class="comment">                cpu进入暂停状态 */</span></span><br><span class="line">			<span class="keyword">if</span> (cpu_idle_force_poll<span class="operator"> || </span>tick<span class="constructor">_check_broadcast_expired()</span>)</span><br><span class="line">				cpu<span class="constructor">_idle_poll()</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cpuidle<span class="constructor">_idle_call()</span>;</span><br><span class="line">		    <span class="comment">/* (5) cpu被local timer中断唤醒退出idle状态，继续执行；</span></span><br><span class="line"><span class="comment">		        但是因为irq是disable状态，中断服务程序并不能马上得到执行*/</span></span><br><span class="line">			<span class="comment">/* (5.1) 退出idle，并且开中断 */</span>	</span><br><span class="line">			</span><br><span class="line">                    <span class="comment">/* (6) 中断打开后，被阻塞的local timer中断服务得到执行，到期的软件timer得到执行；*/</span></span><br><span class="line">                    <span class="comment">/* (6.1) 退出中断时调用tick_nohz_irq_exit()，重新计算一个tick可以被stop的值 */</span></span><br><span class="line">            </span><br><span class="line">			arch<span class="constructor">_cpu_idle_exit()</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (7) 重启tick */</span></span><br><span class="line">		tick<span class="constructor">_nohz_idle_exit()</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick_nohz_irq_enter()/tick_nohz_irq_exit()的代码解析：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static inline void tick<span class="constructor">_nohz_irq_enter(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ts-&gt;idle_active<span class="operator"> &amp;&amp; </span>!ts-&gt;tick_stopped)</span><br><span class="line">		return;</span><br><span class="line">	now = ktime<span class="constructor">_get()</span>;</span><br><span class="line">	<span class="keyword">if</span> (ts-&gt;idle_active)</span><br><span class="line">		tick<span class="constructor">_nohz_stop_idle(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/* (1) 基本就是空操作 */</span></span><br><span class="line">	<span class="keyword">if</span> (ts-&gt;tick_stopped) &#123;</span><br><span class="line">		tick<span class="constructor">_nohz_update_jiffies(<span class="params">now</span>)</span>;</span><br><span class="line">		tick<span class="constructor">_nohz_kick_tick(<span class="params">ts</span>, <span class="params">now</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick<span class="constructor">_nohz_irq_exit(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tick_sched *ts = this<span class="constructor">_cpu_ptr(&amp;<span class="params">tick_cpu_sched</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ts-&gt;inidle)</span><br><span class="line">	    <span class="comment">/* (2) 重新判断stop tick任务 */</span></span><br><span class="line">		<span class="constructor">__tick_nohz_idle_enter(<span class="params">ts</span>)</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tick<span class="constructor">_nohz_full_update_tick(<span class="params">ts</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3、local-timer时钟被关闭时的处理"><a href="#4-3、local-timer时钟被关闭时的处理" class="headerlink" title="4.3、local timer时钟被关闭时的处理"></a>4.3、local timer时钟被关闭时的处理</h3><p>还有一种情况需要考虑，在系统进入深层次的idle状态时，local timer本身的时钟可能会被关闭。比如MTK平台进入soidle状态时，local timer本身会被停止，这时会用一个GPT timer来替代local timer继续工作。</p>
<p>核心函数是timer_setting_before_wfi()/timer_setting_after_wfi()：</p>
<ul>
<li>timer_setting_before_wfi()在进入idle前被调用，读出local timer的剩余值并配置到GPT timer中；</li>
<li>timer_setting_after_wfi()在退出idle后被调用，读出GPT timer的值来重新恢复local timer；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_setting_before_wfi</span><span class="params">(<span class="keyword">bool</span> f26m_off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USING_STD_TIMER_OPS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> timer_left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1) 读出local timer的剩余值 */</span></span><br><span class="line">	timer_left = localtimer_get_counter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2) 根据GPT timer在不同状态下的频率，把剩余值配置到GPT中 */</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">int</span>)timer_left &lt;= <span class="number">0</span>)</span><br><span class="line">		gpt_set_cmp(IDLE_GPT, <span class="number">1</span>); <span class="comment">/* Trigger idle_gpt Timeout imediately */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (f26m_off)</span><br><span class="line">			gpt_set_cmp(IDLE_GPT, div_u64(timer_left, <span class="number">406.25</span>));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		gpt_set_cmp(IDLE_GPT, timer_left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (f26m_off)</span><br><span class="line">		gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_RTC, GPT_CLK_DIV_1);</span><br><span class="line"></span><br><span class="line">	start_gpt(IDLE_GPT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	gpt_get_cnt(GPT1, &amp;timer_left);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_setting_after_wfi</span><span class="params">(<span class="keyword">bool</span> f26m_off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USING_STD_TIMER_OPS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/* (3) 判断当前退出idle状态是否是因为GPT到期引起的 */</span></span><br><span class="line">	<span class="keyword">if</span> (gpt_check_and_ack_irq(IDLE_GPT)) &#123;</span><br><span class="line">	    <span class="comment">/* (3.1) 如果GPT时间已经到期，证明local timer也已经到期，</span></span><br><span class="line"><span class="comment">	        触发local timer在下一时钟执行 */</span></span><br><span class="line">		localtimer_set_next_event(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (f26m_off)</span><br><span class="line">			gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* (4) 退出idle是因为GPT以外的中断源唤醒的 */</span></span><br><span class="line">		<span class="comment">/* waked up by other wakeup source */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> cnt, cmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (4.1) 读出GPT中的剩余到期值，重新配置到local timer中 */</span></span><br><span class="line">		idle_gpt_get_cnt(IDLE_GPT, &amp;cnt);</span><br><span class="line">		idle_gpt_get_cmp(IDLE_GPT, &amp;cmp);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(cmp &lt; cnt)) &#123;</span><br><span class="line">			idle_err(<span class="string">"[%s]GPT%d: counter = %10u, compare = %10u\n"</span>,</span><br><span class="line">					__func__, IDLE_GPT + <span class="number">1</span>, cnt, cmp);</span><br><span class="line">			<span class="comment">/* BUG(); */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (f26m_off) &#123;</span><br><span class="line">			localtimer_set_next_event((cmp - cnt) * <span class="number">1625</span> / <span class="number">4</span>);</span><br><span class="line">			gpt_set_clk(IDLE_GPT, GPT_CLK_SRC_SYS, GPT_CLK_DIV_1);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		localtimer_set_next_event(cmp - cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		stop_gpt(IDLE_GPT);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别说明的是，这种GPT timer全局只有一个，进入soidle的状态时cpu也只有一个在线，所以能正常的工作。</p>
<h2 id="5、hrtimer"><a href="#5、hrtimer" class="headerlink" title="5、hrtimer"></a>5、hrtimer</h2><h3 id="5-1、hrtimer的组织"><a href="#5-1、hrtimer的组织" class="headerlink" title="5.1、hrtimer的组织"></a>5.1、hrtimer的组织</h3><p>hrtimer的组织相对来说还是比较简单的，每个cpu对应一个hrtimer_cpu_base，每个hrtimer_cpu_base中有4类clock_base代表4种时间类型(HRTIMER_BASE_REALTIME、HRTIMER_BASE_MONOTONIC、HRTIMER_BASE_BOOTTIME、HRTIMER_BASE_TAI)的hrtimer，每个clock_base是以红黑树来组织同一类型的hrtimer的：</p>
<p><img src="hrtimer.png" alt="image"></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">	.lock</span> = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases<span class="number">.</span><span class="keyword">lock</span>),</span><br><span class="line"><span class="meta">	.seq</span> = SEQCNT_ZERO(hrtimer_bases<span class="number">.</span>seq),</span><br><span class="line"><span class="meta">	.clock_base</span> =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">			.index</span> = HRTIMER_BASE_MONOTONIC,</span><br><span class="line"><span class="meta">			.clockid</span> = CLOCK_MONOTONIC,</span><br><span class="line"><span class="meta">			.get_time</span> = &amp;ktime_get,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">			.index</span> = HRTIMER_BASE_REALTIME,</span><br><span class="line"><span class="meta">			.clockid</span> = CLOCK_REALTIME,</span><br><span class="line"><span class="meta">			.get_time</span> = &amp;ktime_get_real,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">			.index</span> = HRTIMER_BASE_BOOTTIME,</span><br><span class="line"><span class="meta">			.clockid</span> = CLOCK_BOOTTIME,</span><br><span class="line"><span class="meta">			.get_time</span> = &amp;ktime_get_boottime,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">			.index</span> = HRTIMER_BASE_TAI,</span><br><span class="line"><span class="meta">			.clockid</span> = CLOCK_TAI,</span><br><span class="line"><span class="meta">			.get_time</span> = &amp;ktime_get_clocktai,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES"><a href="#5-2、低精度模式-NOHZ-MODE-INACTIVE-NOHZ-MODE-LOWRES" class="headerlink" title="5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)"></a>5.2、低精度模式(NOHZ_MODE_INACTIVE/NOHZ_MODE_LOWRES)</h3><p>前面几章已经详细描述了执行路径，在低精度模式下hrtimer的实际精度和低精度定时器是一样的，都是基于tick精度的。他的执行路径如下。</p>
<p>NOHZ_MODE_INACTIVE模式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tick_handle_periodic</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">tick_periodic</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">update_process_times</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">run_local_timers</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">hrtimer_run_queues</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<p>NOHZ_MODE_LOWRES模式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tick_nohz_handler</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">tick_sched_handle</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">update_process_times</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">run_local_timers</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">hrtimer_run_queues</span><span class="params">()</span></span></span><br><span class="line">    ↓</span><br><span class="line">__hrtimer_run_queues()</span><br></pre></td></tr></table></figure>
<h3 id="5-3、高精度模式-NOHZ-MODE-HIGHRES"><a href="#5-3、高精度模式-NOHZ-MODE-HIGHRES" class="headerlink" title="5.3、高精度模式(NOHZ_MODE_HIGHRES)"></a>5.3、高精度模式(NOHZ_MODE_HIGHRES)</h3><p>在高精度模式下hrtimer才能发挥出真正的精度，他的可以精确定时到小于一个tick，精度依赖于硬件local timer。</p>
<p>NOHZ_MODE_LOWRES模式：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hrtimer_interrupt</span>()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">__hrtimer_run_queues</span>()</span></span><br></pre></td></tr></table></figure>
<h2 id="6、低精度timer-lowres-timer"><a href="#6、低精度timer-lowres-timer" class="headerlink" title="6、低精度timer(lowres timer)"></a>6、低精度timer(lowres timer)</h2><p>低精度timer在系统中的应用范围更广，若非特别声明是hrtimer其他都是使用低精度timer，类如schedule_timeout()、msleep()。他有以下特点：</p>
<ul>
<li>精度低，以tick为单位计时；</li>
<li>执行上下文，低精度timer执行时是在softirq中，而hrtimer的实际执行是在中断当中。所以低精度的执行精度更小于hrtimer；</li>
<li>对系统的实时影响小，softirq比irq对系统的实时性影响更小；</li>
</ul>
<h3 id="6-1、低精度timer的组织"><a href="#6-1、低精度timer的组织" class="headerlink" title="6.1、低精度timer的组织"></a>6.1、低精度timer的组织</h3><p>低精度timer的组织形式和hrtimer类似，只是timer的链接不是采用红黑树，而是采用tv1 - tv5等一系列的链表。</p>
<p><img src="lowres_timer.png" alt="image"></p>
<p>tv1 - tv5中保留着一系列槽位，每个槽位代表一个超时时间，把相同超时时间的低精度timer链接到同一槽位当中。</p>
<h3 id="6-2、低精度timer的执行路径"><a href="#6-2、低精度timer的执行路径" class="headerlink" title="6.2、低精度timer的执行路径"></a>6.2、低精度timer的执行路径</h3><p>低精度timer的实际执行时在softirq中执行的，在中断中的动作只是简单触发softirq。</p>
<p>中断中：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tick_handle_periodic</span>()/<span class="title">tick_nohz_handler</span>()/<span class="title">hrtimer_interrupt</span>()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">run_local_timers</span>()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="function"><span class="title">raise_softirq</span>(<span class="variable">TIMER_SOFTIRQ</span>);</span></span><br></pre></td></tr></table></figure>
<p>软中断中：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softir<span class="string">q()</span></span><br><span class="line">    ↓</span><br><span class="line">__run_timers()</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_DroidPhoneo">
<sup>DroidPhoneo</sup>. <a href="http://blog.csdn.net/DroidPhone/article/category/1263459" target="_blank" rel="noopener">Linux 时间子系统</a><a href="#reffn_DroidPhoneo" title="Jump back to footnote [DroidPhoneo] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_wowo">
<sup>wowo</sup>. <a href="http://www.wowotech.net/timer_subsystem/time_subsystem_index.html" target="_blank" rel="noopener">wowotech time subsystem</a><a href="#reffn_wowo" title="Jump back to footnote [wowo] in the text."> &#8617;</a>
</blockquote>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/07/11//android-p-fbe.html/" data-toggle="tooltip" data-placement="top" title="Android FBE">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/03/20//device-tree.html/" data-toggle="tooltip" data-placement="top" title="Device Tree 详解">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#hrtimer" title="hrtimer">hrtimer</a>
                        
                          <a class="tag" href="/tags/#tickless" title="tickless">tickless</a>
                        
                          <a class="tag" href="/tags/#monotonic time" title="monotonic time">monotonic time</a>
                        
                          <a class="tag" href="/tags/#timekeeper" title="timekeeper">timekeeper</a>
                        
                          <a class="tag" href="/tags/#clocksource" title="clocksource">clocksource</a>
                        
                          <a class="tag" href="/tags/#clockevent" title="clockevent">clockevent</a>
                        
                          <a class="tag" href="/tags/#noHZ" title="noHZ">noHZ</a>
                        
                          <a class="tag" href="/tags/#lowres timer" title="lowres timer">lowres timer</a>
                        
                          <a class="tag" href="/tags/#wall time" title="wall time">wall time</a>
                        
                          <a class="tag" href="/tags/#xtime" title="xtime">xtime</a>
                        
                          <a class="tag" href="/tags/#boottime" title="boottime">boottime</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; meizu 2025 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="../../../../../js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="../../../../../js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="../../../../../js/hux-blog.min.js"></script>


<!-- Search -->

<script src="../../../../../js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://kernel.meizu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
