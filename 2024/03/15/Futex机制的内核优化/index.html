<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="一个有内涵的技术分享平台">
    <meta name="keyword"  content="meizu,kernel,魅族">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          性能打磨手记：记一段 Futex 机制的内核优化之旅 - 魅族内核团队
        
    </title>

    <link rel="canonical" href="https://kernel.meizu.com/2024/03/15/Futex机制的内核优化/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="../../../../css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="../../../../css/dusign-light.css">

        
<link rel="stylesheet" href="../../../../css/dusign-common-light.css">

        
<link rel="stylesheet" href="../../../../css/font-awesome.css">

        
<link rel="stylesheet" href="../../../../css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="../../../../css/highlight.css">


    
<link rel="stylesheet" href="../../../../css/widget.css">


    
<link rel="stylesheet" href="../../../../css/rocket.css">


    
<link rel="stylesheet" href="../../../../css/signature.css">


    
<link rel="stylesheet" href="../../../../css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="../../../../css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('../../../../img/default.jpg')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Performance" title="Performance">Performance</a>
                            
                        </div>
                        <h1>性能打磨手记：记一段 Futex 机制的内核优化之旅</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Haibo.Chen on
                            2024-03-15
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">魅族内核团队</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="1-futex简介"><a href="#1-futex简介" class="headerlink" title="1. futex简介"></a><strong>1. futex简介</strong></h1><p>Futex 是Fast Userspace muTexes的缩写，由 Linux 2.5.7开始引入。传统的SYSTEM V IPC机制需要系统调用进入内核态去操作某个内核对象，由内核来仲裁同步，事实上大部分情况下并没有资源竞争，此种情况下仍然进入内核态会显得很浪费，系统开销增加进而造成性能折扣，由此引入futex的概念。</p>
<p>futex是一种用户态和内核态混合机制，需要两个部分合作完成。在用户态，futex指的是一个原子变量，用来记录某种锁状态。需要持锁时，如果锁空闲则直接改变futex变量值，即表明持有该锁，不需要陷入内核。释放锁时，如果锁状态中没有线程等锁，则直接置锁状态为空闲，也无需陷入内核。</p>
<p>对于内核而言，futex是一个系统调用。当用户态出现锁竞争，线程需要休眠等待时，通过futex系统调用陷入内核并挂在wait queue中。当释放锁发现有线程在休眠等锁时，通过futex系统调用陷入内核去唤醒等锁的线程。</p>
<p>相比传统的SYSTEM V IPC机制，在无竞争时，用户态通过futex原子变量操作，替代内核对象操作，来提升性能。而绝大部分情况下，锁都是无竞争的，所以futex机制实现用户空间锁非常高效。</p>
<h2 id="1-1-用户态futex同步机制"><a href="#1-1-用户态futex同步机制" class="headerlink" title="1.1 用户态futex同步机制"></a>1.1 用户态futex同步机制</h2><p>所有的futex同步操作都应该从用户空间开始，首先创建一个futex原子变量。其中以pthread_mutex的锁操作过程为例，state表示其持有和竞争状态，0为无人持锁，1为有人持锁但无人竞争，2为有人持锁且有竞争。</p>
<ol>
<li>当线程A准备lock持锁，发现state\=\=0，则直接通过CAS(Compare and Swap)原子操作将state=1，表示持有该锁就结束了lock过程，整个过程并不需要内核参与，非常高效；</li>
<li>当线程B到来准备lock持锁，发现state\=\=1，锁已经被别人持有，于是使state=2表示有竞争，然后通过futex_wait(&amp;state) 操作陷入内核，内核会根据用户空间地址&amp;state创建一个等待队列，然后将B加入到&amp;state的等待队列中，将B休眠；</li>
<li>当线程A退出临界区unlock释放该锁时，发现state\=\=2意识到有人竞争，会将state=0，然后通过futex_wake(&amp;state) 陷入内核来唤醒等待&amp;state的线程B。线程A返回用户空间继续执行，退出unlock流程；</li>
<li>线程B从futex等待队列中移除，并加入调度程序的就绪队列，等待调度。得到调度后返回用户空间重新判断state\=\=0，于是重复步骤1；</li>
</ol>
<h2 id="1-2-内核态futex系统调用"><a href="#1-2-内核态futex系统调用" class="headerlink" title="1.2 内核态futex系统调用"></a>1.2 内核态futex系统调用</h2><p>linux上提供了sys_futex系统调用，对进程竞争情况下的同步处理提供支持。其原型和系统调用号为如下，参数常用的就是三个。uaddr就是用户态下共享内存的地址，也就是用户态的futex变量地址。op存放着操作类型，最常用的是futex_wait和futex_wake。val表示要操作的线程个数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;linux/futex.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line">int futex (int *uaddr, int op, int val, const struct timespec *timeout,int *uaddr2, int val3);</span><br><span class="line"><span class="comment">#define __NR_futex 240</span></span><br></pre></td></tr></table></figure>
<p>内核中futex内部采用了哈希表的数据结构，保存那些需要睡眠的任务。通过用户空间地址 uaddr，flag，以及 futex的读写状态可以计算出hash key值，将需要睡眠的任务的task_struct放到对应的哈希桶上的优先链表的节点中。</p>
<p><img src="1.png" alt=""></p>
<p>futex_wait(uaddr，val，abs_time) 流程：</p>
<ol>
<li>计算 futex 对应的 key，获取 key 对应的哈希表链表。</li>
<li>获取哈希桶链表自旋锁，如果 *uaddr == val 返回错误给用户态。</li>
<li>否则将当前任务状态改为 TASK_INTERRUPTIBLE，并将当前任务插入到 futex 等待队列，释放哈希桶链表自旋锁，然后调度器重新调度。</li>
<li>当该线程从睡眠中被唤醒时，例如超时或者被wakeup，做相应处理后，返回用户态。</li>
</ol>
<p>futex_wake(uaddr，nr_wake) 流程：</p>
<ol>
<li>计算 futex 对应的 key，获取 key 对应的哈希桶。</li>
<li>获取哈希桶的自旋锁，遍历这个哈希桶上的优先链表，找到key匹配的任务，说明该任务在等待 futex，将当前任务添加到唤醒队列 wake_q 中，如果达到了 nr_wake 个，则退出循环。</li>
<li>释放哈希桶自旋锁，唤醒队列 wake_q 中每一个任务。</li>
</ol>
<h1 id="2-futex在Android的应用"><a href="#2-futex在Android的应用" class="headerlink" title="2. futex在Android的应用"></a><strong>2. futex在Android的应用</strong></h1><p>下面是安卓系统中用户空间通用的同步机制框图，最终基本上都是基于 futex 系统调用来实现的。其中java部分同步机制，主要是由ART虚拟机实现的synchronize，和java.util.concurrent库实现的lock机制。C++部分主要是pthread库中实现的锁机制。</p>
<p><img src="2.png" alt=""></p>
<h2 id="2-1-ART锁"><a href="#2-1-ART锁" class="headerlink" title="2.1 ART锁"></a>2.1 ART锁</h2><p>Synchronize是java中的隐式锁，它的获取锁和释放锁都是隐式的，完全交由虚拟机实现。Synchronize生成的字节码会对应两条指令，分别是monitor-enter和monitor-exit。虚拟机锁一开始会通过CAS(Compare and swap)原子操作自旋，但是随着等锁时间增加，锁会不断升级，如果迟迟没有等到锁，最终升级为重量级锁，需要陷入内核休眠。</p>
<p><img src="3.png" alt=""></p>
<p>重量级锁最终会通过futex系统调用，由内核参与实现线程的挂起和唤醒。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Monitor::Lock(Thread* self) </span><br><span class="line">|--&gt;monitor_lock_.ExclusiveLock(self);   </span><br><span class="line">    |--&gt;futex(state_and_contenders_.Address(), FUTEX_WAIT_PRIVATE, cur_state,</span><br><span class="line">                      enable_monitor_timeout_ ? &amp;timeout_ts : nullptr , nullptr, 0)</span><br><span class="line"></span><br><span class="line">bool Monitor::Deflate(Thread* self, ObjPtr<span class="tag">&lt;<span class="name">mirror::Object</span>&gt;</span> obj) &#123;</span><br><span class="line">|--&gt;monitor-&gt;monitor_lock_.ExclusiveUnlock(self);</span><br><span class="line">    |--&gt;futex(state_.Address(), FUTEX_WAKE_PRIVATE, kWakeAll, nullptr, nullptr, 0);</span><br></pre></td></tr></table></figure>
<h2 id="2-2-JUC锁"><a href="#2-2-JUC锁" class="headerlink" title="2.2 JUC锁"></a>2.2 JUC锁</h2><p>java.util.concurrent包中提供的锁机制，称为JUC锁。相比Synchronize更加灵活，功能也更丰富，但是安全性也更低，需要开发者对JUC锁有足够的理解。根据功能分为下面几类</p>
<p><img src="4.png" alt=""></p>
<p><img src="5.jpg" alt=""></p>
<h2 id="2-3-pthread锁"><a href="#2-3-pthread锁" class="headerlink" title="2.3 pthread锁"></a>2.3 pthread锁</h2><p>pthread锁是native层提供的pthread库中的一部分，提供给native层代码使用，来实现各种同步机制。</p>
<h3 id="2-3-1-pthread-mutex"><a href="#2-3-1-pthread-mutex" class="headerlink" title="2.3.1 pthread_mutex"></a>2.3.1 pthread_mutex</h3><p>下面这段代码是pthread_mutex_lock核心部分，通过原子操作atomic_exchange_explicit，这个操作是将锁原子变量_Atomic(uint16_t) state替换为locked_contended，即置为处于竞争状态，并返回原本的state值。如果原本的锁状态不为unlocked即已经被人持有了，则调用__futex_wait_ex陷入内核休眠。如果原本锁状态就是unlocked，也就是没有人持有，则不休眠，也不需要内核参与。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">594      const uint16_t unlocked           = shared | MUTEX_STATE_BITS_UNLOCKED;</span><br><span class="line">595      const uint16_t locked_contended = shared | MUTEX_STATE_BITS_LOCKED_CONTENDED;</span><br><span class="line">605      while (atomic_exchange_explicit(&amp;mutex-&gt;state, locked_contended,</span><br><span class="line">606                                      memory_order_acquire) != unlocked) &#123;</span><br><span class="line">607          if (__futex_wait_ex(&amp;mutex-&gt;state, shared, locked_contended, use_realtime_clock,</span><br><span class="line">608                              abs_timeout_or_null) == -ETIMEDOUT) &#123;</span><br><span class="line">609              return ETIMEDOUT;</span><br><span class="line">610          &#125;</span><br><span class="line">611      &#125;</span><br></pre></td></tr></table></figure>
<p>同样pthread_mutex_unlock核心代码，首先通过原子操作将锁状态state置为unlocked，然后判断原本的锁状态state是否为竞争状态，如果是竞争状态则调用__futex_wake_ex陷入内核来唤醒一个等待该state变量的线程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">629      if (atomic_exchange_explicit(&amp;mutex-&gt;state, unlocked,</span><br><span class="line">630                                   memory_order_release) == locked_contended) &#123;</span><br><span class="line">658          __futex_wake_ex(&amp;mutex-&gt;state, shared, 1);</span><br><span class="line">659      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-pthread-cond"><a href="#2-3-2-pthread-cond" class="headerlink" title="2.3.2 pthread_cond"></a>2.3.2 pthread_cond</h3><p>条件变量pthread_cond，2个典型操作wait和signal，等待和发射某个条件，对应的底层实现分别是futex_wait和futex_wake。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_wait(pthread_cond_t* cond_interface, pthread_mutex_t* mutex) &#123; </span><br><span class="line">    int status = __futex_wait_ex(&amp;cond-&gt;state, cond-&gt;process_shared(), old_state,</span><br><span class="line">                               use_realtime_clock, abs_timeout_or_null);</span><br><span class="line">&#125;</span><br><span class="line">int pthread_cond_signal(pthread_cond_t* cond_interface) &#123;</span><br><span class="line">  __futex_wake_ex(&amp;cond-&gt;state, cond-&gt;process_shared(), thread_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-pthread-rwlock"><a href="#2-3-3-pthread-rwlock" class="headerlink" title="2.3.3 pthread_rwlock"></a>2.3.3 pthread_rwlock</h3><p>  读写锁，加读锁或写锁时，如果遇到互斥情况，通过futex_wait陷入内核休眠等待。释放读写锁时，通过futex_wake陷入内核唤醒等锁线程</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock_interface) &#123;</span><br><span class="line">      futex_result = __futex_wait_ex(&amp;rwlock-&gt;pending_writer_wakeup_serial, rwlock-&gt;pshared,</span><br><span class="line">                                     old_serial, use_realtime_clock, abs_timeout_or_null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __pthread_rwlock_timedrdlock(pthread_rwlock_internal_t* rwlock, bool use_realtime_clock,</span><br><span class="line">                                        const timespec* abs_timeout_or_null) &#123;</span><br><span class="line">      futex_result = __futex_wait_ex(&amp;rwlock-&gt;pending_reader_wakeup_serial, rwlock-&gt;pshared,</span><br><span class="line">                                     old_serial, use_realtime_clock, abs_timeout_or_null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int pthread_rwlock_unlock(pthread_rwlock_t* rwlock_interface) &#123;</span><br><span class="line">    __futex_wake_ex(&amp;rwlock-&gt;pending_writer_wakeup_serial, rwlock-&gt;pshared, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-内核社区的futex优化方案"><a href="#3-内核社区的futex优化方案" class="headerlink" title="3. 内核社区的futex优化方案"></a><strong>3. 内核社区的futex优化方案</strong></h1><p>谷歌通过增加内核futex_swap接口，实现用户态任务调度框架 SwitchTo，来提高两个线程唤醒+休眠的效率。并在此基础上实现direct-thread-switch功能，使被唤醒线程直接利用即将休眠的线程时间片运行，减少调度开销。优化主要是在线程协作的场景，例如IPC通信，client线程切换到特定的server线程，或者server线程切换回到client线程。</p>
<p>移动终端厂商利用futex传递Ux属性，使锁的owner线程继承Ux属性一段时间。具备Ux属性的线程在调度、io、内存等资源的竞争上更优先，owner线程执行更快，这样可以减少原Ux线程等待该futex的时间。</p>
<p>下面分5节分别介绍futex_swap、current_cpu，direct-thread-switch、futex vip优化思路，及实际调试验证结果。</p>
<h2 id="3-1-futex-swap"><a href="#3-1-futex-swap" class="headerlink" title="3.1 futex_swap"></a>3.1 <strong>futex_swap</strong></h2><p>在谷歌内部有一套闭源的用户态任务调度框架 SwitchTo，这个框架可以为谷歌提供延迟敏感的服务，对运行的内容进行细粒度的用户空间控制/调度，它可以让内核来实现上下文的切换，同时将任务何时切换，何时恢复的工作交给了用户态的程序来做，这样既可以实现在任务间协作式切换的功能，又可以不丧失内核对于任务的控制和观察能力。这是使用 SwitchTo 和使用其他线程间切换的组件的上下文切换性能对比，可以看到在使用 SwitchTo 后切换的性能比其他组件提高了一个数量级别。</p>
<p><img src="6.png" alt=""></p>
<p>谷歌工程师Peter Oskolkov <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x70;&#111;&#x73;&#107;&#x40;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;">&#x70;&#111;&#x73;&#107;&#x40;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a>向 LKML（Linux Kernel Mail List） 提出的补丁中有关 futex_swap() 的实现。可以确定的是，SwitchTo 构建在这个futex_swap内核函数之上。futex_swap接口引出：[2] <a href="https://lore.kernel.org/lkml/48058b850de10f949f96b4f311adb649b1fb3ff2.camel@posk.io/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/48058b850de10f949f96b4f311adb649b1fb3ff2.camel@posk.io/</a></p>
<p>对于一些线程交互的场景，例如线程T1与线程T2协助完成一项任务，T1完成一个阶段任务后，需要移交给T2然后等待T2的结果，T2完成阶段任务后再移交给T1。常见的RPC通信一般都是这种交互模式，例如client唤醒server执行相应的任务，client自己休眠，然后server执行完成后唤醒client。用futex操作简化成下面的三个步骤。</p>
<blockquote>
<blockquote>
<p>a. T1: futex-wake T2, futex-wait<br>b. T2: wakes, does what it has been woken to do<br>c. T2: futex-wake T1, futex-wait</p>
</blockquote>
</blockquote>
<p>其中步骤a和c都有2次系统调用，如果有一个futex内核接口，能一次实现两个过程，即一个接口完成1个线程的唤醒和1个线程的休眠，将会带来一些的性能提升。</p>
<p><img src="7.png" alt=""></p>
<p>futex_swap(uaddr，val，abs_time，uaddr2) 流程：</p>
<ol>
<li>获得等待在 uaddr2 上的预备唤醒队列，记录队列第一个任务为 next，对其他任务则执行唤醒。</li>
<li>对 uaddr1 执行 futex_wait()，传入 next。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_swap</span><span class="params">(u32 __user *uaddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, u32 val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">ktime_t</span> *abs_time, u32 __user *uaddr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        u32 <span class="built_in">bitset</span> = FUTEX_BITSET_MATCH_ANY;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        DEFINE_WAKE_Q(wake_q);</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = prepare_wake_q(uaddr2, flags, <span class="number">1</span>, <span class="built_in">bitset</span>, &amp;wake_q);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (!wake_q_empty(&amp;wake_q)) &#123;</span><br><span class="line">                <span class="comment">/* At most one wakee can be present. Pull it out. */</span></span><br><span class="line">                next = container_of(wake_q.first, struct task_struct, wake_q);</span><br><span class="line">                next-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> futex_wait(uaddr, flags, val, abs_time, <span class="built_in">bitset</span>, next);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futex_wait_queue_me</span><span class="params">(struct futex_hash_bucket *hb, struct futex_q *q,</span></span></span><br><span class="line"><span class="function"><span class="params">-                                struct hrtimer_sleeper *timeout)</span></span></span><br><span class="line">+                                struct hrtimer_sleeper *timeout,</span><br><span class="line">+                                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">+                <span class="keyword">if</span> (!timeout || timeout-&gt;task) &#123;</span><br><span class="line">+                        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">+                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">+                                 * wake_up_process() below will be replaced</span></span><br><span class="line"><span class="comment">+                                 * in the next patch with</span></span><br><span class="line"><span class="comment">+                                 * wake_up_process_prefer_current_cpu().</span></span><br><span class="line"><span class="comment">+                                 */</span></span><br><span class="line">+                                wake_up_process(next);</span><br><span class="line">+                                put_task_struct(next);</span><br><span class="line">+                                next = <span class="literal">NULL</span>;</span><br><span class="line">+                        &#125;</span><br><span class="line">                         freezable_schedule();</span><br><span class="line">+                &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>移植到Android平台后，实际测试数据结果futex_swap较FUTEX_WAKE_WAIT相差不大，与社区的提升29.5%有一定出入，不知是不是有什么前置条件。</p>
<p><img src="8.png" alt=""></p>
<p>为了究其原因，从耗时角度对两种运行模式进行拆解，得到下面的流程图。在多核情况下，T1和T2线程会分别在不同cpu上运行。</p>
<p><img src="9.png" alt=""></p>
<p><img src="10.png" alt=""></p>
<p>从整体上对比分析，FUTEX_SWAP相比FUTEX_WAKE_WAIT，虽然少了2次syscall的耗时，但是这2次都是在并行的时间里完成的，并不影响测试用例链路耗时，仅仅是减少了系统的整体负载损耗。经过抽离简化，2种模式下的执行耗时其实都是下面这样，并没有多大差异，所以耗时相同也符合预期。</p>
<p><img src="11.png" alt=""></p>
<p>虽然futex_swap操作并没有能减少2个线程切换的耗时，但是成功将futex_wake+futex_wait操作融合为一个系统调用，为后续的深度优化提供了可能。</p>
<h2 id="3-2-wake-up-process-prefer-current-cpu"><a href="#3-2-wake-up-process-prefer-current-cpu" class="headerlink" title="3.2 wake_up_process_prefer_current_cpu"></a>3.2 <strong>wake_up_process_prefer_current_cpu</strong></h2><p>谷歌工程师 Peter Oskolkov的优化patch[3] ，<a href="https://lore.kernel.org/lkml/d5cf58486a6a5e41581bed9183e8a831908ede0b.camel@posk.io/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/d5cf58486a6a5e41581bed9183e8a831908ede0b.camel@posk.io/</a></p>
<p>在T1通过futex_swap操作唤醒T2并休眠自己时，优先将T2选核到T1的cpu上。</p>
<p><img src="12.png" alt=""></p>
<p>优化patch比较简单，在try_to_wake_up时传入自定义的WF_CURRENT_CPU标志位，在select_task_rq_fair选核时，判断如果有该标志位就将T2的cpu选到当前T1的cpu。这样T1 通过schedule()调度出去时，在next = pick_next_task(rq, prev, &amp;rf)中，极大概率可以直接选中T2，进行无缝切换。同理T2切换到T1时也是如此。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/futex.c b/kernel/futex.c</span><br><span class="line">index f3833190886f..a426671e4bbb <span class="number">100644</span></span><br><span class="line">--- a/kernel/futex.c</span><br><span class="line">+++ b/kernel/futex.c</span><br><span class="line">@@ <span class="number">-2646</span>,<span class="number">12</span> +<span class="number">2646</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futex_wait_queue_me</span><span class="params">(struct futex_hash_bucket *hb, struct futex_q *q,</span></span></span><br><span class="line"><span class="function"><span class="params">                  */</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">if</span> (!timeout || timeout-&gt;task) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">if</span> (next) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">-                                wake_up_process(next);</span></span></span><br><span class="line"><span class="function"><span class="params">+                                wake_up_process_prefer_current_cpu(next);</span></span></span><br><span class="line"><span class="function"><span class="params">                                 put_task_struct(next);</span></span></span><br><span class="line"><span class="function"><span class="params">                                 next = <span class="literal">NULL</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">                         &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span></span></span><br><span class="line"><span class="function"><span class="params">index <span class="number">9</span>a2fbf98fd6f..f894b3e6c9ed <span class="number">100644</span></span></span></span><br><span class="line"><span class="function"><span class="params">--- a/kernel/sched/core.c</span></span></span><br><span class="line"><span class="function"><span class="params">+++ b/kernel/sched/core.c</span></span></span><br><span class="line"><span class="function"><span class="params">@@ <span class="number">-6180</span>,<span class="number">6</span> +<span class="number">6180</span>,<span class="number">11</span> @@ <span class="keyword">void</span> sched_setnuma(struct task_struct *p, <span class="keyword">int</span> nid)</span></span></span><br><span class="line"><span class="function"><span class="params"> &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> #endif <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">+<span class="keyword">int</span> wake_up_process_prefer_current_cpu(struct task_struct *next)</span></span></span><br><span class="line"><span class="function"><span class="params">+&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+        <span class="keyword">return</span> try_to_wake_up(next, TASK_NORMAL, WF_CURRENT_CPU);</span></span></span><br><span class="line"><span class="function"><span class="params">+&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">+</span></span></span><br><span class="line"><span class="function"><span class="params"> #ifdef CONFIG_HOTPLUG_CPU</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span></span></span><br><span class="line"><span class="function"><span class="params">index <span class="number">538b</span>a5d94e99.<span class="number">.80</span>f927bb62eb <span class="number">100644</span></span></span></span><br><span class="line"><span class="function"><span class="params">--- a/kernel/sched/fair.c</span></span></span><br><span class="line"><span class="function"><span class="params">+++ b/kernel/sched/fair.c</span></span></span><br><span class="line"><span class="function"><span class="params">@@ <span class="number">-6656</span>,<span class="number">6</span> +<span class="number">6656</span>,<span class="number">9</span> @@ select_task_rq_fair(struct task_struct *p, <span class="keyword">int</span> prev_cpu, <span class="keyword">int</span> sd_flag, <span class="keyword">int</span> wake_f</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> want_affine = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> sync = (wake_flags &amp; WF_SYNC) &amp;&amp; !(current-&gt;flags &amp; PF_EXITING);</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">+        <span class="keyword">if</span> ((wake_flags &amp; WF_CURRENT_CPU) &amp;&amp; cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span></span></span><br><span class="line"><span class="function"><span class="params">+                <span class="keyword">return</span> cpu;</span></span></span><br><span class="line"><span class="function"><span class="params">+</span></span></span><br></pre></td></tr></table></figure>
<p>通过实测数据，经过current_cpu优化后的FUTEX_SWAP执行耗时降低92.69%，令人惊讶。</p>
<p><img src="13.png" alt=""></p>
<p>通过trace分析，截取2种测试模式运行时三次切换的片段，FUTEX_WAKE_WAIT时2个线程在不同cpu上来回切换，cpu实际频率只有500MHz，因为负载分配在2个cpu上，每个cpu的占用率不到50%。current_cpu优化后的FUTEX_SWAP时，2个线程跑在同一个cpu上，实际cpu频率有2.5GHz，因为负载集中在1个cpu上，cpu的占用率接近100%，所以频率自动调的也高。虽然速度提升10倍，但是其中有5倍是cpu频率影响。</p>
<p>FUTEX_WAKE_WAIT模式：3轮切换耗时182us</p>
<p><img src="14.png" alt=""></p>
<p>FUTEX_SWAP模式：3轮切换耗时18.4us</p>
<p><img src="15.png" alt=""></p>
<p>综上分析，执行时间降低10倍原因:</p>
<ol>
<li>cpu频率高5倍：跑在单核上，cpu利用率高，更有效触发提频</li>
<li>调度效率高2倍：同一个cpu，无缝切换，避免从idle退出的耗时，调度尾延更低，同时cache命中率更高。</li>
</ol>
<p>所以从patch优化效率上来看，实际优化了2倍。在Android上，binder作为主要的IPC通信手段，运行场景跟这很类似，一个binder线程A唤醒另一个binder线程B，线程B执行完任务后反过来唤醒线程A，2个线程交替执行。如果把这里的current_cpu优化放在binder上，或许也有一定的优化效果。</p>
<h2 id="3-3-direct-thread-switch"><a href="#3-3-direct-thread-switch" class="headerlink" title="3.3 direct-thread-switch"></a>3.3 <strong>direct-thread-switch</strong></h2><p>脱离 Android 的全自研鸿蒙 next 宣称支持轻量级线程并发模型，可能就是 direct-thread-switch，已合入服务器欧拉操作系统。</p>
<p><img src="16.png" alt=""></p>
<p>本节内容引自华为欧拉操作系统论坛：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在操作系统中，线程是一个独立的运行单元，一般认为每个线程是独立运行的；但是在实际应用中，经常出现一个业务功能需要多个线程协同处理，这时候线程和线程之间存在逻辑上的关联关系，经常出现线程之间的唤醒与被唤醒。线程的每次“交互”需要内核调度模块参与，一次完整的交互，内核调度模块需要参与选核，入队列，更新负载信息，选任务等流程。系统中如果线程比较多（有数千个线程）,线程负载比较小的场景下，会导致内核调度开销比较大，而且线程之间交互的效率比较低（线程B需要入队列，等待CPU资源，导致runable的时间比较长）。在《The Case <span class="keyword">for</span> Thread Migration- Predictable IPC in a Customizable <span class="keyword">and</span> Reliable OS》这篇论文中讲述了一种新的线程切换思路：执行实体与调度实体分离。在同步IPC场景中，线程之间发生切换，只切换执行实体不切换调度实体，从而提升IPC的通信效率，降低调度开销。通过测试，这种技术可以使得同步IPC的效率提升近<span class="number">10</span>倍。 引用</span><br><span class="line">执行实体与调度实体分离的技术适用于微内核架构，在linux系统中并不适用，主要因为linux系统在设计之初就将执行实体与调度实体融合成一个结构体：task_struct, 经过多年的开发，task_struct结构体已经散布到linux内核的各个模块中，此时拆分执行实体和调度实体，工作量大，难度高，质量难以保障。 我们可以重新审视执行实体和调度实体分离的技术原理，在线程交互时，切换执行实体而不切换调度实体，本质上是利用了原任务的剩余时间片来运行新任务，bypass调度，降低了内核调度开销，同时原任务直接切换到新任务时，新任务不用重新入队列等待CPU资源，这时没有尾时延（runnable时间），大大提升线程交互的效率。这种往往用在同步线程模型中（原任务进入休眠，新任务执行）。</span><br></pre></td></tr></table></figure>
<p>将原任务直接切换到新任务，bypass调度的技术命名为direct-thread-switch，bypass调度的前提必须是利用原任务的剩余时间片，否则会打破CFS调度的公平性。具体由briansun <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#105;&#x6d;&#98;&#x72;&#105;&#x61;&#110;&#x73;&#x75;&#110;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#105;&#x6d;&#98;&#x72;&#105;&#x61;&#110;&#x73;&#x75;&#110;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a>提交到华为欧拉操作系统论坛上实现的patch</p>
<p><a href="https://gitee.com/openeuler/kernel/commit/dad99a5750c4c942300c6626888a6ad52e62bf24" target="_blank" rel="noopener">https://gitee.com/openeuler/kernel/commit/dad99a5750c4c942300c6626888a6ad52e62bf24</a></p>
<p>从patch的描述看，direct-thread-switch是在futex_swap的基础上实现的，是对futex_swap的进一步优化。futex_swap将futex_wake+futex_wait融合到一次系统调用，实现线程T2的唤醒和线程T1的休眠，涉及2次调度。而direct-thread-switch则是在此基础上，bypass调度，直接利用线程T1的剩余时间片来运行线程T2，避免了2次调度的开销。由于是基于futex_swap，所以使用场景也同样有限制，典型的场景是IPC通信，线程模型为T1-&gt;T2—-T2-&gt;T1。</p>
<p>direct-thread-switch代码实现很复杂，目前也只理解了很少一部分。在原有futex_swap基础上，在T1-&gt;T2线程切换时另起炉灶，替代了原有的schedule()函数，以__direct_thread_switch(next)函数直接从T1切换到T2。并提出共享调度实体shared sched_entry的概念，来保证CFS调度的公平性及调度器稳定性。</p>
<p>futex_swap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+                                <span class="keyword">if</span> (flags &amp; FUTEX_FLAGS_DTS_MODE)</span><br><span class="line">+                                       do_dts_switch = direct_thread_switch(next);</span><br></pre></td></tr></table></figure>
<p>由于内核版本差异等因素，该patch并未移植成功，无法实际测试效果，借用openEuler内核社区测试了(futex_wake+futex_wait)、futex_swap、(futex_swap+direct-thread-switch)的切换耗时，futex_swap相比(futex_wake+futex_wait)提升了29.5%，(futex_swap+direct-thread-switch)相比(futex_wake+futex_wait)提升了37.1%</p>
<p><img src="17.png" alt=""></p>
<h2 id="3-4-futex-vip插队优化"><a href="#3-4-futex-vip插队优化" class="headerlink" title="3.4 futex vip插队优化"></a>3.4 <strong>futex vip插队优化</strong></h2><p>目前已有的针对锁的优化特性都是针对内核锁，用户空间锁则不在这些优化范围内，两者有共性。</p>
<p>如果某个用户锁有大量线程并发竞争在等待，等锁造成的响应延迟将非常大。对于用户体验相关的前台vip线程来说非常不友好，需要适当向vip线程倾斜。线程B被加入futex等待队列，这个队列排序原则是RT线程按照其线程优先级0~99来排序，普通线程全部按照优先级100，然后FIFO先进先出原则排序。用户体验相关的vip线程很多是普通线程，所以在这里排队没有优势，需要改变规则，将vip线程排在普通线程之前，RT线程之后。</p>
<p><img src="18.png" alt=""></p>
<p>通过测试用例，创建一个持锁线程A(demo 10622)，然后创建9个普通线程B和一个vip线程C(demo 10630)。线程A先持mutex锁，9个普通线程B等锁，线程C等锁，然后通过命令将线程C设置为vip线程。</p>
<p>当线程A释放锁时，可以看到vip线程C最先被唤醒，即使是最后一个入队也最先被唤醒，其他普通线程则是按照等锁入队FIFO顺序唤醒。所以vip线程的等锁时间也是最短的</p>
<p><img src="19.png" alt=""></p>
<p>为了防止普通线程饿死，还采取了规避措施，如果队列中第一个普通线程等待时间已经超过一定时间，则本次不做vip插队操作。可以看到，当vip线程 12446在等锁入队时，前面其他线程等锁时间超过347.2ms，所以本次不插队，vip线程按照入队顺序出队。</p>
<p><img src="20.png" alt=""></p>
<h2 id="3-5-futex-vip继承优化"><a href="#3-5-futex-vip继承优化" class="headerlink" title="3.5 futex vip继承优化"></a>3.5 <strong>futex vip继承优化</strong></h2><p>在 vip_task 特性中，vip线程享有CFS优先调度、内核锁插队、内存快速分配，binder 优先与继承等优势，vip线程在等普通线程持有的用户空间锁时，普通线程没有相应的资源倾斜，可能导致其在临界区运行很慢，造成”优先级”翻转，vip线程的优势也得不到发挥。参考进程优先级继承的优化思路，vip线程在等用户锁时，临时赋予non-vip线程vip特权一段时间，让其尽快执行脱离临界区，最大程度减少vip线程的等待时延。</p>
<p><img src="21.png" alt=""></p>
<p>futex vip继承在内核实现上，有一些需要解决的问题，即vip线程在等futex锁时，需要知道持锁的线程holder是谁，才能针对持锁线程做boost。不同于内核中的mutex，现有基于futex实现的接口，并没有包含锁owner信息，所以需要对用户空间中相关接口做调整。</p>
<p>对于native的pthread_mutex锁，在调用futex_wait时增加一个参数用来传递futex_info信息，其中就包括owner_id。</p>
<p>内核实现，首先判断等锁线程是不是vip线程，如果是vip则解析其owner_id参数，找到owner task并对其赋予临时的vip特权，直到该owner通过futex_wake来唤醒等待的vip线程，解除vip特权。</p>
<h1 id="4-futex-vip收益测试"><a href="#4-futex-vip收益测试" class="headerlink" title="4. futex vip收益测试"></a><strong>4. futex vip收益测试</strong></h1><p>由于3.1-3.3节的优化依赖于上层的具体应用场景来实现，在安卓上并未找到合适的软件场景，所以没有做过多收益测试。3.4，3.5节契合安卓手机场景，我们分别模拟用户使用场景测试做了实测数据，测得对比数据。</p>
<p>正常使用场景，vip等futex的最大等待时间减少70%，超过100ms的次数减少25%，vip线程等futex总时间减少24%。</p>
<p>重载使用场景，vip等futex的最大等待时间减少67%，超过100ms的次数减少38%，超过200ms次数减少45%，vip线程等futex总时间减少21%。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h1><p>本文首先介绍了linux的futex系统调用，及基于futex的同步机制。然后列举了futex在Android上的几种应用，包括ART锁、JUC锁、pthread锁。</p>
<p>介绍了几种futex性能优化相关的开源案例，其中futex_swap(包含current_cpu)优化和direct-thread-switch优化，线程切换性能分别提升了29.5%和37.1%。futex vip插队及属性继承优化，最大程度保证用户交互线程的响应速度。</p>
<p>最后futex vip插队及属性继承优化，实际模拟用户场景测试收益，取得不错的收益。改善优先级翻转和锁等待的性能延时问题，提高前台应用响应速度，降低偶现卡顿的机率。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2024/05/16/TouchScreen-Basics/" data-toggle="tooltip" data-placement="top" title="指尖上的科技：智能手机触摸屏技术与功耗优化">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2024/01/12/Qcom-Thermal-Engine-frame-analysis/" data-toggle="tooltip" data-placement="top" title="手机温控中枢：高通 Thermal Engine 框架分析">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1-futex简介"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. futex简介</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-用户态futex同步机制"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.1 用户态futex同步机制</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-内核态futex系统调用"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">1.2 内核态futex系统调用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2-futex在Android的应用"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2. futex在Android的应用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-ART锁"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">2.1 ART锁</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-JUC锁"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.2 JUC锁</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-pthread锁"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">2.3 pthread锁</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-1-pthread-mutex"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">2.3.1 pthread_mutex</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-2-pthread-cond"><span class="toc-nav-number">2.3.2.</span> <span class="toc-nav-text">2.3.2 pthread_cond</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-3-pthread-rwlock"><span class="toc-nav-number">2.3.3.</span> <span class="toc-nav-text">2.3.3 pthread_rwlock</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3-内核社区的futex优化方案"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3. 内核社区的futex优化方案</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-futex-swap"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">3.1 futex_swap</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-wake-up-process-prefer-current-cpu"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">3.2 wake_up_process_prefer_current_cpu</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-3-direct-thread-switch"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">3.3 direct-thread-switch</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-4-futex-vip插队优化"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">3.4 futex vip插队优化</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-5-futex-vip继承优化"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">3.5 futex vip继承优化</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4-futex-vip收益测试"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4. futex vip收益测试</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5-总结"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. 总结</span></a></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Performance" title="Performance">Performance</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; meizu 2025 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="../../../../js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="../../../../js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="../../../../js/hux-blog.min.js"></script>


<!-- Search -->

<script src="../../../../js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://kernel.meizu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
