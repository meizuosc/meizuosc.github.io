<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="一个有内涵的技术分享平台">
    <meta name="keyword"  content="meizu,kernel,魅族">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Android Binder - 魅族内核团队
        
    </title>

    <link rel="canonical" href="https://kernel.meizu.com/2019/01/02//android-binder.html/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="../../../../../css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="../../../../../css/dusign-light.css">

        
<link rel="stylesheet" href="../../../../../css/dusign-common-light.css">

        
<link rel="stylesheet" href="../../../../../css/font-awesome.css">

        
<link rel="stylesheet" href="../../../../../css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="../../../../../css/highlight.css">


    
<link rel="stylesheet" href="../../../../../css/widget.css">


    
<link rel="stylesheet" href="../../../../../css/rocket.css">


    
<link rel="stylesheet" href="../../../../../css/signature.css">


    
<link rel="stylesheet" href="../../../../../css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="../../../../../css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('../../../../../../img/default.jpg')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#binder" title="binder">binder</a>
                            
                        </div>
                        <h1>Android Binder</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Peng Weilin on
                            2019-01-02
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">魅族内核团队</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="1、binder原理"><a href="#1、binder原理" class="headerlink" title="1、binder原理"></a>1、binder原理</h1><p>纵观现有市面上所有讲binder的文章，都存在一个最大的问题：没有讲清楚binder对象是什么？<br>不清楚binder对象是什么，那就不能理解handle是什么？不能理解什么时候是binder什么时候是handle，那就不能真正理解整个IPC的通讯过程。</p>
<p>我们首先回到binder的目的，就是IPC(Inter-Process Communication)进程间通讯。那么怎么样实现进程间通讯呢？要素有三个：</p>
<ul>
<li>函数指针；</li>
<li>函数参数；</li>
<li>函数返回值；</li>
</ul>
<p>binder通讯的本质实际上非常简单，就是client、server双方在共享内存的基础上封装成自定义api函数，并无神奇之处。我们看看他是怎么和IPC三要素对应上的：</p>
<h2 id="1-1、IPC函数指针"><a href="#1-1、IPC函数指针" class="headerlink" title="1.1、IPC函数指针"></a>1.1、IPC函数指针</h2><p>binder的service_server可以向service_client提供service服务，但反过来不行。所以binder service其实是单向的，只有service_server端才能提供service函数，且函数只能在service_server端运行。</p>
<p>大部分情况下：<strong>service_server端提供的一组IPC服务本地函数</strong>，就是<strong>binder对象</strong>。</p>
<p>例如，mediaserver注册的一系列service中的一个”media.player”：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/frameworks/</span>av<span class="regexp">/media/</span>mediaserver/main_mediaserver.<span class="string">cpp:</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">    MediaPlayerService:</span>:instantiate();</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="regexp">/frameworks/</span>av<span class="regexp">/media/</span>libmediaplayerservice/MediaPlayerService.<span class="string">cpp:</span></span><br><span class="line"><span class="keyword">void</span> <span class="string">MediaPlayerService:</span>:instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service_server提供了一组可以在server本地运行的函数，即<strong>binder对象</strong>。如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/libmedia/<span class="type">IMediaPlayerService</span>.cpp:</span><br><span class="line"><span class="title">status_t</span> <span class="type">BnMediaPlayerService</span>::onTransact(</span><br><span class="line">    uint32_t code, const <span class="type">Parcel</span>&amp; <span class="class"><span class="keyword">data</span>, <span class="type">Parcel</span>* reply, uint32_t flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayerClient</span>&gt; client =</span><br><span class="line">                interface_cast&lt;<span class="type">IMediaPlayerClient</span>&gt;(<span class="class"><span class="keyword">data</span>.readStrongBinder());</span></span><br><span class="line">            audio_session_t audioSessionId = (audio_session_t) <span class="class"><span class="keyword">data</span>.readInt32();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayer</span>&gt; player = create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(player));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE_MEDIA_RECORDER</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            const <span class="type">String16</span> opPackageName = <span class="class"><span class="keyword">data</span>.readString16();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaRecorder</span>&gt; recorder = createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(recorder));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在service_client端可以通过<strong>handle</strong>来引用这个<strong>binder对象</strong>，还封装了一系列与之对应的函数来组织数据。但是这些函数实际上是通讯用的，函数的实际功能并不能在client本地执行：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/av/media/libmedia/<span class="type">IMediaPlayerService</span>.cpp:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">BpMediaPlayerService</span>: public <span class="type">BpInterface</span>&lt;<span class="type">IMediaPlayerService</span>&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    virtual sp&lt;<span class="type">IMediaPlayer</span>&gt; create(</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">sp</span>&lt;<span class="type">IMediaPlayerClient</span>&gt;&amp; <span class="title">client</span>, <span class="title">audio_session_t</span> <span class="title">audioSessionId</span>) &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IMediaPlayerService</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeStrongBinder(<span class="type">IInterface</span>::<span class="title">asBinder</span>(<span class="title">client</span>));</span></span><br><span class="line"><span class="class">        data.writeInt32(<span class="title">audioSessionId</span>);</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        remote()-&gt;transact(<span class="type">CREATE</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return interface_cast&lt;<span class="type">IMediaPlayer</span>&gt;(<span class="title">reply</span>.<span class="title">readStrongBinder</span>());</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    virtual sp&lt;<span class="type">IMediaRecorder</span>&gt; createMediaRecorder(<span class="title">const</span> <span class="type">String16</span> &amp;<span class="title">opPackageName</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IMediaPlayerService</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeString16(<span class="title">opPackageName</span>);</span></span><br><span class="line"><span class="class">        remote()-&gt;transact(<span class="type">CREATE_MEDIA_RECORDER</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return interface_cast&lt;<span class="type">IMediaRecorder</span>&gt;(<span class="title">reply</span>.<span class="title">readStrongBinder</span>());</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>所以理解<strong>binder对象</strong>和<strong>handle</strong>是非常关键的。service_server端需要在本地执行函数，所以执行时函数调用的3要素(函数、参数、返回值)都必须是本地的，所以它必须拥有一组函数的<strong>binder对象</strong>；service_client端不需要在本地执行，所以它没有函数集的<strong>binder对象</strong>，它只有函数集的远端引用<strong>handle</strong>。</p>
<p>binder通讯的3个主角：service_mannager、service_server、service_client。在各种场景下，分别的<strong>binder对象</strong>和<strong>handle</strong>关系如下：</p>
<table border="1">
<caption> binder object_handle </caption>

<tr>
<th style="width: 200px;">场景</th>
<th style="width: 400px;">client</th>
<th style="width: 400px;">server</th>
</tr>

<tr>
<td> service_manage初始化 </td>
<td>
service_manager:<br/><br/>
本地的binder对象为svcmgr_handler()函数集；<br/>
通过ioctl BINDER_SET_CONTEXT_MGR命令把该binder对象注册成全局handle0；<br/>
</td>
<td>
binder device：<br/><br/>
创建handle0引用，指向service_manager
</td>
</tr>

<tr>
<td> service_server的addService </td>
<td>
service_server:<br/><br/>
target handle：handle0<br/>
data：binder对象为一组本地service函数集；<br/>
</td>
<td>
service_manager：<br/><br/>
binder驱动会创建对该binder对象的引用handle<br/>
通过SVC_MGR_ADD_SERVICE命令把该handle加入到service_manage的handle链表中；<br/>
</td>
</tr>

<tr>
<td> service_client的get_service </td>
<td>
service_client:<br/><br/>
target handle：handle0<br/>
data：service name。整个过程中没有binder对象的参与。<br/>
向service_manager获取service_server的service函数的handle；<br/>
</td>
<td>
service_manage：<br/><br/>
SVC_MGR_GET_SERVICE命令，通过service的name在service_manage的handle链表中查找对应的handle，并且把handle返回给service_client；<br/>
这样对于service_server的binder对象，service_client和service_manage都持有它的handle了；
</td>
</tr>

<tr>
<td> service_client调用service </td>
<td>
service_client:<br/><br/>
target handle：serive handle0。上一步获取的handle。<br/>
data：调用参数。调用参数中也可能包含handle/binder对象。(看server端的处理)<br/>
</td>
<td>
service_server：<br/><br/>
驱动把target handle翻译成本地binder对象，调用对象提供的本地函数。<br/>
对于data中可能包含的含handle/binder对象的处理：<br/>
1、如果包含的handle是本进程binder的引用，把它翻译成本地binder，在本地可以运行；<br/>
2、如果包含的handle不是本进程binder的引用，只能给它创建一份新的引用handle。这个handle也不能在server进程中运行，只能向其他service_server请求服务；<br/>
3、不可能包含binder对象，因为client进程的binder对象在service_server进程中无法运行；<br/>
</td>
</tr>

</table>

<p>衍生出的原则如下：</p>
<ul>
<li>service_server类的进程只有<strong>binder对象</strong>，没有<strong>handle</strong>(除了handle0)，因为它所有操作都必须本地执行，引用远程对象毫无意义；</li>
<li>service_client类的进程只有<strong>handle</strong>，没有<strong>binder对象</strong>，因为它需要远程执行service不需要本地执行；</li>
<li>service_mannager进程同时有<strong>binder对象</strong>和<strong>handle</strong>，它本地<strong>binder对象</strong>的作用就是操作所有其他进程的<strong>handle</strong>；</li>
</ul>
<h2 id="1-2、IPC函数参数"><a href="#1-2、IPC函数参数" class="headerlink" title="1.2、IPC函数参数"></a>1.2、IPC函数参数</h2><p>如上一节描述，service_client可以通过名字向service_manage查询得到handle。这个handle就相当于远程的函数集指针。<br>但是对于一个函数调用，我们除了需要函数指针，还需要传递参数。  </p>
<p>binder使用parcel方式来打包函数参数和返回值。parcel可以用来传递几种类型的数据：</p>
<ul>
<li>普通类型的少量数据；</li>
<li>binder对象/handle(struct flat_binder_object);</li>
<li>fd(struct binder_fd_object)；</li>
</ul>
<p>下面详细描述每种情况的parcel包格式和承载的内容。</p>
<ul>
<li>1、普通类型的少量数据：</li>
</ul>
<p>这种普通类型(int/long/string…)的少量数据存储最为简单，存入时按照一定的顺序存入，取出时按照数据的排列格式取出即可。</p>
<ul>
<li>2、<strong>binder对象</strong>/<strong>handle</strong>(struct flat_binder_object)：</li>
</ul>
<p>这一类型数据的parcel包格式如下： </p>
<p><img src="binder_parcel_binder_object_format.png" alt="binder_parcel_binder_object_format"></p>
<p>可以看到这种类型的parcel包中包含了两种数据：data0/data1/…是普通类型数据；binder_obj0/binder_obj1/…是binder对象，binder_obj0 offset/binder_obj1 offset/…指出了了binder对象在parcel包中的偏移；</p>
<p>binder对象和handle共用结构体struct flat_binder_object。</p>
<p>上一节说过<strong>binder对象</strong>其实就是一组函数的指针，但是一个指针只需要一个long类型就可以标识了，为什么还需要用一个结构体struct flat_binder_object来传递。我理解下来主要的思想如下：使用binder都是面向对象语言c++/java，它们把函数组也要实例化成一个对象，一个对象只有被引用时才不会被回收，远程引用也需要让本地引用加1。</p>
<p>一组service函数，对本地进程来说就是binder，对其他需要使用的进程来说需要远程引用，就是handle，是一对多的关系。关系图如下：</p>
<p><img src="binder_binderobj_and_handle.png" alt="binder_binderobj_and_handle"></p>
<p>binder object是service_server的一个“local binder object”，service_manager和service_client创建了多个远程引用“remote handle”。</p>
<p>这个其实就是binder的核心思想，binder花费了大量的代码在维护这个关系上面：</p>
<ul>
<li>[x] service_server进程在驱动中创建了binder_node节点来保存<strong>binder对象</strong>，把本进程所有的binder_node都挂载在一颗红黑树proc-&gt;nodes上；</li>
<li>[x] service_manager和service_client每个新进程对这个<strong>binder对象</strong>引用，就创建一个新的binder_ref，它的值就是<strong>handle</strong>，并回指向binder_node。并且把本进程对其他service_server的引用都挂载到两颗红黑树proc-&gt;refs_by_node/proc-&gt;refs_by_desc上。并且远程引用会增加service_server进程关于<strong>binder对象</strong>的引用计数；</li>
</ul>
<p>binder驱动负责建立起<strong>binder对象</strong>和<strong>handle</strong>之间的映射关系，创建上述的数据结构，并负责翻译：</p>
<ul>
<li>[x] service_server把本地<strong>binder对象</strong>向service_manager注册。会在service_manager进程本地建立起binder_node，驱动会在service_manager进程中建立起对应的binder_ref引用，那么service_manager进程能看到的其实就是本进程对service_server<strong>binder对象</strong>的一个引用，并不能看到<strong>binder对象</strong>原始值；</li>
<li>[x] service_client根据名字向service_manager查询service。service_manager会返回本进程的handle，在内核中该handle会转换成<strong>binder对象</strong>binder_node。因为service_client不是service的本地进程，所以service_client不能得到<strong>binder对象</strong>，它只能得到引用<strong>handle</strong>。所以再针对service的<strong>binder对象</strong>创建一份service_client进程的本地引用；</li>
<li><p>[x] service_client调用远程service_server的service。内核判断handle引用是service_server的本地对象，就把handle转换成service_server的<strong>binder对象</strong>；</p>
</li>
<li><p>3、fd(struct binder_fd_object)：</p>
</li>
</ul>
<p>parcel还能传输文件句柄fd，此时的包格式如下：</p>
<p><img src="binder_parcel_fd_object_format.png" alt="binder_parcel_fd_object_format"></p>
<p>传输fd的意义何在呢？当binder的两个进程间需要传输大量的数据。例如：图像声音数据、或者是一个对象。可以在匿名共享内存(Ashmem)中创建一块区域，源进程会得到一个相应的fd，再把这个fd使用binder传递给目的进程，就可以共享数据了。</p>
<p>需要特别说明的是对象的传递，在同一个进程内进行函数调用的话，参数对象通常是使用引用的方式传递的。但是如果是跨进程的调用，是没有办法引用的，只有把整个对象复制过去。这种操作叫做对象的序列化，java称为Serializable，android有优化的实现Parcelable。注意对象序列化的Parcelable和binder的parcel数据封装不是一回事，尽管他们原理上很相似。binder并没有提供对象Parcelable的接口，如果我们要跨进程传输对象，只能把对象序列化(Parcelable)到匿名共享内存中，再把对应fd通过binder传输给目的进程。</p>
<p><img src="binder_fdobject_translate.png" alt="binder_fdobject_translate"></p>
<p>binder驱动在检测到传输的是fd，会在新的进程中分配一个新的fd，并指向原来的file结构，这样fd就被跨进程duplicate了。两个进程使用各自的fd对匿名共享内存区域进行mmap映射，就能访问相同的内存区域了。</p>
<h2 id="1-3、IPC函数返回值"><a href="#1-3、IPC函数返回值" class="headerlink" title="1.3、IPC函数返回值"></a>1.3、IPC函数返回值</h2><p>函数返回值也是使用和函数参数一样的parcel结构来封装数据的。就不再重复叙述。</p>
<p>上面提到的原则需要再次强调，在一次service_client和service_server之间的通讯，在传递参数和返回值时都要遵循的准则：service_client只会有<strong>handle</strong>，service_server只会有<strong>binder对象</strong>。</p>
<h2 id="1-4、binder内存"><a href="#1-4、binder内存" class="headerlink" title="1.4、binder内存"></a>1.4、binder内存</h2><p>前面说过binder通讯的本质就是在共享内存上加上一层api，我们来看看他是怎么管理共享内存的。</p>
<p><img src="binder_alloc_buffer.png" alt="binder_alloc_buffer"></p>
<p>我们可以看到：</p>
<ul>
<li>binder驱动给每个进程分配最多4M的buffer空间，这段空间在内核通过binder_proc-&gt;alloc红黑树来管理，同时通过mmap映射到进程用户空间；</li>
<li>和所有的进程通讯机制类似，这段空间相当于进程的接收邮箱inbox，其他进程发过来的消息会从其他进程用户空间复制存放到这里；</li>
<li>因为是mmap的所有本进程的用户空间访问免除了一次拷贝；</li>
<li>另外因为进程支持多个线程，所以多个线程会共享本进程的binder buffer；</li>
</ul>
<p><img src="binder_alloc_buffer_transaction.png" alt="binder_alloc_buffer_transaction"></p>
<p>我们看一下process 0、process n进程和process 1进程进行binder通讯时的buffer使用情况：</p>
<ul>
<li>首先会在process 1进程的inbox(binder buffer)空间中分配buffer；</li>
<li>binder驱动把process 0、process n进程用户空间的消息拷贝到process 1进程的inbox内核buffer中；</li>
<li>因为mmap，process 1进程的用户空间也可以看见这些消息了；</li>
</ul>
<h1 id="2、binder驱动"><a href="#2、binder驱动" class="headerlink" title="2、binder驱动"></a>2、binder驱动</h1><p>驱动是整个binder通讯的核心，java和native都是对其的封装。<br>因为binder驱动代码比较繁杂，看代码比较不好理解。结合第一章讲的基础知识和binder通讯具体场景，我们使用图来分析每一个典型场景下binder驱动内的变化。</p>
<h2 id="2-1、service-manager的初始化"><a href="#2-1、service-manager的初始化" class="headerlink" title="2.1、service_manager的初始化"></a>2.1、service_manager的初始化</h2><p><img src="binder_action_servicemanager_init.png" alt="binder_action_servicemanager_init"></p>
<p>通过上图我们可以看到具体过程：</p>
<ul>
<li>1、binder驱动为service_manager进程创建一个新的binder_node结构，赋值：.ptr=0、.cookie=0、.proc=当前proc；</li>
<li>2、把这个binder_node新节点加入到当前进程的proc-&gt;nodes红黑树中；</li>
<li>3、把binder_device的全局handle 0指针binder_device-&gt;context.binder_context_mgr_node指向新创建的binder_node；这样其他人通过handle 0指针就能找到对应binder_node，进一步找到service_manager是哪一个进程；</li>
</ul>
<p>service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。初始化过程为：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">main</span>() -&gt; <span class="title">binder_open</span>()、<span class="title">binder_become_context_manager</span>()</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2、service-server的addService"><a href="#2-2、service-server的addService" class="headerlink" title="2.2、service_server的addService"></a>2.2、service_server的addService</h2><p><img src="binder_action_serviceserver_addservice.png" alt="binder_action_serviceserver_addservice"></p>
<p>通过上图我们可以看到，在service_server向service_manager注册service的时候，在驱动中的具体流程如下：</p>
<ul>
<li>1、因为是向service_manager注册，所以target handle固定=0。通过binder_device-&gt;context找到handle 0对应的binder_node，也就找到了对应的binder_proc，找到了对应的service_manager进程；</li>
<li>2、在service_manager进程中分配binder buffer，把service_server传递过来的parcel数据全部复制进去；</li>
<li>3、翻译parcel数据中的binder对象，把binder翻译成handle；</li>
<li>4、可以看到service_manager进程的handle就是对service_server进程binder的一个引用。把handle加入到service_manager进程的handle缓存红黑树中；</li>
<li>5、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_manager进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li>
</ul>
<p>service_manager的读取响应和reply动作就不去具体分析了，因为都非常的清晰。service_manager代码在<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a>，可以具体查看。service_manager在svcmgr_handler()函数中响应service_server的SVC_MGR_ADD_SERVICE请求，最终调用do_add_service()把handle和对应的service name加到svclist链表中：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main<span class="function"><span class="params">()</span> -&gt;</span> binder_loop<span class="function"><span class="params">()</span> -&gt;</span> binder_parse<span class="function"><span class="params">()</span> -&gt;</span> svcmgr_handler<span class="function"><span class="params">()</span> -&gt;</span> do_add_service()</span><br></pre></td></tr></table></figure>
<h2 id="2-3、service-client的get-service"><a href="#2-3、service-client的get-service" class="headerlink" title="2.3、service_client的get service"></a>2.3、service_client的get service</h2><p><img src="binder_action_serviceclient_getservice_send.png" alt="binder_action_serviceclient_getservice_send"></p>
<p>如上图service_client向service_manager发送get service请求的数据比较简单：</p>
<ul>
<li>1、根据handle 0找到service_manager进程；</li>
<li>2、在service_manager进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li>
<li>3、parcel的内容中没有binder或者handle，不需要翻译；</li>
<li>4、把parcel数据和其他信息打包成binder_transaction结构，并挂载到proc-&gt;todo/thread-&gt;todo链表中，等待service_manager进程的读取；</li>
</ul>
<p><img src="binder_action_serviceclient_getservice_reply.png" alt="binder_action_serviceclient_getservice_reply"></p>
<p>上图是service_manager给service_client回复信息的过程：</p>
<ul>
<li>1、service_manager根据service name在本地svclist链表中找到对应的handle，它把handle打包进parcel并reply给service_client；</li>
<li>2、根据service_manager所在线程thread-&gt;transaction_stack字段中保存的binder_transaction结构，从.from字段可以找到service_client所在的线程(binder_thread)和进程(binder_proc)；</li>
<li>3、在service_client进程中分配binder buffer，把service_manager传递过来的parcel数据全部复制进去；</li>
<li>4、翻译parcel中打包的handle结构，判断handle指向的binder_node进程不是service_client进程，所以新建service_client进程中对binder_node新的引用。新创建handle并加入到service_client进程的handle缓存红黑树中；</li>
<li>5、这样service_client就从service_manager中获取到了service_server binder对应的引用handle；</li>
<li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li>
</ul>
<h2 id="2-4、service-client调用service"><a href="#2-4、service-client调用service" class="headerlink" title="2.4、service_client调用service"></a>2.4、service_client调用service</h2><p><img src="binder_action_serviceclient_callservice.png" alt="binder_action_serviceclient_callservice"></p>
<p>上图是service_client调用service_server的service的过程：</p>
<ul>
<li>1、service_client的target handle为上一步向service_manager查询得到的handle，根据handle能找到对应binder_node，进一步找到service_server所在进程；</li>
<li>2、在service_server进程中分配binder buffer，把service_client传递过来的parcel数据全部复制进去；</li>
<li>3、parcel中打包了函数参数，如果包含handle对象，需要进行翻译；不可能包含binder对象，因为service_client进程的binder对象在service_server进程中无法运行；</li>
<li>4、如果parcel中包含的handle指向的binder_noe和service_server是同一进程，把它翻译成本地binder，在本地可以运行；</li>
<li>5、如果parcel中包含的handle指向的binder_noe和service_server不是同一进程，那只能在service_server进程中给它创建一份新的引用handle。这个handle也不能在service_server进程中运行，只能向其他service_server请求服务；</li>
<li>6、把翻译后的parcel数据和其他信息打包成binder_transaction结构，并挂载到service_client进程的proc-&gt;todo/thread-&gt;todo链表中，等待service_client进程读取reply；</li>
</ul>
<h2 id="2-5、Scatter-gather模式"><a href="#2-5、Scatter-gather模式" class="headerlink" title="2.5、Scatter-gather模式"></a>2.5、Scatter-gather模式</h2><p>在Android O中binder增加了一种性能改进模式Scatter-gather，这是因为binder在传输IPC参数数据时，因为传输的量不大，binder实际上做了3次拷贝：</p>
<p><img src="binder_transcation_3_copy.png" alt="binder_transcation_3_copy"></p>
<p>Scatter-gather把3次copy优化成1次：</p>
<p><img src="binder_transcation_Scatter-gather_1_copy.png" alt="binder_transcation_Scatter-gather_1_copy"></p>
<p>具体的代码可以看驱动对BINDER_TYPE_PTR类型数据的处理：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">case BINDER_TYPE_PTR: &#123;</span><br><span class="line">	struct binder_buffer_object *bp =</span><br><span class="line">		to_binder_buffer_object(hdr);</span><br><span class="line">	size_t buf_left = sg_buf_end - sg_bufp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bp-&gt;length &gt; buf_left) &#123;</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got transaction with too large buffer\n"</span>,</span><br><span class="line">				  <span class="keyword">proc</span>-&gt;pid,<span class="title"> thread-&gt;pid);</span></span><br><span class="line"><span class="title"></span>	<span class="title">	return_error</span> =<span class="title"> BR_FAILED_REPLY;</span></span><br><span class="line"><span class="title"></span>	<span class="title">	return_error_param</span> = -EINVAL;</span><br><span class="line"><span class="title">		return_error_line</span> =<span class="title"> __LINE__;</span></span><br><span class="line"><span class="title"></span>	<span class="title">	goto</span> err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="title">	if</span> (copy_from_user(sg_bufp,</span><br><span class="line">			   (const<span class="title"> void</span> __user *)(uintptr_t)</span><br><span class="line"><span class="title">			   bp-&gt;buffer,</span> bp-&gt;length)) &#123;</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got transaction with invalid offsets ptr\n"</span>,</span><br><span class="line">				  <span class="keyword">proc</span>-&gt;pid,<span class="title"> thread-&gt;pid);</span></span><br><span class="line"><span class="title"></span>	<span class="title">	return_error_param</span> = -EFAULT;</span><br><span class="line"><span class="title">		return_error</span> =<span class="title"> BR_FAILED_REPLY;</span></span><br><span class="line"><span class="title"></span>	<span class="title">	return_error_line</span> =<span class="title"> __LINE__;</span></span><br><span class="line"><span class="title"></span>	<span class="title">	goto</span> err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	/*<span class="title"> Fixup</span> buffer<span class="title"> pointer</span> to<span class="title"> target</span> <span class="keyword">proc</span><span class="title"> address</span> space */</span><br><span class="line"><span class="title">	bp-&gt;buffer</span> = (uintptr_t)sg_bufp +</span><br><span class="line"><span class="title">		binder_alloc_get_user_buffer_offset(</span></span><br><span class="line"><span class="title"></span>				&amp;target_proc-&gt;alloc);</span><br><span class="line"><span class="title">	sg_bufp</span> +=<span class="title"> ALIGN(bp-&gt;length,</span> sizeof(u64));</span><br><span class="line"></span><br><span class="line"><span class="title">	ret</span> =<span class="title"> binder_fixup_parent(t,</span> thread,<span class="title"> bp,</span> off_start,</span><br><span class="line"><span class="title">				  offp</span> -<span class="title"> off_start,</span></span><br><span class="line"><span class="title"></span>	<span class="title">			  last_fixup_obj,</span></span><br><span class="line"><span class="title"></span>	<span class="title">			  last_fixup_min_off);</span></span><br><span class="line"><span class="title"></span>	if (ret &lt; 0) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = ret;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		goto err_translate_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	last_fixup_obj = bp;</span><br><span class="line">	last_fixup_min_off = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-6、多个binder-context"><a href="#2-6、多个binder-context" class="headerlink" title="2.6、多个binder context"></a>2.6、多个binder context</h2><p>Android O以后创建了3个misc设备，对应3个domain(contexts)，相互独立：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># ls /dev/*binder</span></span><br><span class="line"><span class="regexp">/dev/</span>binder <span class="regexp">/dev/</span>hwbinder <span class="regexp">/dev/</span>vndbinder</span><br></pre></td></tr></table></figure>
<p>因为在Android O以后HIDL也启用了binder通信，使用binder通信的进程越来越多，为了便于管理并且相互隔离，Android把binder划分成了3个domain(contexts)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>IPC Domain</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/binder</td>
<td>IPC between framework/app processes with AIDL interfaces</td>
</tr>
<tr>
<td>/dev/hwbinder</td>
<td>IPC between framework/vendor processes with HIDL interfacesIPC between vendor processes with HIDL interfaces</td>
</tr>
<tr>
<td>/dev/vndbinder</td>
<td>IPC between vendor/vendor processes with AIDL Interfaces</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-7、调试接口"><a href="#2-7、调试接口" class="headerlink" title="2.7、调试接口"></a>2.7、调试接口</h2><p>binder驱动创建了很多调试接口，可以方便的debug binder通讯的过程。</p>
<p>1、”/d/binder/state”</p>
<p>全局情况：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># more /d/binder/state</span><br><span class="line">binder state:</span><br><span class="line">dead nodes:</span><br><span class="line">  node <span class="number">392820</span>: u0000007b50bf75a0 c0000007b2b4d5b80 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">3021</span></span><br><span class="line">  node <span class="number">176573</span>: u0000007b50bf72c0 c0000007b4515a600 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">5571</span></span><br><span class="line">  node <span class="number">56178</span>: u0000007b50a8dfa0 c0000007b50bc31c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">3135</span></span><br><span class="line">  node <span class="number">47334</span>: u0000007b47f0df40 c0000007b47f077c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">1458</span></span><br><span class="line">  node <span class="number">342153</span>: u0000007b47f0d480 c0000007b451bf8c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">5571</span></span><br><span class="line">  node <span class="number">50574</span>: u0000007b451ffa20 c0000007b3519e5c0 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">1458</span></span><br><span class="line">  node <span class="number">49594</span>: u0000007b451ff940 c0000007b3507f480 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">2859</span></span><br></pre></td></tr></table></figure>
<p>2、”/d/binder/stats”</p>
<p>全局统计：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># more /d/binder/stats</span></span><br><span class="line"><span class="attr">binder stats:</span></span><br><span class="line"><span class="attr">BC_TRANSACTION:</span> <span class="number">226132</span></span><br><span class="line"><span class="attr">BC_REPLY:</span> <span class="number">201918</span></span><br><span class="line"><span class="attr">BC_FREE_BUFFER:</span> <span class="number">633493</span></span><br><span class="line"><span class="attr">BC_INCREFS:</span> <span class="number">9234</span></span><br><span class="line"><span class="attr">BC_ACQUIRE:</span> <span class="number">9415</span></span><br><span class="line"><span class="attr">BC_RELEASE:</span> <span class="number">6040</span></span><br><span class="line"><span class="attr">BC_DECREFS:</span> <span class="number">6014</span></span><br><span class="line"><span class="attr">BC_INCREFS_DONE:</span> <span class="number">5551</span></span><br><span class="line"><span class="attr">BC_ACQUIRE_DONE:</span> <span class="number">5552</span></span><br><span class="line"><span class="attr">BC_REGISTER_LOOPER:</span> <span class="number">355</span></span><br><span class="line"><span class="attr">BC_ENTER_LOOPER:</span> <span class="number">229</span></span><br><span class="line"><span class="attr">BC_REQUEST_DEATH_NOTIFICATION:</span> <span class="number">2908</span></span><br><span class="line"><span class="attr">BC_CLEAR_DEATH_NOTIFICATION:</span> <span class="number">2146</span></span><br><span class="line"><span class="attr">BC_DEAD_BINDER_DONE:</span> <span class="number">225</span></span><br><span class="line"><span class="attr">BC_TRANSACTION_SG:</span> <span class="number">118790</span></span><br><span class="line"><span class="attr">BC_REPLY_SG:</span> <span class="number">86885</span></span><br><span class="line"><span class="attr">BR_TRANSACTION:</span> <span class="number">344921</span></span><br><span class="line"><span class="attr">BR_REPLY:</span> <span class="number">288803</span></span><br><span class="line"><span class="attr">BR_TRANSACTION_COMPLETE:</span> <span class="number">633725</span></span><br><span class="line"><span class="attr">BR_INCREFS:</span> <span class="number">5559</span></span><br><span class="line"><span class="attr">BR_ACQUIRE:</span> <span class="number">5560</span></span><br><span class="line"><span class="attr">BR_RELEASE:</span> <span class="number">3436</span></span><br><span class="line"><span class="attr">BR_DECREFS:</span> <span class="number">3435</span></span><br><span class="line"><span class="attr">BR_SPAWN_LOOPER:</span> <span class="number">357</span></span><br><span class="line"><span class="attr">BR_DEAD_BINDER:</span> <span class="number">226</span></span><br><span class="line"><span class="attr">BR_CLEAR_DEATH_NOTIFICATION_DONE:</span> <span class="number">2146</span></span><br><span class="line"><span class="attr">proc:</span> <span class="string">active</span> <span class="number">163</span> <span class="string">total</span> <span class="number">232</span></span><br><span class="line"><span class="attr">thread:</span> <span class="string">active</span> <span class="number">852</span> <span class="string">total</span> <span class="number">3214</span></span><br><span class="line"><span class="attr">node:</span> <span class="string">active</span> <span class="number">1610</span> <span class="string">total</span> <span class="number">5564</span></span><br><span class="line"><span class="attr">ref:</span> <span class="string">active</span> <span class="number">2557</span> <span class="string">total</span> <span class="number">9384</span></span><br><span class="line"><span class="attr">death:</span> <span class="string">active</span> <span class="number">746</span> <span class="string">total</span> <span class="number">2908</span></span><br><span class="line"><span class="attr">transaction:</span> <span class="string">active</span> <span class="number">1</span> <span class="string">total</span> <span class="number">633725</span></span><br><span class="line"><span class="attr">transaction_complete:</span> <span class="string">active</span> <span class="number">0</span> <span class="string">total</span> <span class="number">633725</span></span><br><span class="line"><span class="string">proc</span> <span class="number">10578</span></span><br><span class="line"><span class="string">context</span> <span class="string">binder</span></span><br><span class="line">  <span class="attr">threads:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">requested threads:</span> <span class="number">0</span><span class="string">+2/15</span></span><br><span class="line">  <span class="string">ready</span> <span class="string">threads</span> <span class="number">3</span></span><br><span class="line">  <span class="string">free</span> <span class="string">async</span> <span class="string">space</span> <span class="number">520192</span></span><br><span class="line">  <span class="attr">nodes:</span> <span class="number">41</span></span><br></pre></td></tr></table></figure>
<p>3、”/d/binder/proc/xxx”</p>
<p>具体进程的情况：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cat /d/binder/proc/<span class="number">1037</span></span><br><span class="line">binder proc state:</span><br><span class="line">proc <span class="number">1037</span></span><br><span class="line">context binder</span><br><span class="line">  thread <span class="number">1037</span>: l <span class="number">12</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  thread <span class="number">1094</span>: l <span class="number">00</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  thread <span class="number">1096</span>: l <span class="number">12</span> need_return <span class="number">0</span> tr <span class="number">0</span></span><br><span class="line">  node <span class="number">2758</span>: u0000006fe9c10000 c0000006fe9c0d008 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">704</span></span><br><span class="line">  node <span class="number">1192</span>: u0000006fea02f620 c0000006fea029868 pri <span class="number">0</span>:<span class="number">139</span> hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span> <span class="keyword">is</span> <span class="number">1</span> iw <span class="number">1</span> tr <span class="number">1</span> proc <span class="number">549</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">1190</span>: desc <span class="number">0</span> node <span class="number">2</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">1204</span>: desc <span class="number">1</span> node <span class="number">170</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  <span class="built_in">ref</span> <span class="number">249105</span>: desc <span class="number">2</span> node <span class="number">5946</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  buffer <span class="number">249107</span>: <span class="number">0000000000000000</span> size <span class="number">3600</span>:<span class="number">0</span>:<span class="number">0</span> delivered</span><br></pre></td></tr></table></figure>
<h1 id="3、service-manager实现"><a href="#3、service-manager实现" class="headerlink" title="3、service manager实现"></a>3、service manager实现</h1><p>service_manager逻辑很清晰，代码也不多，主要流程在上节中已经描述就不再详细分析。<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/service_manager.c" target="_blank" rel="noopener">service_manager.c</a>、<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/native/cmds/servicemanager/binder.c" target="_blank" rel="noopener">binder.c</a></p>
<h1 id="4、native实现"><a href="#4、native实现" class="headerlink" title="4、native实现"></a>4、native实现</h1><p>整个native层binder的实现还是以mediaserver为例来说明。</p>
<h2 id="4-1、process-thread"><a href="#4-1、process-thread" class="headerlink" title="4.1、process/thread"></a>4.1、process/thread</h2><p><img src="binder_native_process_thread.png" alt="binder_native_process_thread"></p>
<p>上图已经把native层binder通讯最重要的部分都画出来了，理解了这张图native的实现基本理解了大半：</p>
<ul>
<li>[x] binder在server接收端会创建多个线程，在发送端不会创建专门的线程直接在发送者的线程中；</li>
<li><p>[x] binder在server端的通用对象是BBinder，在client端的通用引用对象是BpBinder。具体service的server端和client端的实现，只要继承这两个类就行了；</p>
</li>
<li><p>1、ProcessState类</p>
</li>
</ul>
<p>因为binder buffer是一个进程一份的，所以不论是client还是server进程，都只会创建一个binder fd，进行一次mmap映射。binder fd、mmap公共资源在本进程内的多个线程间共享。native使用了一个ProcessState类来管理这些进程公共资源。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; proc(<span class="name">ProcessState</span>:<span class="symbol">:self</span>())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* (1) 创建新的ProcessState对象 */</span></span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(<span class="string">"/dev/binder"</span>);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    <span class="comment">/* (1.1) open binder节点"/dev/binder"，获得文件句柄 */</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        <span class="comment">/* (1.2) 根据fd映射1M的mmap空间 */</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            ALOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* (1.1.1) open节点的具体操作 */</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          ALOGE(<span class="string">"Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d"</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* (1.1.2) 设置默认最大接收线程数为15 */</span></span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"Opening '%s' failed: %s\n"</span>, driver, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、IPCThreadState类</li>
</ul>
<p>native binder对线程也进行了封装。  </p>
<ul>
<li>2.1、对于server端来说，native binder创建一个线程池，可以多个接收线程来响应和运行service服务。例如</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ps -eT | grep Binder</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">1180</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_1</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">1886</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_2</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">1887</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_3</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">2489</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_4</span><br><span class="line">mediaex       <span class="number">1028</span>  <span class="number">5497</span>     <span class="number">1</span> <span class="number">2179292</span>  <span class="number">15664</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1028</span>_5</span><br><span class="line">media         <span class="number">1034</span>  <span class="number">1130</span>     <span class="number">1</span> <span class="number">2140724</span>  <span class="number">10968</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1034</span>_1</span><br><span class="line">media         <span class="number">1034</span>  <span class="number">8000</span>     <span class="number">1</span> <span class="number">2140724</span>  <span class="number">10968</span> binder_thread_read  <span class="number">0</span> S Binder:<span class="number">1034</span>_2</span><br></pre></td></tr></table></figure>
<p>具体代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self<span class="literal">()</span>-&gt;start<span class="constructor">ThreadPool()</span>;</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::start<span class="constructor">ThreadPool()</span></span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex <span class="constructor">_l(<span class="params">mLock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">        spawn<span class="constructor">PooledThread(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">void ProcessState::spawn<span class="constructor">PooledThread(<span class="params">bool</span> <span class="params">isMain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = make<span class="constructor">BinderThreadName()</span>;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, <span class="params">name</span>.<span class="params">string</span>()</span>);</span><br><span class="line">        <span class="comment">/* (1)新创建一个PoolThread对象 </span></span><br><span class="line"><span class="comment">            main的意思就是它是一个接收主线程，它不会动态的退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="constructor">PoolThread(<span class="params">isMain</span>)</span>;</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>PoolThread类继承了Thread类，并且实现了线程主循环函数：threadLoop()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PoolThread</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function">        : <span class="title">mIsMain</span><span class="params">(isMain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* (1.1) 线程主循环，进一步调用 */</span></span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>↓<br>创建IPCThreadState对象<br>frameworks/native/libs/binder/IPCThreadState.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">/* (1.1.1) 创建一个本地线程的IPCThreadState对象 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gShutdown) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line">        <span class="keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(<span class="string">"IPCThreadState::self() unable to create TLS key, expect a crash: %s\n"</span>,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br><span class="line">↓ </span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">    mRealCallingPid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// @&#125;</span></span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>最后进入IPCThreadState类的线程主循环函数joinThreadPool()</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(<span class="built_in">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n"</span>, (void*)pthread_self(), getpid());</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123;</span><br><span class="line">            ALOGE(<span class="string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></span><br><span class="line">        <span class="comment">// needed and it is not the main process thread.</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    LOG_THREADPOOL(<span class="string">"**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d\n"</span>,</span><br><span class="line">        (void*)pthread_self(), getpid(), result);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">status_t IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    status_t result;</span><br><span class="line">    int32_t cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.2.1) 和binder驱动交互：</span></span><br><span class="line"><span class="comment">        把mOut中的数据发送给binder驱动</span></span><br><span class="line"><span class="comment">        把接收驱动中的数据到mIn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        size_t IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; sizeof(int32_t)) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (1.1.2.2) 读出接收数据中的cmd */</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing top-level Command: "</span></span><br><span class="line">                 &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* (1.1.2.3) 执行cmd */</span></span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs != <span class="number">0</span>) &#123;</span><br><span class="line">            int64_t starvationTimeMs = uptimeMillis() - mProcess-&gt;mStarvationStartTimeMs;</span><br><span class="line">            <span class="keyword">if</span> (starvationTimeMs &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"binder thread pool (%zu threads) starved for %"</span> PRId64 <span class="string">" ms"</span>,</span><br><span class="line">                      mProcess-&gt;mMaxThreads, starvationTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>我们只需要关注其中BR_TRANSACTION命令的处理：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            Parcel <span class="built_in">buffer</span>;</span><br><span class="line">            <span class="built_in">buffer</span>.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> origPid = mCallingPid;</span><br><span class="line">            <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span>  origPidCopy = mRealCallingPid;</span><br><span class="line">            <span class="comment">// @&#125;</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uid_t</span> origUid = mCallingUid;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> origStrictModePolicy = mStrictModePolicy;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> origTransactionBinderFlags = mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid = tr.sender_pid;</span><br><span class="line">            <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">            mRealCallingPid = tr.sender_pid;</span><br><span class="line">            <span class="comment">// @&#125;</span></span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags = tr.flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);</span></span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">"BR_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self()</span><br><span class="line">                    &lt;&lt; <span class="string">" / obj "</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">" / code "</span></span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; <span class="built_in">buffer</span></span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">                    &lt;&lt; <span class="string">"Data addr = "</span></span><br><span class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.<span class="built_in">buffer</span>)</span><br><span class="line">                    &lt;&lt; <span class="string">", offsets addr="</span></span><br><span class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to</span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    <span class="comment">/* (1.1.2.3.1) 如果target是一个合法的本地对象， </span></span><br><span class="line"><span class="comment">                        把tr.cookie转换成BBinder对象，并调用BBinder-&gt;transact()来处理数据</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, <span class="built_in">buffer</span>,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, <span class="built_in">buffer</span>, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",</span></span><br><span class="line">            <span class="comment">//     mCallingPid, origPid, origUid);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid = origPid;</span><br><span class="line">            <span class="comment">// FLYME:duanlusheng@SHELL.Flyme.hips.Feature &#123;@</span></span><br><span class="line">            mRealCallingPid = origPidCopy;</span><br><span class="line">            <span class="comment">// @&#125;</span></span><br><span class="line">            mCallingUid = origUid;</span><br><span class="line">            mStrictModePolicy = origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags = origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">"BC_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / obj "</span></span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>BBinder是一个标准的通用binder对象，它的transact()函数会被具体的service子类重写，所以会调用到具体子类的transact()函数中<br>frameworks/native/libs/binder/Binder.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> <span class="comment">/*flags*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">            reply-&gt;writeString16(getInterfaceDescriptor());</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>BnMediaPlayerService是负责具体实现的子类，最后会调用进BnMediaPlayerService类的onTransact()函数中：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">status_t</span> <span class="type">BnMediaPlayerService</span>::onTransact(</span><br><span class="line">    uint32_t code, const <span class="type">Parcel</span>&amp; <span class="class"><span class="keyword">data</span>, <span class="type">Parcel</span>* reply, uint32_t flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayerClient</span>&gt; client =</span><br><span class="line">                interface_cast&lt;<span class="type">IMediaPlayerClient</span>&gt;(<span class="class"><span class="keyword">data</span>.readStrongBinder());</span></span><br><span class="line">            audio_session_t audioSessionId = (audio_session_t) <span class="class"><span class="keyword">data</span>.readInt32();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaPlayer</span>&gt; player = create(client, audioSessionId);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(player));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">CREATE_MEDIA_RECORDER</span>: &#123;</span><br><span class="line">            <span class="type">CHECK_INTERFACE</span>(<span class="type">IMediaPlayerService</span>, <span class="class"><span class="keyword">data</span>, reply);</span></span><br><span class="line">            const <span class="type">String16</span> opPackageName = <span class="class"><span class="keyword">data</span>.readString16();</span></span><br><span class="line">            sp&lt;<span class="type">IMediaRecorder</span>&gt; recorder = createMediaRecorder(opPackageName);</span><br><span class="line">            reply-&gt;writeStrongBinder(<span class="type">IInterface</span>::asBinder(recorder));</span><br><span class="line">            return <span class="type">NO_ERROR</span>;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return <span class="type">BBinder</span>::onTransact(code, <span class="class"><span class="keyword">data</span>, reply, flags);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.2、对于client端来说是发送数据，native binder不会对其创建新的线程，但是IPCThreadState类也为client端的发送提供了封装。</li>
</ul>
<p>client端通用的binder远端代理类为BpBinder，它的发送数据到binder驱动的函数为transact()：<br>frameworks/native/libs/binder/BpBinder.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>最后调用到IPCThreadState类的相关方法：<br>frameworks/native/libs/binder/IPCThreadState.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span></span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (1) 把数据写入mOut */</span></span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (2) 使用mOut、mIn和binder驱动进行通讯 */</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* (2.1) 和binder驱动通讯 */</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2、manager-proxy"><a href="#4-2、manager-proxy" class="headerlink" title="4.2、manager proxy"></a>4.2、manager proxy</h2><p>service_client service_server和service_manager通讯时，都是处于client角色，所以只能操作service_manager的代理对象。我们看一下具体的代理对象是怎么创建起来的。</p>
<p>server在注册service服务时，都需要获取到默认manager代理：  </p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager<span class="function"><span class="params">()</span>-&gt;</span>addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/IServiceManager.cpp：  </p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; <span class="built_in">defaultServiceManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="built_in">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex <span class="built_in">_l</span>(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="built_in">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* (1) 创建BpBinder对象，并在此基础上创建它的子类BpServiceManager对象 */</span></span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="built_in">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="built_in">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>|→<br>frameworks/native/libs/binder/ProcessState.cpp</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* (1.1) 为service_manager创建handle=0的BpBinder对象 */</span></span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 */</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Special case for context manager...</span></span><br><span class="line">                <span class="comment">// The context manager is the only object for which we create</span></span><br><span class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></span><br><span class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></span><br><span class="line">                <span class="comment">// is registered before we create the first local reference</span></span><br><span class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></span><br><span class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></span><br><span class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></span><br><span class="line">                <span class="comment">// provide a reference to the context manager, but the</span></span><br><span class="line">                <span class="comment">// driver API does not return status.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></span><br><span class="line">                <span class="comment">// dies while this code runs.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> add a driver API to wait for context manager, or</span></span><br><span class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></span><br><span class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></span><br><span class="line">                <span class="comment">// proper reference counting.</span></span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="keyword">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (1.1.2) 给新handle新创建一个对应BpBinder对象 */</span></span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>|→<br>在创建完标准BpBinder对象以后，使用了一个模板函数interface_cast<IServiceManager>()把子类对象也给创建了。interface_cast()的定义在</p>
<p>frameworks/native/libs/binder/include/binder/IInterface.h:</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename <span class="class"><span class="keyword">INTERFACE</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;<span class="class"><span class="keyword">INTERFACE</span>&gt; <span class="title">interface_cast</span>(<span class="title">const</span> <span class="title">sp</span>&lt;<span class="title">IBinder</span>&gt;&amp; <span class="title">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">INTERFACE</span>::<span class="title">asInterface</span>(<span class="title">obj</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface_cast<IServiceManager>()扩展为：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IServiceManager&gt; interface<span class="constructor">_cast(<span class="params">const</span> <span class="params">sp</span>&lt;IBinder&gt;&amp; <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return IServiceManager::<span class="keyword">as</span><span class="constructor">Interface(<span class="params">obj</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>frameworks/native/libs/binder/include/binder/IInterface.h:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16</span> I<span class="comment">##INTERFACE::descriptor(NAME);           \</span></span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16&amp;</span>                                          \</span><br><span class="line">            I<span class="comment">##INTERFACE::getInterfaceDescriptor() const &#123;              \</span></span><br><span class="line">        <span class="keyword">return</span> I<span class="comment">##INTERFACE::descriptor;                                \</span></span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;I</span><span class="comment">##INTERFACE&gt; I##INTERFACE::asInterface(              \</span></span><br><span class="line">            const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;</span><span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:IBinder&gt;&amp;</span> obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;I</span><span class="comment">##INTERFACE&gt; intr;                               \</span></span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;I<span class="comment">##INTERFACE*&gt;(                          \</span></span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I<span class="comment">##INTERFACE::descriptor).get());               \</span></span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new Bp<span class="comment">##INTERFACE(obj);                          \</span></span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I<span class="comment">##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span></span><br><span class="line">    I<span class="comment">##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span></span><br></pre></td></tr></table></figure>
<p>frameworks/native/libs/binder/IServiceManager.cpp:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(<span class="name">ServiceManager</span>, <span class="string">"android.os.IServiceManager"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>扩展为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define IMPLEMENT_META_INTERFACE(ServiceManager, "android.os.IServiceManager")                       \</span></span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16</span> IServiceManager::descriptor(<span class="string">"android.os.IServiceManager"</span>);           \</span><br><span class="line">    const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:String16&amp;</span>                                          \</span><br><span class="line">            IServiceManager::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        <span class="keyword">return</span> IServiceManager::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;IServiceManager&gt;</span> IServiceManager::asInterface(              \</span><br><span class="line">            const <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;</span><span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:IBinder&gt;&amp;</span> obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        <span class="symbol">:</span><span class="symbol">:android</span><span class="symbol">:</span><span class="symbol">:sp&lt;IServiceManager&gt;</span> intr;                               \</span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;IServiceManager*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IServiceManager::descriptor).get());               \</span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new BpServiceManager(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;                                    \</span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>
<p>所以defaultServiceManager()最后得到了一个BpServiceManager对象，利用它的::addService()方法来注册service。<br>frameworks/native/libs/binder/IServiceManager.cpp：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">BpServiceManager</span> : public <span class="type">BpInterface</span>&lt;<span class="type">IServiceManager</span>&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    explicit <span class="type">BpServiceManager</span>(<span class="title">const</span> <span class="title">sp</span>&lt;<span class="type">IBinder</span>&gt;&amp; <span class="title">impl</span>)</span></span><br><span class="line"><span class="class">        : <span class="type">BpInterface</span>&lt;<span class="type">IServiceManager</span>&gt;(<span class="title">impl</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    virtual status_t addService(<span class="title">const</span> <span class="type">String16</span>&amp; <span class="title">name</span>, <span class="title">const</span> <span class="title">sp</span>&lt;<span class="type">IBinder</span>&gt;&amp; <span class="title">service</span>,</span></span><br><span class="line"><span class="class">            <span class="title">bool</span> <span class="title">allowIsolated</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IServiceManager</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeString16(<span class="title">name</span>);</span></span><br><span class="line"><span class="class">        data.writeStrongBinder(<span class="title">service</span>);</span></span><br><span class="line"><span class="class">        data.writeInt32(<span class="title">allowIsolated</span> ? 1 : 0);</span></span><br><span class="line"><span class="class">        status_t err = remote()-&gt;transact(<span class="type">ADD_SERVICE_TRANSACTION</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return err == <span class="type">NO_ERROR</span> ? reply.readExceptionCode() : err;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    virtual sp&lt;<span class="type">IBinder</span>&gt; checkService( <span class="title">const</span> <span class="type">String16</span>&amp; <span class="title">name</span>) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        <span class="type">Parcel</span> data, reply;</span></span><br><span class="line"><span class="class">        data.writeInterfaceToken(<span class="type">IServiceManager</span>::<span class="title">getInterfaceDescriptor</span>());</span></span><br><span class="line"><span class="class">        data.writeString16(<span class="title">name</span>);</span></span><br><span class="line"><span class="class">        remote()-&gt;transact(<span class="type">CHECK_SERVICE_TRANSACTION</span>, <span class="title">data</span>, &amp;<span class="title">reply</span>);</span></span><br><span class="line"><span class="class">        return reply.readStrongBinder();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>remote()-&gt;transact()会调用到BpBinder的transact()函数，最后IPCThreadState的transact()函数。<br>frameworks/native/libs/binder/BpBinder.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借用老罗的一张图总结，service_manager类之间复杂的关系：</p>
<p><img src="binder_class_manager.jpg" alt="binder_class_manager"></p>
<h2 id="4-3、server"><a href="#4-3、server" class="headerlink" title="4.3、server"></a>4.3、server</h2><p>有了manager的代理对象以后，server就可以注册服务并且创建binder rx服务线程了。</p>
<p>frameworks/av/media/mediaserver/main_mediaserver.cpp:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager<span class="function"><span class="params">()</span>-&gt;</span>addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的细节在上面几节都已经描述过了，还是借用老罗的一张图总结service_server类之间复杂的关系：</p>
<p><img src="binder_class_server.jpg" alt="binder_class_server"></p>
<h2 id="4-4、client-proxy"><a href="#4-4、client-proxy" class="headerlink" title="4.4、client proxy"></a>4.4、client proxy</h2><p>service_client也是创建代理对象，和manager代理非常相似。我们也来具体分析一下。<br>frameworks/av/media/libmedia/IMediaDeathNotifier.cpp:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMediaDeathNotifier::get<span class="constructor">MediaPlayerService()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">"getMediaPlayerService"</span>)</span>;</span><br><span class="line">    Mutex::Autolock <span class="constructor">_l(<span class="params">sServiceLock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (sMediaPlayerService<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* (1) 创建manager代理对象 */</span></span><br><span class="line">        sp&lt;IServiceManager&gt; sm = default<span class="constructor">ServiceManager()</span>;</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* (2) 使用manager代理获取到service的handle, </span></span><br><span class="line"><span class="comment">                并根据handle创建一个BpBinder对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            binder = sm-&gt;get<span class="constructor">Service(String16(<span class="string">"media.player"</span>)</span>);</span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="constructor">ALOGW(<span class="string">"Media player service not published, waiting..."</span>)</span>;</span><br><span class="line">            usleep(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">            sDeathNotifier = <span class="keyword">new</span> <span class="constructor">DeathNotifier()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;link<span class="constructor">ToDeath(<span class="params">sDeathNotifier</span>)</span>;</span><br><span class="line">        <span class="comment">/* (3) 根据BpBinder对象，使用interface_cast&lt;IMediaPlayerService&gt;()函数创建一个BpMediaPlayerService对象 */</span></span><br><span class="line">        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">ALOGE_IF(<span class="params">sMediaPlayerService</span> <span class="operator">==</span> 0, <span class="string">"no media player service!?"</span>)</span>;</span><br><span class="line">    return sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了BpMediaPlayerService对象，即MediaPlayerService的远端代理，就可以调用远端service服务了。<br>frameworks/wilhelm/src/android/android_LocAVPlayer.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocAVPlayer::onPrepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SL_LOGD(<span class="string">"LocAVPlayer::onPrepare()"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* (4.1) 获取到MediaPlayerService的远端代理 */</span></span><br><span class="line">    <span class="function">sp&lt;IMediaPlayerService&gt; <span class="title">mediaPlayerService</span><span class="params">(getMediaPlayerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mediaPlayerService != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mDataLocatorType) &#123;</span><br><span class="line">        <span class="keyword">case</span> kDataLocatorUri:</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* (4.2) 调用远端service服务 */</span></span><br><span class="line">            mPlayer = mediaPlayerService-&gt;create(mPlayerClient <span class="comment">/*IMediaPlayerClient*/</span>,</span><br><span class="line">                    mPlaybackParams.sessionId);</span><br></pre></td></tr></table></figure>
<p>其中通过sm-&gt;getService(String16(“media.player”))返回BpBinder的过程如下：<br>frameworks/native/libs/binder/IServiceManager.cpp:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; get<span class="constructor">Service(<span class="params">const</span> String16&amp; <span class="params">name</span>)</span> const&#123;&#125;</span><br><span class="line">↓</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IBinder&gt; check<span class="constructor">Service( <span class="params">const</span> String16&amp; <span class="params">name</span>)</span> const</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.write<span class="constructor">InterfaceToken(IServiceManager::<span class="params">getInterfaceDescriptor</span>()</span>);</span><br><span class="line">        data.write<span class="constructor">String16(<span class="params">name</span>)</span>;</span><br><span class="line">        <span class="comment">/* (2.1) 向远程manager查询handle */</span></span><br><span class="line">        remote<span class="literal">()</span>-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return reply.read<span class="constructor">StrongBinder()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/Parcel.cpp</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Parcel::readStrongBinder</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    <span class="comment">// Note that a lot of code in Android reads binders by hand with this</span></span><br><span class="line">    <span class="comment">// method, and that code has historically been ok with getting nullptr</span></span><br><span class="line">    <span class="comment">// back (while ignoring error codes).</span></span><br><span class="line">    readNullableStrongBinder(&amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, val);</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">unflatten_binder</span><span class="params">(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                <span class="comment">/* (2.1.1) 根据handle创建BpBinder */</span></span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;<span class="built_in">get</span>()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>然后就来到了创建manager代理对象同样的位置：<br>frameworks/native/libs/binder/ProcessState.cpp:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (2.1.1.1) 查询BpBinder对象缓存，相同handle是否已经创建 */</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Special case for context manager...</span></span><br><span class="line">                <span class="comment">// The context manager is the only object for which we create</span></span><br><span class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></span><br><span class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></span><br><span class="line">                <span class="comment">// is registered before we create the first local reference</span></span><br><span class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></span><br><span class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></span><br><span class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></span><br><span class="line">                <span class="comment">// provide a reference to the context manager, but the</span></span><br><span class="line">                <span class="comment">// driver API does not return status.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></span><br><span class="line">                <span class="comment">// dies while this code runs.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> add a driver API to wait for context manager, or</span></span><br><span class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></span><br><span class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></span><br><span class="line">                <span class="comment">// proper reference counting.</span></span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="keyword">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* (2.1.1.2) 给新handle新创建一个对应BpBinder对象 */</span></span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据BpBinder对象，使用interface_cast<IMediaPlayerService>()函数创建一个BpMediaPlayerService对象的过程如下：</p>
<p>interface_cast<IMediaPlayerService>()扩展为：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline sp&lt;IMediaPlayerService&gt; interface<span class="constructor">_cast(<span class="params">const</span> <span class="params">sp</span>&lt;IBinder&gt;&amp; <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return IMediaPlayerService::<span class="keyword">as</span><span class="constructor">Interface(<span class="params">obj</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IMediaPlayerService定义在：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(<span class="name">MediaPlayerService</span>, <span class="string">"android.media.IMediaPlayerService"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>展开为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define IMPLEMENT_META_INTERFACE(MediaPlayerService, "android.os.IServiceManager")                       \</span></span><br><span class="line">    <span class="keyword">const</span> ::android::String16 IMediaPlayerService::descriptor(<span class="string">"android.os.IServiceManager"</span>);           <span class="string">\</span></span><br><span class="line">    <span class="keyword">const</span> ::android::String16&amp;                                          <span class="string">\</span></span><br><span class="line">            IMediaPlayerService::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> IMediaPlayerService::descriptor;                                <span class="string">\</span></span><br><span class="line">    &#125;                                                                   <span class="string">\</span></span><br><span class="line">    ::android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(              <span class="string">\</span></span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               <span class="string">\</span></span><br><span class="line">    &#123;                                                                   <span class="string">\</span></span><br><span class="line">        ::android::sp&lt;IMediaPlayerService&gt; intr;                               <span class="string">\</span></span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              <span class="string">\</span></span><br><span class="line">            intr = static_cast&lt;IMediaPlayerService*&gt;(                          <span class="string">\</span></span><br><span class="line">                obj-&gt;queryLocalInterface(                               <span class="string">\</span></span><br><span class="line">                        IMediaPlayerService::descriptor).get());               <span class="string">\</span></span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         <span class="string">\</span></span><br><span class="line">                <span class="comment">/* (3.1) 根据BpBinder对象，创建一个BpMediaPlayerService对象 */</span></span><br><span class="line">                intr = <span class="keyword">new</span> BpMediaPlayerService(obj);                          <span class="string">\</span></span><br><span class="line">            &#125;                                                           <span class="string">\</span></span><br><span class="line">        &#125;                                                               <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> intr;                                                    <span class="string">\</span></span><br><span class="line">    &#125;                                                                   <span class="string">\</span></span><br><span class="line">    IMediaPlayerService::IMediaPlayerService() &#123; &#125;                                    <span class="string">\</span></span><br><span class="line">    IMediaPlayerService::~IMediaPlayerService() &#123; &#125;                                   <span class="string">\</span></span><br></pre></td></tr></table></figure>
<p>BpMediaPlayerService的定义为：<br>frameworks/av/media/libmedia/IMediaPlayerService.cpp:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">BpMediaPlayerService: <span class="symbol">public</span></span> <span class="symbol">BpInterface</span>&lt;<span class="symbol">IMediaPlayerService</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> BpMediaPlayerService(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IMediaPlayerService&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IMediaMetadataRetriever&gt; createMetadataRetriever()</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(CREATE_METADATA_RETRIEVER, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>erface_cast&lt;IMediaMetadataRetriever&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还是借用老罗的一张图总结service_client类之间复杂的关系：</p>
<p><img src="binder_class_client.jpg" alt="binder_class_client"></p>
<h2 id="4-5、service-thread管理"><a href="#4-5、service-thread管理" class="headerlink" title="4.5、service thread管理"></a>4.5、service thread管理</h2><p>binder service初始会启动2个main线程来提供服务，在等待service服务过多的情况下会动态的增加binder线程的数量，但是目前没有实现动态减少binder线程可能觉得cache着更好。</p>
<p>service一般默认最大考验开启15个线程，这个数值也可以通过ioctl的BINDER_SET_MAX_THREADS命令来修改。</p>
<p>动态增加binder线程的动作是binder驱动完成的，因为驱动可以看到service进程整个的阻塞情况。</p>
<p>具体驱动代码binder.c：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *<span class="keyword">proc</span>,</span><br><span class="line"><span class="title">			      struct</span> binder_thread *thread,</span><br><span class="line"><span class="title">			      binder_uintptr_t</span> binder_buffer,<span class="title"> size_t</span> size,</span><br><span class="line"><span class="title">			      binder_size_t</span> *consumed,<span class="title"> int</span> non_block)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">proc</span>-&gt;requested_threads == 0 &amp;&amp;</span><br><span class="line"><span class="title">	    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads)</span> &amp;&amp;</span><br><span class="line"><span class="title">	    proc-&gt;requested_threads_started</span> &lt;<span class="title"> proc-&gt;max_threads</span> &amp;&amp;</span><br><span class="line">	    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line"><span class="title">	     BINDER_LOOPER_STATE_ENTERED))</span> /*<span class="title"> the</span> user-space<span class="title"> code</span> fails<span class="title"> to</span> */</span><br><span class="line">	     /*spawn<span class="title"> a</span> new<span class="title"> thread</span> if<span class="title"> we</span> leave<span class="title"> this</span> out */) &#123;</span><br><span class="line">		<span class="keyword">proc</span>-&gt;requested_threads++;</span><br><span class="line"><span class="title">		binder_inner_proc_unlock(proc);</span></span><br><span class="line"><span class="title"></span>	<span class="title">	binder_debug(BINDER_DEBUG_THREADS,</span></span><br><span class="line"><span class="title"></span>			     "%d:%d<span class="title"> BR_SPAWN_LOOPER\n",</span></span><br><span class="line"><span class="title"></span>	<span class="title">		     proc-&gt;pid,</span> thread-&gt;pid);</span><br><span class="line">		</span><br><span class="line">		/* (1) 判断阻塞的情况下发送BR_SPAWN_LOOPER命令，通知native增加接收线程 */</span><br><span class="line"><span class="title">		if</span> (put_user(BR_SPAWN_LOOPER, (uint32_t<span class="title"> __user</span> *)buffer))</span><br><span class="line"><span class="title">			return</span> -EFAULT;</span><br><span class="line"><span class="title">		binder_stat_br(proc,</span> thread,<span class="title"> BR_SPAWN_LOOPER);</span></span><br><span class="line"><span class="title"></span>	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>frameworks/native/libs/binder/IPCThreadState.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓<br>frameworks/native/libs/binder/ProcessState.cpp:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::spawn<span class="constructor">PooledThread(<span class="params">bool</span> <span class="params">isMain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = make<span class="constructor">BinderThreadName()</span>;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, <span class="params">name</span>.<span class="params">string</span>()</span>);</span><br><span class="line">        <span class="comment">/* (1.1) 创建新的binder接收线程 */</span></span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="constructor">PoolThread(<span class="params">isMain</span>)</span>;</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6、死亡通知-DeathRecipient"><a href="#4-6、死亡通知-DeathRecipient" class="headerlink" title="4.6、死亡通知(DeathRecipient)"></a>4.6、死亡通知(DeathRecipient)</h2><p>可以使用BC_REQUEST_DEATH_NOTIFICATION注册死亡通知，在server端正常或者异常死亡的情况下都能收到通知。</p>
<p>在server端进程正常或者异常退出时，会关闭进程所有打开的文件句柄：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span><span class="constructor">_exit()</span></span><br><span class="line">↓</span><br><span class="line">exit<span class="constructor">_files()</span></span><br><span class="line">↓</span><br><span class="line">put<span class="constructor">_files_struct()</span></span><br><span class="line">↓</span><br><span class="line">static <span class="keyword">struct</span> fdtable *close<span class="constructor">_files(<span class="params">struct</span> <span class="params">files_struct</span> <span class="operator">*</span> <span class="params">files</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It is safe to dereference the fd table without RCU or</span></span><br><span class="line"><span class="comment">	 * -&gt;file_lock because this is the last reference to the</span></span><br><span class="line"><span class="comment">	 * files structure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> fdtable *fdt = rcu<span class="constructor">_dereference_raw(<span class="params">files</span>-&gt;<span class="params">fdt</span>)</span>;</span><br><span class="line">	unsigned <span class="built_in">int</span> i, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		unsigned long set;</span><br><span class="line">		i = j<span class="operator"> * </span>BITS_PER_LONG;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= fdt-&gt;max_fds)</span><br><span class="line">			break;</span><br><span class="line">		set = fdt-&gt;open_fds<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line">		<span class="keyword">while</span> (set) &#123;</span><br><span class="line">			<span class="keyword">if</span> (set &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">struct</span> file<span class="operator"> * </span>file = xchg(&amp;fdt-&gt;fd<span class="literal">[<span class="identifier">i</span>]</span>, NULL);</span><br><span class="line">				<span class="keyword">if</span> (file) &#123;</span><br><span class="line">					filp<span class="constructor">_close(<span class="params">file</span>, <span class="params">files</span>)</span>;</span><br><span class="line">					cond<span class="constructor">_resched_rcu_qs()</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			set &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return fdt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用到binder fd的release函数，调用到死亡通知的回调:</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int binder_release(struct inode *nodp, struct <span class="keyword">file</span> *filp)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_proc *<span class="keyword">proc</span> =<span class="title"> filp-&gt;private_data;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title"></span>	debugfs_remove(<span class="keyword">proc</span>-&gt;debugfs_entry);</span><br><span class="line"><span class="title">	binder_defer_work(proc,</span> BINDER_DEFERRED_RELEASE);</span><br><span class="line"></span><br><span class="line"><span class="title">	return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">↓</span><br><span class="line">static<span class="title"> void</span></span><br><span class="line"><span class="title">binder_defer_work(struct</span> binder_proc *<span class="keyword">proc</span>,<span class="title"> enum</span> binder_deferred_state<span class="title"> defer)</span></span><br><span class="line"><span class="title"></span>&#123;</span><br><span class="line">	mutex_lock(&amp;binder_deferred_lock);</span><br><span class="line">	<span class="keyword">proc</span>-&gt;deferred_work |=<span class="title"> defer;</span></span><br><span class="line"><span class="title"></span>	if (hlist_unhashed(&amp;<span class="keyword">proc</span>-&gt;deferred_work_node)) &#123;</span><br><span class="line">		hlist_add_head(&amp;<span class="keyword">proc</span>-&gt;deferred_work_node,</span><br><span class="line">				&amp;binder_deferred_list);</span><br><span class="line"><span class="title">		schedule_work(&amp;binder_deferred_work);</span></span><br><span class="line"><span class="title"></span>	&#125;</span><br><span class="line"><span class="title">	mutex_unlock(&amp;binder_deferred_lock);</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="5、java实现"><a href="#5、java实现" class="headerlink" title="5、java实现"></a>5、java实现</h1><p>略</p>
<h1 id="6、AIDL-Android-Interface-Definition-Language"><a href="#6、AIDL-Android-Interface-Definition-Language" class="headerlink" title="6、AIDL(Android Interface Definition Language)"></a>6、AIDL(Android Interface Definition Language)</h1><p>略</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://blog.csdn.net/Luoshengyang/article/details/6629298" target="_blank" rel="noopener">1、Android系统进程间通信（IPC）机制 罗升阳</a><br><a href="http://light3moon.com/2015/01/28/Android%20Binder%20%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E8%80%85%5BParcel%5D/" target="_blank" rel="noopener">2、Android Binder 分析</a><br><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">3、Android Bander设计与实现</a><br><a href="https://blog.csdn.net/chenying126/article/details/78989413#_Toc503017553" target="_blank" rel="noopener">4、Binder实现原理分析</a><br><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="noopener">5、一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a>  </p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/07/04/Android-R-AVB2-0/" data-toggle="tooltip" data-placement="top" title="Android Verified Boot 2.0">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/11/22//implementation-of-loading-fw-from-userspace.html/" data-toggle="tooltip" data-placement="top" title="kernel 空间加载用户空间fw实现原理">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#binder" title="binder">binder</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; meizu 2025 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="../../../../../js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="../../../../../js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="../../../../../js/hux-blog.min.js"></script>


<!-- Search -->

<script src="../../../../../js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://kernel.meizu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
