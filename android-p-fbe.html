<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="一个有内涵的技术分享平台">
    <meta name="keyword"  content="meizu,kernel,魅族">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Android FBE - 魅族内核团队
        
    </title>

    <link rel="canonical" href="https://kernel.meizu.com//android-p-fbe.html">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="css/dusign-light.css">

        
<link rel="stylesheet" href="css/dusign-common-light.css">

        
<link rel="stylesheet" href="css/font-awesome.css">

        
<link rel="stylesheet" href="css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="css/highlight.css">


    
<link rel="stylesheet" href="css/widget.css">


    
<link rel="stylesheet" href="css/rocket.css">


    
<link rel="stylesheet" href="css/signature.css">


    
<link rel="stylesheet" href="css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 7.3.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#FBE" title="FBE">FBE</a>
                            
                              <a class="tag" href="/tags/#文件级加密" title="文件级加密">文件级加密</a>
                            
                        </div>
                        <h1>Android FBE</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Chen An on
                            2018-07-12
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">魅族内核团队</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="Android-FBE"><a href="#Android-FBE" class="headerlink" title="Android FBE"></a>Android FBE</h2><h3 id="1-FBE-简介"><a href="#1-FBE-简介" class="headerlink" title="1. FBE 简介"></a>1. FBE 简介</h3><ul>
<li>名称: FBE, File-Based Encryption,基于文件的加密</li>
<li>凭据加密 (CE) 存储空间：这是默认存储位置，只有在用户解锁设备后才可用。设备加密 (DE) 存储空间：在直接启动模式期间以及用户解锁设备后均可用。</li>
<li>开启 FBE 方式,在相关的 fstab 文件中添加相关的代码:</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/bootdevice/by-name/userdata                  /data              ext4    noatime,nosuid,nodev,<span class="attribute">barrier</span>=1,noauto_da_alloc,discard wait,check,resize,*<span class="number">*f</span><span class="attribute">ileencryption</span>=aes-256-xts**,quota</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一些概念性内容这里不再赘述，如有需要自行阅读 <a href="https://source.android.com/security/encryption/file-based">Goole FBE</a></li>
</ul>
<h3 id="2-FBE-流程分析"><a href="#2-FBE-流程分析" class="headerlink" title="2. FBE 流程分析"></a>2. FBE 流程分析</h3><h4 id="2-1-开机过程中-加密前的准备"><a href="#2-1-开机过程中-加密前的准备" class="headerlink" title="2.1 开机过程中,加密前的准备"></a>2.1 开机过程中,加密前的准备</h4><ul>
<li>init.rc 中加入相关的代码,用于根据 fstab 文件中进行相关的挂载操作</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on fs</span><br><span class="line">    wait <span class="regexp">/dev/</span>block/bootdevice</span><br><span class="line">    <span class="keyword">write</span> <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>swappiness <span class="number">100</span></span><br><span class="line">    mount_all fstab.qcom</span><br></pre></td></tr></table></figure>

<ul>
<li>看完 init.rc 中,当然是查看 init 进程中如何解析 init.rc ,代码在 <code>system/core/init/builtins.cpp</code> 中:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> BuiltinFunctionMap::Map&amp; <span class="title">BuiltinFunctionMap::map</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">&quot;mount_all&quot;</span>,               &#123;<span class="number">1</span>,     kMax, do_mount_all&#125;&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">do_mount_all</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*mount_fstab 会 fork 出一个子进程调用 fs_mgr_read_fstab 以及 fs_mgr_mount_all 函数,前一个函数用于读取 fstab 文件,后者用于 mount,之后重点分析 fs_mgr_mount_all函数*/</span></span><br><span class="line">    <span class="type">int</span> ret =  <span class="built_in">mount_fstab</span>(fstabfile, mount_mode);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (queue_event) &#123;</span><br><span class="line">        <span class="comment">/* queue_fs_event will queue event based on mount_fstab return code</span></span><br><span class="line"><span class="comment">         * and return processed return code*/</span></span><br><span class="line">        ret = <span class="built_in">queue_fs_event</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>现在来看一下 fs_mgr_mount_all 函数,代码路径在<code>system/core/fs_mgr/fs_mgr.cpp</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fs_mgr_mount_all</span><span class="params">(<span class="keyword">struct</span> fstab *fstab, <span class="type">int</span> mount_mode)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> encryptable = FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fstab-&gt;num_entries; i++) &#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="type">int</span> last_idx_inspected;</span><br><span class="line">        <span class="type">int</span> top_idx = i;</span><br><span class="line"></span><br><span class="line">        mret = <span class="built_in">mount_with_alternatives</span>(fstab, i, &amp;last_idx_inspected, &amp;attempted_idx);</span><br><span class="line">        i = last_idx_inspected;</span><br><span class="line">        mount_errno = errno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Deal with encryptability. */</span></span><br><span class="line">        <span class="keyword">if</span> (!mret) &#123;</span><br><span class="line">            <span class="type">int</span> status = <span class="built_in">handle_encryptable</span>(&amp;fstab-&gt;recs[attempted_idx]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status == FS_MGR_MNTALL_FAIL) &#123;</span><br><span class="line">                <span class="comment">/* Fatal error - no point continuing */</span></span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">                    <span class="comment">// Log and continue</span></span><br><span class="line">                    LERROR &lt;&lt; <span class="string">&quot;Only one encryptable/encrypted partition supported&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//结果赋值给 encryptable</span></span><br><span class="line">                encryptable = status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Success!  Go get the next one */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        ......</span><br><span class="line">    <span class="comment">/*此处返回给父进程,即 queue_fs_event 接收返回值进行之后的处理*/</span></span><br><span class="line">    <span class="keyword">if</span> (error_count) &#123;</span><br><span class="line">        <span class="keyword">return</span> FS_MGR_MNTALL_FAIL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encryptable;</span><br><span class="line">    &#125;</span><br><span class="line">- [ ] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>先来看一下 queue_fs_event 函数,它会根据 mount_fstab 的返回值结果进行不同的操作,而 mount_fstab 会返回 FS_MGR_MNTALL_DEV_FILE_ENCRYPTED 给 queue_fs_event，然后调用 e4crypt_install_keyring 函数用于安装 e4crypt keyring，这个用于存放文件加密的 key，之后设置相关的属性，然后触发 nonencrypted 这个 trigger 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">queue_fs_event</span><span class="params">(<span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = code;</span><br><span class="line">    <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION) &#123;</span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;encrypt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) &#123;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.state&quot;</span>, <span class="string">&quot;encrypted&quot;</span>);</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.type&quot;</span>, <span class="string">&quot;block&quot;</span>);</span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;defaultcrypto&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) &#123;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.state&quot;</span>, <span class="string">&quot;unencrypted&quot;</span>);</span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;nonencrypted&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) &#123;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.state&quot;</span>, <span class="string">&quot;unsupported&quot;</span>);</span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;nonencrypted&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_RECOVERY) &#123;</span><br><span class="line">        <span class="comment">/* Setup a wipe via recovery, and reboot into recovery */</span></span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;fs_mgr_mount_all suggested recovery, so wiping data via recovery.&quot;</span>;</span><br><span class="line">        <span class="type">const</span> std::vector&lt;std::string&gt; options = &#123;<span class="string">&quot;--wipe_data&quot;</span>, <span class="string">&quot;--reason=fs_mgr_mount_all&quot;</span> &#125;;</span><br><span class="line">        <span class="built_in">reboot_into_recovery</span>(options);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* If reboot worked, there is no return. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_FILE_ENCRYPTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_install_keyring</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.state&quot;</span>, <span class="string">&quot;encrypted&quot;</span>);</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.type&quot;</span>, <span class="string">&quot;file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Although encrypted, we have device key, so we do not need to</span></span><br><span class="line">        <span class="comment">// do anything different from the nonencrypted case.</span></span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;nonencrypted&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_IS_METADATA_ENCRYPTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_install_keyring</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.state&quot;</span>, <span class="string">&quot;encrypted&quot;</span>);</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.type&quot;</span>, <span class="string">&quot;file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// defaultcrypto detects file/block encryption. init flow is same for each.</span></span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;defaultcrypto&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == FS_MGR_MNTALL_DEV_NEEDS_METADATA_ENCRYPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_install_keyring</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;ro.crypto.type&quot;</span>, <span class="string">&quot;file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// encrypt detects file/block encryption. init flow is same for each.</span></span><br><span class="line">        ActionManager::<span class="built_in">GetInstance</span>().<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;encrypt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;fs_mgr_mount_all returned unexpected error &quot;</span> &lt;&lt; code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else ... &lt; 0: error */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>之前如果有了解过全盘加密的同学应该会很熟悉,全盘加密会返回 FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION ,然后触发一个 trigger ,最后在 init.rc 中执行 vdc 进程,最后启动 vold 进行全盘加密操作.那现在我们来看一下 FBE 中的 nonencrypted 这个 trigger 中做了什么操作,没看到有触发 vold 的操作啊,那文件加密是什么时候做的呢?不着急,我们继续往下看.</li>
</ul>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    <span class="keyword">class</span><span class="number">_</span>start main</span><br><span class="line">    <span class="keyword">class</span><span class="number">_</span>start <span class="keyword">late</span><span class="number">_</span>start</span><br></pre></td></tr></table></figure>

<ul>
<li>我们知道,正常系统起来后,init 的执行顺序为 <code>early-init</code>,<code>init</code>,<code>late-init</code>.既然我们一下子无法知道 FBE 中 vold 是在什么时候执行的,那就只能一步步跟 init.rc,看下能否发现一些端倪,功夫不负有心人,终于在 init.rc 中发现了一点可能和 FBE 相关的东西. <strong>installkey &#x2F;data</strong> 这个看着有点像.</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">on</span> post-fs-<span class="class"><span class="keyword">data</span></span></span><br><span class="line">    # <span class="type">We</span> chown/chmod /<span class="class"><span class="keyword">data</span> again so because mount is run as root + defaults</span></span><br><span class="line">    chown system system /<span class="class"><span class="keyword">data</span></span></span><br><span class="line">    chmod <span class="number">0771</span> /<span class="class"><span class="keyword">data</span></span></span><br><span class="line">    # <span class="type">We</span> restorecon /<span class="class"><span class="keyword">data</span> in case the userdata partition has been reset.</span></span><br><span class="line">    restorecon /<span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br><span class="line">    # <span class="type">Make</span> sure we have the device encryption key.</span><br><span class="line">    start vold</span><br><span class="line">    installkey /<span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>类似 mount 的处理流程, installkey &#x2F;data 最后会调用<code>system/core/init/builtins.cpp</code> 中的 do_installkey 函数,do_installkey 首先判断是否为文件加密方式,如果是文件加密方式,则会执行 vdc 命令,到这里终于开始进入加密流程过程了.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">do_installkey</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_file_crypto</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> unencrypted_dir = args[<span class="number">1</span>] + e4crypt_unencrypted_folder;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">do_installkeys_ensure_dir_exists</span>(unencrypted_dir.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to create &quot;</span> &lt;&lt; unencrypted_dir;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;std::string&gt; exec_args = &#123;<span class="string">&quot;exec&quot;</span>, <span class="string">&quot;/system/bin/vdc&quot;</span>, <span class="string">&quot;--wait&quot;</span>, <span class="string">&quot;cryptfs&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;enablefilecrypto&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_exec</span>(exec_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-FBE-加密处理流程"><a href="#2-2-FBE-加密处理流程" class="headerlink" title="2.2 FBE 加密处理流程"></a>2.2 FBE 加密处理流程</h4><ul>
<li>先看一下 vdc 代码中的处理流程,在 <code>system/vold/vdc.cpp</code>, 通过 local socket 实现了 vdc 通知 vold 进行之后的操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">........</span><br><span class="line"><span class="keyword">while</span> ((sock = <span class="built_in">socket_local_client</span>(sockname,</span><br><span class="line">                             ANDROID_SOCKET_NAMESPACE_RESERVED,</span><br><span class="line">                             SOCK_STREAM)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_socket) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Error connecting to &quot;</span> &lt;&lt; sockname;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;monitor&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="built_in">do_monitor</span>(sock, <span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="built_in">do_cmd</span>(sock, argc, argv));</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(sock, cmd.<span class="built_in">c_str</span>(), cmd.<span class="built_in">length</span>() + <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to write command&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>代码在 system&#x2F;vold&#x2F;CryptCommandListener.cpp,通过之前的命令执行到 e4crypt_initialize_global_de 函数,到这里终于进入了文件加密的核心部分了,该函数会生成 &#x2F;data&#x2F;unencrypted&#x2F;key.unencrypted key用来设置&#x2F;data下除了<code>directories_to_exclude</code> (system&#x2F;extras&#x2F;ext4_utils&#x2F;ext4_crypt_init_extensions.cpp 中定义)目录的当前所有目录的policy,(更准确的说,用的是 &#x2F;data&#x2F;unencrypted&#x2F;ref ,该文件是是key 的引用(),key 其实是存入到密钥环(keyring)当中去的 ).其实 FBE 下有三种类型的 key 用于整个 Android 系统,那这里只是生成的一把 key,之后的 key 是在哪里生成的呢?</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">e4crypt_initialize_global_de</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;e4crypt_initialize_global_de&quot;</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (s_global_de_initialized) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Already initialized&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *contents_mode;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filenames_mode;</span><br><span class="line">    <span class="built_in">cryptfs_get_file_encryption_modes</span>(&amp;contents_mode, &amp;filenames_mode);</span><br><span class="line">    std::string modestring = std::<span class="built_in">string</span>(contents_mode) + <span class="string">&quot;:&quot;</span> + filenames_mode;</span><br><span class="line"></span><br><span class="line">    std::string mode_filename = std::<span class="built_in">string</span>(<span class="string">&quot;/data&quot;</span>) + e4crypt_key_mode;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::<span class="built_in">WriteStringToFile</span>(modestring, mode_filename)) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Cannot save type&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    std::string device_key_ref;</span><br><span class="line">    <span class="comment">//生成 /data/unencrypted/key这个文件夹  key 是怎样生成的 ,首先会读取 /dev/urandom 节点生成一个随机数，再通过 keymaster key 进行签名操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同时会生成 /data/uncrypt/key/version(版本信息)  /data/uncrypt/key/encrypt_key(之前通过/dev/urandom 生成的 key 再通过 keymaster key 加密过的 key)</span></span><br><span class="line">    <span class="keyword">if</span> (!android::vold::<span class="built_in">retrieveAndInstallKey</span>(<span class="literal">true</span>,</span><br><span class="line">        device_key_path, device_key_temp, &amp;device_key_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    std::string ref_filename = std::<span class="built_in">string</span>(<span class="string">&quot;/data&quot;</span>) + e4crypt_key_ref;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::<span class="built_in">WriteStringToFile</span>(device_key_ref, ref_filename)) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Cannot save key reference to:&quot;</span> &lt;&lt; ref_filename;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Wrote system DE key reference to:&quot;</span> &lt;&lt; ref_filename;</span><br><span class="line">                </span><br><span class="line">    s_global_de_initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成了 uncryptkey 之后, 分析 init.rc 看看之后做了什么操作,看了大部分都是 mkdir 操作啊.</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start bootcharting as soon as possible after the data partition is</span></span><br><span class="line"><span class="comment"># mounted to collect more data.</span></span><br><span class="line">mkdir /data/bootchart <span class="number">0755</span> <span class="built_in">shell</span> <span class="built_in">shell</span></span><br><span class="line">bootchart <span class="built_in">start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avoid predictable entropy pool. Carry over entropy from previous boot.</span></span><br><span class="line">copy /data/<span class="keyword">system</span>/entropy.dat /dev/urandom</span><br><span class="line"></span><br><span class="line"><span class="comment"># create basic filesystem structure</span></span><br><span class="line">mkdir /data/misc <span class="number">01771</span> <span class="keyword">system</span> misc</span><br><span class="line">mkdir /data/misc/recovery <span class="number">0770</span> <span class="keyword">system</span> <span class="built_in">log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>也类似 mount_all ,mkdir 最终调用了 init&#x2F;builtins.cpp 中的 do_mkdir 函数,关注 e4crypt_set_directory_policy 函数实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">do_mkdir</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">//判断是否未文件加密方式,是则执行之后的流程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_set_directory_policy</span>(args[<span class="number">1</span>].<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">            <span class="type">const</span> std::vector&lt;std::string&gt; options = &#123;</span><br><span class="line">                <span class="string">&quot;--prompt_and_wipe_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--reason=set_policy_failed:&quot;</span>s + args[<span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="built_in">reboot_into_recovery</span>(options);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置相关目录的加密 policy,使用的 policy 便是上面生成的 &#x2F;data&#x2F;unencrypted&#x2F;ref (ref 是 key 经过填充后 再经过 sha512 算法得到的东西). directories_to_exclude 指定的相关目录不会被加密,因为该部分相关的子目录需要加密 (加密 key 使用之后生成的 CE&#x2F;DE)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">e4crypt_set_directory_policy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dir || <span class="built_in">strncmp</span>(dir, <span class="string">&quot;/data/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special-case /data/media/obb per b/64566063</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dir, <span class="string">&quot;/data/media/obb&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Try to set policy on this directory, but if it is non-empty this may fail.</span></span><br><span class="line">        <span class="built_in">set_system_de_policy_on</span>(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set policy on first level /data directories</span></span><br><span class="line">    <span class="comment">// To make this less restrictive, consider using a policy file.</span></span><br><span class="line">    <span class="comment">// However this is overkill for as long as the policy is simply</span></span><br><span class="line">    <span class="comment">// to apply a global policy to all /data folders created via makedir</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(dir + <span class="number">6</span>, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Special case various directories that must not be encrypted,</span></span><br><span class="line">    <span class="comment">// often because their subdirectories must be encrypted.</span></span><br><span class="line">    <span class="comment">// This isn&#x27;t a nice way to do this, see b/26641735</span></span><br><span class="line">    std::vector&lt;std::string&gt; directories_to_exclude = &#123;</span><br><span class="line">        <span class="string">&quot;lost+found&quot;</span>,</span><br><span class="line">        <span class="string">&quot;system_ce&quot;</span>, <span class="string">&quot;system_de&quot;</span>,</span><br><span class="line">        <span class="string">&quot;misc_ce&quot;</span>, <span class="string">&quot;misc_de&quot;</span>,</span><br><span class="line">        <span class="string">&quot;media&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;user_de&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    std::string prefix = <span class="string">&quot;/data/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d: directories_to_exclude) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((prefix + d) == dir) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Not setting policy on &quot;</span> &lt;&lt; dir;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set_system_de_policy_on</span>(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>e4crypt_policy_set 先填充了 eep 这个结构体,相关的加密 key 与加密方式都是通过这个结构体进行进一步操作的.最后通过 ioctl 实现相关目录的 key policy ,kernel 部分这里就不去深究了,相关代码位置在 kernel&#x2F;fs&#x2F;crypto&#x2F; 中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">e4crypt_policy_set</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *directory, <span class="type">const</span> <span class="type">char</span> *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">size_t</span> policy_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">int</span> contents_encryption_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">int</span> filenames_encryption_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy_length != EXT4_KEY_DESCRIPTOR_SIZE) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Policy wrong length: &quot;</span> &lt;&lt; policy_length;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(directory, O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to open directory &quot;</span> &lt;&lt; directory;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//填充 eep</span></span><br><span class="line">    ext4_encryption_policy eep;</span><br><span class="line">    eep.version = <span class="number">0</span>;</span><br><span class="line">    eep.contents_encryption_mode = contents_encryption_mode;</span><br><span class="line">    eep.filenames_encryption_mode = filenames_encryption_mode;</span><br><span class="line">    eep.flags = <span class="built_in">e4crypt_get_policy_flags</span>(filenames_encryption_mode);</span><br><span class="line">    <span class="built_in">memcpy</span>(eep.master_key_descriptor, policy, EXT4_KEY_DESCRIPTOR_SIZE);</span><br><span class="line">    <span class="comment">//ioctl 实现最后的加密操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd, EXT4_IOC_SET_ENCRYPTION_POLICY, &amp;eep)) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to set encryption policy for &quot;</span> &lt;&lt; directory;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> policy_hex[EXT4_KEY_DESCRIPTOR_SIZE_HEX];</span><br><span class="line">    <span class="built_in">policy_to_hex</span>(policy, policy_hex);</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Policy for &quot;</span> &lt;&lt; directory &lt;&lt; <span class="string">&quot; set to &quot;</span> &lt;&lt; policy_hex;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面已经分析了 uncryptkey 加密操作. 那么文章开头说的 CE&#x2F;DE 又是在哪做的操作呢? 继续分析 init.rc,发现在 init.rc 中,在 post-fs-data 中创建了一些必要的文件后,是时候为用户0创建相应的key 了 , <code>init_user0</code> 就是做了这个操作,类似之前的 do_installkey 操作, init_user0 最终会调用了 vold 下的 e4crypt_init_user0 函数,该函数会生成 &#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys 目录下的相关文件.注:DE key 加密相关的存储空间就是在这个阶段实现的 CE 加密相关的存储空间还未生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">e4crypt_init_user0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;e4crypt_init_user0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(user_key_dir, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(user_key_dir + <span class="string">&quot;/ce&quot;</span>, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(user_key_dir + <span class="string">&quot;/de&quot;</span>, <span class="number">0700</span>, AID_ROOT, AID_ROOT)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!android::vold::<span class="built_in">pathExists</span>(<span class="built_in">get_de_key_path</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">//第一次系统起来, de/ce key 未创建,所以会走这,创建 DE/CE key 的过程都是在这个函数里面做的,类似 uncrypted key 的生成流程,</span></span><br><span class="line">        <span class="comment">// 也会通过调用 randomKey 函数生成随机 key ,storeKeyAtomically 函数生成 keymaster key ,</span></span><br><span class="line">        <span class="comment">//最后调用 installKey 将 key 加入到 密钥环(keyring)中</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">create_and_install_user_keys</span>(<span class="number">0</span>, <span class="literal">false</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> switch to loading only DE_0 here once framework makes</span></span><br><span class="line">        <span class="comment">// explicit calls to install DE keys for secondary users</span></span><br><span class="line">        <span class="comment">// 加密之后，第一次系统起来直接走这，load key 然后用 keymaster key进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">load_all_de_keys</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We can only safely prepare DE storage here, since CE keys are probably</span></span><br><span class="line">    <span class="comment">// entangled with user credentials.  The framework will always prepare CE</span></span><br><span class="line">    <span class="comment">// storage once CE keys are installed.</span></span><br><span class="line">    <span class="comment">//开始准备 DE 存储空间,e4crypt_prepare_user_storage 先是准备了相关的 DE 目录,之后查找相关用户id 的 key ,最后调用 ensure_policy 用户设置相关目录的加密策略</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">e4crypt_prepare_user_storage</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>, FLAG_STORAGE_DE)) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to prepare user 0 storage&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a non-FBE device that recently left an emulated mode,</span></span><br><span class="line">    <span class="comment">// restore user data directories to known-good state.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">e4crypt_is_native</span>() &amp;&amp; !<span class="built_in">e4crypt_is_emulated</span>()) &#123;</span><br><span class="line">        <span class="built_in">e4crypt_unlock_user_key</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>接着上面的 ensure_policy 函数,通过 cryptfs_get_file_encryption_modes 函数,根据 fstab 文件获取了 FBE 加密方式(contents_mode,filenames_mode),最后通过 e4crypt_policy_ensure 函数设置相关目录的 policy</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">e4crypt_policy_ensure</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *directory, <span class="type">const</span> <span class="type">char</span> *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">size_t</span> policy_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">char</span> *contents_encryption_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">char</span> *filenames_encryption_mode)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> contents_mode = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> filenames_mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">&quot;software&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">&quot;aes-256-xts&quot;</span>)) &#123;</span><br><span class="line">        contents_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(contents_encryption_mode, <span class="string">&quot;ice&quot;</span>)) &#123;</span><br><span class="line">        contents_mode = EXT4_ENCRYPTION_MODE_PRIVATE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Invalid file contents encryption mode: &quot;</span></span><br><span class="line">                   &lt;&lt; contents_encryption_mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filenames_encryption_mode, <span class="string">&quot;aes-256-cts&quot;</span>)) &#123;</span><br><span class="line">        filenames_mode = EXT4_ENCRYPTION_MODE_AES_256_CTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(filenames_encryption_mode, <span class="string">&quot;aes-256-heh&quot;</span>)) &#123;</span><br><span class="line">        filenames_mode = EXT4_ENCRYPTION_MODE_AES_256_HEH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Invalid file names encryption mode: &quot;</span></span><br><span class="line">                   &lt;&lt; filenames_encryption_mode;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_empty;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_dir_empty</span>(directory, &amp;is_empty)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_empty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">e4crypt_policy_set</span>(directory, policy, policy_length,</span><br><span class="line">                                contents_mode, filenames_mode)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">e4crypt_policy_check</span>(directory, policy, policy_length,</span><br><span class="line">                                  contents_mode, filenames_mode)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>那么 CE 空间是在什么时候准备好的？其实那部分代码是在 framework 里面做的。framework 相关代码在 <code>frameworks/base/services/core/java/com/android/server/StorageManagerService.java</code>，调用了 unlockUserKey 函数，该部分代码还是很简单的，主要就是通过 <code>mCryptConnector.execute(&quot;cryptfs&quot;, &quot;unlock_user_key&quot;, userId, serialNumber,encodeBytes(token), encodeBytes(secret));</code>通知 vold 需要去生成 key 了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockUserKey</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> serialNumber, <span class="type">byte</span>[] token, <span class="type">byte</span>[] secret)</span> &#123;</span><br><span class="line">    enforcePermission(android.Manifest.permission.STORAGE_INTERNAL);</span><br><span class="line">    waitForReady();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">        <span class="comment">// When a user has secure lock screen, require secret to actually unlock.</span></span><br><span class="line">        <span class="comment">// This check is mostly in place for emulation mode.</span></span><br><span class="line">        <span class="keyword">if</span> (mLockPatternUtils.isSecure(userId) &amp;&amp; ArrayUtils.isEmpty(secret)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Secret required to unlock secure user &quot;</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCryptConnector.execute(<span class="string">&quot;cryptfs&quot;</span>, <span class="string">&quot;unlock_user_key&quot;</span>, userId, serialNumber,</span><br><span class="line">                    encodeBytes(token), encodeBytes(secret));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLocalUnlockedUsers = ArrayUtils.appendInt(mLocalUnlockedUsers, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> <span class="string">&quot;sys.user.&quot;</span> + userId + <span class="string">&quot;.ce_available&quot;</span>;</span><br><span class="line">        Slog.d(TAG, <span class="string">&quot;Setting property: &quot;</span> + propertyName + <span class="string">&quot;=true&quot;</span>);</span><br><span class="line">        SystemProperties.set(propertyName, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 system&#x2F;vold&#x2F;Ext4Crypt.cpp 中的 <code>e4crypt_unlock_user_key</code> 函数进行解密操作，第一次系统起来的时候，因为用户没有设置密码，所以此时的 key 是没有用 auth 进行签名的，s_ce_key_raw_refs 会直接返回，即此时的 key 是已经解密过的 key 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> rename to &#x27;install&#x27; for consistency, and take flags to know which keys to install</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">e4crypt_unlock_user_key</span><span class="params">(<span class="type">userid_t</span> user_id, <span class="type">int</span> serial, <span class="type">const</span> <span class="type">char</span>* token_hex,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">char</span>* secret_hex)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;e4crypt_unlock_user_key &quot;</span> &lt;&lt; user_id &lt;&lt; <span class="string">&quot; serial=&quot;</span> &lt;&lt; serial</span><br><span class="line">               &lt;&lt; <span class="string">&quot; token_present=&quot;</span> &lt;&lt; (<span class="built_in">strcmp</span>(token_hex, <span class="string">&quot;!&quot;</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_ce_key_raw_refs.<span class="built_in">count</span>(user_id) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Tried to unlock already-unlocked key for user &quot;</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::string token, secret;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">parse_hex</span>(token_hex, &amp;token)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">parse_hex</span>(secret_hex, &amp;secret)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        android::<span class="function">vold::KeyAuthentication <span class="title">auth</span><span class="params">(token, secret)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">read_and_install_user_ce_key</span>(user_id, auth)) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Couldn&#x27;t read key for &quot;</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When in emulation mode, we just use chmod. However, we also</span></span><br><span class="line">        <span class="comment">// unlock directories when not in emulation mode, to bring devices</span></span><br><span class="line">        <span class="comment">// back into a known-good state.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">emulated_unlock</span>(android::vold::<span class="built_in">BuildDataSystemCePath</span>(user_id), <span class="number">0771</span>) ||</span><br><span class="line">            !<span class="built_in">emulated_unlock</span>(android::vold::<span class="built_in">BuildDataMiscCePath</span>(user_id), <span class="number">01771</span>) ||</span><br><span class="line">            !<span class="built_in">emulated_unlock</span>(android::vold::<span class="built_in">BuildDataMediaCePath</span>(<span class="literal">nullptr</span>, user_id), <span class="number">0770</span>) ||</span><br><span class="line">            !<span class="built_in">emulated_unlock</span>(android::vold::<span class="built_in">BuildDataUserCePath</span>(<span class="literal">nullptr</span>, user_id), <span class="number">0771</span>)) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Failed to unlock user &quot;</span> &lt;&lt; user_id;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后调用 prepareUserStorage 用于设置 ce 空间相关的 policy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareUserStorage</span><span class="params">(String volumeUuid, <span class="type">int</span> userId, <span class="type">int</span> serialNumber, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    enforcePermission(android.Manifest.permission.STORAGE_INTERNAL);</span><br><span class="line">    waitForReady();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCryptConnector.execute(<span class="string">&quot;cryptfs&quot;</span>, <span class="string">&quot;prepare_user_storage&quot;</span>, escapeNull(volumeUuid),</span><br><span class="line">                userId, serialNumber, flags);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类似 DE 空间的加密流程 CE 空间也会调用 e4crypt_prepare_user_storage 进行设置目录的 policy ，这样子，加密空间就全部准备好了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">e4crypt_prepare_user_storage</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* volume_uuid, <span class="type">userid_t</span> user_id, <span class="type">int</span> serial,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;e4crypt_prepare_user_storage for volume &quot;</span> &lt;&lt; <span class="built_in">escape_null</span>(volume_uuid)</span><br><span class="line">               &lt;&lt; <span class="string">&quot;, user &quot;</span> &lt;&lt; user_id &lt;&lt; <span class="string">&quot;, serial &quot;</span> &lt;&lt; serial &lt;&lt; <span class="string">&quot;, flags &quot;</span> &lt;&lt; flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FLAG_STORAGE_DE) &#123;</span><br><span class="line">        <span class="comment">// DE_sys key</span></span><br><span class="line">        <span class="keyword">auto</span> system_legacy_path = android::vold::<span class="built_in">BuildDataSystemLegacyPath</span>(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_legacy_path = android::vold::<span class="built_in">BuildDataMiscLegacyPath</span>(user_id);</span><br><span class="line">        <span class="keyword">auto</span> profiles_de_path = android::vold::<span class="built_in">BuildDataProfilesDePath</span>(user_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DE_n key</span></span><br><span class="line">        <span class="keyword">auto</span> system_de_path = android::vold::<span class="built_in">BuildDataSystemDePath</span>(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_de_path = android::vold::<span class="built_in">BuildDataMiscDePath</span>(user_id);</span><br><span class="line">        <span class="keyword">auto</span> user_de_path = android::vold::<span class="built_in">BuildDataUserDePath</span>(volume_uuid, user_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(system_legacy_path, <span class="number">0700</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MANAGE_MISC_DIRS</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(misc_legacy_path, <span class="number">0750</span>, <span class="built_in">multiuser_get_uid</span>(user_id, AID_SYSTEM),</span><br><span class="line">                <span class="built_in">multiuser_get_uid</span>(user_id, AID_EVERYBODY))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(profiles_de_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(system_de_path, <span class="number">0770</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(misc_de_path, <span class="number">01771</span>, AID_SYSTEM, AID_MISC)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(user_de_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">            std::string de_raw_ref;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">lookup_key_ref</span>(s_de_key_raw_refs, user_id, &amp;de_raw_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(de_raw_ref, system_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(de_raw_ref, misc_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(de_raw_ref, user_de_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FLAG_STORAGE_CE) &#123;</span><br><span class="line">        <span class="comment">// CE_n key</span></span><br><span class="line">        <span class="keyword">auto</span> system_ce_path = android::vold::<span class="built_in">BuildDataSystemCePath</span>(user_id);</span><br><span class="line">        <span class="keyword">auto</span> misc_ce_path = android::vold::<span class="built_in">BuildDataMiscCePath</span>(user_id);</span><br><span class="line">        <span class="keyword">auto</span> media_ce_path = android::vold::<span class="built_in">BuildDataMediaCePath</span>(volume_uuid, user_id);</span><br><span class="line">        <span class="keyword">auto</span> user_ce_path = android::vold::<span class="built_in">BuildDataUserCePath</span>(volume_uuid, user_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(system_ce_path, <span class="number">0770</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(misc_ce_path, <span class="number">01771</span>, AID_SYSTEM, AID_MISC)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(media_ce_path, <span class="number">0770</span>, AID_MEDIA_RW, AID_MEDIA_RW)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">prepare_dir</span>(user_ce_path, <span class="number">0771</span>, AID_SYSTEM, AID_SYSTEM)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">e4crypt_is_native</span>()) &#123;</span><br><span class="line">            std::string ce_raw_ref;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">lookup_key_ref</span>(s_ce_key_raw_refs, user_id, &amp;ce_raw_ref)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(ce_raw_ref, system_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(ce_raw_ref, misc_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(ce_raw_ref, media_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">ensure_policy</span>(ce_raw_ref, user_ce_path)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Now that credentials have been installed, we can run restorecon</span></span><br><span class="line">            <span class="comment">// over these paths</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> these paths need to be kept in sync with libselinux</span></span><br><span class="line">            android::vold::<span class="built_in">RestoreconRecursive</span>(system_ce_path);</span><br><span class="line">            android::vold::<span class="built_in">RestoreconRecursive</span>(misc_ce_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-锁屏密码与-FBE-key-的关系"><a href="#2-3-锁屏密码与-FBE-key-的关系" class="headerlink" title="2.3 锁屏密码与 FBE key 的关系"></a>2.3 锁屏密码与 FBE key 的关系</h4><p>开始前，先说说加密思想。Android FBE 中会通过密码文件生成一个 auth ，用这个 auth 再对 key 进行签名。这样子，用户在没有输入正确密码时，是无法进行解密 CE 空间的。那按照这样子，用户在不输入密码的时候岂不是用不了这些内存位置。其实，根据 auth 对 key 的签名，只针对了 CE 空间的 key 进行签名，所以系统在正常起来时，DE 空间其实已经解密完成了，现在就来看下用户在设置密码后，vold 做了哪些处理吧。</p>
<ul>
<li><p>用户设置完成密码后，vold 进程首先会调用 e4crypt_add_user_key_auth 用于生成新的 CE key，一个疑惑，在设置密码完成后，会调用两次该函数，第一次会生成一个未经过 auth 签名的 key，之后会再次生成一个经过 auth 签名的 key，不知这样的意图为何？</p>
</li>
<li><p>e4crypt_fixate_newest_user_key_auth 主要是将用户设置密码后生成的 auth 签名过 key 给重命名成之前的 key 名称</p>
</li>
<li><p>secdiscard 主要用于删除旧的 key 文件</p>
</li>
</ul>
<h4 id="2-4-FBE-解密"><a href="#2-4-FBE-解密" class="headerlink" title="2.4 FBE 解密"></a>2.4 FBE 解密</h4><p>这里说的解密的意思理解成读取可能会比较好理解. Android 的加密思想是如果是未经过授权的读取操作都是无法进行访问的.其实 FBE 解密流程和系统第一次起来时 set policy 的流程几乎是一样的。不同的是，在调用 ensure_policy 时，会对目录检测是否为空，如果是空，则进行 set policy 操作，而如果为非空，则进行 check_policy 操作，所以对 &#x2F;data 的解密操作都在这个 check_policy ，当校验成功后，kernel 会自动对 &#x2F;data 进行解密操作。如果要实现对 &#x2F;data 的解密，最难的倒不是 vold 中解密流程的移植，反倒是 framework 中根据 password 生成的 auth 的提取，因为此时的 key 是使用了 auth 进行签名的 key 了，如何把加密的 key 给解出来倒成了开发的难点。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>分析到最后，其实 FBE 的加密思想并不复杂，相对于 Android 之前的全盘加密，整个流程加密思想几乎是相同的。但无疑文件加密是更为人性化的，用户无需在输入密码就可进行一些基础操作。文中可能还有些不足以及 kernel 部分详细的加密操作都未详谈，欢迎各位指正补充。</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="//implementation-of-loading-fw-from-userspace.html" data-toggle="tooltip" data-placement="top" title="kernel 空间加载用户空间fw实现原理">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="//linux-time.html" data-toggle="tooltip" data-placement="top" title="Linux Time">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#FBE" title="FBE">FBE</a>
                        
                          <a class="tag" href="/tags/#文件级加密" title="文件级加密">文件级加密</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; meizu 2024 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="js/hux-blog.min.js"></script>


<!-- Search -->

<script src="js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://kernel.meizu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&#34;🌱&#34;,&#34;just do it&#34;,&#34;🍀&#34;]' color='[&#34;rgb(121,93,179)&#34; ,&#34;rgb(76,180,231)&#34; ,&#34;rgb(184,90,154)&#34;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
</body>

</html>
