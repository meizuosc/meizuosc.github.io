<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="一个有内涵的技术分享平台">
    <meta name="keyword"  content="meizu,kernel,魅族">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Linux Workqueue - 魅族内核团队
        
    </title>

    <link rel="canonical" href="https://kernel.meizu.com/2016/08/20//linux-workqueue.html/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="../../../../../css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="../../../../../css/dusign-light.css">

        
<link rel="stylesheet" href="../../../../../css/dusign-common-light.css">

        
<link rel="stylesheet" href="../../../../../css/font-awesome.css">

        
<link rel="stylesheet" href="../../../../../css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="../../../../../css/highlight.css">


    
<link rel="stylesheet" href="../../../../../css/widget.css">


    
<link rel="stylesheet" href="../../../../../css/rocket.css">


    
<link rel="stylesheet" href="../../../../../css/signature.css">


    
<link rel="stylesheet" href="../../../../../css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="../../../../../css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('')
                /*post*/
            
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                            
                              <a class="tag" href="/tags/#Workqueue" title="Workqueue">Workqueue</a>
                            
                        </div>
                        <h1>Linux Workqueue</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Peng Weilin on
                            2016-08-20
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">魅族内核团队</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>Workqueue 是内核里面很重要的一个机制，特别是内核驱动，一般的小型任务 (work) 都不会自己起一个线程来处理，而是扔到 Workqueue 中处理。Workqueue 的主要工作就是用进程上下文来处理内核中大量的小任务。</p>
<p>所以 Workqueue 的主要设计思想：一个是并行，多个 work 不要相互阻塞；另外一个是节省资源，多个 work 尽量共享资源 ( 进程、调度、内存 )，不要造成系统过多的资源浪费。</p>
<p>为了实现的设计思想，workqueue 的设计实现也更新了很多版本。最新的 workqueue 实现叫做 CMWQ(Concurrency Managed Workqueue)，也就是用更加智能的算法来实现“并行和节省”。新版本的 workqueue 创建函数改成 <code>alloc_workqueue()</code>，旧版本的函数 <code>create_workqueue()</code> 逐渐会被被废弃。</p>
<blockquote>
<p>本文的代码分析基于 Linux kernel 3.18.22，最好的学习方法还是 “read the fucking source code”</p>
</blockquote>
<h2 id="1-CMWQ-的几个基本概念"><a href="#1-CMWQ-的几个基本概念" class="headerlink" title="1.CMWQ 的几个基本概念"></a>1.CMWQ 的几个基本概念</h2><p>关于 workqueue 中几个概念都是 work 相关的数据结构非常容易混淆，大概可以这样来理解：</p>
<ul>
<li>work        ：工作。</li>
<li>workqueue    ：工作的集合。workqueue 和 work 是一对多的关系。</li>
<li>worker    ：工人。在代码中 worker 对应一个 <code>work_thread()</code> 内核线程。</li>
<li>worker_pool：工人的集合。worker_pool 和 worker 是一对多的关系。</li>
<li>pwq(pool_workqueue)：中间人 / 中介，负责建立起 workqueue 和 worker_pool 之间的关系。workqueue 和 pwq 是一对多的关系，pwq 和 worker_pool 是一对一的关系。</li>
</ul>
<p><img src="wq_topology.png" alt="normal wq_topology"></p>
<p>最终的目的还是把 work( 工作 ) 传递给 worker( 工人 ) 去执行，中间的数据结构和各种关系目的是把这件事组织的更加清晰高效。</p>
<h3 id="1-1-worker-pool"><a href="#1-1-worker-pool" class="headerlink" title="1.1 worker_pool"></a>1.1 worker_pool</h3><p>每个执行 work 的线程叫做 worker，一组 worker 的集合叫做 worker_pool。CMWQ 的精髓就在 worker_pool 里面 worker 的动态增减管理上 <code>manage_workers()</code>。</p>
<p>CMWQ 对 worker_pool 分成两类：</p>
<ul>
<li>normal worker_pool，给通用的 workqueue 使用；</li>
<li>unbound worker_pool，给 WQ_UNBOUND 类型的的 workqueue 使用；</li>
</ul>
<h4 id="1-1-1-normal-worker-pool"><a href="#1-1-1-normal-worker-pool" class="headerlink" title="1.1.1 normal worker_pool"></a>1.1.1 normal worker_pool</h4><p>默认 work 是在 normal worker_pool 中处理的。系统的规划是每个 CPU 创建两个 normal worker_pool：一个 normal 优先级 (nice=0)、一个高优先级 (nice=HIGHPRI_NICE_LEVEL)，对应创建出来的 worker 的进程 nice 不一样。</p>
<p>每个 worker 对应一个 <code>worker_thread()</code> 内核线程，一个 worker_pool 包含一个或者多个 worker，worker_pool 中 worker 的数量是根据 worker_pool 中 work 的负载来动态增减的。</p>
<p>我们可以通过 <code>ps | grep kworker</code> 命令来查看所有 worker 对应的内核线程，normal worker_pool 对应内核线程 (<code>worker_thread()</code>) 的命名规则是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line">	 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">				      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure>
<p>so 类似名字是 normal worker_pool：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">shell@</span>PRO5:/ $ ps | grep <span class="string">"kworker"</span></span><br><span class="line">root      <span class="number">14</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">1</span>:<span class="number">0</span>H		<span class="comment">// cpu1 高优先级 worker_pool 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">17</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">2</span>:<span class="number">0</span>		<span class="comment">// cpu2 低优先级 worker_pool 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">18</span>    <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">2</span>:<span class="number">0</span>H		<span class="comment">// cpu2 高优先级 worker_pool 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">23699</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/<span class="number">0</span>:<span class="number">1</span>		<span class="comment">// cpu0 低优先级 worker_pool 的第 1 个 worker 进程</span></span><br></pre></td></tr></table></figure>
<p><img src="wq_worker_pool.png" alt="normal worker_pool"></p>
<p>对应的拓扑图如下：</p>
<p><img src="wq_normal_wq_topology.png" alt="normal worker_pool topology"></p>
<p>以下是 normal worker_pool 详细的创建过程代码分析：</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>init_workqueues()</code> -&gt; <code>init_worker_pool()</code>/<code>create_worker()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 给每个 cpu 创建对应的 worker_pool</span></span><br><span class="line">	<span class="comment">/* initialize CPU pools */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			BUG_ON(init_worker_pool(pool));</span><br><span class="line">			<span class="comment">// 指定 cpu</span></span><br><span class="line">			pool-&gt;cpu = cpu;</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">			<span class="comment">// 指定进程优先级 nice</span></span><br><span class="line">			pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* alloc pool ID */</span></span><br><span class="line">			mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">			BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">			mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 给每个 worker_pool 创建第一个 worker</span></span><br><span class="line">	<span class="comment">/* create the initial worker */</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_worker_pool</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	spin_lock_init(&amp;pool-&gt;lock);</span><br><span class="line">	pool-&gt;id = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;node = NUMA_NO_NODE;</span><br><span class="line">	pool-&gt;flags |= POOL_DISASSOCIATED;</span><br><span class="line">	<span class="comment">// (1.1) worker_pool 的 work list，各个 workqueue 把 work 挂载到这个链表上，</span></span><br><span class="line">	<span class="comment">// 让 worker_pool 对应的多个 worker 来执行</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;worklist);</span><br><span class="line">	<span class="comment">// (1.2) worker_pool 的 idle worker list，</span></span><br><span class="line">	<span class="comment">// worker 没有活干时，不会马上销毁，先进入 idle 状态备选</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;idle_list);</span><br><span class="line">	<span class="comment">// (1.3) worker_pool 的 busy worker list，</span></span><br><span class="line">	<span class="comment">// worker 正在干活，在执行 work</span></span><br><span class="line">	hash_init(pool-&gt;busy_hash);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1.4) 检查 idle 状态 worker 是否需要 destroy 的 timer</span></span><br><span class="line">	init_timer_deferrable(&amp;pool-&gt;idle_timer);</span><br><span class="line">	pool-&gt;idle_timer.function = idle_worker_timeout;</span><br><span class="line">	pool-&gt;idle_timer.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1.5) 在 worker_pool 创建新的 worker 时，检查是否超时的 timer</span></span><br><span class="line">	setup_timer(&amp;pool-&gt;mayday_timer, pool_mayday_timeout,</span><br><span class="line">		    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pool);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;pool-&gt;manager_arb);</span><br><span class="line">	mutex_init(&amp;pool-&gt;attach_mutex);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">	ida_init(&amp;pool-&gt;worker_ida);</span><br><span class="line">	INIT_HLIST_NODE(&amp;pool-&gt;hash_node);</span><br><span class="line">	pool-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* shouldn't fail above this point */</span></span><br><span class="line">	pool-&gt;attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pool-&gt;attrs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">	id = ida_simple_get(&amp;pool-&gt;worker_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	worker-&gt;pool = pool;</span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// (2.1) 给 normal worker_pool 的 worker 构造进程名</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line">			 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// (2.2) 给 unbound worker_pool 的 worker 构造进程名</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.3) 创建 worker 对应的内核进程</span></span><br><span class="line">	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">					      <span class="string">"kworker/%s"</span>, id_buf);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.4) 设置内核进程对应的优先级 nice</span></span><br><span class="line">	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* prevent userland from meddling with cpumask of workqueue workers */</span></span><br><span class="line">	worker-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.5) 将 worker 和 worker_pool 绑定</span></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.6) 将 worker 初始状态设置成 idle，</span></span><br><span class="line">	<span class="comment">// wake_up_process 以后，worker 自动 leave idle 状态</span></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	wake_up_process(worker-&gt;task);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">if</span> (id &gt;= <span class="number">0</span>)</span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker_attach_to_pool</span><span class="params">(struct worker *worker,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.5.1) 将 worker 线程和 cpu 绑定</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any</span></span><br><span class="line"><span class="comment">	 * online CPUs.  It'll be re-applied when any of the CPUs come up.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_cpus_allowed_ptr(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pool-&gt;attach_mutex ensures %POOL_DISASSOCIATED remains</span></span><br><span class="line"><span class="comment">	 * stable across this function.  See the comments above the</span></span><br><span class="line"><span class="comment">	 * flag definition for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;flags &amp; POOL_DISASSOCIATED)</span><br><span class="line">		worker-&gt;flags |= WORKER_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2.5.2) 将 worker 加入 worker_pool 链表</span></span><br><span class="line">	list_add_tail(&amp;worker-&gt;node, &amp;pool-&gt;workers);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-unbound-worker-pool"><a href="#1-1-2-unbound-worker-pool" class="headerlink" title="1.1.2 unbound worker_pool"></a>1.1.2 unbound worker_pool</h4><p>大部分的 work 都是通过 normal worker_pool 来执行的 ( 例如通过 <code>schedule_work()</code>、<code>schedule_work_on()</code> 压入到系统 workqueue(system_wq) 中的 work)，最后都是通过 normal worker_pool 中的 worker 来执行的。这些 worker 是和某个 CPU 绑定的，work 一旦被 worker 开始执行，都是一直运行到某个 CPU 上的不会切换 CPU。</p>
<p>unbound worker_pool 相对应的意思，就是 worker 可以在多个 CPU 上调度的。但是他其实也是绑定的，只不过它绑定的单位不是 CPU 而是 node。所谓的 node 是对 NUMA(Non Uniform Memory Access Architecture) 系统来说的，NUMA 可能存在多个 node，每个 node 可能包含一个或者多个 CPU。</p>
<p>unbound worker_pool 对应内核线程 (<code>worker_thread()</code>) 的命名规则是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">				      <span class="string">"kworker/%s"</span>, id_buf);</span><br></pre></td></tr></table></figure>
<p>so 类似名字是 unbound worker_pool：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">shell@</span>PRO5:/ $ ps | grep <span class="string">"kworker"</span></span><br><span class="line">root      <span class="number">23906</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/u20:<span class="number">2</span>	<span class="comment">// unbound pool 20 的第 2 个 worker 进程</span></span><br><span class="line">root      <span class="number">24564</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/u20:<span class="number">0</span>	<span class="comment">// unbound pool 20 的第 0 个 worker 进程</span></span><br><span class="line">root      <span class="number">24622</span> <span class="number">2</span>     <span class="number">0</span>      <span class="number">0</span>     worker_thr <span class="number">0000000000</span> S kworker/u21:<span class="number">1</span>	<span class="comment">// unbound pool 21 的第 1 个 worker 进程</span></span><br></pre></td></tr></table></figure>
<p>unbound worker_pool 也分成两类：</p>
<ul>
<li>unbound_std_wq。每个 node 对应一个 worker_pool，多个 node 就对应多个 worker_pool;</li>
</ul>
<p><img src="wq_unbound_std_wq.png" alt="unbound worker_pool: unbound_std_wq"></p>
<p>对应的拓扑图如下：</p>
<p><img src="2016/08/wq_unboundstd_wq_topology.png" alt="unbound_std_wq topology"></p>
<ul>
<li>ordered_wq。所有 node 对应一个 default worker_pool；</li>
</ul>
<p><img src="wq_ordered_wq.png" alt="unbound worker_pool: ordered_wq"></p>
<p>对应的拓扑图如下：</p>
<p><img src="wq_ordered_wq_topology.png" alt="ordered_wq topology"></p>
<p>以下是 unbound worker_pool 详细的创建过程代码分析：</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>init_workqueues()</code> -&gt; unbound_std_wq_attrs/ordered_wq_attrs</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 初始化 normal 和 high nice 对应的 unbound attrs</span></span><br><span class="line">	<span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// (2) unbound_std_wq_attrs</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment">		 * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment">		 * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// (3) ordered_wq_attrs，no_numa = true;</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;no_numa = <span class="literal">true</span>;</span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>__alloc_workqueue_key()</code> -&gt; <code>alloc_and_link_pwqs()</code> -&gt; <code>apply_workqueue_attrs()</code> -&gt; <code>alloc_unbound_pwq()</code>/<code>numa_pwq_tbl_install()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">int</span> <span class="title">max_active</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">		flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate wq and format name */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">		tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 分配 workqueue_struct 数据结构</span></span><br><span class="line">	wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		wq-&gt;unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va_start(args, lock_name);</span><br><span class="line">	vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) pwq 最多放到 worker_pool 中的 work 数</span></span><br><span class="line">	max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">	max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init wq */</span></span><br><span class="line">	wq-&gt;flags = flags;</span><br><span class="line">	wq-&gt;saved_max_active = max_active;</span><br><span class="line">	mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">	atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">	lockdep_init_map(&amp;wq-&gt;lockdep_map, lock_name, key, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3) 给 workqueue 分配对应的 pool_workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue 将 workqueue 和 worker_pool 链接起来</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_free_wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果是 WQ_MEM_RECLAIM 类型的 workqueue</span></span><br><span class="line">	<span class="comment">// 创建对应的 rescuer_thread() 内核进程</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Workqueues which may be used during memory reclaim should</span></span><br><span class="line"><span class="comment">	 * have a rescuer to guarantee forward progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_MEM_RECLAIM) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"></span><br><span class="line">		rescuer = alloc_worker(NUMA_NO_NODE);</span><br><span class="line">		<span class="keyword">if</span> (!rescuer)</span><br><span class="line">			<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">		rescuer-&gt;rescue_wq = wq;</span><br><span class="line">		rescuer-&gt;task = kthread_create(rescuer_thread, rescuer, <span class="string">"%s"</span>,</span><br><span class="line">					       wq-&gt;name);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(rescuer-&gt;task)) &#123;</span><br><span class="line">			kfree(rescuer);</span><br><span class="line">			<span class="keyword">goto</span> err_destroy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wq-&gt;rescuer = rescuer;</span><br><span class="line">		rescuer-&gt;task-&gt;flags |= PF_NO_SETAFFINITY;</span><br><span class="line">		wake_up_process(rescuer-&gt;task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (5) 如果是需要，创建 workqueue 对应的 sysfs 文件</span></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment">	 * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment">	 * list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	for_each_pwq(pwq, wq)</span><br><span class="line">		pwq_adjust_max_active(pwq);</span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (6) 将新的 workqueue 加入到全局链表 workqueues 中</span></span><br><span class="line">	list_add(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_free_wq:</span><br><span class="line">	free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">	kfree(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">	destroy_workqueue(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3.1) normal workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		<span class="comment">// 给 workqueue 的每个 cpu 分配对应的 pool_workqueue，赋值给 wq-&gt;cpu_pwqs</span></span><br><span class="line">		wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu_ptr</span>(<span class="title">wq</span>-&gt;<span class="title">cpu_pwqs</span>, <span class="title">cpu</span>);</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu</span>(<span class="title">cpu_worker_pools</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将初始化时已经创建好的 normal worker_pool，赋值给 pool_workqueue</span></span><br><span class="line">			init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			<span class="comment">// 将 pool_workqueue 和 workqueue 链接起来</span></span><br><span class="line">			link_pwq(pwq);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">	<span class="comment">// (3.2) unbound ordered_wq workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line">		ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">"ordering guarantee broken for workqueue %s\n"</span>, wq-&gt;name);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// (3.3) unbound unbound_std_wq workqueue</span></span><br><span class="line">	<span class="comment">// pool_workqueue 链接 workqueue 和 worker_pool 的过程</span></span><br><span class="line">		<span class="keyword">return</span> apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply_workqueue_attrs</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3.2.1) 根据的 ubound 的 ordered_wq_attrs/unbound_std_wq_attrs</span></span><br><span class="line">	<span class="comment">// 创建对应的 pool_workqueue 和 worker_pool</span></span><br><span class="line">	<span class="comment">// 其中 worker_pool 不是默认创建好的，是需要动态创建的，对应的 worker 内核进程也要重新创建</span></span><br><span class="line">	<span class="comment">// 创建好的 pool_workqueue 赋值给 pwq_tbl[node]</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If something goes wrong during CPU up/down, we'll fall back to</span></span><br><span class="line"><span class="comment">	 * the default pwq covering whole @attrs-&gt;cpumask.  Always create</span></span><br><span class="line"><span class="comment">	 * it even if we don't use it immediately.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dfl_pwq = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line">	<span class="keyword">if</span> (!dfl_pwq)</span><br><span class="line">		<span class="keyword">goto</span> enomem_pwq;</span><br><span class="line"></span><br><span class="line">	for_each_node(node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq_calc_node_cpumask(attrs, node, <span class="number">-1</span>, tmp_attrs-&gt;cpumask)) &#123;</span><br><span class="line">			pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);</span><br><span class="line">			<span class="keyword">if</span> (!pwq_tbl[node])</span><br><span class="line">				<span class="keyword">goto</span> enomem_pwq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dfl_pwq-&gt;refcnt++;</span><br><span class="line">			pwq_tbl[node] = dfl_pwq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save the previous pwq and install the new one */</span></span><br><span class="line">	<span class="comment">// (3.2.2) 将临时 pwq_tbl[node] 赋值给 wq-&gt;numa_pwq_tbl[node]</span></span><br><span class="line">	for_each_node(node)</span><br><span class="line">		pwq_tbl[node] = numa_pwq_tbl_install(wq, node, pwq_tbl[node]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pool_workqueue *<span class="title">alloc_unbound_pwq</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3.2.1.1) 如果对应 attrs 已经创建多对应的 unbound_pool，则使用已有的 unbound_pool</span></span><br><span class="line">	<span class="comment">// 否则根据 attrs 创建新的 unbound_pool</span></span><br><span class="line">	pool = get_unbound_pool(attrs);</span><br><span class="line">	<span class="keyword">if</span> (!pool)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">		put_unbound_pool(pool);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init_pwq(pwq, wq, pool);</span><br><span class="line">	<span class="keyword">return</span> pwq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-worker"><a href="#1-2-worker" class="headerlink" title="1.2 worker"></a>1.2 worker</h3><p>每个 worker 对应一个 <code>worker_thread()</code> 内核线程，一个 worker_pool 对应一个或者多个 worker。多个 worker 从同一个链表中 worker_pool-&gt;worklist 获取 work 进行处理。</p>
<p>所以这其中有几个重点：</p>
<ul>
<li>worker 怎么处理 work；</li>
<li>worker_pool 怎么动态管理 worker 的数量；</li>
</ul>
<h4 id="1-2-1-worker-处理-work"><a href="#1-2-1-worker-处理-work" class="headerlink" title="1.2.1 worker 处理 work"></a>1.2.1 worker 处理 work</h4><p>处理 work 的过程主要在 <code>worker_thread()</code> -&gt; <code>process_one_work()</code> 中处理，我们具体看看代码的实现过程。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>worker_thread()</code> -&gt; <code>process_one_work()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = __<span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">	worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 是否 die</span></span><br><span class="line">	<span class="comment">/* am I supposed to die? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">		worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">		set_task_comm(worker-&gt;task, <span class="string">"kworker/dying"</span>);</span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		worker_detach_from_pool(worker, pool);</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 脱离 idle 状态</span></span><br><span class="line">	<span class="comment">// 被唤醒之前 worker 都是 idle 状态</span></span><br><span class="line">	worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3) 如果需要本 worker 继续执行则继续，否则进入 idle 状态</span></span><br><span class="line">	<span class="comment">// need more worker 的条件： (pool-&gt;worklist != 0) &amp;&amp; (pool-&gt;nr_running == 0)</span></span><br><span class="line">	<span class="comment">// worklist 上有 work 需要执行，并且现在没有处于 running 的 work</span></span><br><span class="line">	<span class="comment">/* no more worker necessary? */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果 (pool-&gt;nr_idle == 0)，则启动创建更多的 worker</span></span><br><span class="line">	<span class="comment">// 说明 idle 队列中已经没有备用 worker 了，先创建 一些 worker 备用</span></span><br><span class="line">	<span class="comment">/* do we need to manage? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment">	 * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment">	 * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finish PREP stage.  We're guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment">	 * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment">	 * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment">	 * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment">	 * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// (5) 如果 pool-&gt;worklist 不为空，从其中取出一个 work 进行处理</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line"><span class="class">			<span class="title">list_first_entry</span>(&amp;<span class="title">pool</span>-&gt;<span class="title">worklist</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">struct</span> <span class="title">work_struct</span>, <span class="title">entry</span>);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">			<span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line">			<span class="comment">// (6) 执行正常的 work</span></span><br><span class="line">			process_one_work(worker, work);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">				process_scheduled_works(worker);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// (7) 执行系统特意 scheduled 给某个 worker 的 work</span></span><br><span class="line">			<span class="comment">// 普通的 work 是放在池子的公共 list 中的 pool-&gt;worklist</span></span><br><span class="line">			<span class="comment">// 只有一些特殊的 work 被特意派送给某个 worker 的 worker-&gt;scheduled</span></span><br><span class="line">			<span class="comment">// 包括：1、执行 flush_work 时插入的 barrier work；</span></span><br><span class="line">			<span class="comment">// 2、collision 时从其他 worker 推送到本 worker 的 work</span></span><br><span class="line">			move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// (8) worker keep_working 的条件：</span></span><br><span class="line">	<span class="comment">// pool-&gt;worklist 不为空 &amp;&amp; (pool-&gt;nr_running &lt;= 1)</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP);supposed</span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">// (9) worker 进入 idle 状态</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock is held and there's no work to process and no need to</span></span><br><span class="line"><span class="comment">	 * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment">	 * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment">	 * event.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> = <span class="title">get_work_pwq</span>(<span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line">	<span class="keyword">int</span> work_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It is permissible to free the struct work_struct from</span></span><br><span class="line"><span class="comment">	 * inside the function that is called from it, this we need to</span></span><br><span class="line"><span class="comment">	 * take into account for lockdep too.  To avoid bogus "held</span></span><br><span class="line"><span class="comment">	 * lock freed" warnings as well as problems when looking into</span></span><br><span class="line"><span class="comment">	 * work-&gt;lockdep_map, make a copy and use that here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* ensure we're on the correct CPU */</span></span><br><span class="line">	WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">		     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.1) 如果 work 已经在 worker_pool 的其他 worker 上执行，</span></span><br><span class="line">	<span class="comment">// 将 work 放入对应 worker 的 scheduled 队列中延后执行</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A single work shouldn't be executed concurrently by</span></span><br><span class="line"><span class="comment">	 * multiple workers on a single cpu.  Check whether anyone is</span></span><br><span class="line"><span class="comment">	 * already processing the work.  If so, defer the work to the</span></span><br><span class="line"><span class="comment">	 * currently executing one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	collision = find_worker_executing_work(pool, work);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(collision)) &#123;</span><br><span class="line">		move_linked_works(work, &amp;collision-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.2) 将 worker 加入 busy 队列 pool-&gt;busy_hash</span></span><br><span class="line">	<span class="comment">/* claim and dequeue */</span></span><br><span class="line">	debug_work_deactivate(work);</span><br><span class="line">	hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)work);</span><br><span class="line">	worker-&gt;current_work = work;</span><br><span class="line">	worker-&gt;current_func = work-&gt;func;</span><br><span class="line">	worker-&gt;current_pwq = pwq;</span><br><span class="line">	work_color = get_work_color(work);</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.3) 如果 work 所在的 wq 是 cpu 密集型的 WQ_CPU_INTENSIVE</span></span><br><span class="line">	<span class="comment">// 则当前 work 的执行脱离 worker_pool 的动态调度，成为一个独立的线程</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment">	 * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">	 * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">	 * execution of the pending work items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (8.4) 在 UNBOUND 或者 CPU_INTENSIVE work 中判断是否需要唤醒 idle worker</span></span><br><span class="line">	<span class="comment">// 普通 work 不会执行这个操作</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment">	 * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment">	 * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment">	 * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment">	 * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment">	 * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment">	 * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment">	 * disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">	trace_workqueue_execute_start(work);</span><br><span class="line">	<span class="comment">// (8.5) 执行 work 函数</span></span><br><span class="line">	worker-&gt;current_func(work);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While we must be careful to not use "work" after this, the trace</span></span><br><span class="line"><span class="comment">	 * point will only record its address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	trace_workqueue_execute_end(work);</span><br><span class="line">	lock_map_release(&amp;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		pr_err(<span class="string">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"</span></span><br><span class="line">		       <span class="string">"     last function: %pf\n"</span>,</span><br><span class="line">		       current-&gt;comm, preempt_count(), task_pid_nr(current),</span><br><span class="line">		       worker-&gt;current_func);</span><br><span class="line">		debug_show_held_locks(current);</span><br><span class="line">		dump_stack();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following prevents a kworker from hogging CPU on !PREEMPT</span></span><br><span class="line"><span class="comment">	 * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment">	 * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment">	 * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment">	 * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment">	 * the same condition doesn't freeze RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cond_resched_rcu_qs();</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear cpu intensive status */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we're done with it, release */</span></span><br><span class="line">	hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">	worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;desc_valid = <span class="literal">false</span>;</span><br><span class="line">	pwq_dec_nr_in_flight(pwq, work_color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-worker-pool-动态管理-worker"><a href="#1-2-2-worker-pool-动态管理-worker" class="headerlink" title="1.2.2 worker_pool 动态管理 worker"></a>1.2.2 worker_pool 动态管理 worker</h4><p>worker_pool 怎么来动态增减 worker，这部分的算法是 CMWQ 的核心。其思想如下：</p>
<ul>
<li>worker_pool 中的 worker 有 3 种状态：idle、running、suspend；</li>
<li>如果 worker_pool 中有 work 需要处理，保持至少一个 running worker 来处理；</li>
<li>running worker 在处理 work 的过程中进入了阻塞 suspend 状态，为了保持其他 work 的执行，需要唤醒新的 idle worker 来处理 work；</li>
<li>如果有 work 需要执行且 running worker 大于 1 个，会让多余的 running worker 进入 idle 状态；</li>
<li>如果没有 work 需要执行，会让所有 worker 进入 idle 状态；</li>
<li>如果创建的 worker 过多，destroy_worker 在 300s(IDLE_WORKER_TIMEOUT) 时间内没有再次运行的 idle worker。</li>
</ul>
<p><img src="wq_worker_statusmachine.png" alt="worker status machine"></p>
<p>详细代码可以参考上节 <code>worker_thread()</code> -&gt; <code>process_one_work()</code> 的分析。</p>
<p>为了追踪 worker 的 running 和 suspend 状态，用来动态调整 worker 的数量。wq 使用在进程调度中加钩子函数的技巧：</p>
<ul>
<li>追踪 worker 从 suspend 进入 running 状态：<code>ttwu_activate()</code> -&gt; <code>wq_worker_waking_up()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wq_worker_waking_up</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">		WARN_ON_ONCE(worker-&gt;pool-&gt;cpu != cpu);</span><br><span class="line">		<span class="comment">// 增加 worker_pool 中 running 的 worker 数量</span></span><br><span class="line">		atomic_inc(&amp;worker-&gt;pool-&gt;nr_running);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>追踪 worker 从 running 进入 suspend 状态：<code>__schedule()</code> -&gt; <code>wq_worker_sleeping()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">wq_worker_sleeping</span><span class="params">(struct task_struct *task, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">kthread_data</span>(<span class="title">task</span>), *<span class="title">to_wakeup</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Rescuers, which may not have all the fields set up like normal</span></span><br><span class="line"><span class="comment">	 * workers, also reach here, let's not access anything before</span></span><br><span class="line"><span class="comment">	 * checking NOT_RUNNING.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (worker-&gt;flags &amp; WORKER_NOT_RUNNING)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* this can only happen on the local cpu */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(cpu != raw_smp_processor_id() || pool-&gt;cpu != cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The counterpart of the following dec_and_test, implied mb,</span></span><br><span class="line"><span class="comment">	 * worklist not empty test sequence is in insert_work().</span></span><br><span class="line"><span class="comment">	 * Please read comment there.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * NOT_RUNNING is clear.  This means that we're bound to and</span></span><br><span class="line"><span class="comment">	 * running on the local cpu w/ rq lock held and preemption</span></span><br><span class="line"><span class="comment">	 * disabled, which in turn means that none else could be</span></span><br><span class="line"><span class="comment">	 * manipulating idle_list, so dereferencing idle_list without pool</span></span><br><span class="line"><span class="comment">	 * lock is safe.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 减少 worker_pool 中 running 的 worker 数量</span></span><br><span class="line">	<span class="comment">// 如果 worklist 还有 work 需要处理，唤醒第一个 idle worker 进行处理</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;pool-&gt;nr_running) &amp;&amp;</span><br><span class="line">	    !list_empty(&amp;pool-&gt;worklist))</span><br><span class="line">		to_wakeup = first_idle_worker(pool);</span><br><span class="line">	<span class="keyword">return</span> to_wakeup ? to_wakeup-&gt;task : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 worker_pool 的调度思想是：如果有 work 需要处理，保持一个 running 状态的 worker 处理，不多也不少。</p>
<p>但是这里有一个问题如果 work 是 CPU 密集型的，它虽然也没有进入 suspend 状态，但是会长时间的占用 CPU，让后续的 work 阻塞太长时间。</p>
<p>为了解决这个问题，CMWQ 设计了 WQ_CPU_INTENSIVE，如果一个 wq 声明自己是 CPU_INTENSIVE，则让当前 worker 脱离动态调度，像是进入了 suspend 状态，那么 CMWQ 会创建新的 worker，后续的 work 会得到执行。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>worker_thread()</code> -&gt; <code>process_one_work()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 设置当前 worker 的 WORKER_CPU_INTENSIVE 标志</span></span><br><span class="line">	<span class="comment">// nr_running 会被减 1</span></span><br><span class="line">	<span class="comment">// 对 worker_pool 来说，当前 worker 相当于进入了 suspend 状态</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment">	 * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">	 * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">	 * execution of the pending work items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 接上一步，判断是否需要唤醒新的 worker 来处理 work</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment">	 * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment">	 * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment">	 * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment">	 * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (3) 执行 work</span></span><br><span class="line">	worker-&gt;current_func(work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 执行完，清理当前 worker 的 WORKER_CPU_INTENSIVE 标志</span></span><br><span class="line">	<span class="comment">// 当前 worker 重新进入 running 状态</span></span><br><span class="line">	<span class="comment">/* clear cpu intensive status */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	WORKER_NOT_RUNNING	= WORKER_PREP | WORKER_CPU_INTENSIVE |</span><br><span class="line">				  WORKER_UNBOUND | WORKER_REBOUND,</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> worker_set_flags(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct worker_pool *pool = worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If transitioning into NOT_RUNNING, adjust nr_running. */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp;</span><br><span class="line">	    !(worker-&gt;flags &amp; WORKER_NOT_RUNNING)) &#123;</span><br><span class="line">		atomic_dec(&amp;pool-&gt;nr_running);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">worker_clr_flags</span><span class="params">(struct worker *worker, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> oflags = worker-&gt;flags;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(worker-&gt;task != current);</span><br><span class="line"></span><br><span class="line">	worker-&gt;flags &amp;= ~flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If transitioning out of NOT_RUNNING, increment nr_running.  Note</span></span><br><span class="line"><span class="comment">	 * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask</span></span><br><span class="line"><span class="comment">	 * of multiple flags, not a single flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WORKER_NOT_RUNNING) &amp;&amp; (oflags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">		<span class="keyword">if</span> (!(worker-&gt;flags &amp; WORKER_NOT_RUNNING))</span><br><span class="line">			atomic_inc(&amp;pool-&gt;nr_running);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-CPU-hotplug-处理"><a href="#1-2-3-CPU-hotplug-处理" class="headerlink" title="1.2.3 CPU hotplug 处理"></a>1.2.3 CPU hotplug 处理</h4><p>从上几节可以看到，系统会创建和 CPU 绑定的 normal worker_pool 和不绑定 CPU 的 unbound worker_pool，worker_pool 又会动态的创建 worker。</p>
<p>那么在 CPU hotplug 的时候，会怎么样动态的处理 worker_pool 和 worker 呢？来看具体的代码分析：</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>workqueue_cpu_up_callback()</code>/<code>workqueue_cpu_down_callback()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);</span><br><span class="line">	hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_down_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params">						 <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params">						 <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">unbind_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_DOWN_PREPARE:</span><br><span class="line">		<span class="comment">/* unbinding per-cpu workers should happen on the local CPU */</span></span><br><span class="line">		INIT_WORK_ONSTACK(&amp;unbind_work, wq_unbind_fn);</span><br><span class="line">		<span class="comment">// (1) cpu down_prepare</span></span><br><span class="line">		<span class="comment">// 把和当前 cpu 绑定的 normal worker_pool 上的 worker 停工</span></span><br><span class="line">		<span class="comment">// 随着当前 cpu 被 down 掉，这些 worker 会迁移到其他 cpu 上</span></span><br><span class="line">		queue_work_on(cpu, system_highpri_wq, &amp;unbind_work);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (2) unbound wq 对 cpu 变化的更新</span></span><br><span class="line">		<span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">		mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">		list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">			wq_update_unbound_numa(wq, cpu, <span class="literal">false</span>);</span><br><span class="line">		mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* wait for per-cpu unbinding to finish */</span></span><br><span class="line">		flush_work(&amp;unbind_work);</span><br><span class="line">		destroy_work_on_stack(&amp;unbind_work);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workqueue_cpu_up_callback</span><span class="params">(struct notifier_block *nfb,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> CPU = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)hcpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> pi;</span><br><span class="line">	<span class="keyword">switch</span> (action &amp; ~CPU_TASKS_FROZEN) &#123;</span><br><span class="line">	<span class="keyword">case</span> CPU_UP_PREPARE:</span><br><span class="line">		for_each_cpu_worker_pool(pool, CPU) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;nr_workers)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (!create_worker(pool))</span><br><span class="line">				<span class="keyword">return</span> NOTIFY_BAD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CPU_DOWN_FAILED:</span><br><span class="line">	<span class="keyword">case</span> CPU_ONLINE:</span><br><span class="line">		mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">		<span class="comment">// (3) CPU up</span></span><br><span class="line">		for_each_pool(pool, pi) &#123;</span><br><span class="line">			mutex_lock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">			<span class="comment">// 如果和当前 CPU 绑定的 normal worker_pool 上，有 WORKER_UNBOUND 停工的 worker</span></span><br><span class="line">			<span class="comment">// 重新绑定 worker 到 worker_pool</span></span><br><span class="line">			<span class="comment">// 让这些 worker 开工，并绑定到当前 CPU</span></span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;CPU == CPU)</span><br><span class="line">				rebind_workers(pool);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pool-&gt;CPU &lt; <span class="number">0</span>)</span><br><span class="line">				restore_unbound_workers_cpumask(pool, CPU);</span><br><span class="line">			mutex_unlock(&amp;pool-&gt;attach_mutex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* update NUMA affinity of unbound workqueues */</span></span><br><span class="line">		list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>)</span><br><span class="line">			wq_update_unbound_numa(wq, CPU, <span class="literal">true</span>);</span><br><span class="line">		mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-workqueue"><a href="#1-3-workqueue" class="headerlink" title="1.3 workqueue"></a>1.3 workqueue</h3><p>workqueue 就是存放一组 work 的集合，基本可以分为两类：一类系统创建的 workqueue，一类是用户自己创建的 workqueue。</p>
<p>不论是系统还是用户的 workqueue，如果没有指定 WQ_UNBOUND，默认都是和 normal worker_pool 绑定。</p>
<h4 id="1-3-1-系统-workqueue"><a href="#1-3-1-系统-workqueue" class="headerlink" title="1.3.1 系统 workqueue"></a>1.3.1 系统 workqueue</h4><p>系统在初始化时创建了一批默认的 workqueue：system_wq、system_highpri_wq、system_long_wq、system_unbound_wq、system_freezable_wq、system_power_efficient_wq、system_freezable_power_efficient_wq。</p>
<p>像 system_wq，就是 schedule_work() 默认使用的。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li>init_workqueues()</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int __init init_workqueues(void)</span><br><span class="line">&#123;</span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">"events"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">"events_highpri"</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">"events_long"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">"events_unbound"</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">"events_freezable"</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">"events_power_efficient"</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">"events_freezable_power_efficient"</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-workqueue-创建"><a href="#1-3-2-workqueue-创建" class="headerlink" title="1.3.2 workqueue 创建"></a>1.3.2 workqueue 创建</h4><p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p>
<h4 id="1-3-3-flush-workqueue"><a href="#1-3-3-flush-workqueue" class="headerlink" title="1.3.3 flush_workqueue()"></a>1.3.3 flush_workqueue()</h4><p>这一部分的逻辑，wq-&gt;work_color、wq-&gt;flush_color 换来换去的逻辑实在看的头晕。看不懂暂时不想看，放着以后看吧，或者有谁看懂了教我一下。：）</p>
<h3 id="1-4-pool-workqueue"><a href="#1-4-pool-workqueue" class="headerlink" title="1.4 pool_workqueue"></a>1.4 pool_workqueue</h3><p>pool_workqueue 只是一个中介角色。</p>
<p>详细过程见上几节的代码分析：alloc_workqueue() -&gt; __alloc_workqueue_key() -&gt; alloc_and_link_pwqs()。</p>
<h3 id="1-5-work"><a href="#1-5-work" class="headerlink" title="1.5 work"></a>1.5 work</h3><p>描述一份待执行的工作。</p>
<h4 id="1-5-1-queue-work"><a href="#1-5-1-queue-work" class="headerlink" title="1.5.1 queue_work()"></a>1.5.1 queue_work()</h4><p>将 work 压入到 workqueue 当中。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li>queue_work() -&gt; queue_work_on() -&gt; __queue_work()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">			 struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">worklist</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> work_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While a work item is PENDING &amp;&amp; off queue, a task trying to</span></span><br><span class="line"><span class="comment">	 * steal the PENDING will busy-loop waiting for it to either get</span></span><br><span class="line"><span class="comment">	 * queued or lose PENDING.  Grabbing PENDING and queueing should</span></span><br><span class="line"><span class="comment">	 * happen with IRQ disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">	debug_work_activate(work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if draining, only works from the same workqueue are allowed */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;</span><br><span class="line">	    WARN_ON_ONCE(!is_chained_work(wq)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// (1) 如果没有指定 cpu，则使用当前 cpu</span></span><br><span class="line">	<span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">		cpu = raw_smp_processor_id();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq which will be used unless @work is executing elsewhere */</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND))</span><br><span class="line">		<span class="comment">// (2) 对于 normal wq，使用当前 cpu 对应的 normal worker_pool</span></span><br><span class="line">		pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// (3) 对于 unbound wq，使用当前 cpu 对应 node 的 worker_pool</span></span><br><span class="line">		pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果 work 在其他 worker 上正在被执行，把 work 压到对应的 worker 上去</span></span><br><span class="line">	<span class="comment">// 避免 work 出现重入的问题</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @work was previously on a different pool, it might still be</span></span><br><span class="line"><span class="comment">	 * running there, in which case the work needs to be queued on that</span></span><br><span class="line"><span class="comment">	 * pool to guarantee non-reentrancy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	last_pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">		worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">			pwq = worker-&gt;current_pwq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">			spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">			spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pwq is determined and locked.  For unbound pools, we could have</span></span><br><span class="line"><span class="comment">	 * raced with pwq release and it could already be dead.  If its</span></span><br><span class="line"><span class="comment">	 * refcnt is zero, repeat pwq selection.  Note that pwqs never die</span></span><br><span class="line"><span class="comment">	 * without another pwq replacing it in the numa_pwq_tbl or while</span></span><br><span class="line"><span class="comment">	 * work items are executing on it, so the retrying is guaranteed to</span></span><br><span class="line"><span class="comment">	 * make forward-progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">			spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* oops */</span></span><br><span class="line">		WARN_ONCE(<span class="literal">true</span>, <span class="string">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt"</span>,</span><br><span class="line">			  wq-&gt;name, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq determined, queue */</span></span><br><span class="line">	trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry))) &#123;</span><br><span class="line">		spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">	work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (5) 如果还没有达到 max_active，将 work 挂载到 pool-&gt;worklist</span></span><br><span class="line">	<span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">		trace_workqueue_activate_work(work);</span><br><span class="line">		pwq-&gt;nr_active++;</span><br><span class="line">		worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line">	<span class="comment">// 否则，将 work 挂载到临时队列 pwq-&gt;delayed_works</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">		worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (6) 将 work 压入 worklist 当中</span></span><br><span class="line">	insert_work(pwq, work, worklist, work_flags);</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-2-flush-work"><a href="#1-5-2-flush-work" class="headerlink" title="1.5.2 flush_work()"></a>1.5.2 <code>flush_work()</code></h4><p>flush 某个 work，确保 work 执行完成。</p>
<p>怎么判断异步的 work 已经执行完成？这里面使用了一个技巧：在目标 work 的后面插入一个新的 work wq_barrier，如果 wq_barrier 执行完成，那么目标 work 肯定已经执行完成。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>queue_work()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flush_work - wait for a work to finish executing the last queueing instance</span></span><br><span class="line"><span class="comment"> * @work: the work to flush</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait until @work has finished execution.  @work is guaranteed to be idle</span></span><br><span class="line"><span class="comment"> * on return if it hasn't been requeued since flush started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * %true if flush_work() waited for the work to finish execution,</span></span><br><span class="line"><span class="comment"> * %false if it was already idle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">	lock_map_acquire(&amp;work-&gt;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;work-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_flush_work(work, &amp;barr)) &#123;</span><br><span class="line">		<span class="comment">// 等待 barr work 执行完成的信号</span></span><br><span class="line">		wait_for_completion(&amp;barr.done);</span><br><span class="line">		destroy_work_on_stack(&amp;barr.work);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">start_flush_work</span><span class="params">(struct work_struct *work, struct wq_barrier *barr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 如果 work 所在 worker_pool 为 NULL，说明 work 已经执行完</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (!pool) &#123;</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="comment">/* see the comment in try_to_grab_pending() with the same code */</span></span><br><span class="line">	pwq = get_work_pwq(work);</span><br><span class="line">	<span class="keyword">if</span> (pwq) &#123;</span><br><span class="line">		<span class="comment">// (2) 如果 work 所在 pwq 指向的 worker_pool 不等于上一步得到的 worker_pool，说明 work 已经执行完</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(pwq-&gt;pool != pool))</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// (3) 如果 work 所在 pwq 为 NULL，并且也没有在当前执行的 work 中，说明 work 已经执行完</span></span><br><span class="line">		worker = find_worker_executing_work(pool, work);</span><br><span class="line">		<span class="keyword">if</span> (!worker)</span><br><span class="line">			<span class="keyword">goto</span> already_gone;</span><br><span class="line">		pwq = worker-&gt;current_pwq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (4) 如果 work 没有执行完，向 work 的后面插入 barr work</span></span><br><span class="line">	insert_wq_barrier(pwq, barr, work, worker);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @max_active is 1 or rescuer is in use, flushing another work</span></span><br><span class="line"><span class="comment">	 * item on the same workqueue may lead to deadlock.  Make sure the</span></span><br><span class="line"><span class="comment">	 * flusher is not running on the same workqueue by verifying write</span></span><br><span class="line"><span class="comment">	 * access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pwq-&gt;wq-&gt;saved_max_active == <span class="number">1</span> || pwq-&gt;wq-&gt;rescuer)</span><br><span class="line">		lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">already_gone:</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_wq_barrier</span><span class="params">(struct pool_workqueue *pwq,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct wq_barrier *barr,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct work_struct *target, struct worker *worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> linked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * debugobject calls are safe here even with pool-&gt;lock locked</span></span><br><span class="line"><span class="comment">	 * as we know for sure that this will not trigger any of the</span></span><br><span class="line"><span class="comment">	 * checks and call back into the fixup functions where we</span></span><br><span class="line"><span class="comment">	 * might deadlock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// (4.1) barr work 的执行函数 wq_barrier_func()</span></span><br><span class="line">	INIT_WORK_ONSTACK(&amp;barr-&gt;work, wq_barrier_func);</span><br><span class="line">	__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&amp;barr-&gt;work));</span><br><span class="line">	init_completion(&amp;barr-&gt;done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @target is currently being executed, schedule the</span></span><br><span class="line"><span class="comment">	 * barrier to the worker; otherwise, put it after @target.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// (4.2) 如果 work 当前在 worker 中执行，则 barr work 插入 scheduled 队列</span></span><br><span class="line">	<span class="keyword">if</span> (worker)</span><br><span class="line">		head = worker-&gt;scheduled.next;</span><br><span class="line">	<span class="comment">// 否则，则 barr work 插入正常的 worklist 队列中，插入位置在目标 work 后面</span></span><br><span class="line">	<span class="comment">// 并且置上 WORK_STRUCT_LINKED 标志</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *bits = work_data_bits(target);</span><br><span class="line"></span><br><span class="line">		head = target-&gt;entry.next;</span><br><span class="line">		<span class="comment">/* there can already be other linked works, inherit and set */</span></span><br><span class="line">		linked = *bits &amp; WORK_STRUCT_LINKED;</span><br><span class="line">		__set_bit(WORK_STRUCT_LINKED_BIT, bits);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debug_work_activate(&amp;barr-&gt;work);</span><br><span class="line">	insert_work(pwq, &amp;barr-&gt;work, head,</span><br><span class="line">		    work_color_to_flags(WORK_NO_COLOR) | linked);</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wq_barrier_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> *<span class="title">barr</span> = <span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">wq_barrier</span>, <span class="title">work</span>);</span></span><br><span class="line">	<span class="comment">// (4.1.1) barr work 执行完成，发出 complete 信号。</span></span><br><span class="line">	complete(&amp;barr-&gt;done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Workqueue-对外接口函数"><a href="#2-Workqueue-对外接口函数" class="headerlink" title="2.Workqueue 对外接口函数"></a>2.Workqueue 对外接口函数</h2><p>CMWQ 实现的 workqueue 机制，被包装成相应的对外接口函数。</p>
<h3 id="2-1-schedule-work"><a href="#2-1-schedule-work" class="headerlink" title="2.1 schedule_work()"></a>2.1 <code>schedule_work()</code></h3><p>把 work 压入系统默认 wq system_wq，WORK_CPU_UNBOUND 指定 worker 为当前 CPU 绑定的 normal worker_pool 创建的 worker。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>schedule_work()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-sschedule-work-on"><a href="#2-2-sschedule-work-on" class="headerlink" title="2.2 sschedule_work_on()"></a>2.2 <code>sschedule_work_on()</code></h3><p>在 <code>schedule_work()</code> 基础上，可以指定 work 运行的 CPU。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>schedule_work_on()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work_on(cpu, system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-schedule-delayed-work"><a href="#2-3-schedule-delayed-work" class="headerlink" title="2.3 schedule_delayed_work()"></a>2.3 <code>schedule_delayed_work()</code></h3><p>启动一个 timer，在 timer 定时到了以后调用 <code>delayed_work_timer_fn()</code> 把 work 压入系统默认 wq system_wq。</p>
<ul>
<li>kernel/workqueue.c:</li>
<li><code>schedule_work_on()</code> -&gt; <code>queue_work_on()</code> -&gt; <code>__queue_work()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work(system_wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">| →</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct delayed_work *dwork,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);</span><br><span class="line">&#125;</span><br><span class="line">|| →</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_delayed_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			   struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read the comment in __queue_work() */</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">		__queue_delayed_work(cpu, wq, dwork, delay);</span><br><span class="line">		ret = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">||| →</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_delayed_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">				struct delayed_work *dwork, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> = &amp;<span class="title">dwork</span>-&gt;<span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||</span><br><span class="line">		     timer-&gt;data != (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dwork);</span><br><span class="line">	WARN_ON_ONCE(timer_pending(timer));</span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;work-&gt;entry));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @delay is 0, queue @dwork-&gt;work immediately.  This is for</span></span><br><span class="line"><span class="comment">	 * both optimization and correctness.  The earliest @timer can</span></span><br><span class="line"><span class="comment">	 * expire is on the closest next tick and delayed_work users depend</span></span><br><span class="line"><span class="comment">	 * on that there's no such delay when @delay is 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!delay) &#123;</span><br><span class="line">		__queue_work(cpu, wq, &amp;dwork-&gt;work);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);</span><br><span class="line"></span><br><span class="line">	dwork-&gt;wq = wq;</span><br><span class="line">	dwork-&gt;cpu = cpu;</span><br><span class="line">	timer-&gt;expires = jiffies + delay;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu != WORK_CPU_UNBOUND))</span><br><span class="line">		add_timer_on(timer, cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">|||| →</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayed_work_timer_fn</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> __data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> = (<span class="title">struct</span> <span class="title">delayed_work</span> *)__<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* should have been called from irqsafe timer with irq already off */</span></span><br><span class="line">	__queue_work(dwork-&gt;cpu, dwork-&gt;wq, &amp;dwork-&gt;work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://git.kernel.org/cgit/Linux/kernel/git/torvalds/Linux.git/tree/Documentation/workqueue.txt?id=refs/tags/v4.7-rc5" target="_blank" rel="noopener">Documentation/workqueue.txt</a></li>
</ol>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/09/01//linux-interrupt.html/" data-toggle="tooltip" data-placement="top" title="Linux Interrupt">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/08/11//linux-selinux-intro.html/" data-toggle="tooltip" data-placement="top" title="SELinux 安全策略解析 ">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Linux" title="Linux">Linux</a>
                        
                          <a class="tag" href="/tags/#Workqueue" title="Workqueue">Workqueue</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; meizu 2025 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="../../../../../js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="../../../../../js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="../../../../../js/hux-blog.min.js"></script>


<!-- Search -->

<script src="../../../../../js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://kernel.meizu.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&#34;🌱&#34;,&#34;just do it&#34;,&#34;🍀&#34;]' color='[&#34;rgb(121,93,179)&#34; ,&#34;rgb(76,180,231)&#34; ,&#34;rgb(184,90,154)&#34;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
</body>

</html>
